%% $RCSfile: fixptrecip.tlc,v $
%% $Revision: 1.2.4.6 $
%% $Date: 2004/04/14 23:47:21 $
%%
%% This file contains tlc code for generation of fixed point reciprocal
%%
%% Copyright 1994-2003 The MathWorks, Inc.
%%

%% Function: FixPt_Reciprocal ==========================================
%%
%% Abstract:
%%  Radix Only Reciprocal
%%
%%  Vc = 1 / Vb
%%
%%  Note the Stored Integers are denoted by B and C
%%
%%  C = 2^(-Eb-Ec) / B
%%
%%  For this example: All integers are UNSIGNED
%%  and are a base integer types supported by the
%%  compiler, such as ushort, uint, ulong
%%
%%  The records C and B must contain
%%  all the fixed point data type and scaling fields.
%%  They must also contain a field called "Label"
%%  In C_Language terms cLabel must be an l-value.
%%  ALabel and bLabel are treated as read only and
%%  they must provide the values (stored integers) for
%%  A and bDT.  Please note none of the Labels can be addresses.
%%
%% Synopsis:
%%      FixPt_Reciprocal(cLabel,cDT,bLabel,bDT,roundMode,satMode)
%%
%%      cLabel,cDT = record describing output
%%      bLabel,bDT = record describing input
%%      roundMode  = string specifying round to "Zero", "Nearest", etc.
%%      satMode    = string specifying "Wrap" or "Saturate" on overflow
%%

%function FixPt_Reciprocal_NoBias(cLabel,cDT,bLabel,bDT,roundMode,satMode) Output
    %%
    %% The following code to determine the numerator value depends 
    %% on the size of int and long for the current code generation 
    %% target.  This has the potential to give different results for
    %% different targets and to be different from simulation, but only 
    %% if the fractional slopes are mismatched.
    %%     For example, suppose the quotient had TotalSlope 1 and
    %% the denominator had TotalSlope 3, then the ideal numerator
    %% would be 1/3.  Quantizing that to 32 bit would be more
    %% accurate than quantizing to 16 or 8 bits.  Small numerical
    %% differences in the quotient would result.  You could 
    %% probably even concoct a senario where an overflow occurred
    %% with one quantization but not another.
    %%     If the fractional slopes are Matched, then the ideal
    %% numerator will be an exact power of two.  There will be no
    %% round-off error when representing this value.  The numerical result of
    %% the division will therefore depend only on the denominators
    %% value and the data type and scaling of the quotient.
    %%     The data type and scaling used for the numerator does effect
    %% the efficiency of the implementation.  Ideally, the data
    %% type an scaling of the invariant numerator is selected so
    %% that the quotient is determined directly from a division
    %% instruction, like
    %%
    %%       QuotientStoredInteger = 0x8000U/DenominatorStoredInteger
    %%
    %% The goal is to avoid the need to pre-shift the numerator, post
    %% shift of the raw quotient and especially to avoid use of repeated 
    %% subtraction.  
    %%     When the slopes are matched and hence the invariant numerator
    %% is a pure power of two, the approach below produces the
    %% one-shot implementation as much as possible.  
    %%     For mis-matched slopes, optimizations were not attempted.
    %%     
    %assign numeratorValueStr = "( ( 2^(0-(%<bDT.FixedExp>)-(%<cDT.FixedExp>)) ) / ( (%<bDT.FracSlope>) * (%<cDT.FracSlope>) ) )"
    %assign numeratorValue = FEVAL("eval", numeratorValueStr )
    %assign numeratorValue = CAST( "Real", numeratorValue )
    %%
    %if bDT.IsSigned
      %%
      %assign numeratorIsSigned = 1
    %else
      %assign numeratorIsSigned = 0
    %endif
    %%
    %assign numeratorLog2      = FEVAL("log2",numeratorValue )
    %assign numeratorLog2Quant = FEVAL("floor",numeratorLog2 )
    %%
    %if numeratorLog2 == numeratorLog2Quant
      %%
      %% pure power of 2
      %%
      %if numeratorLog2 >= 1
        %%
        %if ( IntegerSizes.IntNumBits - numeratorIsSigned ) > numeratorLog2
          %%
          %assign numeratorNumBits = IntegerSizes.IntNumBits
          %%
          %assign numeratorFixExp = 0
          %%
        %else
          %%
          %assign numeratorNumBits = IntegerSizes.LongNumBits
          %%
          %if ( IntegerSizes.LongNumBits - numeratorIsSigned ) > numeratorLog2
            %%
            %assign numeratorFixExp = 0
            %%
          %else
            %%
            %assign numeratorFixExp = numeratorLog2 - ( IntegerSizes.LongNumBits - 1 - numeratorIsSigned ) 
            %%
          %endif
        %endif
      %else
        %%
        %% Stupid case where aside from division by zero
        %% the quotient is always just zero except possibly if it rounds up
        %% or down to stored integer +/-1
        %%
        %assign numeratorNumBits = IntegerSizes.IntNumBits
        %%
        %assign numeratorFixExp = numeratorLog2
        %%
      %endif
      %%
    %else
      %%
      %% mismatch slope correction involved
      %%
      %if cDT.RequiredBits <= IntegerSizes.IntNumBits && bDT.RequiredBits <= IntegerSizes.IntNumBits
        %%
        %assign numeratorNumBits = IntegerSizes.IntNumBits
      %else
        %assign numeratorNumBits = IntegerSizes.LongNumBits
      %endif
      %%
      %assign numeratorFixExp = FEVAL("fixptbestexp", numeratorValue, numeratorNumBits, numeratorIsSigned )
      %%
    %endif    
    %%
    %assign numeratorFixExp = CAST("Number",numeratorFixExp)
    %%
    %assign evalStr = "round((%<numeratorValue>)/(2^(%<numeratorFixExp>)))"
    %%
    %assign numeratorLabel = FEVAL("eval",evalStr)
    %assign numeratorLabel = FEVAL("eval","dec2hex(%<numeratorLabel>,ceil(%<numeratorNumBits>/4))")
    %%
    %assign numeratorLabel = "(0x%<numeratorLabel>"
    %%
    %if !numeratorIsSigned
      %%
      %assign numeratorLabel = "%<numeratorLabel>U"
    %endif
    %%
    %if numeratorNumBits > IntegerSizes.IntNumBits
      %%
      %assign numeratorLabel = "%<numeratorLabel>L"
    %endif
    %%
    %assign numeratorLabel = "%<numeratorLabel>)"
    %%
    %copyrecord cAltDT cDT
    %%
    %assign cAltDT.FracSlope = 1.0
    %assign cAltDT.FixedExp  = 0
    %%
    %copyrecord bAltDT bDT
    %%
    %assign bAltDT.FracSlope = 1.0
    %assign bAltDT.FixedExp  = 0
    %%
    %assign dataTypeName = LibFixPointFormDataTypeName(numeratorIsSigned,numeratorNumBits,numeratorFixExp)
    %%
    %createrecord aDT { ...
      DataTypeName     dataTypeName; ...
      IsSigned         numeratorIsSigned; ...
      RequiredBits     numeratorNumBits; ...
      ActualBits       numeratorNumBits; ...
      FixedExp         numeratorFixExp; ...
      FracSlope        1.0; ...
      Bias             0.0; ...
      NativeType       "#error x" ...
    }
    %%
    %<FixPt_DefineDataType(aDT)>\
    %%
    %<FixPt_Division(cLabel,cAltDT,numeratorLabel,aDT,bLabel,bAltDT,roundMode,satMode)>\
    %%
%endfunction  %% FixPt_Reciprocal_NoBias



%function FixPt_Reciprocal(cLabel,cDT,bLabel,bDT,roundMode,satMode) Output
    %%
    %% force FLOOR to act like EASIEST
    %%   this should be removed when EASIEST is added as an option on fixpt dialogs
    %%
%%    %if roundMode == "Floor"
        %%
%%        %assign roundMode = "Easiest"
        %%
%%    %endif
    %%
  %%
  %%
  %% determine if the signals are floating point
  %%
  %assign cIsFloat = FixPt_DataTypeIsFloat(cDT)
  %assign bIsFloat = FixPt_DataTypeIsFloat(bDT)
  %%
  %if cIsFloat || bIsFloat
      {
          %if cDT.NativeType != "real32_T" || bDT.NativeType != "real32_T"
              %%
              %assign tempType = "real_T"
              %assign oneLabel = "(1.0)"
              %%
              %assign intermediateDT = FixPt_GetDataTypeFromIndex(0)
          %else
              %assign tempType = "real32_T"
              %assign oneLabel = "(1.0F)"
              %%
              %assign intermediateDT = FixPt_GetDataTypeFromIndex(1)
          %endif
          %%
          %assign tempLabelb = "tempFloatPt2"
          %%            
          %openfile captureConvertMul
          %assign retVecStr_b = FixPt_Fix2Fix(tempLabelb,intermediateDT,bLabel,bDT,roundMode,satMode)
          %closefile captureConvertMul
          %%
          %assign intermediateLabel = "(%<oneLabel>/"
          %%
          %if SIZE(retVecStr_b,1) == 3
              %%
              %assign intermediateLabel = intermediateLabel + "%<retVecStr_b[1]>)"
          %else
              %%START_ASSERT
              %<tempType> %<tempLabelb>;
              %%
              %assign intermediateLabel = intermediateLabel + "%<tempLabelb>)"
              %%END_ASSERT
          %endif
          %%
          %if SIZE(retVecStr_b,1) != 3
              %%START_ASSERT
              %<captureConvertMul>\
              %%END_ASSERT
          %endif
          %%            
          %if cIsFloat
              %<FixPt_Fix2FixAlwaysOutput(cLabel,cDT,intermediateLabel,intermediateDT,roundMode,satMode)>\
          %else
              {
                  %assign tempLabelc = "tempFloatPt3"
                  %<tempType> %<tempLabelc>;
                  %<tempLabelc> = %<intermediateLabel>;
                  %<FixPt_Fix2FixAlwaysOutput(cLabel,cDT,tempLabelc,intermediateDT,roundMode,satMode)>\
              }
          %endif
      }
  %else
    %%
    %assign needConvertB = !ISEQUAL(bDT.Bias,0.0)
    %assign needConvertC = !ISEQUAL(cDT.Bias,0.0)
    %%
    %assign needConvertAny = needConvertB || needConvertC
    %%
    %copyrecord cDT_alt cDT
    %copyrecord bDT_alt bDT
    %%
    %assign bTempLabel = bLabel
    %assign cTempLabel = cLabel
    %%
    %if needConvertAny
      {
      %if needConvertB
        %%
        %assign bDT_alt = FixPt_SensorDT_2_BinPointDT(bDT)
        %%
        %assign bTempLabel = "bTempDivNiceScaling"
        %%
        %<bDT_alt.NativeType> %<bTempLabel>;
        %%
      %endif
      %%
      %if needConvertC
        %%
        %assign cDT_alt = FixPt_SensorDT_2_BinPointDT(cDT)
        %%
        %assign cTempLabel = "cTempDivNiceScaling"
        %%
        %<cDT_alt.NativeType> %<cTempLabel>;
        %%
      %endif
      %%
      %if needConvertB
        %%
        %<FixPt_Fix2FixAlwaysOutput(bTempLabel,bDT_alt,bLabel,bDT,roundMode,satMode)>\

      %endif
      %%
    %endif
    %%
    %<FixPt_Reciprocal_NoBias(cTempLabel,cDT_alt,bTempLabel,bDT_alt,roundMode,satMode)>\
    %%
    %if needConvertAny
      %%
      %if needConvertC
        
        %<FixPt_Fix2FixAlwaysOutput(cLabel,cDT,cTempLabel,cDT_alt,roundMode,satMode)>\
        %%
      %endif
      %%
      }
    %endif
  %endif
%endfunction  %% FixPt_Reciprocal
