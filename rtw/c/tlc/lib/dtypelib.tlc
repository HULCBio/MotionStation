%% 
%% $Revision: 1.1.6.10 $
%% 
%%
%% Copyright 1994-2004 The MathWorks, Inc.
%%
%% Abstract:
%%   This TLC library file contains the general purpose utility functions
%%   for accessing data type information.
%%

%if EXISTS("_DTYPELIB_") == 0
%assign _DTYPELIB_ = 1

%if EXISTS("DSP32")
  %assign SizeOfDouble = 4
%else
  %assign SizeOfDouble = 8
%endif
%<LibAddToCompiledModel("SizeOfDouble", SizeOfDouble)>

%% Function: LibBlockInputSignalAliasedThruDataTypeId =========================
%% Abstract:
%%   Return the data type ID the input signal is aliased thru to
%%
%function LibBlockInputSignalAliasedThruDataTypeId(idx)
  %return LibGetDataTypeIdAliasedThruToFromId(...
    LibBlockInputSignalDataTypeId(idx))
%endfunction

%% Function: LibBlockOutputSignalAliasedThruDataTypeId =========================
%% Abstract:
%%   Return the data type ID the output signal is aliased thru to
%%
%function LibBlockOutputSignalAliasedThruDataTypeId(idx)
  %return LibGetDataTypeIdAliasedThruToFromId(...
    LibBlockOutputSignalDataTypeId(idx))
%endfunction

%% Function: LibIsBuiltInDataType ==============================================
%% Abstract:
%%   Does the input data type ID correspond to a builtin type after
%%   resolving thru aliases?
%%
%function LibIsBuiltInDataType(id) void
  %return  LibGetDataTypeIdAliasedThruToFromId(id) < DataTypes.NumSLBuiltInDataTypes
%endfunction

%% Function: LibIsFundamentalBuiltInDataType ====================================
%% Abstract:
%%   Does the input data type ID correspond to a builtin type, without 
%%   resolving thru aliases?
%%
%function LibIsFundamentalBuiltInDataType(id) void
  %return id < DataTypes.NumSLBuiltInDataTypes
%endfunction

%% Function: LibIsDataTypeLogSupported==========================================
%% Abstract:
%%   Is signal logging supported for this data type
%%
%function LibIsDataTypeLogSupported(dTypeId) void
  %if LibIsBuiltInDataType(dTypeId)
    %return 1
  %else
    %assign curDT = FixPt_GetDataTypeFromIndex(dTypeId)
    %%
    %if curDT.IsFixedPoint
      %return 1
    %else
      %return 0
    %endif
  %endif
%endfunction

%% Function: LibIsAliasDataType ==============================================
%% Abstract:
%%   Does the input data type ID correspond to an alias type?
%%
%function LibIsAliasDataType(id) void
  %return LibGetDataTypeIdAliasedThruToFromId(id) != id
%endfunction


%% Function: LibDataTypeNumElements ===========================================
%% Abstract:
%%   How many elements does the data type have?
%%
%function LibDataTypeNumElements(id) void
  %return DataTypes.DataType[id].NumElements
%endfunction


%% Function: LibDataTypeElementName ===========================================
%% Abstract:
%%   Return the name of the idx'th element of datatype 
%%
%function LibDataTypeElementName(id, idx) void
  %return DataTypes.DataType[id].Elements[idx].Name
%endfunction

%% Function: LibDataTypeElementDataTypeId ======================================
%% Abstract:
%%   Return the data type id of the idx'th element of datatype 
%%
%function LibDataTypeElementDataTypeId(id, idx) void
  %return DataTypes.DataType[id].Elements[idx].DataTypeId
%endfunction


%% Function: LibDataTypeElementPadding ======================================
%% Abstract:
%%   Return the padding of the idx'th element of datatype 
%%
%function LibDataTypeElementPadding(id, idx) void
  %return DataTypes.DataType[id].Elements[idx].Padding
%endfunction


%% Function: LibDataTypeElementIsComplex =======================================
%% Abstract:
%%   Return whether the idx'th element of datatype is complex
%%
%function LibDataTypeElementIsComplex(id, idx) void
  %return DataTypes.DataType[id].Elements[idx].IsComplex
%endfunction

%% Function: LibDataTypeElementIsFixPt =======================================
%% Abstract:
%%   Return whether the idx'th element of datatype is Fixed point data type
%%
%function LibDataTypeElementIsFixPt(id, idx) void
  %return DataTypes.DataType[LibDataTypeElementDataTypeId(id,idx)].IsFixedPoint
%endfunction


%% Function: LibDataTypeElementWidth =======================================
%% Abstract:
%%   Return the width of the idx'th element of datatype
%%
%function LibDataTypeElementWidth(id, idx) void
  %return DataTypes.DataType[id].Elements[idx].Width
%endfunction

%% Function: LibDataTypeElementNumDimensions ==============================
%% Abstract:
%%   Return the number of Dimensions of the idx'th element of datatype
%%
%function LibDataTypeElementNumDimensions(id, idx) void
  %return DataTypes.DataType[id].Elements[idx].NumDimensions
%endfunction

%% Function: LibDataTypeElementDimensions ==============================
%% Abstract:
%%   Return the number of Dimensions of the idx'th element of datatype
%%
%function LibDataTypeElementDimensions(id, idx) void
  %return DataTypes.DataType[id].Elements[idx].Dimensions
%endfunction

%% Function: LibIsStructDataType ==============================================
%% Abstract:
%%   Does the input data type ID correspond to a structure type?
%%
%function LibIsStructDataType(id) void
  %return LibDataTypeNumElements(id) > 0
%endfunction


%% Function: LibHeaderFileForDataType ==========================================
%% Abstract:
%%   Return the header file for a data type
%%
%function LibHeaderFileForDataType(dt)
  %return dt.HeaderFile
%endfunction  

%% Function: LibPackageForDataType =============================================
%% Abstract:
%%   Return the package for a data type
%%
%function LibPackageForDataType(dt)
  %if dt.HasObject == 0
    %return ""
  %else
    %return dt.Object.Package
  %endif
%endfunction  

%% Function: LibClassForDataType ===============================================
%% Abstract:
%%   Return the class for a data type
%%
%function LibClassForDataType(dt)
  %if dt.HasObject == 0
    %return ""
  %else
    %return dt.Object.Class
  %endif
%endfunction  

%% Function: LibDescriptionForDataTypeIdx ====================================
%% Abstract: 
%%   Return the Data Description string from the data type index
%%
%function LibDescriptionForDataTypeIdx(id) void 
  %if DataTypes.DataType[id].HasObject == 0
    %return ""
  %else
    %return DataTypes.DataType[id].Object.ObjectProperties.Description
  %endif
%endfunction

%% xxx header to headerfile
%% Function: LibHeaderForDataTypeIdx ====================================
%% Abstract: 
%%   Return the header file for Data Type from the data type index
%%
%function LibHeaderForDataTypeIdx(id) void 
  %return DataTypes.DataType[id].HeaderFile
%endfunction

%% Function: LibConvertBetweenTLCFcnName =======================================
%% Abstract:
%%   Return the name of ConvertBetween TLC function
%%
%function LibConvertBetweenTLCFcnName(id) void
  %if EXISTS("DataTypes.DataType[id].ConvertBetweenTLCFcnName")
    %return DataTypes.DataType[id].ConvertBetweenTLCFcnName
  %else
    %return ""
  %endif
%endfunction



%% Function: LibConvertBetweenTLCFcnFile =======================================
%% Abstract:
%%   Return the file of ConvertBetween TLC function
%%
%function LibConvertBetweenTLCFcnFile(id) void
  %if EXISTS("DataTypes.DataType[id].ConvertBetweenTLCFcnFile")
    %return DataTypes.DataType[id].ConvertBetweenTLCFcnFile
  %else
    %return ""
  %endif
%endfunction



%% Function: LibIsPositiveTLCFcnName ===========================================
%% Abstract:
%%   Return the name of IsPositive TLC function
%%
%function LibIsPositiveTLCFcnName(id) void
  %if EXISTS("DataTypes.DataType[id].IsPositiveTLCFcnName")
    %return DataTypes.DataType[id].IsPositiveTLCFcnName
  %else
    %return ""
  %endif
%endfunction


%% Function: LibIsPositiveTLCFcnFile ===========================================
%% Abstract:
%%   Return the file of IsPositive TLC function
%%
%function LibIsPositiveTLCFcnFile(id) void
  %if EXISTS("DataTypes.DataType[id].IsPositiveTLCFcnFile")
    %return DataTypes.DataType[id].IsPositiveTLCFcnFile
  %else
    %return ""
  %endif
%endfunction


%% Function: LibSignTLCFcnName =================================================
%% Abstract:
%%   Return the name of Sign TLC function
%%
%function LibSignTLCFcnName(id) void
  %if EXISTS("DataTypes.DataType[id].SignTLCFcnName")
    %return DataTypes.DataType[id].SignTLCFcnName
  %else
    %return ""
  %endif
%endfunction


%% Function: LibSignTLCFcnFile =================================================
%% Abstract:
%%   Return the file of Sign TLC function
%%
%function LibSignTLCFcnFile(id) void
  %if EXISTS("DataTypes.DataType[id].SignTLCFcnFile")
    %return DataTypes.DataType[id].SignTLCFcnFile
  %else
    %return ""
  %endif
%endfunction


%% DocFunction{Other Useful Functions}: LibGetDataTypeNameFromId ===============
%% Abstract:
%%   Return the data type name corresponding to a data type ID.
%%
%function LibGetDataTypeNameFromId(id) void
  %return DataTypes.DataType[id].Name
%endfunction


%% DocFunction{Other Useful Functions}: LibGetDataTypeIdAliasedThruToFromId ====
%% Abstract:
%%   Return the data type IdAliasedThruTo corresponding to a data type ID.
%function LibGetDataTypeIdAliasedThruToFromId(id) void
  %return DataTypes.DataType[id].IdAliasedThruTo
%endfunction


%% DocFunction{Other Useful Functions}: LibGetDataTypeStorageIdFromId ========
%% Abstract:
%%   Return the data type StorageId corresponding to a data type ID.
%function LibGetDataTypeStorageIdFromId(id) void
  %return DataTypes.DataType[id].StorageId
%endfunction


%% DocFunction{Other Useful Functions}: LibGetDataTypeEnumFromId ===============
%% Abstract:
%%   Return the data type enum corresponding to a data type ID. For example
%%   id == tSS_DOUBLE => enum = "SS_DOUBLE". If id does not correspond to a
%%   built in data type, this function returns ""
%%
%function LibGetDataTypeEnumFromId(id) void
  %return DataTypes.DataType[id].Enum
%endfunction


%% DocFunction{Other Useful Functions}: LibGetDataTypeComplexNameFromId ========
%% Abstract:
%%   Return the name of the complex data type corresponding to a data type ID.
%%   For example, if id == tSS_DOUBLE then this function returns "creal_T"
%%
%function LibGetDataTypeComplexNameFromId(id) void
  %return DataTypes.DataType[id].ComplexName
%endfunction


%% Function: LibGetRecordDataTypeID ===========================================
%% Abstract:
%%   Return the data type ID for a given record.
%%
%function LibGetRecordDataTypeId(rec) void
  %if EXISTS("rec.DataTypeIdx")
    %assign idx = rec.DataTypeIdx
  %else
    %assign errTxt = "DataTypeIdx is not contained within the specified record"
    %<LibReportFatalError(errTxt)>
  %endif
  %return DataTypes.DataType[idx].Id
%endfunction


%% Function: LibGetRecordIsComplex ============================================
%% Abstract:
%%   Return 1 if the specified record is complex.  Otherwise, return 0
%%
%function LibGetRecordIsComplex(rec)
  %if EXISTS("rec.ComplexSignal")
    %if TYPE(rec.ComplexSignal) == "Number"
      %return rec.ComplexSignal
    %else
      %return (rec.ComplexSignal == "yes")
    %endif
  %else
    %assign errTxt = "ComplexSignal not contained within specified record."
    %<LibReportFatalError(errTxt)>
  %endif
  %return 0
%endfunction


%% Function: LibGetRecordDataTypeName =========================================
%% Abstract:
%%   Return the data type name for a specified record.
%%
%%   Arguments:
%%     rec  - TLC record
%%     reim - Return the data type name or the complex data type name
%%            depending if rec is a complex record and the value of reim.
%%            Assuming Name="real_T" and ComplexName="creal_T", for example,
%%            creal_T is returned for a complex record if reim is specified as
%%            tRealPart or tImagPart.  Otherwise real_T is returned.
%%
%function LibGetRecordDataTypeName(rec, reim)
  %assign id = SLibGetRecordDataTypeId(rec)
  %if SLibGetRecordIsComplex(rec) && reim == ""
    %return LibGetDataTypeComplexNameFromId(id)
  %else
    %return LibGetDataTypeNameFromId(id)
  %endif
%endfunction


%% Function: LibGetRecordAliasedThruDataTypeName ================================
%% Abstract:
%%   Return the aliased thru data type name for a specified record.
%%
%%   Arguments:
%%     rec  - TLC record
%%     reim - Return the data type name or the complex data type name
%%            depending if rec is a complex record and the value of reim.
%%            Assuming Name="real_T" and ComplexName="creal_T", for example,
%%            creal_T is returned for a complex record if reim is specified as
%%            tRealPart or tImagPart.  Otherwise real_T is returned.
%%
%function LibGetRecordAliasedThruDataTypeName(rec, reim)
  %assign id = LibGetDataTypeIdAliasedThruToFromId(SLibGetRecordDataTypeId(rec))
  %if SLibGetRecordIsComplex(rec) && reim == ""
    %return LibGetDataTypeComplexNameFromId(id)
  %else
    %return LibGetDataTypeNameFromId(id)
  %endif
%endfunction


%% Function: LibGetRecordCompositeDataTypeName ================================
%% Abstract:
%%   Return the composite data type name for a specified record.  That is,
%%   return ComplexName if it exists, otherwise, return Name.
%%
%function LibGetRecordCompositeDataTypeName(rec) void
  %assign id = SLibGetRecordDataTypeId(rec)
  %if SLibGetRecordIsComplex(rec)
    %return LibGetDataTypeComplexNameFromId(id)
  %else
    %return LibGetDataTypeNameFromId(id)
  %endif
%endfunction


%% Function: LibGetGroundName =================================================
%% Abstract:
%%   For a given record and real/imaginary specifier, return the name used for
%%   ground or complex ground depending the record type and the value of reim.
%%   Specifically, return:
%%
%%   Name        - Record not complex
%%   Name        - Record complex, and reim equals tRealPart or tImagPart
%%   ComplexName - Record complex and reim is null
%%
%%   Note that the model name is added as a prefix to both Name and ComplexName.
%%   this avoids name clashing when linking multiple models into the same
%%   executable.
%%
%%   Arguments:
%%     rec  - record containing a data type index
%%     reim - tRealPart, tImagPart or ""
%%
%function LibGetGroundName(rec, reim) void
  %assign id = SLibGetRecordDataTypeId(rec)
  %if LibIsStructDataType(id)
    %assign rec.GroundUsed = 1
  %endif
  %if SLibGetRecordIsComplex(rec) && reim == ""
    %assign name = DataTypes.DataType[id].ComplexGroundName
  %else
    %assign name = DataTypes.DataType[id].GroundName
  %endif
  %if name == ""
    %assign strTxt = reim == "" ? "Complex" : ""
    %assign errTxt = "The name for ground has been requested, however, " ...
      "it has not been set by SLibSetDataType%<strTxt>GroundName()."
    %<LibReportFatalError(errTxt)>
  %endif
  %return "%<CompiledModel.Name>_%<name>"
%endfunction


%% Function: LibGetGroundValue ================================================
%% Abstract:
%%   For a given record and real/imaginary specifier, return the value used for
%%   ground depending on the record type and the value of reim.
%%   Specifically, return:
%%
%%   value - Record not complex
%%   value - Record complex, and reim equals tRealPart or tImagPart
%%   ERROR - Record complex and reim is null (complex values are undefined)
%%
%%   Note the value may be a string or an actual numeric value.  For example,
%%   ground is 0.0 for tSS_DOUBLE, but it may be "0x08" for a fixed-point
%%   8-bit integer with a bias.
%%
%%   Arguments:
%%     rec  - record containing a data type index
%%     reim - tRealPart, tImagPart or ""
%%
%function LibGetGroundValue(rec, reim) void
  %if SLibGetRecordIsComplex(rec) && reim == ""
    %% complex ground value undefined
    %assign errTxt = "Complex ground values are undefined."
    %<LibReportFatalError(errTxt)>
  %else
    %% non-complex ground or real/imaginary part of complex ground
    %assign id = SLibGetRecordDataTypeId(rec)
    %assign value = SLibGetGroundValueFromId(id)
  %endif
  %return value
%endfunction

%% Function: LibGetGroundInitFromId ==========================================
%% Abstract:
%%   Returns the value used for ground initialization for the data type id 
%%   passed in.
%%   Specifically, return:
%%
%%   value - ground value of data type id passed in
%%   ERROR - ground value requested for a data type that has not set it's ground
%%           value
%%
%%   Note the value may be a string or an actual numeric value.  For example,
%%   ground is 0.0 for tSS_DOUBLE, but it may be "0x08" for a fixed-point
%%   8-bit integer with a bias.
%%
%%   Arguments:
%%     dtypeid  - data type Id whose ground value is desired
%%
%function LibGetGroundInitFromId(dtypeid) void
  %if LibIsStructDataType(dtypeid)
    %return DataTypes.DataType[dtypeid].GroundInit
  %else
    %return LibGetGroundValueFromId(dtypeid)
  %endif
%endfunction


%% Function: LibGetGroundValueFromId ==========================================
%% Abstract:
%%   Returns the value used for ground for the data type id passed in.
%%   Specifically, return:
%%
%%   value - ground value of data type id passed in
%%   ERROR - ground value requested for a data type that has not set it's ground
%%           value
%%
%%   Note the value may be a string or an actual numeric value.  For example,
%%   ground is 0.0 for tSS_DOUBLE, but it may be "0x08" for a fixed-point
%%   8-bit integer with a bias.
%%
%%   Arguments:
%%     dtypeid  - data type Id whose ground value is desired
%%
%function LibGetGroundValueFromId(dtypeid) void
  %assign value = DataTypes.DataType[dtypeid].GroundValue
  %if LibIsStructDataType(dtypeid)
    %assign DataTypes.DataType[dtypeid].GroundUsed = 1
  %endif
  %% must check that the value was set for this data type
  %if ISEQUAL(value, "")
    %assign errTxt = "The value for ground has been requested " ...
      "without being set by SLibSetDataTypeGroundValue()"
    %<LibReportFatalError(errTxt)>
  %endif
  %return value
%endfunction


%% Function: SLibIsSignedFromId ================================================
%% Abstract:
%%   Return whether the data type corresponding to a data type ID is signed
%%
%function SLibIsSignedFromId(id) void
  %switch LibGetDataTypeIdAliasedThruToFromId(id)
    %case tSS_UINT8
    %case tSS_UINT16
    %case tSS_UINT32
    %case tSS_BOOLEAN
      %return 0
      %break
    %case tSS_INT8
    %case tSS_INT16
    %case tSS_INT32
    %case tSS_DOUBLE
    %case tSS_SINGLE
      %return 1
      %break
    %default
      %assign errTxt = "Invalid data type %<dtypeName>."
      %<LibBlockReportFatalError([], errTxt)>
      %break
  %endswitch
%endfunction


%% Function: SLibIsUnsignedFromId ==============================================
%% Abstract:
%%   Return whether the data type corresponding to a data type ID is an
%%   unsigned
%%
%function SLibIsUnsignedFromId(id) void
  %return !SLibIsSignedFromId(id)
%endfunction

%% Function: SLibGetMLidentFcnFromId ==========================================
%% Abstract:
%%   This function returns a mx-function call which check a mxArray datatype
%%   for compatibility with the TLC datatype id.
%%
%function SLibGetMLidentFcnFromId(id) void
  %switch LibGetDataTypeIdAliasedThruToFromId(id)
    %case tSS_DOUBLE
      %return "mxIsDouble"
    %case tSS_SINGLE
      %return "mxIsSingle"
    %case tSS_UINT8
      %return "mxIsUint8"
    %case tSS_UINT16
      %return "mxIsUint16"
    %case tSS_UINT32
      %return "mxIsUint32"
    %case tSS_BOOLEAN
      %return "mxIsLogical"
    %case tSS_INT8
      %return "mxIsInt8"
    %case tSS_INT16
      %return "mxIsInt16"
    %case tSS_INT32
      %return "mxIsInt32"
    %default
      %return "mxIsNumeric"
  %endswitch
%endfunction %% SLibGetMLidentFcnFromId


%% Function: SLibGetANCICDataTypeFromId ========================================
%% Abstract:
%%   This function returns the equivalent ANCI data type to the specified
%%   TLC datatype id.
%%
%function SLibGetANSICDataTypeFromId(id) void
  %if EXISTS(::OrigName)      
    %assign modelName = CompiledModel.OrigName
  %else
    %assign modelName = CompiledModel.Name
  %endif
  %switch LibGetDataTypeIdAliasedThruToFromId(id)
    %case tSS_DOUBLE
      %assign ansi_type = FEVAL("rtwprivate","getAnsiDataType", ...
        "%<modelName>","tSS_DOUBLE")
      %return ansi_type.val
    %case tSS_SINGLE
      %assign ansi_type = FEVAL("rtwprivate","getAnsiDataType", ...
        "%<modelName>","tSS_SINGLE")
      %return ansi_type.val
    %case tSS_UINT8
      %assign ansi_type = FEVAL("rtwprivate","getAnsiDataType", ...
        "%<modelName>","tSS_UINT8")
      %return ansi_type.val
    %case tSS_UINT16
      %assign ansi_type = FEVAL("rtwprivate","getAnsiDataType", ...
        "%<modelName>","tSS_UINT16")
      %return ansi_type.val
    %case tSS_UINT32
      %assign ansi_type = FEVAL("rtwprivate","getAnsiDataType", ...
        "%<modelName>","tSS_UINT32")
      %return ansi_type.val
    %case tSS_BOOLEAN
      %assign ansi_type = FEVAL("rtwprivate","getAnsiDataType", ...
        "%<modelName>","tSS_BOOLEAN")
      %return ansi_type.val
    %case tSS_INT8
      %assign ansi_type = FEVAL("rtwprivate","getAnsiDataType", ...
        "%<modelName>","tSS_INT8")
      %return ansi_type.val
    %case tSS_INT16
      %assign ansi_type = FEVAL("rtwprivate","getAnsiDataType", ...
        "%<modelName>","tSS_INT16")
      %return ansi_type.val
    %case tSS_INT32
      %assign ansi_type = FEVAL("rtwprivate","getAnsiDataType", ...
        "%<modelName>","tSS_INT32")
      %return ansi_type.val
    %default
      %return "numeric"
  %endswitch
%endfunction %% SLibGetANCICDataTypeFromId


%% Function: SLibGetMLDataTypeFromId ===========================================
%% Abstract:
%%   This function returns the equivalent matlab data type to the specified
%%   TLC datatype id.
%%
%function SLibGetMLDataTypeFromId(id) void
  %switch LibGetDataTypeIdAliasedThruToFromId(id)
    %case tSS_DOUBLE
      %return "double"
    %case tSS_SINGLE
      %return "single"
    %case tSS_UINT8
      %return "uint8"
    %case tSS_UINT16
      %return "uint16"
    %case tSS_UINT32
      %return "uint32"
    %case tSS_BOOLEAN
      %return "logical"
    %case tSS_INT8
      %return "int8"
    %case tSS_INT16
      %return "int16"
    %case tSS_INT32
      %return "int32"
    %default
      %return "numeric"
  %endswitch
%endfunction %% SLibGetMLDataTypeFromId


%% Function: SLibGetIdFromMLDataType ===========================================
%% Abstract:
%%   Return the TLC data type id for the specified MATLAB data type name.
%%
%function SLibGetIdFromMLDataType(dtName)
  %switch dtName
    %case "double"
      %return tSS_DOUBLE
    %case "single"
      %return tSS_SINGLE
    %case "int32"
      %return tSS_INT32
    %case "int16"
      %return tSS_INT16
    %case "int8"
      %return tSS_INT8
    %case "uint32"
      %return tSS_UINT32
    %case "uint16"
      %return tSS_UINT16
    %case "uint8"
      %return tSS_UINT8
    %case "boolean"
    %case "logical"
      %return tSS_BOOLEAN
    %default
      %assign errTxt = "Unknown data type for: %<dtName>"
      %<LibReportFatalError(errTxt)>
  %endswitch
%endfunction  %% SLibGetIdFromMLDataType


%% Function: SLibIsUnsignedBuiltinFromId =======================================
%% Abstract:
%%   Return whether the data type corresponding to a data type ID is an
%%   unsigned builtin
%%
%function SLibIsUnsignedBuiltinFromId(id) void
  %if LibIsBuiltInDataType(id)
    %return SLibIsUnsignedFromId(id)
  %else
    %return 0
  %endif
%endfunction



%% Function: SLibIsIntegerFromId ===============================================
%% Abstract:
%%   Return whether the data type corresponding to a data type ID is an
%%   integer
%%
%function SLibIsIntegerFromId(id) void
  %switch LibGetDataTypeIdAliasedThruToFromId(id)
    %case tSS_UINT8
    %case tSS_UINT16
    %case tSS_UINT32
    %case tSS_BOOLEAN
    %case tSS_INT8
    %case tSS_INT16
    %case tSS_INT32
    %case tSS_TIMER_UINT32_PAIR
      %return 1
      %break
    %case tSS_DOUBLE
    %case tSS_SINGLE
      %return 0
      %break
    %default
      %assign errTxt = "Invalid data type %<dtypeName>."
      %<LibBlockReportFatalError([], errTxt)>
      %break
  %endswitch
%endfunction


%% Function: LibGetNumDataTypesInModel =========================================
%% Abstract:
%%   Return number of data types in a model.  This include built-in an non
%%   built-in data types.
%%
%function LibGetNumDataTypesInModel()
  %return DataTypes.NumDataTypes
%endfunction


%% Function: LibBooleanDataTypeEnabled =========================================
%% Abstract:
%%   Return whether boolean data types are enabled in model or not.
%%
%function LibStrictBooleanCheckEnabled()
  %return DataTypes.StrictBooleanCheckEnabled
%endfunction



%%--------------------------%
%% System Library functions %
%%--------------------------%


%% Function: SLibSetDataTypeName ===============================================
%% Abstract:
%%   Set the data type name for a specified record.  For example, double is
%%   is set to "real_T" by RTW.
%%
%function SLibSetDataTypeName(dataTypeRec, name) void
  %assert EXISTS("dataTypeRec.Name")

  %if ISEQUAL(dataTypeRec.Name,"") || ISEQUAL(dataTypeRec.Name,dataTypeRec.DTName)
    %assign dataTypeRec.Name = name
  %elseif !ISEQUAL(dataTypeRec.Name, name)
    %% This can happen if an s-function rename the data type more than once
    %assign errTxt = "Invalid data type name change from " ...
      "'%<dataTypeRec.Name>' to '%<name>'"
    %<LibReportFatalError(errTxt)>
  %endif
%endfunction %% SLibSetDataTypeName


%% Function: SLibSetDataTypeConvertBetweenTLCFcnName ===========================
%% Abstract:
%%   Set the ConvertBetween TLC function type name for a specified record.
%%
%function SLibSetDataTypeConvertBetweenTLCFcnName(dataTypeRec, name) void
  %if !EXISTS("dataTypeRec.ConvertBetweenTLCFcnName")
    %assign errTxt = "Unable to find 'ConvertBetweenTLCFcnName' field in the data type record " ...
      "for %<dataTypeRec.DTName>"
    %<LibReportFatalError(errTxt)>
  %endif
  %if ISEQUAL(dataTypeRec.ConvertBetweenTLCFcnName,"")
    %assign dataTypeRec.ConvertBetweenTLCFcnName = name
  %elseif !ISEQUAL(dataTypeRec.ConvertBetweenTLCFcnName, name)
    %assign errTxt = "Invalid data type ConvertBetween TLC function name " ...
      "from '%<dataTypeRec.ConvertBetweenTLCFcnName>' to '%<name>'"
    %<LibReportFatalError(errTxt)>
  %endif
%endfunction %% SLibSetDataTypeConvertBetweenTLCFcnName


%% Function: SLibSetDataTypeConvertBetweenTLCFcnFile ===========================
%% Abstract:
%%   Set the ConvertBetween TLC function type file for a specified record.
%%
%function SLibSetDataTypeConvertBetweenTLCFcnFile(dataTypeRec, file) void
  %if !EXISTS("dataTypeRec.ConvertBetweenTLCFcnFile")
    %assign errTxt = "Unable to find 'ConvertBetweenTLCFcnFile' field in the data type record " ...
      "for %<dataTypeRec.Name>"
    %<LibReportFatalError(errTxt)>
  %endif
  %if ISEQUAL(dataTypeRec.ConvertBetweenTLCFcnFile,"")
    %assign dataTypeRec.ConvertBetweenTLCFcnFile = file
  %elseif !ISEQUAL(dataTypeRec.ConvertBetweenTLCFcnFile, file)
    %assign errTxt = "Invalid data type ConvertBetween TLC function file " ...
      "from '%<dataTypeRec.ConvertBetweenTLCFcnFile>' to '%<file>'"
    %<LibReportFatalError(errTxt)>
  %endif
%endfunction %% SLibSetDataTypeConvertBetweenTLCFcnFile


%% Function: SLibSetDataTypeIsPositiveTLCFcnName ===============================
%% Abstract:
%%   Set the IsPositive TLC function type name for a specified record.
%%
%function SLibSetDataTypeIsPositiveTLCFcnName(dataTypeRec, name) void
  %if !EXISTS("dataTypeRec.IsPositiveTLCFcnName")
    %assign errTxt = "Unable to find 'IsPositiveTLCFcnName' field in the data type record " ...
      "for %<dataTypeRec.DTName>"
    %<LibReportFatalError(errTxt)>
  %endif
  %if ISEQUAL(dataTypeRec.IsPositiveTLCFcnName,"")
    %assign dataTypeRec.IsPositiveTLCFcnName = name
  %elseif !ISEQUAL(dataTypeRec.IsPositiveTLCFcnName, name)
    %assign errTxt = "Invalid data type IsPositive TLC function name " ...
      "from '%<dataTypeRec.IsPositiveTLCFcnName>' to '%<name>'"
    %<LibReportFatalError(errTxt)>
  %endif
%endfunction %% SLibSetDataTypeIsPositiveTLCFcnName


%% Function: SLibSetDataTypeIsPositiveTLCFcnFile ===============================
%% Abstract:
%%   Set the IsPositive TLC function type file for a specified record.
%%
%function SLibSetDataTypeIsPositiveTLCFcnFile(dataTypeRec, file) void
  %if !EXISTS("dataTypeRec.IsPositiveTLCFcnFile")
    %assign errTxt = "Unable to find 'IsPositiveTLCFcnFile' field in the data type record " ...
      "for %<dataTypeRec.Name>"
    %<LibReportFatalError(errTxt)>
  %endif
  %if ISEQUAL(dataTypeRec.IsPositiveTLCFcnFile,"")
    %assign dataTypeRec.IsPositiveTLCFcnFile = file
  %elseif !ISEQUAL(dataTypeRec.IsPositiveTLCFcnFile, file)
    %assign errTxt = "Invalid data type IsPositive TLC function file " ...
      "from '%<dataTypeRec.IsPositiveTLCFcnFile>' to '%<file>'"
    %<LibReportFatalError(errTxt)>
  %endif
%endfunction %% SLibSetDataTypeIsPositiveTLCFcnFile


%% Function: SLibSetDataTypeSignTLCFcnName ==============================
%% Abstract:
%%   Set the Sign TLC function type name for a specified record.
%%
%function SLibSetDataTypeSignTLCFcnName(dataTypeRec, name) void
  %if !EXISTS("dataTypeRec.SignTLCFcnName")
    %assign errTxt = "Unable to find 'SignTLCFcnName' field in the data type record " ...
      "for %<dataTypeRec.DTName>"
    %<LibReportFatalError(errTxt)>
  %endif
  %if ISEQUAL(dataTypeRec.SignTLCFcnName,"")
    %assign dataTypeRec.SignTLCFcnName = name
  %elseif !ISEQUAL(dataTypeRec.SignTLCFcnName, name)
    %assign errTxt = "Invalid data type Sign TLC function name " ...
      "from '%<dataTypeRec.SignTLCFcnName>' to '%<name>'"
    %<LibReportFatalError(errTxt)>
  %endif
%endfunction %% SLibSetDataTypeSignTLCFcnName


%% Function: SLibSetDataTypeSignTLCFcnFile ==============================
%% Abstract:
%%   Set the Sign TLC function type file for a specified record.
%%
%function SLibSetDataTypeSignTLCFcnFile(dataTypeRec, file) void
  %if !EXISTS("dataTypeRec.SignTLCFcnFile")
    %assign errTxt = "Unable to find 'SignTLCFcnFile' field in the data type record " ...
      "for %<dataTypeRec.Name>"
    %<LibReportFatalError(errTxt)>
  %endif
  %if ISEQUAL(dataTypeRec.SignTLCFcnFile,"")
    %assign dataTypeRec.SignTLCFcnFile = file
  %elseif !ISEQUAL(dataTypeRec.SignTLCFcnFile, file)
    %assign errTxt = "Invalid data type Sign TLC function file " ...
      "from '%<dataTypeRec.SignTLCFcnFile>' to '%<file>'"
    %<LibReportFatalError(errTxt)>
  %endif
%endfunction %% SLibSetDataTypeSignTLCFcnFile


%% Function: SLibSetDataTypeEnum ===============================================
%% Abstract:
%%   Set the data type enum for a specified record.
%%
%function SLibSetDataTypeEnum(dataTypeRec, enum) void
  %if !EXISTS("dataTypeRec.Enum")
    %assign errTxt = "Unable to find 'Enum' field in the data type record " ...
      "for %<dataTypeRec.DTName>"
    %<LibReportFatalError(errTxt)>
  %endif
  %if ISEQUAL(dataTypeRec.Enum,"")
    %assign dataTypeRec.Enum = enum
  %elseif !ISEQUAL(dataTypeRec.Enum, enum)
    %assign errTxt = "Invalid data type enum change from " ...
      "'%<dataTypeRec.Enum>' to '%<enum>'"
    %<LibReportFatalError(errTxt)>
  %endif
%endfunction %% SLibSetDataTypeEnum


%% Function: SLibSetDataTypeComplexName ========================================
%% Abstract:
%%   Set the complex data type name for a specified record.  For example,
%%   complex double is set to "creal_T" by RTW.
%%
%function SLibSetDataTypeComplexName(dataTypeRec, name) void
  %if ISEQUAL(dataTypeRec.ComplexName, "")
    %assign dataTypeRec.ComplexName = name
  %elseif !ISEQUAL(dataTypeRec.ComplexName, name)
    %assign errTxt = "Invalid complex data type name change from " ...
      "'%<dataTypeRec.ComplexName>' to '%<name>'"
    %<LibReportFatalError(errTxt)>
  %endif
%endfunction %% SLibSetDataTypeComplexName


%% Function: SLibSetDataTypeGroundName =========================================
%% Abstract:
%%   Set the name to be used for ground for a particular data type.  Note that
%%   an error is produced if you attempt to change the name.
%%
%function SLibSetDataTypeGroundName(dataTypeRec, name) void
  %if dataTypeRec.GroundName == ""
    %assign dataTypeRec.GroundName = name
  %elseif dataTypeRec.GroundName != name
    %assign errTxt = "Invalid ground name change from " ...
      "'%<dataTypeRec.GroundName>' to '%<name>'"
    %<LibReportFatalError(errTxt)>
  %endif
%endfunction


%% Function: SLibSetDataTypeComplexGroundName ==================================
%% Abstract:
%%   Set the name to be used for ground for a particular complex data type.
%%   Note that an error is produced if you attempt to change the name.
%%
%function SLibSetDataTypeComplexGroundName(dataTypeRec, name) void
  %if dataTypeRec.ComplexGroundName == ""
    %assign dataTypeRec.ComplexGroundName = name
  %elseif dataTypeRec.ComplexGroundName != name
    %assign errTxt = "Invalid complex ground name change from " ...
      "'%<dataTypeRec.ComplexGroundName>' to '%<name>'"
    %<LibReportFatalError(errTxt)>
  %endif
%endfunction


%% Function: SLibSetDataTypeGroundValue ========================================
%% Abstract:
%%   Set the ground value to be used for a particular data type.  An error
%%   is produced if you attempt to change the value of a particular ground.
%%
%function SLibSetDataTypeGroundValue(dataTypeRec, value) void
  %if ISEQUAL(dataTypeRec.GroundValue, "")
    %assign dataTypeRec.GroundValue = value
  %elseif !ISEQUAL(dataTypeRec.GroundValue, value)
    %assign errTxt = "Invalid ground value change from " ...
      "'%<dataTypeRec.GroundName>' to '%<value>'"
    %<LibReportFatalError(errTxt)>
  %endif
%endfunction


%% Function: SLibSetDataTypeGroundReqInMemory ==================================
%% Abstract:
%%   Mark a ground required in memory.
%%
%function SLibSetDataTypeGroundReqInMemory(dataTypeId) void
  %assign dtRec = DataTypes.DataType[dataTypeId]
  %assign dtRec.GroundReqInMemory = 1
%endfunction


%% Function: SLibSetDataTypeComplexGroundReqInMemory ===========================
%% Abstract:
%%   Mark a complex ground required in memory.
%%
%function SLibSetDataTypeComplexGroundReqInMemory(dataTypeId) void
  %assign dtRec = DataTypes.DataType[dataTypeId]
  %assign dtRec.ComplexGroundReqInMemory = 1
%endfunction


%% Function: SLibGetRecordDataTypeID ===========================================
%% Abstract:
%%   Return the data type ID for a given record.
%%
%function SLibGetRecordDataTypeId(rec) void
  %return LibGetRecordDataTypeId(rec)
%endfunction


%% Function: SLibGetRecordIsComplex ============================================
%% Abstract:
%%   Return 1 if the specified record is complex.  Otherwise, return 0
%%
%function SLibGetRecordIsComplex(rec)
  %return LibGetRecordIsComplex(rec)
%endfunction


%% Function: SLibGetRecordDataTypeName =========================================
%% Abstract:
%%   Return the data type name for a specified record.
%function SLibGetRecordDataTypeName(rec, reim)
  %return LibGetRecordDataTypeName(rec, reim)
%endfunction


%% Function: SLibGetRecordCompositeDataTypeName ================================
%% Abstract:
%%   Return the composite data type name for a specified record.  That is,
%%   return ComplexName if it exists, otherwise, return Name.
%%
%function SLibGetRecordCompositeDataTypeName(rec) void
  %return LibGetRecordCompositeDataTypeName(rec)
%endfunction


%% Function: SLibGetGroundName =================================================
%% Abstract:
%%   For a given record and real/imaginary specifier, return the name used for
%%   ground or complex ground depending the record type and the value of reim.
%%
%function SLibGetGroundName(rec, reim) void
  %return LibGetGroundName(rec, reim)
%endfunction


%% Function: SLibGetGroundValue ================================================
%% Abstract:
%%   For a given record and real/imaginary specifier, return the value used for
%%   ground depending on the record type and the value of reim.
%%
%function SLibGetGroundValue(rec, reim) void
  %return LibGetGroundValue(rec, reim)
%endfunction

%% Function: SLibGetGroundValueFromId ==========================================
%% Abstract:
%%   Returns the value used for ground for the data type id passed in.
%function SLibGetGroundValueFromId(dtypeid) void
  %return LibGetGroundValueFromId(dtypeid)
%endfunction

%% Function: SLibGetCastedValue ================================================
%% Abstract:
%%   This function casts a numeric value based on its data type.  Non built-in
%%   data types are returned "untouched".  Note that this function is useful
%%   for making appropriate TLC types.
%%
%%   For example,
%%
%%     SLibGetCastedValue(Gain, 2)
%%       ==> returns 2 as a TLC "Number" if Gain is an "signed integer"
%%
%%     SLibGetCastedValue(Gain, 2)
%%       ==> returns 2 as a TLC "Unsigned" if Gain is an "unsigned integer"
%%
%%     SLibGetCastedValue(Gain, 2)
%%       ==> returns 2.0 as a TLC "Real" if Gain is a "real" data type
%%
%%     SLibGetCastedValue(Gain, 2)
%%       ==> returns 2 as a TLC "String" if Gain is an unknown data type
%%
%%  Arguments:
%%     rec          = TLC record containing data type information
%%     numericValue = numeric value to format
%%
%function SLibGetCastedValue(rec, numericValue)
  %return(SLibGetCastedValueFromId(SLibGetRecordDataTypeId(rec), numericValue))
%endfunction


%% Function: SLibGetCastedValueFromId ==========================================
%% Abstract:
%%   This function casts a numeric value based on its data type.  Non built-in
%%   data types are returned "untouched".  Note that this function is useful
%%   for making appropriate TLC types.
%%
%%   For example,
%%
%%     SLibGetCastedValue(tSS_INT8, 2)
%%       ==> returns 2 as a TLC "Number" if Gain is an "signed integer"
%%
%%     SLibGetCastedValue(tSS_UINT16, 2)
%%       ==> returns 2 as a TLC "Unsigned" if Gain is an "unsigned integer"
%%
%%     SLibGetCastedValue(tSS_DOUBLE, 2)
%%       ==> returns 2.0 as a TLC "Real" if Gain is a "real" data type
%%
%%     SLibGetCastedValue(myDTid, 2)
%%       ==> returns 2 as a TLC "String" if Gain is an unknown data type
%%
%%   Arguments:
%%     dtypeId      = data type id
%%     numericValue = numeric value to format
%%
%function SLibGetCastedValueFromId(dTypeId, numericValue)
  %% See Also:
  %%   SLibGetFormattedValue
  %%
  %switch LibGetDataTypeIdAliasedThruToFromId(dTypeId)
    %case tSS_DOUBLE

      %% real
      %return CAST("Real", numericValue)

    %case tSS_SINGLE

      %% real
      %if ISFINITE(numericValue)
        %return CAST("Real32", numericValue)
      %else
        %% output rtInf as rtInf, not as rtInfF
        %% output rtMinusInf as rtMinusInf, not as rtMinusInfF
        %% output rtNaN as rtNaN, not as rtNaNF
        %return CAST("Real", numericValue)
      %endif

    %case tSS_UINT8
    %case tSS_UINT16
    %case tSS_UINT32
    %case tSS_BOOLEAN

      %% unsigned integer
      %return CAST("Unsigned", numericValue)

    %case tSS_INT8
    %case tSS_INT16
    %case tSS_INT32

      %% signed integer
      %return CAST("Number", numericValue)

    %default

      %% unknown type
      %return numericValue

  %endswitch
%endfunction


%% DocFunction{Other Useful Functions}: LibMinIntValue =========================
%% Abstract:
%%   For a built-in integer data type, this function returns the formatted
%%   minimum value of that data type
%%
%function LibMinIntValue(dtype) void
  %assign dtypeName = LibGetDataTypeNameFromId(LibGetDataTypeIdAliasedThruToFromId(dtype))
  %switch LibGetDataTypeIdAliasedThruToFromId(dtype)
    %case tSS_UINT8
    %case tSS_UINT16
    %case tSS_UINT32
    %case tSS_INT8
    %case tSS_INT16
    %case tSS_INT32
      %return "MIN_%<dtypeName>"
      %break
    %default
      %assign errTxt = "Invalid data type %<dtypeName>."
      %<LibBlockReportFatalError([], errTxt)>
      %break
  %endswitch
%endfunction %% LibMinIntValue


%% DocFunction{Other Useful Functions}: LibMaxIntValue =========================
%% Abstract:
%%   For a built-in integer data type, this function returns the formatted
%%   maximum value of that data type
%%
%function LibMaxIntValue(dtype) Output
  %assign dtypeName = LibGetDataTypeNameFromId(LibGetDataTypeIdAliasedThruToFromId(dtype))
  %switch LibGetDataTypeIdAliasedThruToFromId(dtype)
    %case tSS_UINT8
    %case tSS_UINT16
    %case tSS_UINT32
    %case tSS_INT8
    %case tSS_INT16
    %case tSS_INT32
      %return "MAX_%<dtypeName>"
      %break
    %default
      %assign errTxt = "Invalid data type %<dtypeName>."
      %<LibBlockReportFatalError([], errTxt)>
      %break
  %endswitch
%endfunction



%% Function: SLibGetFormattedValueFromId =======================================
%% Abstract:
%%   For a built-in data type, this function returns the formatted value of
%%   a numeric value based on its corresponding data type id.
%%   Values that are not associated with a known built-in data types are
%%   returned "untouched".
%%
%%   For example,
%%
%%     SLibGetFormattedValueFromId(Gain, 2)
%%       ==> returns 2 if Gain is an "signed integer" data type
%%
%%     SLibGetFormattedValueFromId(Gain, 2)
%%       ==> returns 2U if Gain is an "unsigned integer" data type
%%
%%     SLibGetFormattedValueFromId(Gain, 2)
%%       ==> returns 2.0 if Gain is a "real" data type
%%
%%     SLibGetFormattedValueFromId(Gain, 2)
%%       ==> returns 2 if Gain is an unknown data type
%%
%%   Arguments:
%%     rec          = data type id
%%     numericValue = numeric value to format
%%
%function SLibGetFormattedValueFromId(id, numericValue)
  %% See Also:
  %%   SLibGetFormattedValue, SLibGetCastedValue
  %%
  %assign dTypeName = LibGetDataTypeNameFromId(LibGetDataTypeIdAliasedThruToFromId(id))
  %switch LibGetDataTypeIdAliasedThruToFromId(id)
    %case tSS_DOUBLE

      %% real
      %return "%<CAST("Real", numericValue)>"

    %case tSS_SINGLE

      %% real
      %if ISFINITE(numericValue)
        %return "%<CAST("Real32", numericValue)>"
      %else
        %% output rtInf as rtInf, not as rtInfF
        %% output rtMinusInf as rtMinusInf, not as rtMinusInfF
        %% output rtNaN as rtNaN, not as rtNaNF
        %assign castValue = %<CAST("Real", numericValue)>
        %return "(%<dTypeName>) %<castValue>"
      %endif

    %case tSS_UINT8
    %case tSS_UINT16
    %case tSS_UINT32

      %% unsigned integer
      %return "%<CAST("Unsigned", numericValue)>"

    %case tSS_INT8
    %case tSS_INT16

      %% signed integer
      %return "%<CAST("Number", numericValue)>"

    %case tSS_INT32

      %% signed integer 32
      %if numericValue == (-2147483647 - 1)
        %% suppress compiler warning when using largest negative
        %% 2s-complement number for 32-bit integers
        %return "%<LibMinIntValue(id)>"
      %else
        %return "%<CAST("Number", numericValue)>"
      %endif

    %case tSS_BOOLEAN

      %% boolean
      %return (numericValue != 0) ? "TRUE" : "FALSE"

    %default

      %% unknown type
      %return numericValue

  %endswitch
%endfunction

%% Function: SLibGetFormattedValue =============================================
%% Abstract:
%%   For a built-in data type, this function returns the formatted value of
%%   a numeric value based on its corresponding data type record.
%%   Values that are not associated with a known built-in data types are
%%   returned "untouched".
%%
%%   Arguments:
%%     rec          = TLC record containing data type information
%%     numericValue = numeric value to format
%%
%function SLibGetFormattedValue(rec, numericValue)
  %% See Also:
  %%   SLibGetFormattedValueFromId, SLibGetCastedValue
  %%
  %return SLibGetFormattedValueFromId(SLibGetRecordDataTypeId(rec),numericValue)
%endfunction


%% Function: FcnEmulateResultForDSP32 ==========================================
%% Abstract:
%%   Returns the code for forcing the output to emulate to correct size of the
%%   data type.
%%
%function FcnEmulateResultForDSP32(dtIdx,cvar) Output
  %if EXISTS("DSP32")
    %if DSP32 == 1
      %if     LibGetDataTypeIdAliasedThruToFromId(dtIdx) == tSS_UINT8
        /* Emulate data types sizes for (u)int8 and (u)int16 */
        %<cvar> = %<cvar> & 0x000000ff;
      %elseif LibGetDataTypeIdAliasedThruToFromId(dtIdx) == tSS_UINT16
        /* Emulate data types sizes for (u)int8 and (u)int16 */
        %<cvar> = %<cvar> & 0x0000ffff;
      %elseif LibGetDataTypeIdAliasedThruToFromId(dtIdx) == tSS_INT8
        /* Emulate data types sizes for (u)int8 and (u)int16 */
        if (%<cvar> & 0x00000080) {
          %<cvar> = %<cvar> | 0xffffff00;
        } else {
          %<cvar> = %<cvar> & 0x000000ff;
        }
      %elseif LibGetDataTypeIdAliasedThruToFromId(dtIdx) == tSS_INT16
        /* Emulate data types sizes for (u)int8 and (u)int16 */
        if (%<cvar> & 0x00008000) {
          %<cvar> = %<cvar> | 0xffff0000;
        } else {
          %<cvar> = %<cvar> & 0x0000ffff;
        }
      %endif
    %endif
  %endif
%endfunction


%% Function: SLibSumWithSaturate ===============================================
%% Abstract:
%%   Returns the code for saturating an integer addition or subtraction.
%%
%%   o Overflow detection:
%%     Unsigned:
%%          c = a + b: if c < a => overflow (MAX)
%%          c = a - b; if b > a => overflow (MIN)
%%     Signed: (NOTE: some of == are not needed.  In order to be the same as
%%              fixed point, I decided to have them)
%%
%%          1- c = a + b: if (a >= 0) && (b >= 0) && (c < 0) => overflow (MAX)
%%          2- c = a + b: if (a < 0)  && (b < 0)  && (c >= 0)=> overflow (MIN)
%%
%%          3- c = a - b: if (a >= 0) && (b < 0)  && (c < 0) => overflow (MAX)
%%          4- c = a - b: if (a < 0)  && (b >= 0) && (c >= 0)=> overflow (MIN)
%%
%%   Arguments:
%%     dtIdx   - the data type index for a, b and c.
%%     sign    - the operation to be performed, i.e. "+" or "-".
%%     c       - the result variable name.
%%     a       - the first operand variable name.
%%     b       - the second operand variable name.
%%     bufferOverWriteTmp - temporary buffer needed when (c == a) or (c == b)
%%                          if we know the actual arguments are such that this
%%                          is not true, simply pass in ""
%%
%function SLibSumWithSaturate(dtIdx,sign,c,a,b, bufferOverWriteTmp) Output
  %assign DTnameRe = LibGetDataTypeNameFromId(dtIdx)
  %assign outputvar = c
  %if (c == a || c == b)
    %assign c = bufferOverWriteTmp
    {
    %<DTnameRe> %<bufferOverWriteTmp>;
    \
  %endif
  %switch LibGetDataTypeIdAliasedThruToFromId(dtIdx)
    %case tSS_UINT8
    %case tSS_UINT16
    %case tSS_UINT32
      %if sign == "+"
        %<c> = %<a> + %<b>;
        %<FcnEmulateResultForDSP32(dtIdx,c)>\
        if(%<c> < %<a>) {
          %<c> = %<LibMaxIntValue(dtIdx)>;
        }
      %elseif sign == "-"
        %<c> = %<a> - %<b>;
        if (%<b> > %<a>) {
          %<c> = %<LibMinIntValue(dtIdx)>;
        }
      %else
        %assign errTxt = "Invalid sign specified '%<sign>'"
        %<LibBlockReportFatalError([], errTxt)>
      %endif
      %break
    %case tSS_INT8
    %case tSS_INT16
    %case tSS_INT32
      %if sign == "+"
        %<c> = %<a> + %<b>;
        %<FcnEmulateResultForDSP32(dtIdx,c)>\
        if ((%<a> >= 0) && (%<b> >= 0) && (%<c> < 0)) {
          %<c> = %<LibMaxIntValue(dtIdx)>;
        } else if ((%<a> < 0) && (%<b> < 0) && (%<c> >= 0)) {
          %<c> = %<LibMinIntValue(dtIdx)>;
        }
      %elseif sign == "-"
        %<c> = %<a> - %<b>;
        %<FcnEmulateResultForDSP32(dtIdx,c)>\
        if (((%<a> >= 0) && (%<b> < 0) && (%<c> < 0))) {
          %<c> = %<LibMaxIntValue(dtIdx)>;
        } else if ((%<a> < 0) && (%<b> >= 0) && (%<c> >= 0)) {
          %<c> = %<LibMinIntValue(dtIdx)>;
        }
      %else
        %assign errTxt = "Invalid sign specified '%<sign>'"
        %<LibBlockReportFatalError([], errTxt)>
      %endif
      %break
    %default
      %assign errTxt = "Invalid data type %<DTnameRe>."
      %<LibBlockReportFatalError([], errTxt)>
      %break
  %endswitch
  %if (outputvar == a || outputvar == b)
    %<outputvar> = %<bufferOverWriteTmp>;
    }
  %endif
%endfunction


%% LibComplexConvertBetween ====================================================
%% Abstract:
%%   Apply ConvertBetween to data that may be complex
%%
%%   Arguments:
%%     dstId = type being converted to
%%     srcId = type being converted from
%%     cmplx = whether the signal is complex
%%     input = input signal
%%     options = options
%%     output = output signal
%%
%function LibComplexConvertBetweenForSrcId(dstId, srcId, cmplx, input, ...
  options, output) Output
  %assign ConvertBetweenFcn = ...
     LibConvertBetweenTLCFcnName(srcId)
  %if !cmplx
    %assign status = %<ConvertBetweenFcn>(dstId,srcId,input,options,output)
    %return status
  %else
    %assign realInput = "%<input>.%<tRealPart>"
    %assign imagInput = "%<input>.%<tImagPart>"
    %assign realOutput = "%<output>.%<tRealPart>"
    %assign imagOutput = "%<output>.%<tImagPart>"
    %assign status = %<ConvertBetweenFcn>(dstId,srcId,realInput,options,realOutput)
    %if status != 1
      %return status
    %endif
    %assign status = %<ConvertBetweenFcn>(dstId,srcId,imagInput,options,imagOutput)
    %return status
  %endif
%endfunction

%% LibOutputExprCast ============================================================
%% Abstract:
%%   Return whether or not a block's output expression needs to be explicitly
%%   cast to the datatype of the block's output; this needs to be done for C
%%   to prevent implicit upcasts of short integer types
%%
%function LibOutputExprCast(srcBlk, idx)
  %assign cast = ""
  %if !CompiledModel.EnforceIntegerDowncast || !srcBlk.EnforceIntegerDowncast
    %return cast
  %endif
  %assign dtype = SLibGetRecordDataTypeId(srcBlk.DataOutputPort[idx])
  %assign storageId = DataTypes.DataType[dtype].StorageId
  %% If the datatype is known to resolve to a builtin, do it for short
  %% integers
  %if LibIsBuiltInDataType(storageId)
    %if SLibIsIntegerFromId(storageId)
      %if CompiledModel.IntegerSizesExists
	%switch storageId
	  %case tSS_UINT8
	  %case tSS_INT8
            %if 8 < IntegerSizes.IntNumBits
  	      %assign cast = "(%<LibGetDataTypeNameFromId(storageId)>)"
	    %endif
	    %break
	  %case tSS_INT16
	  %case tSS_UINT16
            %if 16 < IntegerSizes.IntNumBits
  	      %assign cast = "(%<LibGetDataTypeNameFromId(storageId)>)"
	    %endif
	    %break
	  %default
	    %break    
	%endswitch
      %% If IntegerSizes target property does not exist, go with default
      %else
	%switch storageId
	  %case tSS_UINT8
	  %case tSS_UINT16
	  %case tSS_INT8
	  %case tSS_INT16
	    %assign cast = "(%<LibGetDataTypeNameFromId(storageId)>)"
	    %break
	  %default
	    %break    
	%endswitch
      %endif
    %endif
  %% If it doesn't resolve to a builtin, just cast to the output type
  %% unless a structure type
  %elseif !LibIsStructDataType(dtype)
    %assign cast = "(%<LibGetDataTypeNameFromId(dtype)>)"
  %endif
  %return cast
%endfunction

%% Function: SLibConvertBetweenBuiltin =========================================
%% Abstract:
%%   Convert between builtin datatypes
%%
%%   Arguments:
%%     outDType = desired output data type
%%     inDType = actual input data type
%%     inLabel = input signal
%%     options = options
%%     outLabel = output signal
%function SLibConvertBetweenBuiltin(outDType,inDType,inLabel,options,outLabel) Output
  %assign zero = SLibGetFormattedValueFromId(inDType,0)
  %if outDType == tSS_BOOLEAN
    %if inDType == tSS_BOOLEAN
      %<outLabel> = %<inLabel>;
    %else
      %<outLabel> = %<inLabel> != %<zero>;
    %endif
  %else
    %assign outDTypeName = LibGetDataTypeNameFromId(outDType)
    %<outLabel> = (%<outDTypeName>) %<inLabel>;
  %endif
  %return 1
%endfunction

%% Function: SLibIsPositiveBuiltin =============================================
%% Abstract:
%%   Convert between builtin datatypes
%%
%%   Arguments:
%%    inDType = type of input
%%    inLabel = input signal
%%    options = options
%%    outLabel = output signal
%%
%function SLibIsPositiveBuiltin(inDType, inLabel, options, outLabel) Output
  %if inDType == tSS_BOOLEAN
    %<outLabel> = %<inLabel>;
  %else
    %assign zero = SLibGetFormattedValueFromId(inDType,0)
    %<outLabel> = %<inLabel> > %<zero>;
  %endif
  %return 1
%endfunction

%% Function: SLibSignBuiltin ===================================================
%% Abstract:
%%   Convert between builtin datatypes
%%
%%   Arguments:
%%      inDType = type of input
%%      inLabel = input signal
%%      options = options
%%      outLabel = output signal
%%
%function SLibSignBuiltin(inDType, inLabel, options, outLabel) Output
  %if inDType == tSS_BOOLEAN
    %<outLabel> = %<inLabel>;
  %else
     %assign zero = SLibGetFormattedValueFromId(inDType,0)
     if (%<inLabel> > %<zero>) {
       %<outLabel> = 1;
     } else if (%<inLabel> < %<zero>) {
       %<outLabel> = -1;
     } else {
       %<outLabel> = 0;
     }
  %endif
  %return 1
%endfunction

%% Function: SLibSigToLogDataType ==============================================
%% Abstract:
%%   Convenient utility to return signal datatype as log datatype
%%   if signal datatype is builtin, otherwise return the specified
%%   logging datatype to be used
%%
%function SLibSigToLogDataType(sigDataType, usedLogDataType) void
  %if LibIsBuiltInDataType(sigDataType)
    %return sigDataType
  %else
    %return usedLogDataType
  %endif
%endfunction


%% Function: SLibHandleSaturateOnOverflow ======================================
%% Abstract:
%%   Convenient utility to process a block's saturate on overflow flag;
%%   return whether or not to generate saturating code.
%%
%function SLibHandleSaturateOnOverflow(block) void
  %if block.ParamSettings.SaturateOnOverflow == "Needed"
    %assign doSaturate = 1
  %elseif ParamSettings.SaturateOnOverflow == "NeededButOff"
    %<SLibCacheOverflowWarning(block)>\
    %assign doSaturate = 0
  %else
    %assign doSaturate = 0
  %endif
  %return doSaturate
%endfunction

%% Function: SLibSetupDatatypeInfo =============================================
%% Abstract:
%%   Setup variables and fields pertaining to Datatype information
%%
%function SLibSetupDatatypeInfo() void
  %%
  %% Map DataTypeTable
  %%
  %with CompiledModel
    %foreach dtIdx = DataTypes.NumDataTypes
      %assign dt = DataTypes.DataType[dtIdx]
      %%
      %% A "Name" identifier is added to all DataType records with
      %% a null default value.  RTW will error out if a block uses a
      %% non-built-in data type without setting "Name" according to
      %% SLibSetDataTypeName.
      %%
      %% Additionally, ground is defined for each built-in data type.
      %% Custom data types can be defined similarly from within a block's
      %% BlockInstanceSetup or BlockTypeSetup function.  Again, RTW will
      %% error out if a block sources to an undefined ground.
      %%
      %<LibAddIdentifier(dt, "Name", "")>
      %<LibAddIdentifier(dt, "ConvertBetweenTLCFcnName", "")>
      %<LibAddIdentifier(dt, "IsPositiveTLCFcnName", "")>
      %<LibAddIdentifier(dt, "SignTLCFcnName", "")>
      %<LibAddIdentifier(dt, "ConvertBetweenTLCFcnFile", "")>
      %<LibAddIdentifier(dt, "IsPositiveTLCFcnFile", "")>
      %<LibAddIdentifier(dt, "SignTLCFcnFile", "")>
      %<LibAddIdentifier(dt, "Enum", "")>
      %<LibAddIdentifier(dt, "GroundName", "")>
      %<LibAddIdentifier(dt, "GroundValue", "")>
      %<LibAddIdentifier(dt, "GroundInit", "")>
      %<LibAddIdentifier(dt, "GroundReqInMemory", 0)>
      %<LibAddIdentifier(dt, "GroundUsed", 0)>
      %<LibAddIdentifier(dt, "ComplexName", "")>
      %<LibAddIdentifier(dt, "ComplexGroundName", "")>
      %<LibAddIdentifier(dt, "ComplexGroundReqInMemory", 0)>
      %%
      %% Setup all built-in and pre-defined (fcn_call, pointer, integer
      %% and action) types.
      %%
      %switch dt.DTName
	%case "double"
	  %<SLibSetDataTypeName(dt, "real_T")>
	  %<SLibSetDataTypeEnum(dt, "SS_DOUBLE")>
	  %<SLibSetDataTypeConvertBetweenTLCFcnName(dt, ...
	    "SLibConvertBetweenBuiltin")>
	  %<SLibSetDataTypeIsPositiveTLCFcnName(dt, "SLibIsPositiveBuiltin")>
	  %<SLibSetDataTypeSignTLCFcnName(dt, "SLibSignBuiltin")>
	  %<LibAddToCompiledModel("tSS_DOUBLE", dt.Id)>
	  %assign gndName = "RGND"
	  %<SLibSetDataTypeGroundName(dt, gndName)>
	  %<SLibSetDataTypeGroundValue(dt, 0.0)>
	  %<SLibSetDataTypeComplexName(dt, "creal_T")>
	  %<SLibSetDataTypeComplexGroundName(dt, gndName + "_Complex")>
	  %break
	%case "single"
	  %<SLibSetDataTypeName(dt, "real32_T")>
	  %<SLibSetDataTypeEnum(dt, "SS_SINGLE")>
	  %<SLibSetDataTypeConvertBetweenTLCFcnName(dt, ...
	    "SLibConvertBetweenBuiltin")>
	  %<SLibSetDataTypeIsPositiveTLCFcnName(dt, "SLibIsPositiveBuiltin")>
	  %<SLibSetDataTypeSignTLCFcnName(dt, "SLibSignBuiltin")>
	  %<LibAddToCompiledModel("tSS_SINGLE", dt.Id)>
	  %assign gndName = "R32GND"
	  %<SLibSetDataTypeGroundName(dt, gndName)>
	  %<SLibSetDataTypeGroundValue(dt, "0.0F")>
	  %<SLibSetDataTypeComplexName(dt, "creal32_T")>
	  %<SLibSetDataTypeComplexGroundName(dt, gndName + "_Complex")>
	  %break
	%case "boolean"
	  %<SLibSetDataTypeName(dt, "boolean_T")>
	  %<SLibSetDataTypeEnum(dt, "SS_BOOLEAN")>
	  %<SLibSetDataTypeConvertBetweenTLCFcnName(dt, ...
	    "SLibConvertBetweenBuiltin")>
	  %<SLibSetDataTypeIsPositiveTLCFcnName(dt, "SLibIsPositiveBuiltin")>
	  %<SLibSetDataTypeSignTLCFcnName(dt, "SLibSignBuiltin")>
	  %<LibAddToCompiledModel("tSS_BOOLEAN", dt.Id)>
	  %assign gndName = "BGND"
	  %<SLibSetDataTypeGroundName(dt, gndName)>
	  %<SLibSetDataTypeGroundValue(dt, "FALSE")>
	  %% complex boolean undefined
	  %break
	%case "int8"
	  %<SLibSetDataTypeName(dt, "int8_T")>
	  %<SLibSetDataTypeEnum(dt, "SS_INT8")>
	  %<SLibSetDataTypeConvertBetweenTLCFcnName(dt, ...
	    "SLibConvertBetweenBuiltin")>
	  %<SLibSetDataTypeIsPositiveTLCFcnName(dt, "SLibIsPositiveBuiltin")>
	  %<SLibSetDataTypeSignTLCFcnName(dt, "SLibSignBuiltin")>
	  %<LibAddToCompiledModel("tSS_INT8", dt.Id)>
	  %assign gndName = "I8GND"
	  %<SLibSetDataTypeGroundName(dt, gndName)>
	  %<SLibSetDataTypeGroundValue(dt, 0)>
	  %<SLibSetDataTypeComplexName(dt, "cint8_T")>
	  %<SLibSetDataTypeComplexGroundName(dt, gndName + "_Complex")>
	  %break
	%case "uint8"
	  %<SLibSetDataTypeName(dt, "uint8_T")>
	  %<SLibSetDataTypeEnum(dt, "SS_UINT8")>
	  %<SLibSetDataTypeConvertBetweenTLCFcnName(dt, ...
	    "SLibConvertBetweenBuiltin")>
	  %<SLibSetDataTypeIsPositiveTLCFcnName(dt, "SLibIsPositiveBuiltin")>
	  %<SLibSetDataTypeSignTLCFcnName(dt, "SLibSignBuiltin")>
	  %<LibAddToCompiledModel("tSS_UINT8", dt.Id)>
	  %assign gndName = "U8GND"
	  %<SLibSetDataTypeGroundName(dt, gndName)>
	  %<SLibSetDataTypeGroundValue(dt, 0)>
	  %<SLibSetDataTypeComplexName(dt, "cuint8_T")>
	  %<SLibSetDataTypeComplexGroundName(dt, gndName + "_Complex")>
	  %break
	%case "int16"
	  %<SLibSetDataTypeName(dt, "int16_T")>
	  %<SLibSetDataTypeEnum(dt, "SS_INT16")>
	  %<SLibSetDataTypeConvertBetweenTLCFcnName(dt, ...
	    "SLibConvertBetweenBuiltin")>
	  %<SLibSetDataTypeIsPositiveTLCFcnName(dt, "SLibIsPositiveBuiltin")>
	  %<SLibSetDataTypeSignTLCFcnName(dt, "SLibSignBuiltin")>
	  %<LibAddToCompiledModel("tSS_INT16", dt.Id)>
	  %assign gndName = "I16GND"
	  %<SLibSetDataTypeGroundName(dt, gndName)>
	  %<SLibSetDataTypeGroundValue(dt, 0)>
	  %<SLibSetDataTypeComplexName(dt, "cint16_T")>
	  %<SLibSetDataTypeComplexGroundName(dt, gndName + "_Complex")>
	  %break
	%case "uint16"
	  %<SLibSetDataTypeName(dt, "uint16_T")>
	  %<SLibSetDataTypeEnum(dt, "SS_UINT16")>
	  %<SLibSetDataTypeConvertBetweenTLCFcnName(dt, ...
	    "SLibConvertBetweenBuiltin")>
	  %<SLibSetDataTypeIsPositiveTLCFcnName(dt, "SLibIsPositiveBuiltin")>
	  %<SLibSetDataTypeSignTLCFcnName(dt, "SLibSignBuiltin")>
	  %<LibAddToCompiledModel("tSS_UINT16", dt.Id)>
	  %assign gndName = "U16GND"
	  %<SLibSetDataTypeGroundName(dt, gndName)>
	  %<SLibSetDataTypeGroundValue(dt, 0)>
	  %<SLibSetDataTypeComplexName(dt, "cuint16_T")>
	  %<SLibSetDataTypeComplexGroundName(dt, gndName + "_Complex")>
	  %break
	%case "int32"
	  %<SLibSetDataTypeName(dt, "int32_T")>
	  %<SLibSetDataTypeEnum(dt, "SS_INT32")>
	  %<SLibSetDataTypeConvertBetweenTLCFcnName(dt, ...
	    "SLibConvertBetweenBuiltin")>
	  %<SLibSetDataTypeIsPositiveTLCFcnName(dt, "SLibIsPositiveBuiltin")>
	  %<SLibSetDataTypeSignTLCFcnName(dt, "SLibSignBuiltin")>
	  %<LibAddToCompiledModel("tSS_INT32", dt.Id)>
	  %assign gndName = "I32GND"
	  %<SLibSetDataTypeGroundName(dt, gndName)>
	  %<SLibSetDataTypeGroundValue(dt, 0)>
	  %<SLibSetDataTypeComplexName(dt, "cint32_T")>
	  %<SLibSetDataTypeComplexGroundName(dt, gndName + "_Complex")>
	  %break
	%case "uint32"
	  %<SLibSetDataTypeName(dt, "uint32_T")>
	  %<SLibSetDataTypeEnum(dt, "SS_UINT32")>
	  %<SLibSetDataTypeConvertBetweenTLCFcnName(dt, ...
	    "SLibConvertBetweenBuiltin")>
	  %<SLibSetDataTypeIsPositiveTLCFcnName(dt, "SLibIsPositiveBuiltin")>
	  %<SLibSetDataTypeSignTLCFcnName(dt, "SLibSignBuiltin")>
	  %<LibAddToCompiledModel("tSS_UINT32", dt.Id)>
	  %assign gndName = "U32GND"
	  %<SLibSetDataTypeGroundName(dt, gndName)>
	  %<SLibSetDataTypeGroundValue(dt, 0)>
	  %<SLibSetDataTypeComplexName(dt, "cuint32_T")>
	  %<SLibSetDataTypeComplexGroundName(dt, gndName + "_Complex")>
	  %break
	%case "fcn_call"
	  %<SLibSetDataTypeName(dt, "fcn_call_T")>
	  %break
	%case "pointer"
	  %<SLibSetDataTypeName(dt, "pointer_T")>
	  %<SLibSetDataTypeEnum(dt, "SS_POINTER")>
	  %<LibAddToCompiledModel("tSS_POINTER", dt.Id)>
	  %break
	%case "integer"
	  %<SLibSetDataTypeName(dt, "int_T")>
	  %<SLibSetDataTypeEnum(dt, "SS_INTEGER")>
	  %<LibAddToCompiledModel("tSS_INTEGER", dt.Id)>
	  %break
	%case "action"
	  %<SLibSetDataTypeName(dt, "action_T")>
	  %break
	%case "timer_uint32_pair"
	  %<SLibSetDataTypeName(dt, "timer_uint32_pair_T")>
	  %<SLibSetDataTypeEnum(dt, "SS_TIMER_UINT32_PAIR")>
	  %<LibAddToCompiledModel("tSS_TIMER_UINT32_PAIR", dt.Id)>
	  %break
	%default
	  %<SLibSetDataTypeName(dt,dt.DTName)>
	  %assign aIdx = dt.IdAliasedThruTo
	  %assign sIdx = dt.StorageId
	  %% Structure type
	  %if LibIsStructDataType(dtIdx)
	    %assign gndName = "%<CompiledModel.Name>_rtZ%<dt.Name>"
	    %<SLibSetDataTypeGroundName(dt, "%<gndName>")>
	    %<SLibSetDataTypeGroundValue(dt, "%<gndName>")>
	    %assign numElements = dt.NumElements
	    %assign padded = 0
	    %openfile gndValue
	    { \
	    %foreach eIdx = numElements
	      %assign padding = LibDataTypeElementPadding(dtIdx, eIdx)
	      %if eIdx < (numElements - 1) || padding > 0
		%assign comma = ","
	      %else
		%assign comma = ""
	      %endif
	      %assign eDtId = LibDataTypeElementDataTypeId(dtIdx, eIdx)
	      %assign eName = LibDataTypeElementName(dtIdx, eIdx)
	      %assign eIsComplex = LibDataTypeElementIsComplex(dtIdx, eIdx)
	      %if LibIsStructDataType(eDtId)
		%assign eGround = DataTypes.DataType[eDtId].GroundInit
	      %else
		%assign eGround = LibGetGroundValueFromId(eDtId)
	      %endif
	      %if eIsComplex
		%assign eGround = "{%<eGround>, %<eGround>}"
	      %endif
	      %assign eWidth = LibDataTypeElementWidth(dtIdx, eIdx)
	      %if eWidth == 1
		%<eGround>\
	      %else
		{ \
		%foreach elem = eWidth
		  %if elem > 0
		    , \
		  %endif
		  %<eGround>\
		%endforeach
	        } \
	      %endif
	      %<comma> /* %<eName> */
	      %if padding > 0
		%if eIdx < (numElements - 1)
		  %assign comma = ", "
		%else
		  %assign comma = ""
		%endif
		%if padding == 1
		  0U%<comma> /* sl_padding%<padded> */
		%else
		  { \
		  %foreach j = padding
		    %if j < (padding - 1)
		      %assign padcomma = ", "
		    %else
		      %assign padcomma = ""
		    %endif
		    0U%<padcomma>\
		  %endforeach
		  }%<comma> /* sl_padding%<padded> */
		%endif
		%assign padded = padded + 1
	      %endif
	    %endforeach
  	    } \
	    %closefile gndValue
	    %assign dt.GroundInit = gndValue
	    
	  %% Alias type
	  %elseif aIdx != dtIdx
	    %assign aDt = DataTypes.DataType[aIdx]
	    %<SLibSetDataTypeEnum(dt, aDt.Enum)>
	    %<SLibSetDataTypeConvertBetweenTLCFcnName(dt, ...
	      aDt.ConvertBetweenTLCFcnName)>
	    %<SLibSetDataTypeIsPositiveTLCFcnName(dt, ...
	      aDt.IsPositiveTLCFcnName)>
	    %<SLibSetDataTypeSignTLCFcnName(dt, ...
	      aDt.SignTLCFcnName)>
	    %<SLibSetDataTypeConvertBetweenTLCFcnFile(dt, ...
	      aDt.ConvertBetweenTLCFcnFile)>
	    %<SLibSetDataTypeIsPositiveTLCFcnFile(dt, ...
	      aDt.IsPositiveTLCFcnFile)>
	    %<SLibSetDataTypeSignTLCFcnFile(dt, ...
	      aDt.SignTLCFcnFile)>
	    %<SLibSetDataTypeGroundName(dt, aDt.GroundName)>
	    %<SLibSetDataTypeGroundValue(dt, aDt.GroundValue)>
	    %if aDt.GroundReqInMemory
	      %<SLibSetDataTypeGroundReqInMemory(dt)>
	    %endif
	    %if LibGetDataTypeComplexNameFromId(aIdx) != ""
	      %assign cName = "c%<dt.Name>"
	      %<SLibSetDataTypeComplexName(dt, cName)>
	      %<SLibSetDataTypeComplexGroundName(dt, aDt.ComplexGroundName)>
	    %endif
	    %if aDt.ComplexGroundReqInMemory
	      %<SLibSetDataTypeComplexGroundReqInMemory(dt)>
	    %endif
          %% Simulink.OpaqueType
	  %elseif LibPackageForDataType(dt) == "Simulink" && ...
	          LibClassForDataType(dt) == "OpaqueType"
	    %<SLibSetDataTypeGroundValue(dt, 0)>
	  %endif
	  %break
      %endswitch
      %<FixPt_DataTypeSetup(dtIdx)>
    %endforeach
    %% Add tSS_INVALID_DATA_TYPE_ID = -10
    %<LibAddToCompiledModel("tSS_INVALID_DATA_TYPE_ID", -10)>
  %endwith
  %<SLibWriteDatatypeTypedefs()>
%endfunction %% SLibSetupDatatypeInfo


%% Function: SLibWriteDatatypeTypedefs ==========================================
%% Abstract:
%%   Write datatype typedefs
%%
%function SLibWriteDatatypeTypedefs() void
  %assign headerFiles = []
  %assign numHeaderFiles = 0
  %with CompiledModel
    %openfile tmpBuffer
    %foreach dtIdx = DataTypes.NumDataTypes
      %assign dt = DataTypes.DataType[dtIdx]
      %assign dtHeaderFile = LibHeaderFileForDataType(dt) 
      %if dtHeaderFile != ""
	%if numHeaderFiles == 0
	  %assign headerFiles = headerFiles + "%<dtHeaderFile>"
	  %assign numHeaderFiles = 1
	%else
	  %assign duplicate = 0
	  %foreach idx = numHeaderFiles
	    %if headerFiles[idx] == dtHeaderFile
	      %assign duplicate = 1
	      %break
	    %endif
	  %endforeach
	  %if !duplicate
	    %assign headerFiles = headerFiles + "%<dtHeaderFile>"
	    %assign numHeaderFiles = numHeaderFiles + 1
	  %endif  
	%endif
      %else
	%assign aIdx = dt.IdAliasedTo
	%assign numElements = dt.NumElements
	%assign descStr = SLibGetDescriptionForData(DataTypes.DataType[dtIdx])
	%assign descStr = ISEMPTY(descStr) ? "" : "/* " + descStr + " */"
	%if LibIsAliasDataType(dtIdx)
	  %assign aDt = DataTypes.DataType[aIdx]
	  #ifndef _DEFINED_TYPEDEF_FOR_%<dt.Name>_
	  #define _DEFINED_TYPEDEF_FOR_%<dt.Name>_
	  typedef %<aDt.Name> %<dt.Name>; %<descStr>
	  %if SupportComplex && aDt.ComplexName != ""
	    typedef %<aDt.ComplexName> %<dt.ComplexName>;
	  %endif
	  #endif
	  
	%elseif LibIsStructDataType(dtIdx)
	  %assign padded = 0
	  #ifndef _DEFINED_TYPEDEF_FOR_%<dt.Name>_
	  #define _DEFINED_TYPEDEF_FOR_%<dt.Name>_
	  typedef struct {
	    %foreach eIdx = numElements
	      %assign eName = LibDataTypeElementName(dtIdx, eIdx)
	      %assign eDtId = LibDataTypeElementDataTypeId(dtIdx, eIdx)
	      %assign eCplx = LibDataTypeElementIsComplex(dtIdx, eIdx)
	      %if eCplx 
		%assign eDtNm = LibGetDataTypeComplexNameFromId(eDtId)
	      %else
		%assign eDtNm = LibGetDataTypeNameFromId(eDtId)
	      %endif
	      %assign eWidth = LibDataTypeElementWidth(dtIdx, eIdx)
	      %if eWidth == 1
		%assign arrayDim = ""
	      %else
		%assign arrayDim = "[%<eWidth>]"
	      %endif
	      %<eDtNm> %<eName>%<arrayDim>;
	      %assign padding = LibDataTypeElementPadding(dtIdx, eIdx)
	      %if padding == 1
		unsigned char sl_padding%<padded>;
		%assign padded = padded + 1
	      %elseif padding > 0
		unsigned char sl_padding%<padded>[%<padding>];
		%assign padded = padded + 1
	      %endif
	    %endforeach
	  } %<dt.Name>; %<descStr>
	  #endif
	  
	%endif
      %endif
    %endforeach
    %closefile tmpBuffer

    %assign typesFile = SLibAddModelFile("SystemHeader","Simulink", "%<Name>_types")
    %<SLibSetModelFileAttribute(typesFile, "Typedefs", tmpBuffer)>
    %if numHeaderFiles > 0
      %openfile tmpBuffer
      %foreach idx = numHeaderFiles
	#include %<headerFiles[idx]>
      %endforeach
      %closefile tmpBuffer
      %<SLibSetModelFileAttribute(typesFile, "Includes", tmpBuffer)>
    %endif

  %endwith
%endfunction %% SLibWriteDatatypeInfo


%% Function: SLibWriteDatatypeGrounds ==========================================
%% Abstract:
%%   Write data type grounds
%%
%function SLibWriteDatatypeGrounds() void
  %with CompiledModel
    %assign defsFile = SLibAddModelFile("SystemBody","Simulink", "%<Name>")
    %assign declsFile = SLibAddModelFile("SystemHeader","Simulink", "%<Name>")
    %foreach dtIdx = DataTypes.NumDataTypes
      %assign dt = DataTypes.DataType[dtIdx]
      %if LibIsStructDataType(dtIdx)
	%if dt.GroundUsed
	  %assign gndName = dt.GroundName
	  %assign defGnd = "const %<dt.Name> %<gndName> = %<dt.GroundInit>;\n\n"
	  %assign declGnd = "extern const %<dt.Name> %<gndName>;\n\n"
	  %<SLibSetModelFileAttribute(defsFile, "Definitions", defGnd)>
	  %<SLibSetModelFileAttribute(declsFile, "Declarations", declGnd)>
	%endif
      %endif
    %endforeach
  %endwith
%endfunction %% SLibWriteDatatypeGrounds


%% Function: SLibSfunRegisterAndSetDataType ==================================
%% Abstract:
%%   Set the Data Type the data type for an sfunction, input, output, or DWork.
%%   Register the data type if necessary, such as for fixed point data types.
%%
%% Arguments:
%%  categoryStr       string   "input", "output", or "dwork"
%%  SimstrucLabel     string   generated code RValue for simstruct
%%  elementIndexLabel string   generated code RValue for index of 
%%                                 input, output, dwork
%%  origDataTypeIndex integer  data type index written to rtw file
%%  modeForUnknownStr string   How to handle case when data type is unknown
%%                              "namedObject", "none", "warning", "error"
%function SLibSfunRegisterAndSetDataType(...
  categoryStr, ...
  SimstrucLabel, ...
  elementIndexLabel, ...
  origDataTypeIndex, ...
  modeForUnknownStr) Output
  %%
  if (ssGetSimMode(%<SimstrucLabel>) != SS_SIMMODE_SIZES_CALL_ONLY) {
  %switch categoryStr
      %%
    %case "input"
      %%
      %assign dataTypeSetFuncStr = "ssSetInputPortDataType"
      %%
      %break
      %%
    %case "output"
      %%
      %assign dataTypeSetFuncStr = "ssSetOutputPortDataType"
      %%
      %break
      %%
    %case "dwork"
      %%
      %assign dataTypeSetFuncStr = "ssSetDWorkDataType"
      %%
      %break
      %%
    %default
      %%START_ASSERT
      %<LibReportFatalError("Unknown category, %<category>, for setting sfunction data type.")>
      %%END_ASSERT
  %endswitch
  %%
  %if LibIsFundamentalBuiltInDataType(origDataTypeIndex)
    %assign dtEnum = LibGetDataTypeEnumFromId(origDataTypeIndex)
    %<dataTypeSetFuncStr>(%<SimstrucLabel>, %<elementIndexLabel>, %<dtEnum>);
  %else
    %%
    %assign curDT = FixPt_GetDataTypeFromIndex(origDataTypeIndex)
    %%
    %if curDT.IsFixedPoint
      %% NOTE:
      %% The source code for user written fixed-point C S-Functions must 
      %% contain two extra #includes.  
      %% First, at the beginning of the C file, just after the standard
      %%      #include "simstruc.h"
      %% also put
      %%      #include "fixedpoint.h"
      %% Second, at the end of the C file, just after the standard
      %%      # include "simulink.c"
      %% also put
      %%      # include "fixedpoint.c"
      %%
      {
        DTypeId dataTypeIdReg =
        %if FixPt_DataTypeIsFloat(curDT)
          ssRegisterDataTypeFxpScaledDouble(
        %else
          ssRegisterDataTypeFxpFSlopeFixExpBias(
        %endif
        %<SimstrucLabel>,
        %<curDT.IsSigned>,
        %<curDT.RequiredBits>,
        %<curDT.FracSlope>,
        %<curDT.FixedExp>,
        %<curDT.Bias>,
        0 /* false means do NOT obey data type override setting for this subsystem */ );
        
        %<dataTypeSetFuncStr>(%<SimstrucLabel>, %<elementIndexLabel>, dataTypeIdReg );
      }
    %else
      %assign dtEnum = LibGetDataTypeEnumFromId(origDataTypeIndex)
      %%
      %if dtEnum == "SS_POINTER" || dtEnum == "SS_INTEGER"
        %<dataTypeSetFuncStr>(%<SimstrucLabel>, %<elementIndexLabel>, %<dtEnum>);
      %else
        %switch modeForUnknownStr
            %%
          %case "namedObject"
            %%
            {
              DTypeId dataTypeIdReg;
              
              ssRegisterTypeFromNamedObject(
                %<SimstrucLabel>,
                "%<LibGetDataTypeNameFromId(origDataTypeIndex)>",
                &dataTypeIdReg);
              
              if(dataTypeIdReg == INVALID_DTYPE_ID) return;
              %<dataTypeSetFuncStr>(%<SimstrucLabel>, %<elementIndexLabel>, dataTypeIdReg );
            }
            %%
            %break
            %%
          %case "none"
            %%
            %break
            %%
          %default
            %%
            %openfile dataTypeRegFailMsg
User-defined data type %<LibGetDataTypeNameFromId(origDataTypeIndex)> is required
for %<categoryStr> %<elementIndexLabel>, but the information needed to define 
this data type in the generated S-Function is unknown. 
            %if modeForUnknownStr == "warning"
The generated code that normally specifies the data type of this 
%<categoryStr> is being omitted.  If additional custom code does not register 
this user-define data type and set the data type of this %<categoryStr>, 
then the generated code will be incomplete.
            %endif
            %closefile dataTypeRegFailMsg
            %if EXISTS("block")
              %if modeForUnknownStr == "warning"
                %<LibBlockReportWarning(block,dataTypeRegFailMsg)>
              %else
                %<LibBlockReportFatalError(block,dataTypeRegFailMsg)>
              %endif
            %else
              %if modeForUnknownStr == "warning"
                %<LibReportWarning(dataTypeRegFailMsg)>
              %else
                %<LibReportFatalError(dataTypeRegFailMsg)>
              %endif
          %endif
        %endswitch
      %endif
    %endif
  %endif
  }
  %return
%endfunction %% SLibSfunRegisterAndSetDataType

%%
%% End of library code
%%

%endif %% _DTYPELIB_

%% [EOF] dtypelib.tlc
