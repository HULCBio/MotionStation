%%
%% $Revision: 1.1.6.3 $ 
%%
%% Abstract:
%%      TLC file for generating the nonfinite code via Target Function Library (TFL).
%%
%% Copyright 2003-2004 The MathWorks, Inc.

%implements "genrtnonfinite" "C"

%% Function: FcnLittleEndian ===================================================
%% Abstract:
%%      Setup code for nonfinte values on little-endian processors
%% 
%function FcnLittleEndian() Output
  typedef struct {
    uint32_T fraction : 23;
    uint32_T exponent  : 8;
    uint32_T sign      : 1;
  } LittleEndianIEEESingle;
  
  typedef struct {
    struct {
      uint32_T fraction2;
    } wordH;
    struct {
      uint32_T fraction1 : 20;
      uint32_T exponent  : 11;
      uint32_T sign      : 1;
    } wordL;
  } LittleEndianIEEEDouble;
  
  (*(LittleEndianIEEESingle*)&rtInfF).sign      = 0;
  (*(LittleEndianIEEESingle*)&rtInfF).exponent  = 0xFF;
  (*(LittleEndianIEEESingle*)&rtInfF).fraction  = 0;
  rtMinusInfF = rtInfF;
  rtNaNF = rtInfF;
  (*(LittleEndianIEEESingle*)&rtMinusInfF).sign = 1;
  (*(LittleEndianIEEESingle*)&rtNaNF).fraction  = 0x7FFFFF;
  
  if (realSize == 4) {
    (*(LittleEndianIEEESingle*)&rtInf).sign      = 0;
    (*(LittleEndianIEEESingle*)&rtInf).exponent  = 0xFF;
    (*(LittleEndianIEEESingle*)&rtInf).fraction  = 0;
    rtMinusInf = rtInf;
    rtNaN = rtInf;
    (*(LittleEndianIEEESingle*)&rtMinusInf).sign = 1;
    (*(LittleEndianIEEESingle*)&rtNaN).fraction  = 0x7FFFFF;
  } else {
    (*(LittleEndianIEEEDouble*)&rtInf).wordL.sign      = 0;
    (*(LittleEndianIEEEDouble*)&rtInf).wordL.exponent  = 0x7FF;
    (*(LittleEndianIEEEDouble*)&rtInf).wordL.fraction1 = 0;
    (*(LittleEndianIEEEDouble*)&rtInf).wordH.fraction2 = 0;
  
    rtMinusInf = rtInf;
    (*(LittleEndianIEEEDouble*)&rtMinusInf).wordL.sign = 1;
    (*(LittleEndianIEEEDouble*)&rtNaN).wordL.sign      = 0;
    (*(LittleEndianIEEEDouble*)&rtNaN).wordL.exponent  = 0x7FF;
    (*(LittleEndianIEEEDouble*)&rtNaN).wordL.fraction1 = 0xFFFFF;
    (*(LittleEndianIEEEDouble*)&rtNaN).wordH.fraction2 = 0xFFFFFFFF;
  }
%endfunction

%% Function: FcnBigEndian ======================================================
%% Abstract:
%%      Setup code for nonfinte values on big-endian processors
%% 
%function FcnBigEndian() Output
  typedef struct {
    uint32_T sign      : 1;
    uint32_T exponent  : 8;
    uint32_T fraction  : 23;
  } BigEndianIEEESingle;
  
  typedef struct {
    struct {
      uint32_T sign      : 1;
      uint32_T exponent  : 11;
      uint32_T fraction1 : 20;
    } wordL;
    struct {
      uint32_T fraction2;
    } wordH;
  } BigEndianIEEEDouble;
  
  (*(BigEndianIEEESingle*)&rtInfF).sign      = 0;
  (*(BigEndianIEEESingle*)&rtInfF).exponent  = 0xFF;
  (*(BigEndianIEEESingle*)&rtInfF).fraction  = 0;
  rtMinusInfF = rtInfF;
  rtNaNF = rtInfF;
  (*(BigEndianIEEESingle*)&rtMinusInfF).sign = 1;
  (*(BigEndianIEEESingle*)&rtNaNF).fraction  = 0x7FFFFF;
  
  if (realSize == 4) {
    (*(BigEndianIEEESingle*)&rtInf).sign      = 0;
    (*(BigEndianIEEESingle*)&rtInf).exponent  = 0xFF;
    (*(BigEndianIEEESingle*)&rtInf).fraction  = 0;
    rtMinusInf = rtInf;
    rtNaN = rtInf;
    (*(BigEndianIEEESingle*)&rtMinusInf).sign = 1;
    (*(BigEndianIEEESingle*)&rtNaN).fraction  = 0x7FFFFF;
  } else {
    (*(BigEndianIEEEDouble*)&rtInf).wordL.sign      = 0;
    (*(BigEndianIEEEDouble*)&rtInf).wordL.exponent  = 0x7FF;
    (*(BigEndianIEEEDouble*)&rtInf).wordL.fraction1 = 0;
    (*(BigEndianIEEEDouble*)&rtInf).wordH.fraction2 = 0;
    
    rtMinusInf = rtInf;
    (*(BigEndianIEEEDouble*)&rtMinusInf).wordL.sign = 1;
    (*(BigEndianIEEEDouble*)&rtNaN).wordL.sign      = 0;
    (*(BigEndianIEEEDouble*)&rtNaN).wordL.exponent  = 0x7FF;
    (*(BigEndianIEEEDouble*)&rtNaN).wordL.fraction1 = 0xFFFFF;
    (*(BigEndianIEEEDouble*)&rtNaN).wordH.fraction2 = 0xFFFFFFFF;
    }
%endfunction


%% Function: rt_InitInfAndNaN ==================================================
%% Abstract:
%%      GENERATE entry point for Target Function Library TLC callbacks. Creates
%%      header and source file contents for nonfinites.
%%
%function rt_InitInfAndNaN(fctInfo,fileH,fileC) void
  
  %if EXISTS(::OrigName)
    %assign modelName = CompiledModel.OrigName
  %else
    %assign modelName = CompiledModel.Name
  %endif

  %if ConfigSet.IsERTTarget && !ConfigSet.GenerateErtSFunction && ...
    ModelReferenceTargetType != "SIM"
    %assign tmfVersion = FEVAL("get_tmf_version", modelName)
    %if ConfigSet.PurelyIntegerCode || !ConfigSet.SupportNonFinite || ...
      (!SLibRealNonFinitesRequired() && (tmfVersion != "Standalone"))
      %% No need to generate nonfinites.
      %<LibSetSourceFileSection(fileH, "Filter", 1)>
      %<LibSetSourceFileSection(fileC, "Filter", 1)>
      %return
    %endif                                                                  
  %endif
  
  %% Create header file contents
  %openfile buf
  /*
  * %<fctInfo.FileName>.c
  *
  %<SLibCommonHeaderInfo()>\
  */
  %closefile buf
  %<LibSetSourceFileSection(fileH, "Banner", buf)>

  %assign tmfFullPath = FEVAL("rtwprivate","get_makertwsettings", modelName, "TemplateMakefile")
  %assign isvc = FEVAL("findstr","_vc.tmf", tmfFullPath)
  %assign isvc = !ISEMPTY(isvc)

  %openfile buf
  %if isvc
    %% For MSVC, we need to use a function which needs float.h. We
    %% don't track this header dependency in TFL because it is a dynamic
    %% dependency which is only needed for the RTW target of a ML Host
    %% with MSVC for which float.h will be available.
    #include <float.h>
  %endif
  #include "rtwtypes.h"

  %closefile buf
  %<LibSetSourceFileSection(fileH, "Includes", buf)>

  %openfile buf
  extern real_T rtInf;
  extern real_T rtMinusInf;
  extern real_T rtNaN;
  extern real32_T rtInfF;
  extern real32_T rtMinusInfF;
  extern real32_T rtNaNF;

  extern void rt_InitInfAndNaN(int_T realSize);
  extern boolean_T rtIsInf(real_T value);
  extern boolean_T rtIsInfF(real32_T value);
  extern boolean_T rtIsNaN(real_T value);
  extern boolean_T rtIsNaNF(real32_T value);

  %closefile buf
  %<LibSetSourceFileSection(fileH, "Declarations", buf)>
  
  %% Create source file contents
  %openfile buf
  /*
  * %<fctInfo.FileName>.c
  *
  %<SLibCommonHeaderInfo()>\
  *
  * Abstract:
  *      Real-Time Workshop function to intialize non-finites,
  *      (Inf, NaN and -Inf).
  */
  %closefile buf
  %<LibSetSourceFileSection(fileC, "Banner", buf)>
  
  %openfile buf
  #include "rt_nonfinite.h"
  
  %closefile buf
  %<LibSetSourceFileSection(fileC, "Includes", buf)>

  %openfile buf
  real_T rtInf;
  real_T rtMinusInf;
  real_T rtNaN;
  
  real32_T rtInfF;
  real32_T rtMinusInfF;
  real32_T rtNaNF;
  %closefile buf
  %<LibSetSourceFileSection(fileC, "Declarations", buf)>
  
  %openfile buf
  /* Function: rt_InitInfAndNaN ==================================================
  * Abstract:
  *	Initialize the rtInf, rtMinusInf, and rtNaN needed by the
  *	generated code. NaN is initialized as non-signaling. Assumes IEEE.
  */
  void rt_InitInfAndNaN(int_T realSize) {
    %if !ConfigSet.IsERTTarget || ConfigSet.TargetEndianess == "Unspecified"
      short one = 1;
      enum {
	LittleEndian,
	BigEndian
      } machByteOrder = (*((char *) &one) == 1) ? LittleEndian : BigEndian;
      
      switch (machByteOrder) {
	case LittleEndian: {
	  %<FcnLittleEndian()>
	}
	break;
	case BigEndian: {
	  %<FcnBigEndian()>
	}
	break;
      }
    %elseif ConfigSet.TargetEndianess == "LittleEndian"
      %<FcnLittleEndian()>
    %elseif ConfigSet.TargetEndianess == "BigEndian"
      %<FcnBigEndian()>
    %else
      %openfile errTxt
      Unsupported Target Endianess: %<ConfigSet.TargetEndianess>
      %closefile errTxt
      %<LibReportFatalError(errTxt)>
    %endif
  }
  
  /* Function: rtIsInf ==================================================
  * Abstract:
  *	Test if value is infinite
  */
  boolean_T rtIsInf(real_T value) {
    return(value==rtInf || value==rtMinusInf);
  }
  
  /* Function: rtIsInfF =================================================
  * Abstract:
  *	Test if single-precision value is infinite
  */
  boolean_T rtIsInfF(real32_T value) {
    return((value)==rtInfF || (value)==rtMinusInfF);
  }
  
  /* Function: rtIsNaN ==================================================
  * Abstract:
  *	Test if value is not a number
  */
  boolean_T rtIsNaN(real_T value) {
    %if isvc
      %% For MSVC, we need to use a special function
      return _isnan(value)? true:false;
    %else
      return(value!=value);
    %endif
  }
  
  /* Function: rtIsNaNF =================================================
  * Abstract:
  *	Test if single-precision value is not a number
  */
  boolean_T rtIsNaNF(real32_T value) {
    %if isvc
      %% For MSVC, we need to use a special function
      return _isnan((real_T)value)? true:false;
    %else
      return(value!=value);
    %endif
  }
  
  /* end rt_nonfinite.c */
  %closefile buf
  %<LibSetSourceFileSection(fileC, "Functions", buf)>
%endfunction
