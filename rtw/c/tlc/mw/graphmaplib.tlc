%% $RCSfile: graphmaplib.tlc,v $
%% $Revision: 1.2.4.3 $
%% $Date: 2004/04/14 23:48:26 $
%%
%% April 10, 2001
%% Copyright 1994-2004 The MathWorks, Inc.
%%
%% Disclaimer
%% ==========
%%
%% The functionality provided in this TLC module is currently under
%% development.
%% 
%% Nomenclature
%% ============
%% 
%%  ? Lines and words marked with the question mark are subject to discussion,
%%    change or general not settled at this point in time
%%
%%  i Lines leaded by "i" marking Mathworks internal fields that should not
%%    be used by a customer
%%
%% Syntax  
%% ======
%%
%% Subsystem - Sybsystem or root level system
%%
%% Abstract
%% ========
%%
%% The BlockHierarchyMap provides a in memory representation of the
%% graphical model.
%%
%% BlockHierarchyMap {
%%   NumSubsystems           - Number of node records in the 
%%
%%   Subsystem {
%%     Name                  - Mangled subsystem name
%%     SLName                - Unmangled subsystem name
%%
%%     SubsystemBlkIndex     - [ Subsystem index, Block index ] back reference
%%                             to the subsystem block in the 
%%                             BlockHierarchyMap
%%
%%     Type                  - Subsystem type (root, enable, trigger, fcncall
%%                             action, virtual)
%%     MaskType              - empty ("") if not mask other wise mask type
%%     ChildSubsystems       - Vector of subsystem indices that include all
%%                             child subsystem blocks
%%     ChildSubsystemBlks    - Vector of block indices that include all 
%%                             child subsystem blocks
%%     InputPortBlocks       - Vector of indices that include all input port
%%                             blocks
%%     OutputPortBlocks      - Vector of indices that include all output port
%%                             blocks
%%     DataStoreBlocks       - Vector of indices that include all data store
%%                             memory blocks
%%     NumBlocks             - Number of Blocks
%%
%%     Block {
%%       Name                - Mangled block name
%%       SLName              - Unmangled block name
%%       Type                - BlockType includes subsystems, input and output 
%%                             port blocks
%%       Virtual [0, 1, 2]   - (no, yes, pcv) pcv ... post compile virtual
%%
%% i     _blkref             - [system idx, instance idx, block idx]
%% i                           This field is for internal usage only. A library
%% i                           function will be provided that returns the real
%% i                           block record ([-1, -1, -1] for virtual or pcv)
%%       NumDataOutputPorts  - Number of data output ports
%%       NumDataInputPorts   - Number of data input ports                      
%%       NumControlInputPorts
%%                           - Number of control (enable, trigger, fcn-call)
%%                             input ports
%%
%%       DataOutputPort {
%%         Name              - Mangled port name
%%         SLName            - Unmangled port name
%%         SignalLabel       - Label of the signal line connected
%%                             to the output port
%%         Connected         - (no, yes, partial) or (0,1,2)
%%         TestPoint         - 1 if the user marked the output port as a
%%                             testpoint (0 otherwise)
%%         NumRegions        - Number of contiguous memory regions
%%
%%         Region {
%%           MemoryMapIdx    - Index into the global memory map
%%                             Information about data type, dimension, ...
%%                             can be read from the global memory map
%%           Offset          - non zero if connected to a merge block
%%           Length          - length of the contiguous memory region
%%           Dimensions       
%%           Connected       - (no, yes) or (0, 1) 
%%
%%         }
%%       }
%%
%%       DataInputPort {     - same contents as DataOutputPort
%%       }
%%
%%       ControlInputPort {  - same contents as DataOutputPort
%%       }
%%
%%       NumParameters
%%       Parameter {
%%         Name              - Mangled parameter name
%%         IsReference       - (no, yes) or (0, 1) is references by a 
%%                              workspace or mask variable
%%         MemoryMapIdx
%%       }
%%  
%%       NumContStates
%%       ContState {
%%         Name             - Named continues state
%%         Dimensions
%%         MemoryMapIdx
%%       }
%%       
%%       NumDiscStates
%%       DiscState {
%%         Name             - Named discrete state
%%         Dimensions
%%         MemoryMapIdx
%%       }
%%       
%%       NumDerivatives
%%       Derivative {
%%         Name             - empty
%%         Dimensions
%%         MemoryMapIdx
%%       }
%%       
%%       NumDataStores      - non zero if data store memory block
%%       DataStore {
%%         Name             - Name of the data store
%%         SLName           - 
%%         MemoryName       -  
%%         Dimenstion
%%         MemoryMapIdx
%%       }
%% 
%%     } %% end of Block
%%   } %% end of Subsystem
%% } %% end of BlockHierarchyMap
%%
%%

%% Function: FcnMapBlockHierarchy =============================================
%% Abstract:
%%   Maps the block hierarchy map to the global mememory map.
%%
%function FcnMapBlockHierarchy() void
  %with BlockHierarchyMap  
    %foreach sybsysIdx = NumSubsystems
      %with Subsystem[sybsysIdx]
	%foreach blkIdx = NumBlocks
	  %with Block[blkIdx]
	    %foreach portIdx = NumDataInputPorts
	      %<FcnMapPort(DataInputPort[portIdx])>
	    %endforeach
	    %foreach portIdx = NumControlInputPorts
	      %<FcnMapPort(ControlInputPort[portIdx])>
	    %endforeach
	    %foreach portIdx = NumDataOutputPorts
	      %<FcnMapPort(DataOutputPort[portIdx])>
	    %endforeach
	    %foreach paraIdx = NumParameters
	      %<FcnMapParameter(Parameter[paraIdx])>
	    %endforeach
	    %foreach dstateIdx = NumDiscStates
	      %<FcnMapDState(DiscState[dstateIdx])>
	    %endforeach
	    %foreach cstateIdx = NumContStates
	      %<FcnMapCState(ContState[cstateIdx])>
	    %endforeach
	    %foreach cderivIdx = NumDerivatives
	      %<FcnMapCStateDerivatives(Derivative[cderivIdx])>
	    %endforeach
	    %foreach dstoreIdx = NumDataStores
	      %<FcnMapDStore(DataStore[dstoreIdx])>
	    %endforeach
	  %endwith
	%endforeach
      %endwith
    %endforeach
  %endwith %% BlockHierarchyMap
%endfunction

%% Function: SLibSystemBlockExist =============================================
%% Abstract:
%%   Returns true if there a one to one mapping from a block record in the
%%   block hierarchy map to a block record in the Systems record exist.
%%
%function SLibSystemBlockExist(grBlock) void
  %return (ISFIELD(grBlock, "_blkref") && grBlock._blkref[2] != -1) ? ...
    TLC_TRUE : TLC_FALSE
%endfunction

%% Function: SLibGraphicalBlockExist ==========================================
%% Abstract:
%%   Returns true if there a one to one mapping from a block record in the
%%   Systems record to a block record in block hierarchy map the exist.
%%
%function SLibGraphicalBlockExist(block) void
  %return (ISFIELD(block, "GrSrc") && block.GrSrc[1] != -1) ? ...
    TLC_TRUE : TLC_FALSE
%endfunction

%% Function: SLibGetGraphicalBlockIdx =========================================
%% Abstract:
%%   This function returns the graphical block index for System block record.
%%
%% Example:
%%
%%   %if SLibGraphicalBlockExist(block)
%%     %assign grBlockIndex = SLibGetGraphicalBlockIdx(block)
%%     %with CompiledModel.BlockHierarchyMap
%%       %assign grSubSys = Subsystem[grBlockIndex[0]]
%%       %assign grBlock  = grSubSys.Block[grBlockIndex[1]]
%%     %endwith
%%   %endif
%%
%function SLibGetGraphicalBlockIdx(block) void
  %return ISFIELD(block, "GrSrc") ? block.GrSrc : [-1, -1]
%endfunction

%% Function: SLibGetSystemBlockIdx ============================================
%% Abstract:
%%   This function returns the system block index for block hierarchy map block
%%   record.
%% 
%% Example:
%%
%%   %if SLibSystemBlockExist(grBlock)
%%     %assign blockIndex = SLibGetSystemBlockIdx(grBlock)
%%     %with CompiledModel
%%       %assign system = System[blockIndex[0]]
%%       %assign  block = system.Block[blockIndex[2]]
%%     %endwith
%%   %endif
%%
%function SLibGetSystemBlockIdx(grBlock) void
  %return ISFIELD(grBlock, "_blkref") ? grBlock._blkref : [-1, -1, -1]
%endfunction

%% Function: FcnMapPort =======================================================
%% Abstract:
%%   Maps a port object to the global memory map.
%%
%function FcnMapPort(port) void
  %createrecord portObj { SignalSrc [-1] SignalOffset [-1] Width 1 }
  %with port
    %foreach regIdx = NumRegions
      %assign portObj.SignalSrc = Region[regIdx]._Source
      %assign sigRec = SLibGetSourceRecord(portObj, 0)
      %if !ISEMPTY(sigRec) %% grounded or function call
        %assign Region[regIdx].MemoryMapIdx = sigRec.MemoryMapIdx
      %endif
    %endforeach
  %endwith
%endfunction

%% Function: FcnMapParameter ==================================================
%% Abstract:
%%   Maps a parameter object to the global memory map.
%%
%function FcnMapParameter(parameter) void
  %if parameter._idx > -1 %% post compile virtual blocks
    %assign parameter.MemoryMapIdx = ...
      ModelParameters.Parameter[parameter._idx].MemoryMapIdx
  %endif
%endfunction

%% Function: FcnMapDState =====================================================
%% Abstract:
%%   Maps a discrete state object to the global memory map.
%%
%function FcnMapDState(dstate) void
  %if dstate._idx > -1 %% post compile virtual blocks
    %assign dstate.MemoryMapIdx = ...
      CompiledModel.DWorks.DWork[dstate._idx].MemoryMapIdx
  %endif
%endfunction

%% Function: FcnMapCState =====================================================
%% Abstract:
%%   Maps a Continuous state object to the global memory map.
%%
%function FcnMapCState(cstate) void
  %assign cstate.MemoryMapIdx = ...
    CompiledModel.ContStates.ContState[cstate._idx].MemoryMapIdx 
%endfunction

%% Function: FcnMapCStateDerivatives =========================================
%% Abstract:
%%   Maps a Continuous state object to the global memory map.
%%
%function FcnMapCStateDerivatives(cderiv) void
  %assign cderiv.MemoryMapIdx = ...
    CompiledModel.ContStates.ContState[cderiv._idx].DerivativeMemoryMapIdx 
%endfunction

%% Function: FcnMapDStore =====================================================
%% Abstract:
%%   Maps a data store memory block to the global memory map.
%%
%function FcnMapDStore(dstore) void
  %if dstore._idx > -1 %% post compile virtual blocks
    %assign dstore.MemoryMapIdx = ...
      CompiledModel.DWorks.DWork[dstore._idx].MemoryMapIdx
  %endif
%endfunction

