<html><head><title>Creating C++ S-Functions (Writing S-Functions)</title>
<!-- $Revision: 1.6 $  $Date: 2002/06/27 13:11:15 $ -->

<!-- DOCNAME: Writing S-Functions -->
<!-- CHUNKNAME: Source File Format -->
<!-- CHAPNAME: Creating C++ S-Functions -->
<!-- HEADSTUFF -->
<link rel=stylesheet href="docstyle1.css" type="text/css">
</head>
<body bgcolor=#ffffff>
<!-- NAVBARTOP -->
<table border=0 width="100%" cellpadding=0 cellspacing=0><tr>
<td valign=baseline bgcolor="#ffe4b0"><b>Writing S-Functions</b></td>
<td valign=baseline bgcolor="#ffe4b0" align=right><a href="sfun_c++.html"><img src="b_prev.gif" border=0></a>&nbsp;&nbsp;&nbsp;<a href="sfun_c++3.html"><img src="b_next.gif" border=0></a></td>
</tr>
</table>


<a name="source_file_format"></a><!-- H1 --><a name="88371"></a><p><font size=+2 color="#990000"><b>Source File Format</b></font><br>
<p><a name="88372"></a>The format of the C++ source for an S-function is nearly identical to that of the source for an S-function written in C. The main difference is that you must tell the C++ compiler to use C calling conventions when compiling the callback methods. This is necessary because the Simulink simulation engine assumes that callback methods obey C calling conventions. </p>
<p><a name="88774"></a>To tell the compiler to use C calling conventions when compiling the callback methods, wrap the C++ source for the S-function callback methods in an <code>extern "C"</code> statement. The C++ version of the <code>sfun_counter</code> S-function example (<code><em>matlabroot</em></code><code>/simulink/src/sfun_counter_cpp.cpp</code>) illustrates usage of the <code>extern "C"</code> directive to ensure that the compiler generates Simulink-compatible callback methods:</p>
<ul class=continued><li class=continued><pre><a name="88431"></a>/*  File    : sfun_counter_cpp.cpp
<a name="88432"></a> *  Abstract:
<a name="88433"></a> *
<a name="88434"></a> *      Example of an C++ S-function which stores an C++ object in
<a name="88435"></a> *      the pointers vector PWork.
<a name="88436"></a> *
<a name="88437"></a> *  Copyright 1990-2000 The MathWorks, Inc.
<a name="88438"></a> * 
<a name="88439"></a> */
<a name="88440"></a>
<a name="88441"></a>#include "iostream.h"
<a name="88442"></a>
<a name="88443"></a>class  counter {
<a name="88444"></a>    double  x;
<a name="88445"></a>public:
<a name="88446"></a>    counter() {
<a name="88447"></a>        x = 0.0;
<a name="88448"></a>    }
<a name="88449"></a>    double output(void) {
<a name="88450"></a>        x = x + 1.0;
<a name="88451"></a>        return x; 
<a name="88452"></a>    }
<a name="88453"></a>};
<a name="88454"></a>
<a name="88455"></a>#ifdef __cplusplus
<a name="88456"></a>extern "C" { // use the C fcn-call standard for all functions  
<a name="88457"></a>#endif       // defined within this scope                     
<a name="88458"></a>
<a name="88459"></a>#define S_FUNCTION_LEVEL 2
<a name="88460"></a>#define S_FUNCTION_NAME  sfun_counter_cpp
<a name="88461"></a>
<a name="88462"></a>/*
<a name="88463"></a> * Need to include simstruc.h for the definition of the SimStruct and
<a name="88464"></a> * its associated macro definitions.
<a name="88465"></a> */
<a name="88466"></a>#include "simstruc.h"
<a name="88467"></a>
<a name="88468"></a>/*====================*
<a name="88469"></a> * S-function methods *
<a name="88470"></a> *====================*/
<a name="88471"></a>
<a name="88472"></a>/* Function: mdlInitializeSizes ===============================================
<a name="88473"></a> * Abstract:
<a name="88474"></a> *    The sizes information is used by Simulink to determine the S-function
<a name="88475"></a> *    block's characteristics (number of inputs, outputs, states, etc.).
<a name="88476"></a> */
<a name="88477"></a>static void mdlInitializeSizes(SimStruct *S)
<a name="88478"></a>{
<a name="88479"></a>    /* See sfuntmpl_doc.c for more details on the macros below */
<a name="88480"></a>
<a name="88481"></a>    ssSetNumSFcnParams(S, 1);  /* Number of expected parameters */
<a name="88482"></a>    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {
<a name="88483"></a>        /* Return if number of expected != number of actual parameters */
<a name="88484"></a>        return;
<a name="88485"></a>    }
<a name="88486"></a>
<a name="88487"></a>    ssSetNumContStates(S, 0);
<a name="88488"></a>    ssSetNumDiscStates(S, 0);
<a name="88489"></a>
<a name="88490"></a>    if (!ssSetNumInputPorts(S, 0)) return;
<a name="88491"></a>    
<a name="88492"></a>    if (!ssSetNumOutputPorts(S, 1)) return;
<a name="88493"></a>    ssSetOutputPortWidth(S, 0, 1);
<a name="88494"></a>
<a name="88495"></a>    ssSetNumSampleTimes(S, 1);
<a name="88496"></a>    ssSetNumRWork(S, 0);
<a name="88497"></a>    ssSetNumIWork(S, 0);
<a name="88498"></a>    ssSetNumPWork(S, 1); // reserve element in the pointers vector
<a name="88499"></a>    ssSetNumModes(S, 0); // to store a C++ object
<a name="88500"></a>    ssSetNumNonsampledZCs(S, 0);
<a name="88501"></a>
<a name="88502"></a>    ssSetOptions(S, 0);
<a name="88503"></a>}
<a name="88603"></a>
<a name="88504"></a>
<a name="88505"></a>
<a name="88506"></a>
<a name="88507"></a>/* Function: mdlInitializeSampleTimes =========================================
<a name="88508"></a> * Abstract:
<a name="88509"></a> *    This function is used to specify the sample time(s) for your
<a name="88510"></a> *    S-function. You must register the same number of sample times as
<a name="88511"></a> *    specified in ssSetNumSampleTimes.
<a name="88512"></a> */
<a name="88513"></a>static void mdlInitializeSampleTimes(SimStruct *S)
<a name="88514"></a>{
<a name="88515"></a>    ssSetSampleTime(S, 0, mxGetScalar(ssGetSFcnParam(S, 0)));
<a name="88516"></a>    ssSetOffsetTime(S, 0, 0.0);
<a name="88517"></a>
<a name="88518"></a>}
<a name="88519"></a>
<a name="88520"></a>#define MDL_START  /* Change to #undef to remove function */
<a name="88521"></a>#if defined(MDL_START) 
<a name="88522"></a>  /* Function: mdlStart =======================================================
<a name="88523"></a>   * Abstract:
<a name="88524"></a>   *    This function is called once at start of model execution. If you
<a name="88525"></a>   *    have states that should be initialized once, this is the place
<a name="88526"></a>   *    to do it.
<a name="88527"></a>   */
<a name="88528"></a>  static void mdlStart(SimStruct *S)
<a name="88529"></a>  {
<a name="88530"></a>      ssGetPWork(S)[0] = (void *) new counter; // store new C++ object in the
<a name="88531"></a>  }                                            // pointers vector
<a name="88532"></a>#endif /*  MDL_START */
<a name="88533"></a>
<a name="88534"></a>/* Function: mdlOutputs =======================================================
<a name="88535"></a> * Abstract:
<a name="88536"></a> *    In this function, you compute the outputs of your S-function
<a name="88537"></a> *    block. Generally outputs are placed in the output vector, ssGetY(S).
<a name="88538"></a> */
<a name="88539"></a>static void mdlOutputs(SimStruct *S, int_T tid)
<a name="88540"></a>{
<a name="88541"></a>    counter *c = (counter *) ssGetPWork(S)[0];   // retrieve C++ object from
<a name="88542"></a>    real_T  *y = ssGetOutputPortRealSignal(S,0); // the pointers vector and use
<a name="88543"></a>    y[0] = c-&gt;output();                          // member functions of the
<a name="88544"></a>}                                                // object
<a name="88545"></a>
<a name="88546"></a>/* Function: mdlTerminate =====================================================
<a name="88547"></a> * Abstract:
<a name="88548"></a> *    In this function, you should perform any actions that are necessary
<a name="88549"></a> *    at the termination of a simulation.  For example, if memory was
<a name="88550"></a> *    allocated in mdlStart, this is the place to free it.
<a name="88551"></a> */
<a name="88552"></a>static void mdlTerminate(SimStruct *S)
<a name="88553"></a>{
<a name="88554"></a>    counter *c = (counter *) ssGetPWork(S)[0]; // retrieve and destroy C++
<a name="88555"></a>    delete c;                                  // object in the termination
<a name="88556"></a>}                                              // function
<a name="88557"></a>/*======================================================*
<a name="88558"></a> * See sfuntmpl_doc.c for the optional S-function methods *
<a name="88559"></a> *======================================================*/
<a name="88560"></a>
<a name="88561"></a>/*=============================*
<a name="88562"></a> * Required S-function trailer *
<a name="88563"></a> *=============================*/
<a name="88564"></a>
<a name="88565"></a>#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
<a name="88566"></a>#include "simulink.c"      /* MEX-file interface mechanism */
<a name="88567"></a>#else
<a name="88568"></a>#include "cg_sfun.h"       /* Code generation registration function */
<a name="88569"></a>#endif
<a name="88570"></a>
<a name="88571"></a>#ifdef __cplusplus
<a name="88572"></a>} // end of extern "C" scope
<a name="88573"></a>#endif
<a name="88574"></a>
</pre></li></ul>

<br>


<p><table bgcolor="#ffe4b0" border=0 width="100%" cellpadding=0 cellspacing=0><tr valign=top><td align=left width=20><a href="sfun_c++.html"><img src="b_prev.gif" border=0 align=bottom></a>&nbsp;</td><td align=left>&nbsp;Creating C++ S-Functions</td><td>&nbsp;</td><td align=right>Making C++ Objects Persistent&nbsp;</td><td align=right width=20><a href="sfun_c++3.html"><img src="b_next.gif" border=0 align=bottom></a></td></tr></table>

<br>
<!-- Copyright 2002 The MathWorks, Inc. -->
<!-- Last updated: Fri Jun 21 05:41:02 2002 -->
</body>
</html>


