<html><head><title>Creating C++ S-Functions (Writing S-Functions)</title>
<!-- $Revision: 1.6 $  $Date: 2002/06/27 13:11:22 $ -->

<!-- DOCNAME: Writing S-Functions -->
<!-- CHUNKNAME: Making C++ Objects Persistent -->
<!-- CHAPNAME: Creating C++ S-Functions -->
<!-- HEADSTUFF -->
<link rel=stylesheet href="docstyle1.css" type="text/css">
</head>
<body bgcolor=#ffffff>
<!-- NAVBARTOP -->
<table border=0 width="100%" cellpadding=0 cellspacing=0><tr>
<td valign=baseline bgcolor="#ffe4b0"><b>Writing S-Functions</b></td>
<td valign=baseline bgcolor="#ffe4b0" align=right><a href="sfun_c++2.html"><img src="b_prev.gif" border=0></a>&nbsp;&nbsp;&nbsp;<a href="sfun_c++4.html"><img src="b_next.gif" border=0></a></td>
</tr>
</table>


<a name="making_c++_objects_persistent"></a><!-- H1 --><a name="88429"></a><p><font size=+2 color="#990000"><b>Making C++ Objects Persistent</b></font><br>
<p><a name="88615"></a>Your C++ callback methods might need to create persistent C++ objects, that is, objects that continue to exist after the method exits. For example, a callback method might need to access an object created during a previous invocation. Or one callback method might need to access an object created by another callback method. To create persistent C++ objects in your S-function:</p>
<ol start="1">
<a name="88620"></a><li>Create a pointer work vector to hold pointers to the persistent object between method invocations:
<ul class=continued><li class=continued><pre><a name="88633"></a>static void mdlInitializeSizes(SimStruct *S)
<a name="88634"></a>{
<a name="88678"></a>    ...
<a name="88654"></a>    ssSetNumPWork(S, 1); // reserve element in the pointers vector
<a name="88655"></a>                         // to store a C++ object
<a name="88677"></a>    ...
<a name="88659"></a> }
</pre></li></ul>
<a name="88679"></a><li>Store a pointer to each object that you want to be persistent in the pointer work vector:
<ul class=continued><li class=continued><pre><a name="88682"></a>  static void mdlStart(SimStruct *S)
<a name="88683"></a>  {
<a name="88684"></a>      ssGetPWork(S)[0] = (void *) new counter; // store new C++ object in the
<a name="88685"></a>  }                                            // pointers vector
</pre></li></ul>
<a name="88680"></a><li>Retrieve the pointer in any subsequent method invocation to access the object:
<ul class=continued><li class=continued><pre><a name="88690"></a>static void mdlOutputs(SimStruct *S, int_T tid)
<a name="88691"></a>{
<a name="88692"></a>    counter *c = (counter *) ssGetPWork(S)[0];   // retrieve C++ object from
<a name="88693"></a>    real_T  *y = ssGetOutputPortRealSignal(S,0); // the pointers vector and use
<a name="88694"></a>    y[0] = c-&gt;output();                          // member functions of the
<a name="88695"></a>}                                                // object
</pre></li></ul>
<a name="88688"></a><li>Destroy the objects when the simulation terminates:
<ul class=continued><li class=continued><pre><a name="88700"></a>static void mdlTerminate(SimStruct *S)
<a name="88701"></a>{
<a name="88702"></a>    counter *c = (counter *) ssGetPWork(S)[0]; // retrieve and destroy C++
<a name="88703"></a>    delete c;                                  // object in the termination
<a name="88704"></a>}                                              // function
</pre></li></ul>
</ol>

<br>


<p><table bgcolor="#ffe4b0" border=0 width="100%" cellpadding=0 cellspacing=0><tr valign=top><td align=left width=20><a href="sfun_c++2.html"><img src="b_prev.gif" border=0 align=bottom></a>&nbsp;</td><td align=left>&nbsp;Source File Format</td><td>&nbsp;</td><td align=right>Building C++ S-Functions&nbsp;</td><td align=right width=20><a href="sfun_c++4.html"><img src="b_next.gif" border=0 align=bottom></a></td></tr></table>

<br>
<!-- Copyright 2002 The MathWorks, Inc. -->
<!-- Last updated: Fri Jun 21 05:41:02 2002 -->
</body>
</html>


