<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>fi Basics</title>
      <meta name="generator" content="MATLAB 7.0">
      <meta name="date" content="2004-04-09">
      <meta name="m-file" content="fibasicsdemo"><style>
body {
  background-color: white;
  margin:10px;
}
h1 {
  color: #990000; 
  font-size: x-large;
}
h2 {
  color: #990000;
  font-size: medium;
}
p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

pre.codeinput {
  margin-left: 30px;
}

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.showbuttons {
  margin-left: 30px;
  border: solid black 2px;
  padding: 4px;
  background: #EBEFF3;
}

pre.codeoutput {
  color: gray;
  font-style: italic;
}
pre.error {
  color: red;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows.  On Gecko-based browsers, the shrink-to-fit doesn't work. */ 
p,h1,h2,div {
  /* for MATLAB's browser */
  width: 600px;
  /* for Mozilla, but the "width" tag overrides it anyway */
  max-width: 600px;
  /* for IE */
  width:expression(document.body.clientWidth > 620 ? "600px": "auto" );
}

    </style></head>
   <body>
      <h1>fi Basics</h1>
      <introduction>
         <p>Demonstrates the basic use of the fixed-point numeric object <tt>fi</tt>.
         </p>
      </introduction>
      <h2>Contents</h2>
      <div>
         <ul>
            <li><a href="#1">Notation</a></li>
            <li><a href="#2">Display options</a></li>
            <li><a href="#3">Default fi attributes</a></li>
            <li><a href="#5">Specifying Signed and WordLength properties</a></li>
            <li><a href="#7">Precision</a></li>
            <li><a href="#12">Data access</a></li>
            <li><a href="#13">double(a)</a></li>
            <li><a href="#15">a.double = ...</a></li>
            <li><a href="#17">int(a), a.int = ...</a></li>
            <li><a href="#19">Relationship between stored integer value and real-world value</a></li>
            <li><a href="#20">bin(a), oct(a), dec(a), hex(a)</a></li>
            <li><a href="#24">a.bin = ..., a.oct = ..., a.dec = ..., a.hex = ...</a></li>
            <li><a href="#29">Specifying FractionLength</a></li>
            <li><a href="#34">A(:) = B vs. A = B</a></li>
            <li><a href="#37">Specifying properties with parameter/value pairs</a></li>
            <li><a href="#39">Numeric type properties</a></li>
            <li><a href="#45">Display preferences</a></li>
            <li><a href="#46">Display of real-world values</a></li>
            <li><a href="#51">Display of fi math properties</a></li>
            <li><a href="#53">fi math properties</a></li>
            <li><a href="#58">FullPrecision math</a></li>
            <li><a href="#59">Full Precision Product Mode</a></li>
            <li><a href="#60">MaxProductWordLength</a></li>
            <li><a href="#61">Full Precision Sum Mode</a></li>
            <li><a href="#67">MaxSumWordLength</a></li>
            <li><a href="#68">KeepLSB math</a></li>
            <li><a href="#70">fi(v, T, F)</a></li>
            <li><a href="#72">KeepMSB math</a></li>
            <li><a href="#78">SpecifyPrecision math</a></li>
            <li><a href="#83">CastBeforeSum</a></li>
            <li><a href="#88">Math with other built-in data types.</a></li>
            <li><a href="#89">fi * double</a></li>
            <li><a href="#90">Some differences between fi and C</a></li>
            <li><a href="#91">fi * int8</a></li>
         </ul>
      </div>
      <h2>Notation<a name="1"></a></h2>
      <p>The fixed-point numeric object is called <b><tt>fi</tt></b> because J.H. Wilkinson used <b><tt>fi</tt></b> to denote fixed-point computations in his classic texts Rounding Errors in Algebraic Processes (1963), and The Algebraic
         Eigenvalue Problem (1965).
      </p>
      <h2>Display options<a name="2"></a></h2>
      <p>Before we begin, let's set some display options.  We will have more to say about these later.</p><pre class="codeinput">format <span class="string">loose</span>
format <span class="string">long</span> <span class="string">g</span>
reset(fipref)
fipref(<span class="string">'FiMathDisplay'</span>,<span class="string">'none'</span>);
</pre><h2>Default fi attributes<a name="3"></a></h2>
      <p>To assign a fixed-point data type to a number or variable with the default fixed-point parameters, use the <tt>fi</tt> constructor.
      </p>
      <p>For example, the following creates fixed-point variables <tt>a</tt> and <tt>b</tt> with attributes shown in the display, all of which we can specify when the variables are constructed.  Note that when the
         <tt>FractionLength</tt> property is not specified, it is set automatically to "best precision" for the given word length, keeping the most-significant
         bits of the value.
      </p><pre class="codeinput">a = fi(pi)
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 13
</pre><pre class="codeinput">b = fi(0.1)
</pre><pre class="codeoutput"> 
b =
 
        0.0999984741210938


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 18
</pre><h2>Specifying Signed and WordLength properties<a name="5"></a></h2>
      <p>The second and third numeric arguments specify <tt>Signed</tt> (<tt>true</tt> or 1 = <tt>signed</tt>, <tt>false</tt> or 0 = <tt>unsigned</tt>), and <tt>WordLength</tt> in bits, respectively.
      </p><pre class="codeinput"><span class="comment">% Signed 8-bit</span>
a = fi(pi, 1, 8)
</pre><pre class="codeoutput"> 
a =
 
                   3.15625


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 8
        FractionLength: 5
</pre><pre class="codeinput"><span class="comment">% Unsigned 20-bit</span>
b = fi(exp(1), 0, 20)
</pre><pre class="codeoutput"> 
b =
 
          2.71828079223633


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: false
            WordLength: 20
        FractionLength: 18
</pre><h2>Precision<a name="7"></a></h2>
      <p>The data is stored internally with as much precision as is specified. However, it is important to be aware that initializing
         high precision fixed-point variables with double-precision floating-point variables may not give you the resolution that you
         might expect at first glance.  For example, let's initialize an unsigned 100-bit fixed-point variable with 0.1, and then examine
         its binary expansion:
      </p><pre class="codeinput">a = fi(0.1, 0, 100);
</pre><pre class="codeinput">bin(a)
</pre><pre class="codeoutput">
ans =

1100110011001100110011001100110011001100110011001101000000000000000000000000000000000000000000000000

</pre><p>Note that the infinite repeating binary expansion of 0.1 gets cut off at the 52nd bit (in fact, the 53rd bit is significant
         and it is rounded up into the 52nd bit). This is because double-precision floating-point variables (the default MATLAB data
         type), are stored in 64-bit floating-point format, with 1 bit for the sign, 11 bits for the exponent, and 52 bits for the
         mantissa plus one "hidden" bit for an effective 53 bits of precision.  Even though double-precision floating-point has a very
         large range, it's precision is limited to 53 bits.  For more information on floating-point arithmetic, refer to Chapter 1
         of Cleve Moler's book, Numerical Computing with MATLAB.  The pdf version can be found here: <a href="http://www.mathworks.com/company/aboutus/founders/clevemoler.html">http://www.mathworks.com/company/aboutus/founders/clevemoler.html</a></p>
      <p>So, why have more precision than floating-point?  Because most fixed-point processors have data stored in a smaller precision,
         and then compute with larger precisions.  For example, let's initialize a 40-bit unsigned <tt>fi</tt> and multiply using the default full-precision for products.
      </p>
      <p>Note that the full-precision product of 40-bit operands is 80 bits, which is greater precision than standard double-precision
         floating-point.
      </p><pre class="codeinput">a = fi(0.1, 0, 40);
bin(a)
</pre><pre class="codeoutput">
ans =

1100110011001100110011001100110011001101

</pre><pre class="codeinput">b = a*a
</pre><pre class="codeoutput"> 
b =
 
        0.0100000000000045


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: false
            WordLength: 80
        FractionLength: 86
</pre><pre class="codeinput">bin(b)
</pre><pre class="codeoutput">
ans =

10100011110101110000101000111101011100001111010111000010100011110101110000101010

</pre><h2>Data access<a name="12"></a></h2>
      <p>The data can be accessed in a number of ways which map to built-in data types and binary strings.  For example,</p>
      <h2>double(a)<a name="13"></a></h2><pre class="codeinput">a = fi(pi);
double(a)
</pre><pre class="codeoutput">
ans =

              3.1416015625

</pre><p>returns the double-precision floating-point "real-world" value of <tt>a</tt>, quantized to the precision of <tt>a</tt>.
      </p>
      <h2>a.double = ...<a name="15"></a></h2>
      <p>We can also set the real-world value in a double.</p><pre class="codeinput">a.double = exp(1)
</pre><pre class="codeoutput"> 
a =
 
             2.71826171875


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 13
</pre><p>sets the real-world value of <tt>a</tt> to <tt>e</tt>, quantized to <tt>a</tt>'s numeric type.
      </p>
      <h2>int(a), a.int = ...<a name="17"></a></h2><pre class="codeinput">int(a)
</pre><pre class="codeoutput">
ans =

  22268

</pre><p>returns the "stored integer" in the smallest built-in integer type available, up to 32 bits.</p>
      <p>Conversely, <tt>a.int = ...</tt> sets the stored integer.
      </p><pre class="codeinput">a.int = 25736
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 13
</pre><h2>Relationship between stored integer value and real-world value<a name="19"></a></h2>
      <p>In <tt>BinaryPoint</tt> scaling, the relationship between the stored integer value and the real-world value is
      </p>
      <p><img vspace="5" hspace="5" src="fibasicsdemo_eq243170.png"> </p>
      <p>There is also <tt>SlopeBias</tt> scaling, which has the relationship
      </p>
      <p><img vspace="5" hspace="5" src="fibasicsdemo_eq219972.png"> </p>
      <p>where</p>
      <p><img vspace="5" hspace="5" src="fibasicsdemo_eq212613.png"> </p>
      <p>and</p>
      <p><img vspace="5" hspace="5" src="fibasicsdemo_eq54429.png"> </p>
      <p>The math operators of <tt>fi</tt> work with <tt>BinaryPoint</tt> scaling, but not with <tt>SlopeBias</tt> scaling.
      </p>
      <h2>bin(a), oct(a), dec(a), hex(a)<a name="20"></a></h2>
      <p>return the stored integer in binary, octal, unsigned decimal, and hexidecimal strings, respectively.</p><pre class="codeinput">bin(a)
</pre><pre class="codeoutput">
ans =

0110010010001000

</pre><pre class="codeinput">oct(a)
</pre><pre class="codeoutput">
ans =

062210

</pre><pre class="codeinput">dec(a)
</pre><pre class="codeoutput">
ans =

25736

</pre><pre class="codeinput">hex(a)
</pre><pre class="codeoutput">
ans =

6488

</pre><h2>a.bin = ..., a.oct = ..., a.dec = ..., a.hex = ...<a name="24"></a></h2>
      <p>set the stored integer from  binary, octal, unsigned decimal, and hexidecimal strings, respectively.</p>
      <p><img vspace="5" hspace="5" src="fibasicsdemo_eq9852.png"> </p><pre class="codeinput">a.bin = <span class="string">'0110010010001000'</span>
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 13
</pre><p><img vspace="5" hspace="5" src="fibasicsdemo_eq10768.png"> </p><pre class="codeinput">a.oct = <span class="string">'031707'</span>
</pre><pre class="codeoutput"> 
a =
 
           1.6180419921875


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 13
</pre><p><img vspace="5" hspace="5" src="fibasicsdemo_eq8186.png"> </p><pre class="codeinput">a.dec = <span class="string">'22268'</span>
</pre><pre class="codeoutput"> 
a =
 
             2.71826171875


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 13
</pre><p><img vspace="5" hspace="5" src="fibasicsdemo_eq9686.png"> </p><pre class="codeinput">a.hex = <span class="string">'0333'</span>
</pre><pre class="codeoutput"> 
a =
 
           0.0999755859375


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 13
</pre><h2>Specifying FractionLength<a name="29"></a></h2>
      <p>When the <tt>FractionLength</tt> property is not specifyed, it is computed to be the best precision for the magnitude of the value and given word length.
         You may also specify the fraction length directly as the fourth numeric argument.  In the following, compare the fraction
         length of <tt>a</tt>, which was explicitly set to 0, to the fraction length of <tt>b</tt>, which was set to best precision for the magnitude of the value.
      </p><pre class="codeinput">a = fi(10,1,16,0)
</pre><pre class="codeoutput"> 
a =
 
    10


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 0
</pre><pre class="codeinput">b = fi(10,1,16)
</pre><pre class="codeoutput"> 
b =
 
    10


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 11
</pre><p>Note that the stored integer values of <tt>a</tt> and <tt>b</tt> are different, even though their real-world values are the same.  This is because the real-world value of <tt>a</tt> is the stored integer scaled by 2^0 = 1, while the real-world value of <tt>b</tt> is the stored integer scaled by 2^-11 = 0.00048828125.
      </p><pre class="codeinput">int(a)
</pre><pre class="codeoutput">
ans =

     10

</pre><pre class="codeinput">int(b)
</pre><pre class="codeoutput">
ans =

  20480

</pre><h2>A(:) = B vs. A = B<a name="34"></a></h2>
      <p>There is a difference between</p><pre> A = B</pre><p>and</p><pre> A(:) = B</pre><p>In the first case, <tt>A = B</tt> replaces A with B, and A assumes B's numeric type.
      </p>
      <p>In the second case, <tt>A(:) = B</tt> assigns the value of B into A, while keeping A's numeric type.  This is very handy for casting one numeric type into another.
      </p>
      <p>For example, to cast a 16-bit number into an 8-bit number, let</p><pre class="codeinput">A = fi(0,1,8,7)
</pre><pre class="codeoutput"> 
A =
 
     0


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 8
        FractionLength: 7
</pre><pre class="codeinput">B = fi(pi/4,1,16,15)
</pre><pre class="codeoutput"> 
B =
 
            0.785400390625


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 15
</pre><p>Cast B's 16-bit number into A's 8-bit number.</p><pre class="codeinput">A(:) = B
</pre><pre class="codeoutput"> 
A =
 
                 0.7890625


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 8
        FractionLength: 7
</pre><h2>Specifying properties with parameter/value pairs<a name="37"></a></h2>
      <p>Thus far, we have been specifying the numeric type properties by passing numeric arguments to the <tt>fi</tt> constructor.  We can also specify properties by giving the name of the property as a string followed by the value of the
         property:
      </p><pre class="codeinput">a = fi(pi,<span class="string">'WordLength'</span>,20)
</pre><pre class="codeoutput"> 
a =
 
          3.14159393310547


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 20
        FractionLength: 17
</pre><p>For more information on <tt>fi</tt> properties, type
      </p><pre> help fi</pre><p>or</p><pre> doc fi</pre><p>at the MATLAB command line.</p>
      <h2>Numeric type properties<a name="39"></a></h2>
      <p>All of the numeric type properties of <tt>fi</tt> are encapsulated in an object named <tt>numerictype</tt>:
      </p><pre class="codeinput">T = numerictype
</pre><pre class="codeoutput"> 
T =
 

              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 15
</pre><p>The numeric type properties can be modified either when the object is created by passing in parameter/value arguments</p><pre class="codeinput">T = numerictype(<span class="string">'WordLength'</span>,40,<span class="string">'FractionLength'</span>,37)
</pre><pre class="codeoutput"> 
T =
 

              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 40
        FractionLength: 37
</pre><p>or they may be assigned by using the dot notation</p><pre class="codeinput">T.Signed = false
</pre><pre class="codeoutput"> 
T =
 

              DataType: Fixed
               Scaling: BinaryPoint
                Signed: false
            WordLength: 40
        FractionLength: 37
</pre><p>All of the numeric type properties of a <tt>fi</tt> may be set at once by passing in the <tt>numerictype</tt> object.  This is handy, for example, when creating more than one <tt>fi</tt> object that share the same numeric type.
      </p><pre class="codeinput">a = fi(pi,<span class="string">'numerictype'</span>,T)
</pre><pre class="codeoutput"> 
a =
 
          3.14159265359194


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: false
            WordLength: 40
        FractionLength: 37
</pre><pre class="codeinput">b = fi(exp(1),<span class="string">'numerictype'</span>,T)
</pre><pre class="codeoutput"> 
b =
 
          2.71828182845638


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: false
            WordLength: 40
        FractionLength: 37
</pre><p>For more information on <tt>numerictype</tt> properties, type
      </p><pre> help numerictype</pre><p>or</p><pre> doc numerictype</pre><p>at the MATLAB command line.</p>
      <h2>Display preferences<a name="45"></a></h2>
      <p>The display preferences for <tt>fi</tt> can be set with the <tt>fipref</tt> object. They can be saved between MATLAB sessions with the <tt>savefipref</tt> command.
      </p>
      <h2>Display of real-world values<a name="46"></a></h2>
      <p>When displaying real-world values, the closest double-precision floating-point value is displayed.  As we have seen, double-precision
         floating-point may not always be able to represent the exact value of high-precision fixed-point number.  For example, an
         8-bit fractional number can be represented exactly in doubles
      </p><pre class="codeinput">a = fi(1,1,8,7)
</pre><pre class="codeoutput"> 
a =
 
                 0.9921875


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 8
        FractionLength: 7
</pre><pre class="codeinput">bin(a)
</pre><pre class="codeoutput">
ans =

01111111

</pre><p>while a 100-bit fractional number cannot (1 is displayed, when the exact value is 1 - 2^-99):</p><pre class="codeinput">b = fi(1,1,100,99)
</pre><pre class="codeoutput"> 
b =
 
     1


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 100
        FractionLength: 99
</pre><p>Note, however, that the full precision is preserved in the internal representation of <tt>fi</tt></p><pre class="codeinput">bin(b)
</pre><pre class="codeoutput">
ans =

0111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

</pre><p>The display of the <tt>fi</tt> object is also affected by MATLAB's <tt>format</tt> command.  In particular, when displaying real-world values, it is handy to use
      </p><pre> format long g</pre><p>so that as much precision as is possible will be displayed.</p>
      <h2>Display of fi math properties<a name="51"></a></h2>
      <p>Thus far, we have been hiding the display of the properties that control math operations, which was the effect of the</p><pre> fipref('FiMathDisplay','none')</pre><p>command at the beginning, and we have been using the default full-precision arithmetic.</p>
      <p>Now we are ready to explore other math options, so we turn the <tt>fi</tt> math display property to <tt>full</tt> so we can monitor the changes in the properties.  Note that even when the math properties are not displayed, they are still
         in effect.
      </p><pre class="codeinput">fipref(<span class="string">'FiMathDisplay'</span>,<span class="string">'full'</span>)
</pre><pre class="codeoutput"> 
ans =
 
         NumberDisplay: 'RealWorldValue'
    NumericTypeDisplay: 'full'
         FimathDisplay: 'full'

</pre><p>There are also other display options to make a more shorthand display of the numeric type properties, and options to control
         the display of the value (as real-world value, binary, octal, decimal integer, or hex).
      </p>
      <p>For more information on display preferences, type</p><pre> help fipref
 help savefipref
 help format</pre><p>or</p><pre> doc fipref
 doc savefipref
 doc format</pre><p>at the MATLAB command line.</p>
      <h2>fi math properties<a name="53"></a></h2>
      <p>Similar to the way the <tt>numerictype</tt> object encapsulate the numeric type properties of <tt>fi</tt>, the properties that control <tt>fi</tt> math operations are encapsulated in an object named <tt>fimath</tt>:
      </p><pre class="codeinput">F = fimath
</pre><pre class="codeoutput"> 
F =
 

             RoundMode: round
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><p>All of the properties may be modified.</p>
      <p>The <tt>fi</tt> math properties may be modified either when the object is created by passing in parameter/value arguments
      </p><pre class="codeinput">F = fimath(<span class="string">'RoundMode'</span>,<span class="string">'floor'</span>)
</pre><pre class="codeoutput"> 
F =
 

             RoundMode: floor
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><p>or they may be assigned by using the dot notation</p><pre class="codeinput">F.OverflowMode = <span class="string">'wrap'</span>
</pre><pre class="codeoutput"> 
F =
 

             RoundMode: floor
          OverflowMode: wrap
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><p>All of the <tt>fi</tt> math properties may be set at once at object creation. The round mode and the overflow mode are used to quantize the initial
         value, and for all other math operations where rounding and overflow apply.
      </p><pre class="codeinput">a = fi(pi,<span class="string">'fimath'</span>,F)
</pre><pre class="codeoutput"> 
a =
 
           3.1414794921875


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 13

             RoundMode: floor
          OverflowMode: wrap
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><h2>FullPrecision math<a name="58"></a></h2>
      <p>The default is for all math operations to be executed in full precision, growing bits in the result as necessary.</p>
      <h2>Full Precision Product Mode<a name="59"></a></h2>
      <p>A full precision product requires a word length equal to the sum of the word lengths of the operands.  In the following, note
         that the word length of the product <tt>c</tt> is equal to the word length of <tt>a</tt> plus the word length of <tt>b</tt>.  The fraction length of <tt>c</tt> is also equal to the fraction length of <tt>a</tt> plus the fraction length of <tt>b</tt>.
      </p><pre class="codeinput">a = fi(pi,1,20);
b = fi(exp(1),1,16);
c = a * b
</pre><pre class="codeoutput"> 
c =
 
          8.53967452421784


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 36
        FractionLength: 30

             RoundMode: round
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><h2>MaxProductWordLength<a name="60"></a></h2>
      <p>Even though the maximum word length allowable in <tt>fi</tt> is 65535, it is easy to let the precision get away from you, especially in loops, so we have the <tt>MaxProductWordLength</tt> property so that you can catch yourself. The default value is 128, but you can modify this value for your own situation.
          In this way, you can ensure that your calculations are never being carried out in a higher precision than your hardware allows.
          For example, if you want all calculations done in full precision, but want to ensure that nothing is ever caculated to more
         precision than your hardware is capable of, say 40 bits, then set the maximum product and sum word lengths to 40.
      </p>
      <p>For an example of how it is easy to let the word length grow, consider the following loop.  The product word length will double
         each time through the loop, so the final product word length will be 16*2^5 = 512. In the event that this is not what you
         intended, an error will be thrown when the product word length exceeds the default value of 128. Our code has been written
         to catch and display the error.  If you wish to let the word length continue to grow, just set <tt>MaxProductWordLength</tt> to something larger than 512.
      </p><pre class="codeinput"><span class="keyword">try</span>
  a = fi(pi);
  <span class="keyword">for</span> k=1:5
    a = a*a;
  <span class="keyword">end</span>
<span class="keyword">catch</span>
  disp(lasterr)
<span class="keyword">end</span>
</pre><pre class="codeoutput">MaxProductWordLength is 128 bits and a minimum word length of 256 bits is necessary to guarantee that this product can be computed with no loss of precision.  Increase MaxProductWordLength if you want the product to grow to a larger word length.
</pre><h2>Full Precision Sum Mode<a name="61"></a></h2>
      <p>A full precision sum requires a word length that grows <tt>log2(n)</tt> bits, where <tt>n</tt> is the number of summands.
      </p>
      <p>For example, if there are <tt>n=2</tt> summands, then <tt>log2(2)=1</tt>, and so the sum must grow by one bit.  In this example, the word length of the summands <tt>a</tt> and <tt>b</tt> are each 24 bits, and the sum <tt>c</tt> is 25 bits.
      </p><pre class="codeinput">a = fi(pi,1,24);
b = fi(exp(1),1,24);
c = a + b
</pre><pre class="codeoutput"> 
c =
 
          5.85987424850464


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 25
        FractionLength: 21

             RoundMode: round
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><p>In this example, we create a random matrix with 8 rows and 2 columns with a word length of 20 bits (after first resetting
         the random number generator state for repeatability of the example).
      </p><pre class="codeinput">randn(<span class="string">'state'</span>,0);
A = fi(randn(8,2),1,20)
</pre><pre class="codeoutput"> 
A =
 
  Column 1 

        -0.432563781738281
         -1.66558074951172
         0.125335693359375
         0.287673950195312
         -1.14646911621094
             1.19091796875
          1.18916320800781
       -0.0376358032226562

  Column 2 

         0.327293395996094
         0.174636840820312
         -0.18670654296875
         0.725791931152344
         -0.58831787109375
          2.18318939208984
        -0.136398315429688
         0.113929748535156


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 20
        FractionLength: 17

             RoundMode: round
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><p>The <tt>sum</tt> function sums the 8 elements in each column, so the sum needs to grow by <tt>log2(8) = 3</tt> bits to give a sum with a 23 bit word length.
      </p><pre class="codeinput">sum(A)
</pre><pre class="codeoutput"> 
ans =
 
  Column 1 

        -0.489158630371094

  Column 2 

          2.61341857910156


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 23
        FractionLength: 17

             RoundMode: round
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><p>Note that the + operator can't tell if there are more coming, so that</p><pre>  a+a+a+a</pre><p>is different from</p><pre>  sum([a a a a])</pre><p>The latter is preferred, because <tt>sum([a a a a])</tt> knows that there are four summands, and will only grow log2(4) = 2 bits, while <tt>a+a+a+a</tt> will grow 3 bits, one for each +.  The difference is much greater for larger n.  The sum of 64 numbers computed as a+a+a+...+a
         will grow 63 bits, while sum([a a ... a]) will only grow log2(64) = 6 bits.
      </p>
      <p>For example:</p><pre class="codeinput">a = fi(pi)
</pre><pre class="codeoutput"> 
a =
 
              3.1416015625


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 13

             RoundMode: round
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><p>Note that this sum grows three bits</p><pre class="codeinput">a+a+a+a
</pre><pre class="codeoutput"> 
ans =
 
               12.56640625


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 19
        FractionLength: 13

             RoundMode: round
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><p>while this sum can be smarter, and only grows two (and still guarantees no overflow)</p><pre class="codeinput">sum([a a a a])
</pre><pre class="codeoutput"> 
ans =
 
               12.56640625


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 18
        FractionLength: 13

             RoundMode: round
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><h2>MaxSumWordLength<a name="67"></a></h2>
      <p>Similar to <tt>MaxProductWordLength</tt>, you can also set the maximum value for the sum word length so that the precision never exceeds, say, the size of the accumulator
         in your hardware.
      </p>
      <h2>KeepLSB math<a name="68"></a></h2>
      <p>When the sum or product mode is set to <tt>KeepLSB</tt>, then the least-significant bits of the sum or product are kept.  If the word length of the result is sufficient to store
         the full precision value, then the value is positioned in the least-significant bits of the result.  If the word length is
         smaller than is necessary to store the full precision value, then overflow occurs.
      </p>
      <p>For example, to simulate arithmetic as it happens in C integers, set the product and sum modes to keep the least-significant
         bits, and the overflow mode to wrap.  Even though the ANSI C standard only defines the overflow characteristics of unsigned
         integers (wrap), and does not define the behavior of overflow for signed integers, most C implementations use wrap (modulo)
         two's-complement overflow for signed integers.
      </p>
      <p>In this example, we simulate 8-bit signed C integers.</p><pre class="codeinput">S8 = numerictype(<span class="string">'Signed'</span>,1,<span class="string">'WordLength'</span>,8,<span class="string">'FractionLength'</span>,0)
</pre><pre class="codeoutput"> 
S8 =
 

              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 8
        FractionLength: 0
</pre><pre class="codeinput">C8 = fimath(<span class="string">'RoundMode'</span>,<span class="string">'floor'</span>,<span class="string">'OverflowMode'</span>,<span class="string">'wrap'</span>,<span class="keyword">...</span>
            <span class="string">'ProductMode'</span>,<span class="string">'KeepLSB'</span>,<span class="string">'ProductWordLength'</span>,8,<span class="keyword">...</span>
            <span class="string">'SumMode'</span>,<span class="string">'KeepLSB'</span>,<span class="string">'SumWordLength'</span>,8)
</pre><pre class="codeoutput"> 
C8 =
 

             RoundMode: floor
          OverflowMode: wrap
           ProductMode: KeepLSB
     ProductWordLength: 8
               SumMode: KeepLSB
         SumWordLength: 8
         CastBeforeSum: true
</pre><h2>fi(v, T, F)<a name="70"></a></h2>
      <p>Since the numeric type and fi math parameters are commonly passed to the <tt>fi</tt> constructor, there is a signature that allows the (value, numerictype, fimath) triple to be entered.
      </p>
      <p>Let <tt>a</tt> be an 8-bit signed integer with the math defined like C and an initial value of 64.
      </p><pre class="codeinput">a = fi(64,S8,C8)
</pre><pre class="codeoutput"> 
a =
 
    64


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 8
        FractionLength: 0

             RoundMode: floor
          OverflowMode: wrap
           ProductMode: KeepLSB
     ProductWordLength: 8
               SumMode: KeepLSB
         SumWordLength: 8
         CastBeforeSum: true
</pre><p>In full precision math a+a=128, but in wrap two's-complement arithmetic, +128 is congruent to -128, as it would be in C:</p><pre class="codeinput">a+a
</pre><pre class="codeoutput"> 
ans =
 
  -128


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 8
        FractionLength: 0

             RoundMode: floor
          OverflowMode: wrap
           ProductMode: KeepLSB
     ProductWordLength: 8
               SumMode: KeepLSB
         SumWordLength: 8
         CastBeforeSum: true
</pre><h2>KeepMSB math<a name="72"></a></h2>
      <p>When the sum or product mode is set to <tt>KeepMSB</tt>, then the most-significant bits of the sum or product are kept.  If the word length of the result is sufficient to store
         the full precision value, then the value is positioned in the most-significant bits of the result.  If the word length is
         smaller than is necessary to store the full precision value, then rounding occurs.
      </p>
      <p>Most fixed-point processors produce a product that has twice as many bits as its operands so that no quantization occurs during
         the computation of the product. However, some do not, such as the Zilog Z893xx, which accepts 16-bit operands, but produces
         a 24-bit result rather than the 32-bit result required for full precision.  To simulate this processor, we would set the <tt>ProductMode</tt> to <tt>KeepMSB</tt>, and the <tt>ProductWordLength</tt> to 24:
      </p><pre class="codeinput">Z893math = fimath(<span class="string">'ProductMode'</span>,<span class="string">'KeepMSB'</span>,<span class="string">'ProductWordLength'</span>,24);
a = fi(0.1,1,16,16,<span class="string">'fimath'</span>,Z893math)
</pre><pre class="codeoutput"> 
a =
 
         0.100006103515625


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 16

             RoundMode: round
          OverflowMode: saturate
           ProductMode: KeepMSB
     ProductWordLength: 24
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><p>Note that the quantized product is the 24 most-significant bits of the product.</p><pre class="codeinput">a*a
</pre><pre class="codeoutput"> 
ans =
 
        0.0100012421607971


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 24
        FractionLength: 24

             RoundMode: round
          OverflowMode: saturate
           ProductMode: KeepMSB
     ProductWordLength: 24
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><p>Also, many textbooks do roundoff error analysis for "single-precision" fixed-point products and sums with fractional numbers.
         In this example, we simulate 8-bit unsigned fractional numbers (all values between 0 and 1).
      </p><pre class="codeinput">U8 = numerictype(<span class="string">'Signed'</span>,0,<span class="string">'WordLength'</span>,8,<span class="string">'FractionLength'</span>,8)
</pre><pre class="codeoutput"> 
U8 =
 

              DataType: Fixed
               Scaling: BinaryPoint
                Signed: false
            WordLength: 8
        FractionLength: 8
</pre><pre class="codeinput">F8 = fimath(<span class="string">'ProductMode'</span>,<span class="string">'KeepMSB'</span>,<span class="string">'ProductWordLength'</span>,8,<span class="keyword">...</span>
            <span class="string">'SumMode'</span>,<span class="string">'KeepMSB'</span>,<span class="string">'SumWordLength'</span>,8)
</pre><pre class="codeoutput"> 
F8 =
 

             RoundMode: round
          OverflowMode: saturate
           ProductMode: KeepMSB
     ProductWordLength: 8
               SumMode: KeepMSB
         SumWordLength: 8
         CastBeforeSum: true
</pre><p>Let <tt>a</tt> be an 8-bit unsigned fractional number with fractional arithmetic that quantizes products and sums to keep the most-significant
         bits.
      </p><pre class="codeinput">a = fi(0.1, U8, F8)
</pre><pre class="codeoutput"> 
a =
 
                 0.1015625


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: false
            WordLength: 8
        FractionLength: 8

             RoundMode: round
          OverflowMode: saturate
           ProductMode: KeepMSB
     ProductWordLength: 8
               SumMode: KeepMSB
         SumWordLength: 8
         CastBeforeSum: true
</pre><p>In the following, note that a product that is also a fractional number has been produced, and the 8 most-significant bits
         have been retained.
      </p><pre class="codeinput">a*a
</pre><pre class="codeoutput"> 
ans =
 
                0.01171875


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: false
            WordLength: 8
        FractionLength: 8

             RoundMode: round
          OverflowMode: saturate
           ProductMode: KeepMSB
     ProductWordLength: 8
               SumMode: KeepMSB
         SumWordLength: 8
         CastBeforeSum: true
</pre><h2>SpecifyPrecision math<a name="78"></a></h2>
      <p>When we want full control over the math operations, we set the product or sum mode to SpecifyPrecision, and then fully specify
         the word length and fraction length of the result.
      </p><pre class="codeinput">F = fimath(<span class="string">'ProductMode'</span>,<span class="string">'SpecifyPrecision'</span>,<span class="keyword">...</span>
           <span class="string">'ProductWordLength'</span>,24,<span class="keyword">...</span>
           <span class="string">'ProductFractionLength'</span>,23,<span class="keyword">...</span>
           <span class="string">'SumMode'</span>,<span class="string">'SpecifyPrecision'</span>,<span class="keyword">...</span>
           <span class="string">'SumWordLength'</span>,40,<span class="keyword">...</span>
           <span class="string">'SumFractionLength'</span>,23)
</pre><pre class="codeoutput"> 
F =
 

             RoundMode: round
          OverflowMode: saturate
           ProductMode: SpecifyPrecision
     ProductWordLength: 24
 ProductFractionLength: 23
               SumMode: SpecifyPrecision
         SumWordLength: 40
     SumFractionLength: 23
         CastBeforeSum: true
</pre><pre class="codeinput">a = fi(pi/4,<span class="string">'fimath'</span>,F)
</pre><pre class="codeoutput"> 
a =
 
            0.785400390625


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 15

             RoundMode: round
          OverflowMode: saturate
           ProductMode: SpecifyPrecision
     ProductWordLength: 24
 ProductFractionLength: 23
               SumMode: SpecifyPrecision
         SumWordLength: 40
     SumFractionLength: 23
         CastBeforeSum: true
</pre><pre class="codeinput">b = fi(exp(1)/4,<span class="string">'fimath'</span>,F)
</pre><pre class="codeoutput"> 
b =
 
           0.6795654296875


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 15

             RoundMode: round
          OverflowMode: saturate
           ProductMode: SpecifyPrecision
     ProductWordLength: 24
 ProductFractionLength: 23
               SumMode: SpecifyPrecision
         SumWordLength: 40
     SumFractionLength: 23
         CastBeforeSum: true
</pre><p>Then the products will always be 24,23</p><pre class="codeinput">a*b
</pre><pre class="codeoutput"> 
ans =
 
         0.533730983734131


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 24
        FractionLength: 23

             RoundMode: round
          OverflowMode: saturate
           ProductMode: SpecifyPrecision
     ProductWordLength: 24
 ProductFractionLength: 23
               SumMode: SpecifyPrecision
         SumWordLength: 40
     SumFractionLength: 23
         CastBeforeSum: true
</pre><p>And the sums will always be 40,23</p><pre class="codeinput">a+b
</pre><pre class="codeoutput"> 
ans =
 
           1.4649658203125


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 40
        FractionLength: 23

             RoundMode: round
          OverflowMode: saturate
           ProductMode: SpecifyPrecision
     ProductWordLength: 24
 ProductFractionLength: 23
               SumMode: SpecifyPrecision
         SumWordLength: 40
     SumFractionLength: 23
         CastBeforeSum: true
</pre><h2>CastBeforeSum<a name="83"></a></h2>
      <p>Unfortunately, there is no += operator in MATLAB, so in order to simulate the accumulation of sums, such as might be done
         in this code snippet from C, we have the <tt>CastBeforeSum</tt> parameter.
      </p><pre> acc  = a;
 acc += b;</pre><p>When <tt>CastBeforeSum</tt> is true (1), then the operands are cast to the numeric type of the sum before the addition takes place.  This behavior models
         most DSP chips.
      </p>
      <p>When <tt>CastBeforeSum</tt> is false (0), then the operands are added in full precision, and then cast to the numeric type of the sum.  This behavior
         models many ASIC or FPGA implementations.
      </p>
      <p>The difference only matters when the numeric type of the sum has less precision or range than the numeric types of the operands.</p>
      <p>Here is a simple example.  Let the numeric type of the sum be an integer (the fraction length is zero), and let the operands
         have one fractional bit that would sum to be an integer.  If the operands were cast to the numeric type of the sum before
         addition, then the fractional bit would be lost before the addition.  If the operands were added and then cast to the numeric
         type of the sum, then the fractional bits would be significant.
      </p><pre class="codeinput">F = fimath(<span class="string">'RoundMode'</span>,<span class="string">'floor'</span>,<span class="keyword">...</span>
            <span class="string">'SumMode'</span>,<span class="string">'SpecifyPrecision'</span>,<span class="keyword">...</span>
           <span class="string">'SumWordLength'</span>,16,<span class="string">'SumFractionLength'</span>,0,<span class="keyword">...</span>
           <span class="string">'CastBeforeSum'</span>,true)
</pre><pre class="codeoutput"> 
F =
 

             RoundMode: floor
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: SpecifyPrecision
         SumWordLength: 16
     SumFractionLength: 0
         CastBeforeSum: true
</pre><pre class="codeinput">a = fi(0.5,<span class="string">'fimath'</span>,F)
</pre><pre class="codeoutput"> 
a =
 
                       0.5


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 15

             RoundMode: floor
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: SpecifyPrecision
         SumWordLength: 16
     SumFractionLength: 0
         CastBeforeSum: true
</pre><p>In the following, the 0.5 gets quantized to 0 before the addition takes place, and so the sum is 0</p><pre class="codeinput">a + a
</pre><pre class="codeoutput"> 
ans =
 
     0


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 0

             RoundMode: floor
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: SpecifyPrecision
         SumWordLength: 16
     SumFractionLength: 0
         CastBeforeSum: true
</pre><p>Now, set <tt>CastBeforeSum</tt> to true and repeat the experiment.  Note that the <tt>fi</tt> math parameters can be changed on a <tt>fi</tt> variable at any time
      </p><pre class="codeinput">a.CastBeforeSum = false
</pre><pre class="codeoutput"> 
a =
 
                       0.5


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 15

             RoundMode: floor
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: SpecifyPrecision
         SumWordLength: 16
     SumFractionLength: 0
         CastBeforeSum: false
</pre><p>Now the sum 0.5+0.5 = 1 gets done first, and then is cast to an integer, so the sum is 1.</p><pre class="codeinput">a + a
</pre><pre class="codeoutput"> 
ans =
 
     1


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 16
        FractionLength: 0

             RoundMode: floor
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: SpecifyPrecision
         SumWordLength: 16
     SumFractionLength: 0
         CastBeforeSum: false
</pre><h2>Math with other built-in data types.<a name="88"></a></h2>
      <h2>fi * double<a name="89"></a></h2>
      <p>When doing arithmetic between <tt>fi</tt> and <tt>double</tt>, the double is cast to a <tt>fi</tt> with the same word length and signedness of the <tt>fi</tt>, and best-precision fraction length.  The result of the operation is a <tt>fi</tt>.
      </p><pre class="codeinput">a = fi(pi);
b = 0.5 * a
</pre><pre class="codeoutput"> 
b =
 
             1.57080078125


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 32
        FractionLength: 28

             RoundMode: round
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><h2>Some differences between fi and C<a name="90"></a></h2>
      <p>Note that in C, the result of an operation between a integer data type with a double data type will promote to a double.</p>
      <p>However, in MATLAB, the result of an operation between a built-in integer data type with a double data type will be an integer.
          In this respect, the <tt>fi</tt> object behaves like the built-in integer data types in MATLAB: the result of an operation between a <tt>fi</tt> and a double is a <tt>fi</tt>.
      </p>
      <h2>fi * int8<a name="91"></a></h2>
      <p>When doing arithmetic between fi and one of the built-in integer data types [u]int[8,16,32], then the word length and signedness
         of the the integer are preserved.  The result of the operation is a fi.
      </p><pre class="codeinput">a = fi(pi);
b = int8(2) * a
</pre><pre class="codeoutput"> 
b =
 
               6.283203125


              DataType: Fixed
               Scaling: BinaryPoint
                Signed: true
            WordLength: 24
        FractionLength: 13

             RoundMode: round
          OverflowMode: saturate
           ProductMode: FullPrecision
  MaxProductWordLength: 128
               SumMode: FullPrecision
      MaxSumWordLength: 128
         CastBeforeSum: true
</pre><p class="footer">Copyright 2004 The MathWorks, Inc.<br>
         Published with MATLAB&reg; 7.0<br></p>
      <!--
##### SOURCE BEGIN #####
%% fi Basics
% Demonstrates the basic use of the fixed-point numeric object |fi|.

%% Notation
% The fixed-point numeric object is called *|fi|* because J.H. Wilkinson
% used *|fi|* to denote fixed-point computations in his classic texts
% Rounding Errors in Algebraic Processes (1963), and The Algebraic
% Eigenvalue Problem (1965).

%% Display options
% Before we begin, let's set some display options.  We will have
% more to say about these later. 
format loose
format long g
reset(fipref)
fipref('FiMathDisplay','none');

%% Default fi attributes
% To assign a fixed-point data type to a number or variable with the
% default fixed-point parameters, use the |fi| constructor.  
%
% For example, the following creates fixed-point variables |a| and |b| with
% attributes shown in the display, all of which we can specify when the
% variables are constructed.  Note that when the |FractionLength| property
% is not specified, it is set automatically to "best precision" for the
% given word length, keeping the most-significant bits of the value.

a = fi(pi)
%%
b = fi(0.1)

%% Specifying Signed and WordLength properties
% The second and third numeric arguments specify |Signed| (|true| or 1 =
% |signed|, |false| or 0 = |unsigned|), and |WordLength| in bits,
% respectively.

% Signed 8-bit
a = fi(pi, 1, 8)

%%

% Unsigned 20-bit
b = fi(exp(1), 0, 20)

%% Precision
% The data is stored internally with as much precision as is specified.
% However, it is important to be aware that initializing high precision
% fixed-point variables with double-precision floating-point variables may
% not give you the resolution that you might expect at first glance.  For
% example, let's initialize an unsigned 100-bit fixed-point variable with
% 0.1, and then examine its binary expansion:
a = fi(0.1, 0, 100);
%%
bin(a)

%%
% Note that the infinite repeating binary expansion of 0.1 gets cut off at
% the 52nd bit (in fact, the 53rd bit is significant and it is rounded up
% into the 52nd bit). This is because double-precision floating-point
% variables (the default MATLAB data type), are stored in 64-bit
% floating-point format, with 1 bit for the sign, 11 bits for the exponent,
% and 52 bits for the mantissa plus one "hidden" bit for an effective 53
% bits of precision.  Even though double-precision floating-point has a
% very large range, it's precision is limited to 53 bits.  For more
% information on floating-point arithmetic, refer to Chapter 1 of Cleve
% Moler's book, Numerical Computing with MATLAB.  The pdf version can be
% found here:
% <http://www.mathworks.com/company/aboutus/founders/clevemoler.html>
%
% So, why have more precision than floating-point?  Because most fixed-point
% processors have data stored in a smaller precision, and then compute with
% larger precisions.  For example, let's initialize a 40-bit unsigned |fi|
% and multiply using the default full-precision for products.
%
% Note that the full-precision product of 40-bit operands is 80 bits, which
% is greater precision than standard double-precision floating-point.
a = fi(0.1, 0, 40);
bin(a)

%%

b = a*a

%%

bin(b)

%% Data access
% The data can be accessed in a number of ways which map to built-in data
% types and binary strings.  For example, 
%% double(a)
a = fi(pi);
double(a)
%% 
% returns the double-precision floating-point "real-world" value of |a|,
% quantized to the precision of |a|.
%% a.double = ...
% We can also set the real-world value in a double.
a.double = exp(1)
%%
% sets the real-world value of |a| to |e|, quantized to |a|'s numeric type.
%% int(a), a.int = ...
int(a)
%%
% returns the "stored integer" in the smallest built-in integer type
% available, up to 32 bits.
% 
% Conversely, |a.int = ...| sets the stored integer.
a.int = 25736

%% Relationship between stored integer value and real-world value
% In |BinaryPoint| scaling, the relationship between the stored integer
% value and the real-world value is
%
% $$ \mbox{Real-world value} = (\mbox{Stored integer})\cdot
% 2^{-\mbox{Fraction length}}.$$
%
% There is also |SlopeBias| scaling, which has the relationship
%
% $$ \mbox{Real-world value} = (\mbox{Stored integer})\cdot
% \mbox{Slope}+ \mbox{Bias}$$
%
% where
%
% $$ \mbox{Slope} = (\mbox{Slope adjustment factor})\cdot
% 2^{\mbox{Fixed exponent}}.$$
%
% and
%
% $$\mbox{Fixed exponent} = -\mbox{Fraction length}.$$
%
% The math operators of |fi| work with |BinaryPoint| scaling, but not with
% |SlopeBias| scaling.

%%
%% bin(a), oct(a), dec(a), hex(a)
% return the stored integer in binary, octal, unsigned decimal, and
% hexidecimal strings, respectively.
bin(a)
%%
oct(a)
%%
dec(a)
%%
hex(a)

%% a.bin = ..., a.oct = ..., a.dec = ..., a.hex = ...
% set the stored integer from  binary, octal, unsigned decimal, and
% hexidecimal strings, respectively.
%%
% $$\mbox{\texttt{fi}}(\pi)$$
a.bin = '0110010010001000'
%%
% $$\mbox{\texttt{fi}}(\phi)$$
a.oct = '031707'
%%
% $$\mbox{\texttt{fi}}(e)$$
a.dec = '22268'
%%
% $$\mbox{\texttt{fi}}(0.1)$$
a.hex = '0333'

%% Specifying FractionLength 
% When the |FractionLength| property is not specifyed, it is computed to be
% the best precision for the magnitude of the value and given word length.
% You may also specify the fraction length directly as the fourth numeric
% argument.  In the following, compare the fraction length of |a|, which
% was explicitly set to 0, to the fraction length of |b|, which was set to
% best precision for the magnitude of the value.
a = fi(10,1,16,0)
%%
b = fi(10,1,16)

%%
% Note that the stored integer values of |a| and |b| are different, even
% though their real-world values are the same.  This is because the
% real-world value of |a| is the stored integer scaled by 2^0 = 1, while
% the real-world value of |b| is the stored integer scaled by 2^-11 =
% 0.00048828125.
%%
int(a)
%%
int(b)

%% A(:) = B vs. A = B
% There is a difference between
%
%   A = B
%
% and
%
%   A(:) = B
% 
% In the first case, |A = B| replaces A with B, and A assumes B's numeric
% type.
%
% In the second case, |A(:) = B| assigns the value of B into A, while
% keeping A's numeric type.  This is very handy for casting one numeric
% type into another.
%
% For example, to cast a 16-bit number into an 8-bit number, let
A = fi(0,1,8,7)
%%
B = fi(pi/4,1,16,15)
%%
% Cast B's 16-bit number into A's 8-bit number.
A(:) = B

%% Specifying properties with parameter/value pairs
% Thus far, we have been specifying the numeric type properties by passing
% numeric arguments to the |fi| constructor.  We can also specify
% properties by giving the name of the property as a string followed by the
% value of the property:
a = fi(pi,'WordLength',20)
%%
% For more information on |fi| properties, type
%
%   help fi
%
% or
%
%   doc fi
%
% at the MATLAB command line.

%% Numeric type properties
% All of the numeric type properties of |fi| are encapsulated in an object
% named |numerictype|:
T = numerictype
%%
% The numeric type properties can be modified either when the object is
% created by passing in parameter/value arguments
T = numerictype('WordLength',40,'FractionLength',37)
%%
% or they may be assigned by using the dot notation
T.Signed = false
%%
% All of the numeric type properties of a |fi| may be set at once by
% passing in the |numerictype| object.  This is handy, for example, when
% creating more than one |fi| object that share the same numeric type.
a = fi(pi,'numerictype',T)
%%
b = fi(exp(1),'numerictype',T)
%%
% For more information on |numerictype| properties, type
%
%   help numerictype
%
% or
%
%   doc numerictype
%
% at the MATLAB command line.

%% Display preferences
% The display preferences for |fi| can be set with the |fipref| object.
% They can be saved between MATLAB sessions with the |savefipref| command.

%% Display of real-world values
%
% When displaying real-world values, the closest double-precision
% floating-point value is displayed.  As we have seen, double-precision
% floating-point may not always be able to represent the exact value of
% high-precision fixed-point number.  For example, an 8-bit fractional
% number can be represented exactly in doubles
a = fi(1,1,8,7)
%%
bin(a)
%%
% while a 100-bit fractional number cannot (1 is displayed, when
% the exact value is 1 - 2^-99):
b = fi(1,1,100,99)
%%
% Note, however, that the full precision is preserved in the internal
% representation of |fi|
bin(b)
%%
% The display of the |fi| object is also affected by MATLAB's |format|
% command.  In particular, when displaying real-world values, it is
% handy to use
%
%   format long g
%
% so that as much precision as is possible will be displayed.

%% Display of fi math properties
% Thus far, we have been hiding the display of the properties that control
% math operations, which was the effect of the
%
%   fipref('FiMathDisplay','none')
%
% command at the beginning, and we have been using the default
% full-precision arithmetic.
%
% Now we are ready to explore other math options, so we turn the |fi| math
% display property to |full| so we can monitor the changes in the
% properties.  Note that even when the math properties are not displayed,
% they are still in effect.
fipref('FiMathDisplay','full')
%%
% There are also other display options to make a more shorthand display of
% the numeric type properties, and options to control the display of the
% value (as real-world value, binary, octal, decimal integer, or hex).
%
% For more information on display preferences, type
%
%   help fipref
%   help savefipref
%   help format
%
% or
%
%   doc fipref
%   doc savefipref
%   doc format
%
% at the MATLAB command line.

%% fi math properties
% Similar to the way the |numerictype| object encapsulate the numeric type
% properties of |fi|, the properties that control |fi| math operations are
% encapsulated in an object named |fimath|:
F = fimath
%%
% All of the properties may be modified.
%%
% The |fi| math properties may be modified either when the object is
% created by passing in parameter/value arguments

F = fimath('RoundMode','floor')

%%
% or they may be assigned by using the dot notation

F.OverflowMode = 'wrap'

%%
% All of the |fi| math properties may be set at once at object creation.
% The round mode and the overflow mode are used to quantize the initial
% value, and for all other math operations where rounding and overflow
% apply.

a = fi(pi,'fimath',F)

%% FullPrecision math
% The default is for all math operations to be executed in full precision,
% growing bits in the result as necessary.

%% Full Precision Product Mode
% A full precision product requires a word length equal to the sum of
% the word lengths of the operands.  In the following, note that the
% word length of the product |c| is equal to the word length of |a| plus
% the word length of |b|.  The fraction length of |c| is also equal to
% the fraction length of |a| plus the fraction length of |b|.
a = fi(pi,1,20);
b = fi(exp(1),1,16);
c = a * b

%% MaxProductWordLength
% Even though the maximum word length allowable in |fi| is 65535, it is
% easy to let the precision get away from you, especially in loops, so we
% have the |MaxProductWordLength| property so that you can catch yourself.
% The default value is 128, but you can modify this value for your own
% situation.  In this way, you can ensure that your calculations are never
% being carried out in a higher precision than your hardware allows.  For
% example, if you want all calculations done in full precision, but want to
% ensure that nothing is ever caculated to more precision than your
% hardware is capable of, say 40 bits, then set the maximum product and sum
% word lengths to 40.
%
% For an example of how it is easy to let the word length grow, consider
% the following loop.  The product word length will double each time
% through the loop, so the final product word length will be 16*2^5 = 512.
% In the event that this is not what you intended, an error will be thrown
% when the product word length exceeds the default value of 128. Our code
% has been written to catch and display the error.  If you wish to let the
% word length continue to grow, just set |MaxProductWordLength| to
% something larger than 512.

try
  a = fi(pi);
  for k=1:5
    a = a*a;
  end
catch
  disp(lasterr)
end

%% Full Precision Sum Mode
% A full precision sum requires a word length that grows |log2(n)| bits,
% where |n| is the number of summands.  
%
% For example, if there are |n=2| summands, then |log2(2)=1|, and so the
% sum must grow by one bit.  In this example, the word length of the
% summands |a| and |b| are each 24 bits, and the sum |c| is 25 bits.
a = fi(pi,1,24);
b = fi(exp(1),1,24);
c = a + b

%%
% In this example, we create a random matrix with 8 rows and 2 columns with
% a word length of 20 bits (after first resetting the random number
% generator state for repeatability of the example).
randn('state',0);
A = fi(randn(8,2),1,20)
%%
% The |sum| function sums the 8 elements in each column, so the sum needs
% to grow by |log2(8) = 3| bits to give a sum with a 23 bit word length.
sum(A)

%%
% Note that the + operator can't tell if there are more coming, so that 
%   
%    a+a+a+a
% 
% is different from
%
%    sum([a a a a])
%
% The latter is preferred, because |sum([a a a a])| knows that there are
% four summands, and will only grow log2(4) = 2 bits, while |a+a+a+a|
% will grow 3 bits, one for each +.  The difference is much greater for
% larger n.  The sum of 64 numbers computed as a+a+a+...+a will grow 63
% bits, while sum([a a ... a]) will only grow log2(64) = 6 bits.
%
% For example:
a = fi(pi)
%%
% Note that this sum grows three bits
a+a+a+a
%%
% while this sum can be smarter, and only grows two (and still guarantees
% no overflow)
sum([a a a a])

%% MaxSumWordLength
% Similar to |MaxProductWordLength|, you can also set the maximum value for
% the sum word length so that the precision never exceeds, say, the size of
% the accumulator in your hardware.

%% KeepLSB math
% When the sum or product mode is set to |KeepLSB|, then the
% least-significant bits of the sum or product are
% kept.  If the word length of the result is sufficient to store the full
% precision value, then the value is positioned in the least-significant
% bits of the result.  If the word length is smaller than is necessary to
% store the full precision value, then overflow occurs.  
%
% For example, to simulate arithmetic as it happens in C integers, set the
% product and sum modes to keep the least-significant bits, and the
% overflow mode to wrap.  Even though the ANSI C standard only defines the
% overflow characteristics of unsigned integers (wrap), and does not define
% the behavior of overflow for signed integers, most C implementations use
% wrap (modulo) two's-complement overflow for signed integers.
%
% In this example, we simulate 8-bit signed C integers. 
S8 = numerictype('Signed',1,'WordLength',8,'FractionLength',0)
%%
C8 = fimath('RoundMode','floor','OverflowMode','wrap',...
            'ProductMode','KeepLSB','ProductWordLength',8,...
            'SumMode','KeepLSB','SumWordLength',8)
%% fi(v, T, F)
% Since the numeric type and fi math parameters are commonly passed to
% the |fi| constructor, there is a signature that allows the (value,
% numerictype, fimath) triple to be entered.
%
% Let |a| be an 8-bit signed integer with the math defined like C and an
% initial value of 64.
a = fi(64,S8,C8)
%%
% In full precision math a+a=128, but in wrap two's-complement
% arithmetic, +128 is congruent to -128, as it would be in C:
a+a

%% KeepMSB math
% When the sum or product mode is set to |KeepMSB|, then the
% most-significant bits of the sum or product are
% kept.  If the word length of the result is sufficient to store the full
% precision value, then the value is positioned in the most-significant
% bits of the result.  If the word length is smaller than is necessary to
% store the full precision value, then rounding occurs.  
%
% Most fixed-point processors produce a product that has twice as many bits
% as its operands so that no quantization occurs during the computation of
% the product. However, some do not, such as the Zilog Z893xx, which
% accepts 16-bit operands, but produces a 24-bit result rather than the
% 32-bit result required for full precision.  To simulate this processor,
% we would set the |ProductMode| to |KeepMSB|, and the |ProductWordLength|
% to 24:
Z893math = fimath('ProductMode','KeepMSB','ProductWordLength',24);
a = fi(0.1,1,16,16,'fimath',Z893math)
%%
% Note that the quantized product is the 24 most-significant bits of the
% product.
a*a

%% 
% Also, many textbooks do roundoff error analysis for "single-precision"
% fixed-point products and sums with fractional numbers. In this example, we
% simulate 8-bit unsigned fractional numbers (all values between 0 and 1).
U8 = numerictype('Signed',0,'WordLength',8,'FractionLength',8)
%%
F8 = fimath('ProductMode','KeepMSB','ProductWordLength',8,...
            'SumMode','KeepMSB','SumWordLength',8)
%%
% Let |a| be an 8-bit unsigned fractional number with fractional arithmetic
% that quantizes products and sums to keep the most-significant bits.
a = fi(0.1, U8, F8)
%%
% In the following, note that a product that is also a fractional number
% has been produced, and the 8 most-significant bits have been retained.
a*a

%% SpecifyPrecision math
% When we want full control over the math operations, we set the product or
% sum mode to SpecifyPrecision, and then fully specify the word length and
% fraction length of the result.
F = fimath('ProductMode','SpecifyPrecision',...
           'ProductWordLength',24,...
           'ProductFractionLength',23,...
           'SumMode','SpecifyPrecision',...
           'SumWordLength',40,...
           'SumFractionLength',23)
%%
a = fi(pi/4,'fimath',F)
%%
b = fi(exp(1)/4,'fimath',F)
%%
% Then the products will always be 24,23
a*b
%%
% And the sums will always be 40,23
a+b

%% CastBeforeSum
% Unfortunately, there is no += operator in MATLAB, so in order to simulate
% the accumulation of sums, such as might be done in this code snippet from
% C, we have the |CastBeforeSum| parameter.
%
%   acc  = a;
%   acc += b;
% 
% When |CastBeforeSum| is true (1), then the operands are cast to the
% numeric type of the sum before the addition takes place.  This behavior
% models most DSP chips.
%
% When |CastBeforeSum| is false (0), then the operands are added in full
% precision, and then cast to the numeric type of the sum.  This behavior
% models many ASIC or FPGA implementations.
%
% The difference only matters when the numeric type of the sum has less
% precision or range than the numeric types of the operands.
%
% Here is a simple example.  Let the numeric type of the sum be an integer
% (the fraction length is zero), and let the operands have one fractional
% bit that would sum to be an integer.  If the operands were cast to the
% numeric type of the sum before addition, then the fractional bit would be
% lost before the addition.  If the operands were added and then cast to
% the numeric type of the sum, then the fractional bits would be
% significant.
F = fimath('RoundMode','floor',...
            'SumMode','SpecifyPrecision',...
           'SumWordLength',16,'SumFractionLength',0,...
           'CastBeforeSum',true)
%%
a = fi(0.5,'fimath',F)
%%
% In the following, the 0.5 gets quantized to 0 before the addition
% takes place, and so the sum is 0
a + a

%%
% Now, set |CastBeforeSum| to true and repeat the experiment.  Note that
% the |fi| math parameters can be changed on a |fi| variable at any time
a.CastBeforeSum = false
%%
% Now the sum 0.5+0.5 = 1 gets done first, and then is
% cast to an integer, so the sum is 1.
a + a

%% Math with other built-in data types.
%% fi * double
% When doing arithmetic between |fi| and |double|, the double is cast to a
% |fi| with the same word length and signedness of the |fi|, and
% best-precision fraction length.  The result of the operation is a |fi|.
a = fi(pi);
b = 0.5 * a

%% Some differences between fi and C
% Note that in C, the result of an operation between a integer data type
% with a double data type will promote to a double.  
%
% However, in MATLAB, the result of an operation between a built-in
% integer data type with a double data type will be an integer.  In this
% respect, the |fi| object behaves like the built-in integer data types
% in MATLAB: the result of an operation between a |fi| and a double is a
% |fi|.

%% fi * int8
% When doing arithmetic between fi and one of the built-in integer data
% types [u]int[8,16,32], then the word length and signedness of the the
% integer are preserved.  The result of the operation is a fi.
a = fi(pi);
b = int8(2) * a


%%
% Copyright 2004 The MathWorks, Inc.

%%
% $Revision: 1.1.6.1 $

##### SOURCE END #####
-->
   </body>
</html>