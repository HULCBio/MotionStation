function rtw_c(h,modelName,rtwroot,templateMakefile,buildOpts,buildArgs,infoStruct,varargin)
% RTW_C Creates the makefile used to build the RTW C code image.
%
%       RTW_C creates a makefile from the templateMakefile which is then
%       used by make to create the image.
%
%       This function is designed to be invoked by make_rtw.
%       All arguments (modelName,rtwroot,templateMakefile,buildOpts,buildArgs)
%       are assumed to be present.
%
%       buildOpts is a structure containing:
%          buildOpts.sysTargetFile
%          buildOpts.noninlinedSFcns
%          buildOpts.listSFcns
%          buildOpts.solver
%          buildOpts.solverType
%          buildOpts.numst
%          buildOpts.tid01eq
%          buildOpts.ncstates
%          buildOpts.mem_alloc
%          buildOpts.modules
%          buildOpts.RTWVerbose
%          buildOpts.codeFormat
%          buildOpts.compilerEnvVal -   '' or the location of the env var
%                                       for the compiler. This will be
%                                       non-NULL on the PC when we
%                                       use the mex preferences file
%                                       to determine which template makefile
%                                       to use.


%       Copyright 1994-2002 The MathWorks, Inc.
%       $Revision: 1.116.4.21 $

ispc = strncmp(computer,'PC',2);

if(nargin<8)
   extraTokenReplacements = LocGetExtraToken(h,infoStruct);
else
   extraTokenReplacements = varargin{1};
end
%--------------------------------------------------------------------%
% Update marker file which is used by the make utilities to determine %
% when to re-build objects due to the "model name changing           %
%-------------------------------------------------------------------%

rtwProjFile      = 'rtw_proj.tmw';
simStructDirInfo = dir(fullfile(matlabroot,'simulink','include','simstruc.h'));
rtwProjFileContents1 = ['Real-Time Workshop project for ', modelName, ...
                    ' using ', templateMakefile, ...
                    '. MATLAB root = ', matlabroot, ...
                    '. SimStruct date: ', simStructDirInfo.date];
rtwProjFileContents2 = ['This file is generated by the Real-Time ', ...
                    'Workshop for use by the make utility\nto determine when to ', ...
                    'rebuild objects when the name of the current Real-Time ', ...
                    'Workshop project changes.\n'];

% Get rtwinfomat name with relative path
anchorDir = loc_calculate_path(h.BuildDirectory,infoStruct.relativePathToAnchor);
rtwinfomatfilename = rtwprivate('rtwinfomatman',anchorDir,'getMatFileName','binary', ...
                          h.ModelName, h.MdlRefBuildArgs.ModelReferenceTargetType);
% get relative path to rtwinfomat
if strmatch(h.StartDirToRestore, rtwinfomatfilename)
    rtwinfomatfilename = fullfile(infoStruct.relativePathToAnchor, ...
        rtwinfomatfilename(length(h.StartDirToRestore)+1:end));
end
rtwProjFileContents3 = ['The rtwinfomat located at: ' rtwinfomatfilename];

rtmDefMexp = '';
if ~isempty(dir(rtwProjFile))
  fid = fopen(rtwProjFile,'r');
  if fid == -1
    error(['Unable to open RTW project marker file: ',rtwProjFile]);
  end
  line1 = fgetl(fid);
  line2 = fgetl(fid);
  line2 = fgetl(fid); % rtwProjFileContents2 contains 2 lines
  line3 = fgetl(fid);
  fclose(fid);
  dowrite = (~strcmp(line1,rtwProjFileContents1)) || ...
      (~strcmp(line3,rtwProjFileContents3));
else
  dowrite = 1;
end

if isfield(buildOpts, 'DispHook')
  dh = buildOpts.DispHook;
else
  dh = {@disp};
end

if dowrite
  if buildOpts.RTWVerbose
    feval(dh{:},['### Creating project marker file: ', rtwProjFile]);
  end
  fid = fopen(rtwProjFile,'w');
  if fid == -1
    error(['Unable to create RTW project marker file: ',rtwProjFile]);
  end
  fprintf(fid, '%s\n', rtwProjFileContents1);
  fprintf(fid, rtwProjFileContents2);
  fprintf(fid, '%s\n', rtwProjFileContents3);
  fprintf(fid, rtmDefMexp);
  fclose(fid);
end

%----------------------------%
% Read the template makefile %
%----------------------------%

fid = fopen(templateMakefile, 'r');
if fid == -1
  error(['Unable to open template makefile: ',templateMakefile]);
end
tmfContents = char(fread(fid, [1, inf], 'char'));
fclose(fid);

makefileFileSeparator = GetMacro(tmfContents,'MAKEFILE_FILESEP',templateMakefile,0);
sysTargetFile = GetMacro(tmfContents, 'SYS_TARGET_FILE', templateMakefile, 1);

if ~strcmp(sysTargetFile, 'any')
  if ispc
    diffSTF = ~strcmpi(sysTargetFile,buildOpts.sysTargetFile);
  else
    diffSTF = ~strcmp(sysTargetFile,buildOpts.sysTargetFile);
  end

  if diffSTF
    error(['SYS_TARGET_FILE is defined as "', sysTargetFile, ...
           '" in template makefile, ', templateMakefile, ...
           ' where as model is configured for "', ...
           buildOpts.sysTargetFile, '".']);
  end
end

%------------------------------------------------------------------------%
% Handle RTWBuildArgs model property (update template makefile contents) %
%------------------------------------------------------------------------%

% Parse RTW options and remove any defines from it if we find
% replacement tokens in the tmf contents, otherwise we need to pass
% the build argument to the make command. Note, we assume RTWBuildArgs
% was set via the rtw options gui and doesn't contain extra spaces,
% etc.
%
% Note: this parameter is set in PrepareBuildArgs from ConfigSet. Values
% with spaces will have double-qoutes.
args = get_param(modelName,'RTWBuildArgs');

% assumes args come in quoted appropriately for matlab command line
% (i.e. single-quoted if needed)

eval(['CurlyBracketOperator ' args ';']);

argsAsCellArray = [ans,extraTokenReplacements]; % convert args to cell array

for i=1:length(argsAsCellArray)

  field = argsAsCellArray{i};

  eqIdx = findstr(field,'=');
  fieldName = field(1:eqIdx-1);
  fieldVal  = field(eqIdx+1:end);

  % Always replace the token in the template makefile since
  % we can assume that the template makefile handles 0 for on
  % and 1 for off. However, if we are passing the build argument
  % to the template makefile through the command line (e.g.
  % make_rtw EXT_MODE=1), we must pass non-zero values. We
  % need to do this for backwards compatibility since template
  % makefiles checked for the existence of a build argument and
  % not the value of it.
  replaceName = ['|>',fieldName,'<|'];
  if findstr(tmfContents,replaceName)
    % Remove double-quotes for make variables that are found in the
    % tmf. In general, make utitlies handle values in the makefile
    % that have spaces, without the need for double quotes.
    fieldVal = strrep(fieldVal,'"','');
    tmfContents = strrep(tmfContents, replaceName, fieldVal);
  elseif ~strcmp(fieldVal,'0')
    % If variable is to be passed in on make command line, leave double
    % quotes around the value to get past the command line shell.
    if isempty(buildArgs)
      buildArgs = field;
    else
      buildArgs = [buildArgs, ' ', field];
    end
  end

%   disp([mfilename ': ' ...
%         'fieldName <' fieldName '> '...
%         'fieldVal <' fieldVal '> '...
%         'whole field <' field '>']);
end

%------------------------------------------------------------%
% Parse BUILD and DOWNLOAD options from buildArgs if present %
%------------------------------------------------------------%

[buildImage,buildArgs] = ParseBuildArgs(buildArgs,'BUILD');
[download,buildArgs] = ParseBuildArgs(buildArgs,'DOWNLOAD');

switch (buildOpts.solver)
 case 'FixedStepDiscrete'
  solver    = '';
  solverObj = '';
 case 'VariableStepDiscrete'
  solver    = '';
  solverObj = '';
 otherwise
  solver    = [buildOpts.solver, '.c'];
  solverObj = [buildOpts.solver, '.obj'];
end


makefileName = [modelName,'.mk'];

tmf     = get_param(modelName,'RTWTemplateMakefile');
matroot = rtwroot(1:end-4); % remove "/rtw" or "\rtw"

arch = lower(computer);
if strcmp(arch,'pcwin')
  arch = 'win32';
end
matbin = fullfile(matroot,'bin',arch);
if exist(matbin) ~= 7
  matbin = fullfile(matroot,'bin');
end

if makefileFileSeparator == '/'
	% Force unix stype paths compatible with gmake
	matroot = strrep(matroot,'\','/');
	matbin = strrep(matbin,'\','/');
end

% Need to be robust to C++ and varying extension cases
modelModulesObj = change_file_ext(buildOpts.modules);

% Exclude object files directly included into non-inlined s-functions.
% Theses are included later on under S_FUNCTION_LIB. If included here,
% multiple inclusions of these object files cause build failures.
idxObjInNonInlinedSFcns  = regexpi(buildOpts.noninlinedSFcns, ...
                                    '((\.o(bj)?)|(\.lib)|(\.a))$');
filteredBuildOptsModules = buildOpts.modules;
for counter = 1:length(idxObjInNonInlinedSFcns)
   if ~isempty(idxObjInNonInlinedSFcns{counter})
     modelModulesObj = strrep(modelModulesObj, ...
                              buildOpts.noninlinedSFcns{counter},'');
     filteredBuildOptsModules = strrep(filteredBuildOptsModules, ...
                                       buildOpts.noninlinedSFcns{counter},'');
   end
 end

multitasking = num2str(strcmp(buildOpts.solverMode,'MultiTasking'));

releaseVersion = release_version;

if system_dependent('purify')
  purifyMatlabBuild = '1';
else
  purifyMatlabBuild = '0';
end


% Handle model reference blocks
modelrefCell = {};
modelrefInfo = buildOpts.modelrefInfo;
for idx = 1:length(modelrefInfo)
  fileName =  modelrefInfo{idx}{2};
  modelrefCell{idx} = fileName;
end

modelrefCellUnique = unique(modelrefCell);
modelrefStr = '';
for idx=1:length(modelrefCellUnique)
  modelrefStr = [modelrefStr,' ', modelrefCellUnique{idx}];
end


tmfContents = strrep(tmfContents, tmf,                     makefileName);
tmfContents = strrep(tmfContents, '|>MODEL_NAME<|',        modelName);
tmfContents = strrep(tmfContents, '|>MODEL_MODULES<|',     filteredBuildOptsModules);
tmfContents = strrep(tmfContents, '|>MODEL_MODULES_OBJ<|', modelModulesObj);
tmfContents = strrep(tmfContents, '|>MAKEFILE_NAME<|',     makefileName);
tmfContents = strrep(tmfContents, '|>MATLAB_ROOT<|',       matroot);
tmfContents = strrep(tmfContents, '|>MATLAB_BIN<|',        matbin);
tmfContents = strrep(tmfContents, '|>SOLVER<|',            solver);
tmfContents = strrep(tmfContents, '|>SOLVER_OBJ<|',        solverObj);
tmfContents = strrep(tmfContents, '|>SOLVER_TYPE<|',       buildOpts.solverType);
tmfContents = strrep(tmfContents, '|>NUMST<|',             buildOpts.numst);
tmfContents = strrep(tmfContents, '|>TID01EQ<|',           buildOpts.tid01eq);
tmfContents = strrep(tmfContents, '|>NCSTATES<|',          buildOpts.ncstates);
tmfContents = strrep(tmfContents, '|>MEM_ALLOC<|',         buildOpts.mem_alloc);

grtInterface = 0;
if strcmp(buildOpts.codeFormat,'Embedded-C')
  cs = getActiveConfigSet(modelName);
  grtInterface = strcmp(get_param(cs,'GRTInterface'), 'on');
end

if strcmp(buildOpts.codeFormat,'Embedded-C')
  opts = '';
  if (grtInterface || ...
       ~strcmp(buildOpts.sysTargetFile,'modelrefsim.tlc') && ...
       ~isempty(buildOpts.noninlinedSFcns))
    %%
    %% For ERT with non-inlined s-functions must #define {RT, USE_RTMODEL}
    %% for simstruc.h.   Remove when rtwtypes.h has this line
    opts = ' -DRT -DUSE_RTMODEL -DERT';
  end
  if strcmp(buildOpts.tid01eq,'1')
    opts = [opts, ' -DTID01EQ=1'];
  end
  if ~strcmp(opts, '')
    opts = [' OPTS="', opts, '"'];
    buildArgs = [buildArgs, opts];
  end
end
tmfContents = strrep(tmfContents, '|>BUILDARGS<|',         buildArgs);
tmfContents = strrep(tmfContents, '|>COMPUTER<|',          computer);
tmfContents = strrep(tmfContents, '|>MEXEXT<|',            mexext);
tmfContents = strrep(tmfContents, '|>MULTITASKING<|',      multitasking);
tmfContents = strrep(tmfContents, '|>RELEASE_VERSION<|',   releaseVersion);
tmfContents = strrep(tmfContents, '|>PURIFY<|',            purifyMatlabBuild);
tmfContents = strrep(tmfContents, '|>MODELREFS<|',         modelrefStr);

if strcmp(buildOpts.codeFormat, 'S-Function')
  usermodules = parsestrforvar(buildArgs,'USER_SRCS');
  userobjs = parsestrforvar(buildArgs,'USER_OBJS');
  tmfContents = strrep(tmfContents, '|>USERMODULES<|',  ...
                       [usermodules, ' ',userobjs]);
end

% ---------------------------------------------------- %
% Expand |>START_EXPAND_RULE<| ... |>EXPAND_DIR_NAME<| %
%          /* make rule */                             %
%        |>END_EXPAND_RULE<|                           %
% ---------------------------------------------------- %
last_error = lasterr;
last_warng = lastwarn;

listSFcns      = buildOpts.listSFcns;
currDir        = pwd;
includeDirs    = {};
sourceDirs     = {};
sfcnNames      = {};
sfcnLibs       = '';
%% always add RTW library sources
sfcnPathArray  = {fullfile(matlabroot,'rtw','c','libsrc')};
libraryList    = {};
locationList   = {};
modulesArray   = {};
preCompLib     = {};
preCompLibLoc  = {};
preCompModules = {};

[aDummyMFileList, mexf] = inmem;

% Only build Stateflow for non-accelerator targets
if strcmp(buildOpts.codeFormat, 'Accelerator_S-Function')
  sfIsHere = 0;
else
  sfIsHere = any(strcmp(mexf,'sf'));
end

if (sfIsHere)
  sf_makeinfo = sf_rtw('get_sf_makeinfo',modelName);
  % dboissy says:
  % These are no longer taken from the Stateflow RTW
  % target.  They are instead taken directly from
  % the configset.
  %if ~isempty(sf_makeinfo)
  %  sourceDirs  = sf_makeinfo.fileNameInfo.userAbsPaths;
  %  includeDirs = sf_makeinfo.fileNameInfo.userIncludeDirs;
  %end
  [prevErrMsg, prevErrId] = lasterr;
  try
    sfcnPathArray = sf_rtw('update_sf_include_libraries',modelName,sf_makeinfo.fileNameInfo,sfcnPathArray,h);
  catch
    lasterr(prevErrMsg, prevErrId);
  end
end

% Add custom code settings from configset
cs          = getActiveConfigSet(modelName);
rtwSettings = cs.getComponent('any', 'Real-Time Workshop');

% Parse custom code settings in an effort to resolve file names
custCodeFiles = rtw_resolve_custom_code(h, rtwSettings.CustomInclude, rtwSettings.CustomSource, rtwSettings.CustomLibrary);

% Add settings to global source, include, and libs
sourceDirs  = [sourceDirs custCodeFiles.parsedSrcPaths];
includeDirs = [includeDirs custCodeFiles.parsedIncludePaths];

% Add libs specified in the custom code settings
for i=1:length(custCodeFiles.parsedLibFiles)
  sfcnLibs = [sfcnLibs, [custCodeFiles.parsedLibFiles{i}, ' ']];
end

for i=1:length(listSFcns)
  sfcnNames = {sfcnNames{:}, listSFcns{i}{2}};
end

if ~isempty(sfcnNames)
  sfcnNames = unique(sfcnNames);
  for i=1:length(sfcnNames)
    [sfcnPath, sfcnName] = fileparts(which(sfcnNames{i}));
    if ~isempty(sfcnPath)
      sfcnPathArray = {sfcnPathArray{:}, sfcnPath};
    end

    % Create additional INCLUDEPATHS/RULES for s-functions
    if (exist([sfcnPath, filesep, sfcnName, '.h']) == 2)
      includeDirs = {includeDirs{:}, sfcnPath};
    end
    if (exist([sfcnPath, filesep, sfcnName, '.c']) == 2)
      hLoc = fileparts(which([sfcnName,'.c']));
      sourceDirs    = { sourceDirs{:}, hLoc };
    end
    if (exist([sfcnPath, filesep, sfcnName, '.cpp']) == 2)
      hLoc = fileparts(which([sfcnName,'.cpp']));
      sourceDirs    = { sourceDirs{:}, hLoc };
    end

  end
end
sfcnPathArray = unique(sfcnPathArray);
%
for i=1:length(sfcnPathArray)
  cd(sfcnPathArray{i});
  if exist(['.',filesep,'rtwmakecfg.m']) > 0 || ...
        exist(['.',filesep,'rtwmakecfg.p']) > 0
    set_param(0, 'CurrentSystem', modelName);
    rtwCfgStr = eval('rtwmakecfg','[]');
    tmpIncludeDirs = eval('rtwCfgStr.includePath', '{}');
    tmpSourceDirs  = eval('rtwCfgStr.sourcePath',  '{}');
    includeDirs    = { includeDirs{:}, tmpIncludeDirs{:} };
    sourceDirs     = { sourceDirs{:},  tmpSourceDirs{:}  };
    bPreCompile    = eval('rtwCfgStr.precompile', '0');
    tmpLibraryStr      = eval('rtwCfgStr.library', '{}');
    tmpLibraryList     = eval('{tmpLibraryStr(:).Name}','{}');
    tmpLibraryLocation = eval('{tmpLibraryStr(:).Location}','{''''}');
    tmpModulesArray    = eval('{tmpLibraryStr(:).Modules}','{}');
    if bPreCompile
      preCompLib     = { tmpLibraryList{:},     preCompLib{:} };
      preCompLibLoc  = { tmpLibraryLocation{:}, preCompLibLoc{:} };
      preCompModules = { tmpModulesArray{:},    preCompModules{:} };
    else
      libraryList    = { tmpLibraryList{:}, libraryList{:} };
      locationList   = { tmpLibraryLocation{:}, locationList{:} };
      modulesArray   = { tmpModulesArray{:}, modulesArray{:} };
    end
  end
end
%
includeDirs = sf('Private', 'ordered_unique_paths', includeDirs);
sourceDirs  = sf('Private', 'ordered_unique_paths', sourceDirs);
%
[libraryList, idx] = unique(libraryList);
modulesArray = modulesArray(idx);
locationList = locationList(idx);
%
[preCompLib, idx] = unique(preCompLib);
preCompModules = preCompModules(idx);
preCompLibLoc = preCompLibLoc(idx);
%
%-----------------------------------------------------------%
%Filling in S-FUNCTION MODULES related information          %
%-----------------------------------------------------------%
cd(currDir);
currPath  = path;
searchPath= unique({sourceDirs{:},...
                    includeDirs{:},...
                    '..',...
                    '.',...
                    [matlabroot,filesep,'simulink',filesep,'src']});
cmdOut = evalc('addpath(searchPath{:})');
sfcns =' ';
sfcnObjs = '';
cppSfcns = '0';
% treat non-inlined non-sfunction same as non-inlined sfunction.
buildOpts.noninlinedSFcns = [buildOpts.noninlinedSFcns, ...
                             buildOpts.noninlinednonSFcns];
for i=1:length(buildOpts.noninlinedSFcns)
  name = buildOpts.noninlinedSFcns{i};
  if ~isempty(regexp(name, '\w+\.lib', 'once'))
    sfcnLibs = [sfcnLibs, [name, ' ']];
  elseif ~isempty(regexp(name, '\w+\.a', 'once'))
    %
    % If the filename begins with "lib" and is not in the current
    % directory, use the unix-peculiar libpath library file name
    % reference transform (librob.a -> -lrob); otherwise, leave
    % the name alone.  The library must then be on the library
    % path (e.g. LD_LIBRARY_PATH environment var.) or must be
    % set explicitly in the make_rtw command using
    % LDFLAGS= -L<libpathitem> for RTW to find the library.
    %
    if ( isempty(dir(name)) && ...
         length(name) > 3 && ...
         strcmp(name(1:3),'lib') )
      sfcnLibs = [sfcnLibs, ['-l',strrep(name(4:end),'.a',' ')]];
    else
      %
      %lib file must be in pwd or is a nonstandard name;
      %We expect the user libs to be not in the
      %code generation directory. If however we detect
      %it in pwd we put it in pwd else it is in the parent dir.
      if(~isempty(dir(name)))
        sfcnLibs = [sfcnLibs, ['.',filesep, name, ' ']];
      else
        sfcnLibs = [sfcnLibs, ['..',filesep, name, ' ']];
      end
    end
  elseif ~isempty(regexp(name, '\w+\.obj','once'))
     % objects found here will go on the link command
     sfcnLibs = [sfcnLibs, ['..', filesep, name, ' ']];
  elseif ~isempty(regexp(name, '\w+\.o','once'))
    % objects found here will go on the link command
    sfcnLibs = [sfcnLibs, ['..', filesep, name, ' ']];
  else
    if(exist([name,'.cpp'],'file') == 2)
      sfcns  = [sfcns, [name, '.cpp ']];
      cppSfcns = '1' ;
      sfcnObjs = [sfcnObjs, [name, '.obj ']];
    elseif(exist([name,'.c'],'file') == 2)
      sfcns  = [sfcns, [name, '.c ']];
      sfcnObjs = [sfcnObjs, [name, '.obj ']];
    end
  end
end
if length(sfcns) > 0
  sfcns(end) = [];
end
path(currPath);
tmfContents = strrep(tmfContents, '|>S_FUNCTIONS<|',       sfcns);
tmfContents = strrep(tmfContents, '|>S_FUNCTIONS_LIB<|',   sfcnLibs);
tmfContents = strrep(tmfContents, '|>S_FUNCTIONS_OBJ<|',   sfcnObjs);
tmfContents = strrep(tmfContents, '|>HASCPPSFUNCTION<|',   cppSfcns);
%
if makefileFileSeparator == '/'
	% Force unix stype paths compatible with gmake
	sourceDirs = strrep(sourceDirs,'\','/');
end
tmfContents = ExpandRule(tmfContents, sourceDirs,  ...
                         '|>START_EXPAND_RULES<|', ...
                         '|>END_EXPAND_RULES<|',   ...
                         '|>EXPAND_DIR_NAME<|');

if makefileFileSeparator == '/'
	% Force unix stype paths compatible with gmake
	includeDirs = strrep(includeDirs,'\','/');
end
tmfContents = ExpandRule(tmfContents, includeDirs,    ...
                         '|>START_EXPAND_INCLUDES<|', ...
                         '|>END_EXPAND_INCLUDES<|',   ...
                         '|>EXPAND_DIR_NAME<|');

  % translate include path into relative paths.
  relativeincludePaths=[];
  for i=1:length(infoStruct.includePaths)
    relativeincludePaths{i} = fullfile(infoStruct.relativePathToAnchor, infoStruct.includePaths{i});
  end                     
tmfContents = ExpandRule(tmfContents, relativeincludePaths,    ...
                         '|>START_MDLREFINC_EXPAND_INCLUDES<|', ...
                         '|>END_MDLREFINC_EXPAND_INCLUDES<|',   ...
                         '|>MODELREF_INC_PATH<|');
                     
% update preCompLib fields of rtwinfo.
preCompLibLoc  = strrep(preCompLibLoc, matlabroot, '$(MATLAB_ROOT)');
infoStruct = rtwinfomatman(anchorDir,'updatepreComps','binary',h.ModelName,...
    h.MdlRefBuildArgs.ModelReferenceTargetType,preCompLib,preCompLibLoc,preCompModules);
preCompLib     = infoStruct.preCompLib;
preCompLibLoc  = infoStruct.preCompLibLoc;
preCompModules = infoStruct.preCompModules;

tmfContents = ExpandNestedRule(tmfContents, libraryList, locationList, ...
                               '|>START_EXPAND_LIBRARIES<|',   ...
                               '|>END_EXPAND_LIBRARIES<|',     ...
                               '|>EXPAND_LIBRARY_NAME<|',      ...
                               '|>EXPAND_LIBRARY_LOCATION<|',  ...
                               modulesArray,                  ...
                               '|>START_EXPAND_MODULES<|',     ...
                               '|>END_EXPAND_MODULES<|',       ...
                               '|>EXPAND_MODULE_NAME<|', makefileFileSeparator);

tmfContents = ExpandNestedRule(tmfContents, preCompLib, preCompLibLoc, ...
                               '|>START_PRECOMP_LIBRARIES<|', ...
                               '|>END_PRECOMP_LIBRARIES<|',   ...
                               '|>EXPAND_LIBRARY_NAME<|',     ...
                               '|>EXPAND_LIBRARY_LOCATION<|', ...
                               preCompModules,               ...
                               '|>START_EXPAND_MODULES<|',    ...
                               '|>END_EXPAND_MODULES<|',      ...
                               '|>EXPAND_MODULE_NAME<|', makefileFileSeparator);

lasterr(last_error); lastwarn(last_warng);

%------------------------------------------------%
% Check for any token that has not been replaced %
%------------------------------------------------%
if ~isfield(buildOpts, 'ignoreTokenCheck') || ~buildOpts.ignoreTokenCheck
  if findstr(tmfContents, '= |>')
    [starti endi] = regexp(tmfContents, '(= |>)(\w*)(<|)');
    if ~isempty(starti)
      feval(dh{:},sprintf(['!-----\n' ...
                    'The following make variables are used in the template make file, ' ...
                    'but they are not defined.\n' 'You may have a mismatch between the system ' ...
                    'target file and the template make file.']));
      for idx = 1 : length(starti)
        feval(dh{:},tmfContents(starti(idx):endi(idx)));
      end
      feval(dh{:},'-----!');
    end
  end
end


%---------------------------------------%
% Write new model.mk makefile if needed %
%---------------------------------------%

skipWrite = 0;
if ~isempty(dir(makefileName))
  fid = fopen(makefileName,'r');
  if fid == -1
    error(['Error opening ',makefileName]);
  end
  oldContents = char(fread(fid, [1, inf], 'char'));
  fclose(fid);
  skipWrite = strcmp(oldContents,tmfContents);
else
  skipWrite = 0;
end

if ~skipWrite
  fid = fopen(makefileName,'w');
  if fid == -1
    error(['Unable to create new makefile: ',makefileName]);
  end
  if buildOpts.RTWVerbose
    feval(dh{:},['### Creating ',makefileName, ' from ', templateMakefile]);
  end
  fwrite(fid, tmfContents, 'char');
  fclose(fid);
else
  if buildOpts.RTWVerbose
    feval(dh{:},['### ', makefileName, ' which is generated from ', ...
                 templateMakefile, ' is up to date']);
  end
end


%--------------------------------------------------------------------%
% Setup makeCmd (we do this here because on pc we generate model.bat %
%--------------------------------------------------------------------%
make = GetMacro(tmfContents,'MAKECMD',templateMakefile,0);
if isempty(make)
  make = GetMacro(tmfContents,'MAKE',templateMakefile,1); % for backwards compat
end
if isunix
  if strcmp(make,'make')
    gmake = [matlabroot,'/rtw/bin/',lower(computer),'/make'];
    if exist(gmake,'file')
      make = gmake;
    end
  end
else
	if ispc
		% If gmake is used the forward slashes may be used
		% in the specification of the make location in the
		% tmf file. Convert to dos compatible backslash path
		% format for invoking make from the shell.
		make = strrep(make,'/','\');
	end
end

makeCmd = [make, ' -f ' makefileName, ' ',buildArgs];

%-------------------------------------------------------------------------------
%
% Some platforms and/or targets can't just execute the raw make command. They
% may need to wrap it inside of a generated script.  E.g. on Windows we
% typically wrap the raw make command in a batch (.bat) file that sets up some
% environment variables needed during the build process. E.g. wrap_make_cmd()
% takes 'nmake -f model.mk MAT_FILE=1' as args.makeCmd, creates model.bat and
% returns 'model.bat'. UNIX typically does not need to wrap the make command so
% it comes back untouched.
%
%-------------------------------------------------------------------------------
%
aWrapMakeCmdArgs.make           = make; % e.g. 'nmake'
aWrapMakeCmdArgs.makeCmd        = makeCmd; % e.g. 'nmake -f model.mk MAT_FILE=1'
aWrapMakeCmdArgs.modelName      = modelName;
aWrapMakeCmdArgs.verbose        = buildOpts.RTWVerbose;
aWrapMakeCmdArgs.compilerEnvVal = buildOpts.compilerEnvVal;
aWrapMakeCmdArgs.sysTargetFile  = buildOpts.sysTargetFile; % e.g. 'ert.tlc'
aWrapMakeCmdArgs.TemplateMakefile = h.TemplateMakefile;
aWrapMakeCmdArgs.mexOpts        = h.mexOpts;

makeCmd = wrap_make_cmd(aWrapMakeCmdArgs);

%-----------------------------------------------------------------%
% If we are only generating code and the model.mk file, then exit %
%-----------------------------------------------------------------%

if buildOpts.generateCodeOnly
  loc_refresh_codebrowser(h.ModelName, anchorDir);
  return;
end

%-------------------------------------------------------%
% Invoke the build procedure if on the correct platform %
%-------------------------------------------------------%

host = GetMacro(tmfContents, 'HOST', templateMakefile, 1);

% This check has precedence over buildArgs such as BUILD=yes
if ~(strcmp(host,computer) || ...
      (strcmp(host,'UNIX') && isunix) ||  ...
      (strcmp(host,'PC') && ispc) || strcmp(host,'ANY'))
  buildImage = false;
  feval(dh{:},['### Make will not be invoked - template makefile is for a ' ...
               'different host']);
end

% This check has lower precedence than buildArgs such as BUILD=yes
if isempty(buildImage)
  build = GetMacro(tmfContents,'BUILD',templateMakefile,1);
  buildImage = strcmpi(build,'yes') || strcmp(build,'1');
  if ~buildImage
    feval(dh{:},['### Make will not be invoked - BUILD macro in template ', ...
          'makefile is set to ''',build,'''']);
  end
end

tmfVersion = rtwprivate('get_tmf_version',modelName);
%---------------------------------------------------------%
% When applicable, ensure Makefile supports MdlRef builds %
%---------------------------------------------------------%
if ~strcmp(h.MdlRefBuildArgs.ModelReferenceTargetType,...
          'NONE')  || ~isempty(infoStruct.modelRefs)
  if ~(buildImage && strcmp(tmfVersion,'ModelReference'))
    buildError = ['### Model Reference requires the makefile to support ',...
                  'compilation. Consider updating makefile: ''',...
                  templateMakefile, ''' or selecting ''Generate code only'''];
    error(buildError);
  end
end

%---------------------------------------------------------%
% When applicable, ensure Makefile supports shared utility%
%---------------------------------------------------------%
if buildImage && strcmp(tmfVersion,'Standalone') && ...
        strcmp(uget_param(modelName,'UtilityFuncGeneration'),'Shared location')
    buildError = ['### Real-Time Workshop requires the makefile to support ',...
                  'generating utility functions in shared location. Consider updating makefile: ''',...
                  templateMakefile, ''' or selecting ''Auto'''];
    error(buildError);
end

if buildImage

  %-------------------------------------%
  % Invoke make to build the executable %
  %-------------------------------------%

  buildSuccess = GetMacro(tmfContents,'BUILD_SUCCESS',templateMakefile,0);
  if isempty(buildSuccess)
    buildSuccess = '### Created';
  elseif buildSuccess(1) == '['
    buildSuccess = eval(buildSuccess);
  end

  buildError = GetMacro(tmfContents,'BUILD_ERROR',templateMakefile,0);
  if isempty(buildError)
    buildError = ['Error(s) encountered while building model "', ...
                  modelName, '"'];
  elseif buildError(1) == '['
    buildError = eval(buildError);
  end

  if buildOpts.RTWVerbose
    feval(dh{:},['### Building ',modelName,': ',makeCmd]);
  end

  % Allow makefile to override a RTW Verbose setting of 0 (off)
  makefileVerboseVal = GetMacro(tmfContents,'VERBOSE_BUILD_OFF_TREATMENT',templateMakefile,0);
  makefileVerboseOverride = false;
  if ~isempty(makefileVerboseVal) && strcmp(makefileVerboseVal,'PRINT_OUTPUT_ALWAYS');
    makefileVerboseOverride = true;
  end
    
  if buildOpts.RTWVerbose || makefileVerboseOverride
    aEchoArg = {'-echo'};
  else
    aEchoArg = {};
  end

  % save makeCmd into rtwinfo
  tokenmakeCmd = strrep(makeCmd, matlabroot, '$(MATLAB_ROOT)');
  infoStruct = rtwprivate('rtwinfomatman',anchorDir,'updateField','binary', ...
                        h.ModelName, h.MdlRefBuildArgs.ModelReferenceTargetType, 'makeCmd',tokenmakeCmd);

  loc_refresh_codebrowser(h.ModelName, anchorDir);

  [status,result] = system(makeCmd, aEchoArg{:});
  
  % The code below is commented out since it causes the output of the make command
  % to appear all at once when it returns, failing to give the user a sense of
  % progress.  So, as with TLC output at the moment, I'm bailing on capturing
  % all output and I've gone back to using the '-echo' option to system().
  %
  % if buildOpts.RTWVerbose
  %   feval(dh{:}, result);
  % end

  % Status return isn't well defined so check strings.
  if ispc && (strcmp(buildOpts.codeFormat, 'S-Function') || ...
             strcmp(buildOpts.codeFormat, 'Accelerator_S-Function'))
    % mex returns ok status to make, so need to check stdout
    if strcmp(buildOpts.codeFormat, 'S-Function')
      mexFName = ['..', filesep, modelName, '_sf.', mexext];
    else
      mexFName = ['..', filesep, modelName, '_acc.', mexext];
    end
    mexError = ['Error: Link of ''', mexFName, ''' failed.'];
    if ~isempty(findstr(mexError, result)) || ...
          status || isempty(findstr(buildSuccess,result))
      if ~buildOpts.RTWVerbose && ~makefileVerboseOverride
        feval(dh{:},result);
      end
      if exist(mexFName,'file')
        rtw_delete_file(mexFName);
      end
      error(buildError);
    end
  elseif status || isempty(findstr(buildSuccess,result))
    if ~status && isempty(findstr(buildSuccess,result))
      buildError = ['### Unable to find build success string: "' buildSuccess '" in build log.'];
    end
    if ~buildOpts.RTWVerbose && ~makefileVerboseOverride
      feval(dh{:},result);
    end
    if ispc
      noCmdMsg{1} = ['internal or external command, operable program ', ...
                     'or batch file']; %WinNT makecmd not found
      noCmdMsg{2} = 'The system cannot find the path specified';
      % noCmdMsg{2} - WinNT using %makepathpath%\bin\makecmd
      noCmdMsg{3} = 'Bad command or file name';  % Win95 any command

      for i=1:length(noCmdMsg)
        msg = noCmdMsg{i};
        if length(result) > length(msg) && ~isempty(findstr(result,msg))

          buildError = ['It appears that the build process was unable to ',...
                        'locate some utility (e.g. make, ' ...
                        sprintf('\n'),...
                        'compiler, linker, etc.). ' ...
                        'Please verify your path and tool environment '...
                        'variables ',...
                        sprintf('\n'),...
                        'are correct. You should be able to execute the ',...
                        'make command: ', ...
                        sprintf('\n   '), ...
                        makeCmd, ...
                        sprintf('\n'), ...
                        'at an MS DOS Command Prompt in ',...
                        'the directory:', ...
                        sprintf('\n   '), ...
                        pwd, ...
                        sprintf('\n'), ...
                        'Currently, this generates the following error: ', ...
                        sprintf('\n'), ...
                        result];
          break
        end
      end
    end
    error(buildError);
  end

  %---------------------------------------------------%
  % Invoke make to download image to target if needed %
  %---------------------------------------------------%
  if isempty(download)
    download = GetMacro(tmfContents, 'DOWNLOAD', templateMakefile,0);
    if isempty(download)
      download=0;
    else
      download=strcmpi(download,'yes') || strcmp(download,'1');
    end;
  end

  if download
    downloadSuccess = GetMacro(tmfContents,'DOWNLOAD_SUCCESS', ...
                               templateMakefile,0);
    if isempty(downloadSuccess)
      downloadSuccess = '### Downloaded';
    elseif downloadSuccess(1) == '['
      downloadSuccess = eval(downloadSuccess);
    end

    downloadError = GetMacro(tmfContents,'DOWNLOAD_ERROR',...
                             templateMakefile,0);
    if isempty(downloadError)
      downloadError = ['Error(s) encountered while downloading model "', ...
                       modelName, '"'];
    elseif downloadError(1) == '['
      downloadError = eval(downloadError);
    end

    makeCmd = [make, ' -f ' makefileName, ' download ',buildArgs];
    feval(dh{:},['### Downloading ',modelName,': ',makeCmd]);
    if buildOpts.RTWVerbose || makefileVerboseOverride
      echoArg = {'-echo'};
    else
      echoArg = {};
    end
    if isunix
      % avoid returning result as it will block on all child processes
      status = unix(makeCmd, echoArg{:});
      if status ~= 0
        error(downloadError);
      end
    elseif ispc
      [aDummyStatus,result]=dos(makeCmd, echoArg{:});
      % On pc, status isn't well defined, thus search result string.
      if isempty(findstr(downloadSuccess,result))
        if ~buildOpts.RTWVerbose && ~makefileVerboseOverride
          feval(dh{:},result);
        end
        error(downloadError);
      end
    else
      error('Fatal error, unhandled system type');
    end
  end

  %-------------------------------------------------------%
  % Handle additional flags for RTW S-Function codeFormat %
  %-------------------------------------------------------%
  bCreateSFunctionModel = 0;
  if strcmp(buildOpts.codeFormat, 'S-Function')
    % Get create new model flag from makefile
    createmodel = GetMacro(tmfContents, 'CREATEMODEL', templateMakefile,0);
    if isempty(createmodel)
      bCreateSFunctionModel = 0;
    else
      bCreateSFunctionModel = strcmp(createmodel,'1');
    end
  elseif strcmp(buildOpts.codeFormat,'Embedded-C')
    args = get_param(modelName,'RTWBuildArgs');
    if ~isempty(findstr(args, 'GENERATE_ERT_S_FUNCTION=1'))
      bCreateSFunctionModel = 1;
    end
  end

  if bCreateSFunctionModel
    % Get 'use parameter values' flag from makefile
    useparamvalues = GetMacro(tmfContents, 'USEPARAMVALUES', ...
                              templateMakefile, 0);
    if isempty(useparamvalues )
      useparamvalues = 0;
    else
      useparamvalues = strcmp(useparamvalues,'1');
    end
    newmodelname = newmodelfromold(modelName);
    newblockname = [newmodelname,'/RTW S-Function'];
    currdir = pwd;
    cd('..');
    rtwlib([],[],[],'load');
    add_block('rtwlib/S-Function Target/RTW S-Function', newblockname);
    SetupSfcnTunableParameters(modelName, useparamvalues, newblockname, ...
                               currdir);
    SetupSfcnPortLabels(modelName, newblockname);
    set_param(newblockname, 'EnableBusSupport', 'on');
    open_system(newmodelname);
    cd(currdir);
  end
end

%end rtw_c


%-----------------%
% Local functions %
%-----------------%


function loc_refresh_codebrowser(modelName, anchorDir)
  activeCodeObj = getActiveCode(modelName);
  activeCodeObj.refresh(anchorDir);

% Function: GetMacro ==========================================================
% Abstract:
%     Look for an expression of the form "name = value" within the supplied
%     string and, if found, returns the specified value. If the macro is
%     defined more than once, the first definition is supplied. If the
%     macro is not found, an error is issued.
%
function value = GetMacro(string, name, file, mustBePreset)
  value = []; % assume not present

  tmpStr = string;
  i      = findstr(tmpStr, name);
  while ~isempty(i)
    i = i(1) + length(name);
    while isspace(tmpStr(i))
      i = i + 1;
    end;
    if tmpStr(i) == '='
      i       = i + 1;
      lf      = 10;
      cr      = 13;
      while isspace(tmpStr(i)) && tmpStr(i) ~= cr && tmpStr(i) ~= lf
        i = i + 1;
      end;
      j = i;
      while tmpStr(j) ~= lf && tmpStr(j) ~= cr
        j = j + 1;
      end
      j = j-1;
      value = deblank(tmpStr(i:j));
      return;
    end
    tmpStr = tmpStr(i:end);
    i      = findstr(tmpStr,name);
  end

  if isempty(value) && mustBePreset
    error(['"',name,' = value" macro not defined in template makefile ', ...
           file]);
  end
%end GetMacro



% Function: ParseBuildArgs =====================================================
% Abstract:
%     Remove any ITEM=value from buildArgs and return the desired
%     value.  The parsedValue must be one of: ITEM=yes, ITEM=no, ITEM=1,
%     ITEM=0. The parsedValue returned will be the numeric value 1, 0, or empty.
%
function [parsedValue,buildArgsOut] = ParseBuildArgs(buildArgsIn,item)

  [value,buildArgsOut]=parsestrforvar(buildArgsIn,item);
  if isempty(value)
    parsedValue = [];
  else
    switch value
     case {'yes', '1'}
      parsedValue = 1;
     case {'no', '0'}
      parsedValue = 0;
     otherwise
      error(['Invalid make argument specified, ', item(1:end-1) ...
             ' must be one of yes, no, 1, 0']);
    end
  end

%endfunction %% ParseBuildArgs


% Function: SetupSfcnTunableParameters =========================================
% Abstract:
%      The global structure rtwsfcn_ModelName contains the tunable
%      parameter names and values.  Setup the s-function block to
%      have these parameters and setup the mask to show them.
%      Note: the global variable is created by tlc code during code generation.
%
function SetupSfcnTunableParameters(modelName,useparamvalues,block,currdir)
  rtwsfcnStruct = ['rtwsfcn_', modelName];
  sfcnName = [modelName, '_sf'];
  
  % Check the original setup of the RTW S-Function.
  maskVariables = get_param(block,'maskvariables');
  if isempty(maskVariables)
    maskValues = {};
    origNumVars = 0;
  else
    expectedVars = 'rtw_sf_name=&1;showVar=@2;';
    if ~isequal(maskVariables, expectedVars)
      errTxt = ['Assert: Error in block ''%s''\n', ...
                'Unexpected mask variables in RTW S-Function'];
      error(sprintf(errTxt, block));
    end

    % Initialize local variables for existing mask parameters.
    maskPrompts = get_param(block, 'maskprompts');
    maskValues = {sfcnName; 'off'};
    origNumVars = 2;
  end
  
  if evalin('base',['exist(''', rtwsfcnStruct,''')']) == 1
    eval(['global ', rtwsfcnStruct]); rtwSfcnStr = eval(rtwsfcnStruct);
    
    for idx = 1:length(rtwSfcnStr)
      maskVarIdx     = idx + origNumVars;
      maskPromptName = [rtwSfcnStr(idx).Name, ':'];
      maskVarName    = sprintf('sfcnParam%d', idx);
      if (useparamvalues || isempty(rtwSfcnStr(idx).NameStr))
        % NOTE: In some cases we can not reliably use the parameter in the
        % base workspace.  In these cases, the TLC code leave the NameStr
        % empty so we will need to use the ValueStr instead.
        maskValue = rtwSfcnStr(idx).ValueStr;
      else
        % Use the parameter from the base workspace (if available)
        maskValue = rtwSfcnStr(idx).NameStr;
      end

      if idx == 1
        paramStr = maskVarName;
      else
        paramStr = [paramStr, ', ', maskVarName];
      end
      maskPrompts{maskVarIdx,1} = maskPromptName;
      maskValues {maskVarIdx,1} = maskValue;
      maskVariables = [maskVariables, ...
                       maskVarName, '=@', num2str(maskVarIdx), ';'];
    end
    evalin('base',['clear global ', rtwsfcnStruct]);
    set_param(block,'parameters',    paramStr, ...
                    'maskprompts',   maskPrompts, ...
                    'maskvariables', maskVariables, ...
                    'maskvalues',    maskValues, ...
                    'FunctionName',  sfcnName);
    if(length(maskPrompts)>12)
      AddParamDispCntrlBttn(block)
    end
  else
    set_param(block,'maskvalues', maskValues, ...
                    'FunctionName', sfcnName);
  end
  
  % Warning for excessively long maskValueString
  maskValueStr = get_param(block, 'MaskValueString');
  whosResult   = whos('maskValueStr');
  if (whosResult.bytes > 65534)
    warnTxt = ...
        ['The MaskValueString of ''%s'' uses %d bytes of memory (>64K). ', ...
         'This block can be used in simulation but the MaskValueString ', ...
         'will not be reloaded correctly if saved in its current form. ', ...
         'To enable saving and reloading, reduce the number of characters ', ...
         'entered into the block''s mask parameter fields.'];
    warning(sprintf(warnTxt, block, whosResult.bytes));
  end
%endfunction SetupSfcnTunableParameters


% Function: AddParamDispCntrlBttn(block)===============
% Abstract:
%     This function add an popup parameter to control
%     mask parameter display
%
function AddParamDispCntrlBttn(block)

  maskPrompts     = get_param(block,'maskprompts');
  maskVariables   = get_param(block,'maskvariables');
  maskStyles      = get_param(block,'maskstyles');
  maskCallbacks   = get_param(block,'maskcallbacks');
  maskValues      = get_param(block,'maskvalues');

  Num_param       = length(maskPrompts);
  Num_sfun_param  = Num_param-2;
  Num_prm_on1page =  10;

  popup_str='popup(';
  i=0;
  while Num_sfun_param-i*Num_prm_on1page>Num_prm_on1page
      popup_str=[popup_str,'[',...
                 num2str(1+i*Num_prm_on1page),...
                 '..', num2str((i+1)*Num_prm_on1page),...
                       ']|'];
      i=i+1;
  end
  popup_str=[popup_str,'[',...
             num2str(1+i*Num_prm_on1page),'..',num2str(Num_sfun_param),...
             '])'];

  % insert the disp cntrl bttn after 'Generated sfun name'
  % and 'Show model List'
  maskVariables =[maskVariables,';'];
  for j=3:Num_param
    i=Num_param-j+3;
    maskPrompts{  i+1,:}=maskPrompts{  i,:};
    maskStyles{   i+1,:}=maskStyles{   i,:};
    maskCallbacks{i+1,:}=maskCallbacks{i,:};
    maskValues{   i+1,:}=maskValues{   i,:};
    s2=['=@',num2str(i),';'];
    s3=['=@',num2str(i+1),';'];
    maskVariables=strrep(maskVariables,s2,s3);
  end

  str_ind=strfind(maskVariables,'=@2;');
  s1=maskVariables(1:str_ind+3);
  s2='prm_to_disp=@3; ';
  s1=strcat(s1,s2);
  s3=maskVariables(str_ind+4:end-1);
  maskVariables=strcat(s1,s3);

  maskStyles{   3,:}=popup_str;
  maskPrompts{  3,:}='Display S-function Parameters:';
  maskCallbacks{3,:}='slmaskprmdispcntrl(gcbh)';
  maskValues{   3,:}='[1..10]';

  set_param(block,'maskprompts',   maskPrompts, ...
		  'maskvariables', maskVariables, ...
		  'maskstyles',    maskStyles, ...
                  'maskcallbacks', maskCallbacks,...
                  'maskvalues',maskValues);

%End of AddParamDispBttn(block)==================

% Function: SetupSfcnPortLabels ===============================================
% Abstract:
%      This function sets the port labels of a generated S-function. The port
%      names are set to the root in- and outport names of the source model.
%
function SetupSfcnPortLabels(modelName, newblockname)
  try
    inportBlks = find_system(modelName, 'SearchDepth',1, 'BlockType', 'Inport');
    outportBlks = find_system(modelName, 'SearchDepth',1, 'BlockType', ...
                              'Outport');
    inportBlkNames = get_param(inportBlks, 'Name');
    outportBlkNames = get_param(outportBlks, 'Name');

    inportLabels = '';
    newline = sprintf('\n');
    for i = 1:length(inportBlkNames)
      thisLabel = strrep(inportBlkNames{i},newline,' ');
      inportLabels = sprintf('%s\nport_label(''input'',%d,''%s'');', ...
                             inportLabels,i,thisLabel);
    end
    outportLabels = '';
    for i = 1:length(outportBlkNames)
      thisLabel = strrep(outportBlkNames{i},newline,' ');
      outportLabels = sprintf('%s\nport_label(''output'',%d,''%s'');', ...
                              outportLabels,i,thisLabel);
    end

    % Create MaskDisplay
    maskdisp = sprintf('%s%s',inportLabels,outportLabels);
    set_param(newblockname,'MaskDisplay',maskdisp);

    % Increase size properly
    oldPos = get_param(newblockname, 'Position');
    newSize = (max(length(inportBlkNames), length(outportBlkNames)) * 15) + 10;
    set_param(newblockname, 'Position', [oldPos(1:3), oldPos(2)+newSize]);
  end
%endfunction SetupSfcnPortLabels

%Function: ExpandNestedRule ===================================================
%
%
function tmfContents = ExpandNestedRule(tmfContents, ...
                                        libraries, ...
                                        locations, ...
                                        startToken, endToken, ...
                                        libToken, locToken, ...
                                        modules, ...
                                        mStartToken, mEndToken, mToken, makefileFileSeparator)

  lengthStartToken = length(startToken);
  lengthEndToken   = length(endToken);

  startPos = findstr(tmfContents,startToken);
  endPos   = findstr(tmfContents,endToken);

  numOfStart = length(startPos);
  numOfEnd   = length(endPos);
  % check for syntax error
  if numOfStart ~= numOfEnd
    if numOfStart > numOfEnd
      errMsg = sprintf(['TMF SYNTAX ERROR: missing %s token ' ...
                        'for make-rule expansion.'], endToken);
    else
      errMsg = sprintf(['TMF SYNTAX ERROR: missing %s token ', ...
                        'for make-rule expansion.'], startToken);
    end
    error(errMsg)
  end

  for i=1:numOfStart
    expandedRule = '';
    if startPos(i) > endPos(i)
      errMsg = sprintf(['TMF SYNTAX ERROR: found %s before ', ...
                        'related %s token.'], endToken, startToken);
      error(errMsg);
    end

    tmfRule = tmfContents(startPos(i)+lengthStartToken:endPos(i)-1);

    for j=1:length(libraries)
      rule = char(strrep(tmfRule, libToken, libraries(j)));
      location = strrep(locations(j), matlabroot, '$(MATLAB_ROOT)');
		if makefileFileSeparator == '/'
			% Force unix stype paths compatible with gmake
			location = strrep(location,'\','/');
		end
      rule = char(strrep(rule, locToken, location));
      rule = ExpandRule(rule, modules{j}, mStartToken, mEndToken, mToken);
      expandedRule = [expandedRule, rule];
    end

    tmpStartPos = startPos(i)-1;
    tmpEndPos   = endPos(i)+lengthEndToken;
    tmfContents = [ tmfContents(1:tmpStartPos), ...
                    expandedRule, ...
                    tmfContents(tmpEndPos:end) ];
    expRuleOffset = length(expandedRule) - tmpEndPos + tmpStartPos + 1;
    for j=i:numOfStart
      startPos(j) = startPos(j) + expRuleOffset;
      endPos(j)   = endPos(j)   + expRuleOffset;
    end
  end


% Function: ExpandRule ========================================================
% Abstract:
%      This function expands the text from tmfContents between start- and
%      end-token for all directories and replaces the dirToken with the
%      current directory.
%
function tmfContents = ExpandRule(tmfContents, directories, ...
                                  startToken, endToken, dirToken)

  lengthStartToken = length(startToken);
  lengthEndToken   = length(endToken);

  startPos = findstr(tmfContents,startToken);
  endPos   = findstr(tmfContents,endToken);

  numOfStart = length(startPos);
  numOfEnd   = length(endPos);
  % check for syntax error
  if numOfStart ~= numOfEnd
    if numOfStart > numOfEnd
      errMsg = sprintf(['TMF SYNTAX ERROR: missing %s token ' ...
                        'for make-rule expansion.'], endToken);
    else
      errMsg = sprintf(['TMF SYNTAX ERROR: missing %s token ', ...
                        'for make-rule expansion.'], startToken);
    end
    error(errMsg)
  end

  for i=1:numOfStart
    expandedRule = '';
    if startPos(i) > endPos(i)
      errMsg = sprintf(['TMF SYNTAX ERROR: found %s before ', ...
                        'related %s token.'], endToken, startToken);
      error(errMsg);
    end

    tmfRule = tmfContents(startPos(i)+lengthStartToken:endPos(i)-1);

    for j=1:length(directories)
      relativeDirectory  = strrep(directories{j}, matlabroot, '$(MATLAB_ROOT)');
      expandedRule = [expandedRule, ...
                      char(strrep(tmfRule, dirToken, ...
                                  quoteIfNeeded(relativeDirectory,'"')))];
    end

    tmpStartPos = startPos(i)-1;
    tmpEndPos   = endPos(i)+lengthEndToken;
    tmfContents = [ tmfContents(1:tmpStartPos), ...
                    expandedRule, ...
                    tmfContents(tmpEndPos:end) ];
    expRuleOffset = length(expandedRule) - tmpEndPos + tmpStartPos + 1;
    for j=i:numOfStart
      startPos(j) = startPos(j) + expRuleOffset;
      endPos(j)   = endPos(j)   + expRuleOffset;
    end
  end

%endfunction


function y = CurlyBracketOperator(varargin)

  y = varargin;

function result = change_file_ext(filenames)

result = filenames;

if length(filenames) == 0
	return;
end

if filenames(length(filenames)) ~= ' '
	filenames = [filenames ' '];
end

filenames = strrep(filenames, '.c ', '.obj ');
filenames = strrep(filenames, '.C ', '.obj ');
filenames = strrep(filenames, '.cpp ', '.obj ');
filenames = strrep(filenames, '.CPP ', '.obj ');

result = filenames;

% We assume relativePath in format of "../.."
function [simplePath] = loc_calculate_path(inputPath,relativePath)
simplePath = inputPath;
% adding inputPath trailing '/'
if ~strcmp(inputPath(end),filesep)
    inputPath(end+1) = filesep;
end
tokens = strfind(inputPath,filesep);
layers = length(strfind(relativePath,'..'));
if (layers > 0) && (length(tokens) > layers)
   simplePath = simplePath(1:tokens(end-layers));
   % remove trailing '/' unless it's the only character
   if ~strcmp(simplePath, filesep)
       simplePath(end) = '';
   end
end


%------------------------------------------------------------------------------
function extraTokenReplacements = LocGetExtraToken(h,infoStruct)
  computer_type = computer;
  anchorDir = h.StartDirToRestore;

  extraTokenReplacements{1} = ['MODELLIB=',infoStruct.modelLibName];

  relativePathToAnchor = infoStruct.relativePathToAnchor;

  if ~rtw_gen_shared_utils(h.ModelName)
    % When build is unrelated to modelreference, slprj related variables are empty.
    SHARED_SRC_str = '';
    SHARED_LIB_name = '';
    sharedSourcesDirRel = '';
    sharedBinaryDirRel = '';
  else    
    sharedSourcesDirRel = fullfile(relativePathToAnchor,infoStruct.sharedSourcesDir);
    sharedBinaryDirRel  = fullfile(relativePathToAnchor,infoStruct.sharedBinaryDir);
    
    if isempty(dir(fullfile(anchorDir,infoStruct.sharedSourcesDir, '*.c')))
      % prevent nmake rules from being broken when target is empty
      SHARED_SRC_str = '';
      SHARED_LIB_name = '';
    else
      SHARED_SRC_str = fullfile(sharedSourcesDirRel, '*.c');
      SHARED_LIB_name = fullfile(sharedSourcesDirRel, 'rtwshared.lib');
    end
  end
  
  if(ispc)
    isVc = ~isempty(strfind(h.TemplateMakefile,'_vc.tmf'));
    isLcc= ~isempty(strfind(h.TemplateMakefile,'_lcc.tmf'));
    if (isLcc)
      extraTokenReplacements{end+1} = ['SHARED_SRC=', strrep(SHARED_SRC_str,'\','/')];
      extraTokenReplacements{end+1} = ['SHARED_SRC_DIR=',strrep(sharedSourcesDirRel,'\','/')];
      extraTokenReplacements{end+1} = ['SHARED_BIN_DIR=',strrep(sharedBinaryDirRel,'\','/')];
      extraTokenReplacements{end+1} = ['MODELREF_LINK_LIBS=', ...
                          sprintf('%s ',infoStruct.linkLibraries{:})];
      extraTokenReplacements{end+1} = ['SHARED_LIB=', SHARED_LIB_name];     
      
    else
      extraTokenReplacements{end+1} = ['SHARED_SRC=', SHARED_SRC_str];
      extraTokenReplacements{end+1} = ['SHARED_SRC_DIR=',sharedSourcesDirRel];
      extraTokenReplacements{end+1} = ['SHARED_BIN_DIR=',sharedBinaryDirRel];
      extraTokenReplacements{end+1} = ['MODELREF_LINK_LIBS=', ...
                          sprintf('%s ',infoStruct.linkLibraries{:})];
      extraTokenReplacements{end+1} = ['SHARED_LIB=', ...
                          SHARED_LIB_name];      
    end
  end

  if(isunix)
    extraTokenReplacements{end+1} = ['SHARED_SRC=', SHARED_SRC_str];
    extraTokenReplacements{end+1} = ['SHARED_SRC_DIR=',sharedSourcesDirRel];
    extraTokenReplacements{end+1} = ['SHARED_BIN_DIR=',sharedBinaryDirRel];
    if isempty(deblank(sprintf('%s ',infoStruct.linkLibraries{:})))
      pathString = '';
    else
      if strcmpi(computer_type, 'MAC')
        % on MAC we don't copy the linkLibraries, instead we include full
        % path for them. This is to address a MAC specific lib
        % out-of-date issue.
        linkLibFullPathsRel = infoStruct.linkLibrariesFullPaths;
        for i=1:length(linkLibFullPathsRel)
          linkLibFullPathsRel{i} = fullfile(relativePathToAnchor, ...
                                            linkLibFullPathsRel{i});
        end
        pathString = sprintf('%s ',linkLibFullPathsRel{:});
      else
        pathString = sprintf('%s ',infoStruct.linkLibraries{:});
      end
    end
    extraTokenReplacements{end+1} = ['MODELREF_LINK_LIBS=',pathString];
    extraTokenReplacements{end+1} = ['SHARED_LIB=', SHARED_LIB_name];
  end

  if ~isempty(infoStruct.linkLibraries) && ~strcmpi(computer_type, 'MAC') && ~h.BuildOpts.generateCodeOnly
    for i=1:length(infoStruct.linkLibraries)
      rtw_copy_file(fullfile(infoStruct.relativePathToAnchor,infoStruct.linkLibrariesFullPaths{i}),...
                    '.');
    end
  end

  extraTokenReplacements{end+1} = ['RELATIVE_PATH_TO_ANCHOR=', relativePathToAnchor];
  extraTokenReplacements{end+1} = ['MODELREF_TARGET_TYPE=' h.MdlRefBuildArgs.ModelReferenceTargetType];

%endfunction

%[eof] rtw_c.m
