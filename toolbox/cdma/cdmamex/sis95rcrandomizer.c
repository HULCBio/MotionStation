/*	  
 *  Module Name: sis95rcrandomizer.c
 *
 *  Description:
 *      Generates a masking pattern of '0' and '1' s that randomly mask out  
 *      the redundant data generated by the code repetition. The masking  
 *      pattern is determined by the data rate of the frame and by a block  
 *      of 14 bits taken from the long code. 
 *      These 14 bits are the last ones of the long code used for spreading in 
 *      the previous to the last power control group of the previous frame.
 * 
 *  Inputs:
 *      Data Rate
 *          Integer scalar representing the data rate index (0 for full-rate, 
 *          1 for half-rate, 2 for 1/8-rate and 3 for 1/16-rate).
 *      LC In
 *          Binary Vector, containing the Long Code that must be used with  
 *          the data frame being processed.
 * 
 *  Outputs:
 *      Gated LC Out
 *          Binary vector representing the switch which indicates whether 
 *          to transmit or not.
 * 
 *  Parameters:
 *      Channel Type
 *          Logical Channel Type (ACCESS/TRAFFIC): 1 for ACCESS and 2 for 
 *          TRAFFIC.
 *      Randomizer Initial State
 *          Initial value of the randomizer's state (15 x 1 binary vector),  
 *          that is updated by the incoming long code, and specifies the  
 *          location of gated-off power-groups in the frame.
 *
 *  Copyright 1999-2002 The MathWorks, Inc. and ALGOREX, Inc.
 *  $Revision: 1.14.2.1 $  $Date: 2004/04/12 22:59:54 $
 */
#define S_FUNCTION_NAME sis95rcrandomizer
#define S_FUNCTION_LEVEL 2

#include "cdma_frm.h"

#define NUM_ARGS        2
#define CH_TYPE_ARG     ssGetSFcnParam(S,0)
#define INIT_LOC_ARG    ssGetSFcnParam(S,1)

#define DYNAMIC_SAMPLE_TIME     -1
#define NUM_PWR_GRP_CHIPS       384
#define NUM_PWR_GRPS            16
#define NUM_REP_CHIP            4
#define LC_LOC_IND_START        (384*4*15 - 14)
#define TOTAL_PORTS             3

enum {SYNC=0, PAGING};
enum {ACCESS=1, TRAFFIC};

enum {RATE_96=0, RATE_48, RATE_24, RATE_12};
enum {RATE_144=0, RATE_72, RATE_36, RATE_18};

#define	NUMSYMBIN   params->numSymbIn
#define GATE        params->pGate   
#define LCST        params->pLCSt   
#define COUNTER     params->counter  
#define RATE        params->rate

typedef struct rlRand{
    
    int numSymbIn;
    int *pGate;
    int *pLCSt;
    int counter;
    int rate;
    
}  rl_Rand;

#ifdef MATLAB_MEX_FILE
#define MDL_CHECK_PARAMETERS
static void mdlCheckParameters(SimStruct *S) {
    const char *msg = NULL;
    
    if ((mxGetM(CH_TYPE_ARG)*mxGetN(CH_TYPE_ARG) != 1) ||
        ((mxGetPr(CH_TYPE_ARG)[0] != (real_T) 1.0) &&
        (mxGetPr(CH_TYPE_ARG)[0] != (real_T) 2.0))) {
        msg = "Channel type must be 1 or 2";
        goto ERROR_EXIT;
    }
    
    if ((mxGetM(INIT_LOC_ARG)*mxGetN(INIT_LOC_ARG) != 0) &&
        (mxGetM(INIT_LOC_ARG)*mxGetN(INIT_LOC_ARG) != 14)) {
        msg = "Randomizer initial state must be a 14-element vector or empty";
        goto ERROR_EXIT;
    }
    
ERROR_EXIT:
    
    if (msg != NULL) {
        ssSetErrorStatus(S,msg);
		return;
    }
}
#endif


static void mdlInitializeSizes(SimStruct *S)
{
    ssSetNumSFcnParams(S, NUM_ARGS);
    
#if defined(MATLAB_MEX_FILE)
    if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {
        mdlCheckParameters(S);
        if (ssGetErrorStatus(S) != NULL) {
            return;
        }
    } else
        return; /* Simulink will report a parameter mismatch error */
#endif
    ssSetSFcnParamNotTunable(S, 0);
    
    if (!ssSetNumInputPorts(S, 2)) return;
    /* Rate input */
    ssSetInputPortVectorDimension(   S, 0, 1);
    ssSetInputPortFrameData(         S, 0, FRAME_NO);
	ssSetInputPortDirectFeedThrough( S, 0, 1);

    /* Data input */
    if (!ssSetInputPortDimensionInfo(S, 1, DYNAMIC_DIMENSION)) return;
    ssSetInputPortFrameData(         S, 1, FRAME_INHERITED);
	ssSetInputPortDirectFeedThrough( S, 1, 1);

    /* Output */
	if (!ssSetNumOutputPorts(S,1)) return;
    if (!ssSetOutputPortDimensionInfo(S, 0, DYNAMIC_DIMENSION)) return;
    ssSetOutputPortFrameData(         S, 0, FRAME_INHERITED);

    ssSetNumContStates(    S, 0);   /* number of continuous states           */
    ssSetNumDiscStates(    S, 0);   /* number of discrete states             */
    ssSetNumSampleTimes(   S, 1);   /* number of sample times                */
    ssSetNumRWork(         S, 0);   /* number of real work vector elements   */
    ssSetNumIWork(         S, 0);   /* number of integer work vector elements*/
    ssSetNumPWork(         S, 1);   /* number of pointer work vector elements*/
    ssSetNumModes(         S, 0);   /* number of mode work vector elements   */
    ssSetNumNonsampledZCs( S, 0);   /* number of nonsampled zero crossings   */
    ssSetOptions(          S, SS_OPTION_EXCEPTION_FREE_CODE);
}

/* Function: detAllPortWidths
 * Purpose: Determine the widths for the input and output ports based 
 *          on the parameters passed in. The widths are stored in an int
 *          array with first the input widths and then the outputs.
 */
void detAllPortWidths(SimStruct *S, int *widths)
{
    int size = ssGetInputPortWidth(S, 1);
    
    widths[0]  = 1;
    widths[1]  = size;
    widths[2]  = size;
}

#if defined(MATLAB_MEX_FILE)
#define MDL_SET_INPUT_PORT_FRAME_DATA
static void mdlSetInputPortFrameData(SimStruct *S, int_T portIdx,
                                         Frame_T frameData)
{
    if (portIdx == 1){
        ssSetInputPortFrameData(S, 1, frameData);
	    ssSetOutputPortFrameData(S, 0, frameData);
    }
}

#define MDL_SET_INPUT_PORT_DIMENSION_INFO
static void mdlSetInputPortDimensionInfo(SimStruct *S, int_T port,
                                      const DimsInfo_T *dimsInfo)
{	
    int widths[TOTAL_PORTS], size;
    
    /* set the 2nd input port only */
    if (port == 1){
        if(!ssSetInputPortDimensionInfo(S, port, dimsInfo)) return;
        
        size = ssGetInputPortWidth(S, 1);
        if ((384*64)%size !=0){
            ssSetErrorStatus(S,
              "Number of input symbols must be positive and must divide 384*64");
            return;
        }
    }
    
    detAllPortWidths(S, widths);
    
    /* Set all port dimensions */
    if(!cdmaSetAllPortsDimensions(S, port, dimsInfo, true,
                                  widths,           /* Input widths */
                                  2,                /* Last inport to set */         
                                  &widths[2],       /* Output widths */
                                  1,                /* Last outport to set */
                                  1)) return;       /* Skip the first inport */
}

#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
static void mdlSetOutputPortDimensionInfo(SimStruct *S, int_T port,
                                          const DimsInfo_T *dimsInfo)
{
    int widths[TOTAL_PORTS];
    detAllPortWidths(S, widths);
    
    /* Set all port dimensions */
    if(!cdmaSetAllPortsDimensions(S, port, dimsInfo, false,
                                  widths,           /* Input widths */
                                  2,                /* Last inport to set */         
                                  &widths[2],       /* Output widths */
                                  1,                /* Last outport to set */
                                  1)) return;       /* Skip the first inport */
}

#define MDL_SET_DEFAULT_PORT_DIMENSION_INFO
static void mdlSetDefaultPortDimensionInfo(SimStruct *S)
{
    int port = 1;  /* select the second port */
	int widths[TOTAL_PORTS]; 
    
    /* initialize a dynamically-dimensioned DimsInfo_T */
    DECL_AND_INIT_DIMSINFO(dInfo); 

    detAllPortWidths(S, widths);

    /* select valid inport dimensions, sample-based mode */
    dInfo.width     = widths[port];
    dInfo.numDims   = 1;
    dInfo.dims      = &widths[port];

    /* call the input function */
    mdlSetInputPortDimensionInfo(S, port, &dInfo);
}
#endif

static void mdlInitializeSampleTimes(SimStruct *S)
{
    ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME);
    ssSetOffsetTime(S, 0, 0.0);
}

#define MDL_INITIALIZE_CONDITIONS   /* Change to #undef to remove function */
#if defined(MDL_INITIALIZE_CONDITIONS)
static void mdlInitializeConditions(SimStruct *S)
{
    rl_Rand *params;
    real_T *pInitLCSt;
    int i, n;
    
    params    = (rl_Rand *) calloc(1, sizeof(rl_Rand));
    GATE      = (int *) calloc(NUM_PWR_GRPS, sizeof(int));
    LCST      = (int *) calloc(14, sizeof(int));
    NUMSYMBIN = ssGetInputPortWidth(S,1);
    COUNTER   = 0;
    
    n = NUM_PWR_GRP_CHIPS * NUM_PWR_GRPS * NUM_REP_CHIP;
    n -= NUMSYMBIN * (n / NUMSYMBIN);
    
#ifdef MATLAB_MEX_FILE
    if ((params == NULL) || (GATE==NULL) || (LCST==NULL)){
        ssSetErrorStatus(S,"Not enough memory to allocate for work vectors");
        return;
    }
    if ((NUMSYMBIN < 1) || n){
        ssSetErrorStatus(S, "Number of input symbols must be positive and must divide 384*64");
        return;
    }
#endif
    
    if ((mxGetM(INIT_LOC_ARG)*mxGetN(INIT_LOC_ARG)) == 0){
        for (i=0 ; i<14; i++)
            LCST[i] = 0;
    } else{
        pInitLCSt = mxGetPr(INIT_LOC_ARG);
        for (i=0 ; i<14; i++)
            LCST[i] = (pInitLCSt[i] != 0.0);
    }
    
    ssSetPWorkValue(S, 0, params);
    
}

#endif	/* MDL_INITIALIZE_CONDITIONS */   

static void mdlOutputs(SimStruct *S, int_T tid)
{
    int rlError, chType;
    rl_Rand *params;
    const char *msg = NULL;
    int j, k=0, last, first, error=0, pwrGpInd;
    
    real_T *randOut             =  ssGetOutputPortRealSignal(S,0);
    InputRealPtrsType ppLcIn    =  ssGetInputPortRealSignalPtrs(S, 1);
    
    params = (rl_Rand *) ssGetPWorkValue(S, 0);
    RATE   = (int) *( *(ssGetInputPortRealSignalPtrs( S, 0)));
    chType = (int) mxGetScalar(CH_TYPE_ARG);
    
    switch(chType){
    case ACCESS:
        if (RATE!=RATE_48){
            msg = "Data rate for Access channel must be half rate";
            goto ERROR_EXIT;
        }
        break;
    case TRAFFIC:
        if ((RATE!=RATE_96) && (RATE!=RATE_48) && (RATE!=RATE_24) && (RATE!=RATE_12)){
            msg = "Data rate for Traffic channel is incorrect";
            goto ERROR_EXIT;
        }
        
        break;
    }
    
    if (chType == ACCESS)  /* No gating-off */
        RATE = RATE_96;
    
     if (COUNTER == 0){
        
        for (j=0; j<NUM_PWR_GRPS; j++)
            GATE[j] = 0;
        
        switch (RATE){
        case RATE_48:
            for (j=0; j<(NUM_PWR_GRPS / 2); j++){
                pwrGpInd = 2*j + (int) LCST[j];
                GATE[pwrGpInd] = 1;
            }
            break;
            
        case RATE_24:
            for (j=0; j<(NUM_PWR_GRPS / 4); j++){
                pwrGpInd = (4*j + (int) LCST[j])     * (1 - (int) LCST[j + 8]) +
                    (4*j + 2 + (int) LCST[j]) * (int) LCST[j + 8];
                GATE[pwrGpInd] = 1;
            }
            break;
            
        case RATE_12:
            for (j=0; j<(NUM_PWR_GRPS / 8); j++){
                pwrGpInd = (8*j + (int) LCST[j])     * (1 - (int) LCST[2*j + 8]) * (1 - (int) LCST[j + 12]) +
                    (8*j + 2 + (int) LCST[j]) * (int) LCST[2*j + 8]       * (1 - (int) LCST[j + 12]) +
                    (8*j + 4 + (int) LCST[j]) * (1 - (int) LCST[2*j + 9]) * (int) LCST[j + 12] +
                    (8*j + 6 + (int) LCST[j]) * (int) LCST[2*j + 9]       * (int) LCST[j + 12];
                GATE[pwrGpInd] = 1;
            }
            break;
            
        default:
            for (j=0; j<NUM_PWR_GRPS; j++)
                GATE[j] = 1;                  
            break;
        }
    }
    
    if (((COUNTER + NUMSYMBIN) >= LC_LOC_IND_START) && (COUNTER < (LC_LOC_IND_START + 14))){
        
        
        last  = COUNTER + NUMSYMBIN - LC_LOC_IND_START;
        last  = (last < 13) ? last : 13;
        first = COUNTER - LC_LOC_IND_START;
        k     = (first > 0) ? 0 : -first;
        first = (first > 0) ? first : 0;
        for (j=first; j<last; j++)
            LCST[j+1] = (int) *ppLcIn[k++];
    }
    
    for (j=0; j<NUMSYMBIN; j++){
        k = (COUNTER + j) / (NUM_PWR_GRP_CHIPS * NUM_REP_CHIP);
        
        /* Collect data to check at end of loop if error in input data */
        error |= (int)(*ppLcIn[j]);
        randOut[j] = (real_T) GATE[k];
    }
    
    COUNTER += NUMSYMBIN;
    COUNTER %= NUM_PWR_GRP_CHIPS * NUM_PWR_GRPS * NUM_REP_CHIP;
    
    /* If error in input data then inform user */
    if ((error != 0) && (error != 1))
        msg = "Input must be a binary vector";
    
    
ERROR_EXIT:
#ifdef MATLAB_MEX_FILE
    if (msg != NULL) {
        ssSetErrorStatus(S,msg);
		return;
    }
#endif
    
}

static void mdlTerminate(SimStruct *S)
{
    rl_Rand *params = (rl_Rand *) ssGetPWorkValue(S, 0);
    free(GATE);
    free(LCST);
    free(params);
    
}

/*=============================*
* Required S-function trailer *
*=============================*/

#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
#include "simulink.c"      /* MEX-file interface mechanism */
#else
#include "cg_sfun.h"       /* Code generation registration function */
#endif
