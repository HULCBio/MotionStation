function [a,areavec]=areamat(Z,refvec,ellipsoid,units)
%AREAMAT Calculate geographic area of a regular data grid.
%
%   A = AREAMAT(Z,REFVEC) calculates the spherical surface area of the
%   regular data grid, Z.  Any entry of 1 contributes to the surface area
%   total.  The output, A, is the surface area fraction covered by the
%   nonzero entries in the input Z.  A binary matrix Z might be one
%   generated by a logical statement, such as Z = topo > 0.
%
%   A = AREAMAT(Z,REFVEC,ELLIPSOID) uses the input ELLIPSOID to describe
%   the sphere or ellipsoid.  The output, A, is in square units
%   corresponding to the units of ELLIPSOID(1).
%
%   [A,AREAVEC] = AREAMAT(...) returns the vector AREAVEC containing the
%   cellular area per row of the Z.  The surface area of any cell is
%   constant across a row of the input matrix Z.
%
%   See also AREAINT, AREAQUAD.

%   Copyright 1996-2003 The MathWorks, Inc.
%   Written by:  E. Brown, E. Byrns
%   $Revision: 1.9.4.2 $  $Date: 2003/12/13 02:50:07 $

checknargin(2,4,nargin,mfilename);
% Note: Argument 'units' is not used.

if nargin == 2
    ellipsoid = [];
    units = [];
elseif nargin == 3 && ischar(ellipsoid)
    units = ellipsoid;
    ellipsoid = [];
elseif nargin == 3 && ~ischar(ellipsoid)
    units = [];
end

%  Empty argument test
% 
% if isempty(units);
%     units = 'degrees';
% end

%  Test ellipsoid only if it has been supplied.  Otherwise, let areaquad
%  deal with default settings of the ellipsoid vector.

if ~isempty(ellipsoid)
    ellipsoid = checkellipsoid(ellipsoid,mfilename,'ELLIPSOID',3);
end

%  Ensure Z is binary

if any(nonzeros(Z) ~= 1)
    eid = sprintf('%s:%s:nonBinaryMap',getcomp,mfilename);
    error(eid,'%s','Input map must be binary (0''s and 1''s)');
end

checkrefvec(refvec,mfilename,'MAPLEGEND',2);

%  Convert the refvec to degrees.
%  In V1.0, only degrees are supported so this is not necessary.
%  Although the parsing still allows for degrees, reference to this option
%  has been removed from both the online help and the reference guide.

%if strcmp(units,'dms') | strcmp(units,'dm')
%   refvec(2:3) = angledim(refvec(2:3),units,'degrees');
%else
%   factor = angledim(1,units,'degrees');
%   refvec = refvec .* [1/factor  factor  factor];
%end

%  Get map limits and size of Z.

[lat,long]=limitm(Z,refvec);
[r,c]=size(Z);


% Each cell of Z is, in spherical geometry, the intersection
% of a lune with a zone.  Every cell in a given 1-cell-wide zone
% has equal area; areas of cells in a given 1-cell-wide lune
% decrease as the poles are approached.

% Define vector with one element for each row (zone) of Z
% and assign it the area for a cell at that latitude.  The resulting
% vector is a sort of 'reference lune'.

tops    = (lat(1)+(1:r)/refvec(1))';
bottoms = [lat(1);tops(1:r-1)];

areavec = areaquad(bottoms, zeros(size(bottoms)), ...
                   tops,    ones(size(bottoms))/refvec(1), ...
				   ellipsoid, 'degrees' );

%  Total area for 'one' elements.
%  Avoid matrix multiplication (areavec' * Z)  because this
%  can be extremely time consuming for large sparse Z.

[i,j] = find(Z);
a = sum(areavec(i));
