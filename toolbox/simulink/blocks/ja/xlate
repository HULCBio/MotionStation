% tbx/simulink/blocks/ja/xlate

<(sliideg)Low
>(sliideg)低
<(sliideg)Hi
>(sliideg)高
<(sliideg)Help
>(sliideg)ﾍﾙﾌﾟ
<(sliideg)Close
>(sliideg)閉じる
<(slideg)The Slider Gain is in a locked system.  You must place it in a model in order to operate.
>(slideg)Slider Gainはﾛｯｸされたｼｽﾃﾑにあります。操作をするにはﾓﾃﾞﾙ内に置く必要があります
<(slideg)Error
>(slideg)ｴﾗｰ
<(manswitch)Manual Switch block must be placed in a model or unlocked library in order to operate.
>(manswitch)Manual Switchﾌﾞﾛｯｸはﾓﾃﾞﾙ、またはﾛｯｸされていないﾗｲﾌﾞﾗﾘに置く必要があります

% Blocks translations
<(busCreatorddg)Bus object:
>(busCreatorddg)bus ｵﾌﾞｼﾞｪｸﾄ:
<(busCreatorddg)Inherit bus signal names from input ports
>(busCreatorddg)入力ﾎﾟｰﾄからﾊﾞｽ信号名を継承
<(busCreatorddg)Require input signal names to match signals below
>(busCreatorddg)下記の信号に適合する入力信号名が必要
<(busCreatorddg)Rename selected signal:
>(busCreatorddg)選択した信号名の変更:
<(busCreatorddg)Specify properties via bus object
>(busCreatorddg)busｵﾌﾞｼﾞｪｸﾄによりﾌﾟﾛﾊﾟﾃｨを指定
<(busCreatorddg)Bus object:
>(busCreatorddg)busｵﾌﾞｼﾞｪｸﾄ:
<(busCreatorddg)Edit
>(busCreatorddg)編集
<(busCreatorddg)Output as structure
>(busCreatorddg)構造体として出力
<(busSelectorddg)Select>>
>(busSelectorddg)選択>>

% The following messages are from MaskDescription in "simulink.mdl".
<(sl.mdl_Desc)The Band-Limited White Noise block generates normally distributed random numbers that are suitable for use in continuous or hybrid systems.
>(sl.mdl_Desc)Band-Limited White Noiseﾌﾞﾛｯｸ は、連続またはﾊｲﾌﾞﾘｯﾄﾞｼｽﾃﾑでの使用に適した正規分布する乱数を生成します｡
<(sl.mdl_Desc)Discrete-time State-Space Realization
>(sl.mdl_Desc)離散時間状態空間実現
<(sl.mdl_Desc)A Direct Form II realization of the specified transfer function is used.  Only single input multiple output transfer functions are supported.  \n\nThe data types and scalings of the output, the coefficients, and any temporary variables are automatically selected.  The automatic choices will be acceptable in many situations.  In situations where the automatic choices give unacceptable results, manual layout of the filter is necessary.  For manual layout, it is suggested that the blocks under this mask be used as a starting point.\n\nNote 1:\nThe full denominator should have a leading coefficient of +1.0, but this leading coefficient should be excluded when entering the parameter.  For example, if the denominator is\n  den = \n            1         -1.7         0.72\njust enter\n  den(2:end)  =\n         -1.7         0.72\n\nNote 2:\nThe numerator does NOT need to be the same size as the full denominator.
>(sl.mdl_Desc)指定された伝達関数のDirect Form II実現を使用します。単入力他出力の伝達関数のみｻﾎﾟｰﾄします。 \n\n出力と係数といくつかのﾃﾝﾎﾟﾗﾘ変数のﾃﾞｰﾀﾀｲﾌﾟとｽｹｰﾘﾝｸﾞは自動的に選択されます。自動的な選択は様々な状態を受け入れることができます。自動的な選択が受け入れられない状態だと、ﾌｨﾙﾀを手動で配置する必要があります。手動での配置は、ﾏｽｸされたﾌﾞﾛｯｸが開始点として使われことをることを意味します。\n\n注意 1:\nﾌﾙの分母は+1.0のﾘｰﾃﾞｨﾝｸﾞ係数をもちますが、このﾘｰﾃﾞｨﾝｸﾞ係数はﾊﾟﾗﾒｰﾀが入力されるときに除かれます。例えば、分母が\n den = \n            1         -1.7         0.72\nの場合は、以下と同じことになります。\n  den(2:end)  =\n         -1.7         0.72\n\n注意 2:\n分子はﾌﾙの分母と同じｻｲｽﾞである必要はありません
<(sl.mdl_Desc)A Direct Form II realization of the specified transfer function is used.  Only single input single output transfer functions are supported.  \n\nThe data types and scalings of the output, the coefficients, and any temporary variables are automatically selected.  The automatic choices will be acceptable in many situations.  In situations where the automatic choices give unacceptable results, manual layout of the filter is necessary.  For manual layout, it is suggested that the blocks under this mask be used as a starting point.\n\nNote 1:\nThe full denominator should have a leading coefficient of +1.0, but this leading coefficient should be excluded when entering the parameter.  For example, if the denominator is\n  den = \n            1         -1.7         0.72\njust enter\n  den(2:end)  =\n         -1.7         0.72\n\nNote 2:\nThe numerator does NOT need to be the same size as the full denominator.
>(sl.mdl_Desc)指定された伝達関数のDirect Form II実現を使用します。単入力他出力の伝達関数のみｻﾎﾟｰﾄします。 \n\n出力と係数といくつかのﾃﾝﾎﾟﾗﾘ変数のﾃﾞｰﾀﾀｲﾌﾟとｽｹｰﾘﾝｸﾞは自動的に選択されます。自動的な選択は様々な状態を受け入れることができます。自動的な選択が受け入れられない状態だと、ﾌｨﾙﾀを手動で配置する必要があります。手動での配置は、ﾏｽｸされたﾌﾞﾛｯｸが開始点として使われことをることを意味します。\n\n注意 1:\nﾌﾙの分母は+1.0のﾘｰﾃﾞｨﾝｸﾞ係数をもちますが、このﾘｰﾃﾞｨﾝｸﾞ係数はﾊﾟﾗﾒｰﾀが入力されるときに除かれます。例えば、分母が\n den = \n            1         -1.7         0.72\nの場合は、以下と同じことになります。\n  den(2:end)  =\n         -1.7         0.72\n\n注意 2:\n分子はﾌﾙの分母と同じｻｲｽﾞである必要はありません。
<(sl.mdl_Desc)Normally, the output is the signal u delayed by one sample period.\nWhen the enable signal is false, the block is disabled, and the state and output values do not change except for resets.  The enable action is vectorized and supports scalar expansion.
>(sl.mdl_Desc)通常､ 出力は 1ｻﾝﾌﾟﾙ時間遅延した信号 u です｡\nenable 信号がfalseの場合､ ﾌﾞﾛｯｸは使用できず､ 状態と出力値は､ ﾘｾｯﾄ以外では変更しません｡ enable ｱｸｼｮﾝはﾍﾞｸﾄﾙ化され､ ｽｶﾗ拡張をｻﾎﾟｰﾄします｡
<(sl.mdl_Desc)Decrease the Real World Value of Signal by 1.0\nOverflows will always wrap.
>(sl.mdl_Desc)信号のReal World Value を1.0まで減少させます｡\nｵｰﾊﾞｰﾌﾛｰは 常にwrapします｡
<(sl.mdl_Desc)Decrease the Stored Value of Signal by 1\nFloating Point signals are decreased by 1.0\nOverflows will always wrap.
>(sl.mdl_Desc)信号のStored Valueを1まで減少させます｡\n固定小数点の信号は､ 1.0まで減少します｡\nｵｰﾊﾞｰﾌﾛｰは常にwrapします｡
<(sl.mdl_Desc)A subsystem block template containing an inport and outport block.
>(sl.mdl_Desc)inportおよびoutportﾌﾞﾛｯｸを含むｻﾌﾞｼｽﾃﾑﾌﾞﾛｯｸのﾃﾝﾌﾟﾚｰﾄです。
<(sl.mdl_Desc)A discontinuity offset at zero models coulomb friction.  Linear gain models viscous friction.\ny = sign(x) * (Gain * abs(x) + Offset)
>(sl.mdl_Desc)ｸｰﾛﾝ摩擦ﾓﾃﾞﾙのｾﾞﾛでの不連続なｵﾌｾｯﾄ｡  線形のｹﾞｲﾝﾓﾃﾞﾙの粘性摩擦係数｡\ny = sign(x) * (Gain * abs(x) + Offset)
<(sl.mdl_Desc)Output zero for inputs within deadzone.  Offset input signals by either the Start or End value when outside of the deadzone.
>(sl.mdl_Desc)不感帯内の入力に対してｾﾞﾛを出力します｡ 不感帯外の場合は、上限値または下限値のどちらかの入力によるｵﾌｾｯﾄされた入力信号を出力。
<(sl.mdl_Desc)Limit rising and falling rates of the signals at the second input by using the first input (upper limit) and the third input (lower limit).
>(sl.mdl_Desc)1番目の入力(上限)と3番目の入力(下限)を使用して、2番目の入力での信号の立ち上がりと立ち下がりを制限します｡
<(sl.mdl_Desc)Bound the range of the second input by using the first input (upper limit) and the third input (lower limit).
>(sl.mdl_Desc)1番目の入力(上限)と3番目の入力(下限)を使用して、2番目の入力の範囲とします｡
<(sl.mdl_Desc)If the input is above the threshold, the output is zero, otherwise the output equals the input.
>(sl.mdl_Desc)入力が閾値より高い場合､ 出力はｾﾞﾛであり､ そうでない場合､ 出力は入力と等しくなります｡
<(sl.mdl_Desc)Output the current input value minus the previous input value.
>(sl.mdl_Desc)ｶﾚﾝﾄの入力値から前の入力値を引いて出力します。
<(sl.mdl_Desc)Discrete-time derivative of the input.\n\nThis block only works with fixed sample rates, so it will not work inside a triggered subsystem.
>(sl.mdl_Desc)入力の離散時間の微分｡\n\nこのﾌﾞﾛｯｸは固定ｻﾝﾌﾟﾙﾚｰﾄとしてのみ動作するため､ ﾄﾘｶﾞｻﾌﾞｼｽﾃﾑ内では動作しません｡
<(sl.mdl_Desc)This block implements a first-order hold by extrapolating between sample points using a first-order polynomial.
>(sl.mdl_Desc)このﾌﾞﾛｯｸは､ 一次多項式を使用してｻﾝﾌﾟﾙ点間を推定することにより1次ﾎｰﾙﾄﾞを実現します｡
<(sl.mdl_Desc)Delay a signal N sample periods.
>(sl.mdl_Desc)信号をNｻﾝﾌﾟﾙ時間遅延させます。
<(sl.mdl_Desc)Delay a signal N sample periods and output all the delay versions.
>(sl.mdl_Desc)信号をNｻﾝﾌﾟﾙ時間遅延させ、すべての遅延を出力します｡
<(sl.mdl_Desc)Discrete-time first order transfer function.  The transfer function has a unity DC gain.
>(sl.mdl_Desc)離散時間の1次伝達関数｡  伝達関数は､ 単一DCｹﾞｲﾝをもちます｡
<(sl.mdl_Desc)Discrete-time lead or lag compensator.  The compensator has a unity instantaneous gain, the DC gain equals (1-Zero)/(1-Pole).\n\nLead compensation is obtained when 0 < Pole < Zero < 1.\nLag compensation is obtained when 0 < Zero < Pole < 1.
>(sl.mdl_Desc)離散時間のleadまたはlag補償器｡  補償器は瞬間的な単一ｹﾞｲﾝをもち､ DCｹﾞｲﾝは (1-Zero)/(1-Pole) と等しくなります｡\n\nLead補償は､ 0 < Pole < Zero < 1の場合に得られます｡\nLag補償は､ 0 < Zero < Pole < 1 の場合に得られます｡
<(sl.mdl_Desc)Discrete-time transfer function that has a real zero and (effectively) has no pole.
>(sl.mdl_Desc)ｾﾞﾛをもち､ (実際に) 極をもたない離散時間の伝達関数
<(sl.mdl_Desc)Output the weighted moving average of the input.
>(sl.mdl_Desc)入力の重み付き移動平均の出力
<(sl.mdl_Desc)Clear ith bit of the stored integer to 0.  Scaling is ignored.
>(sl.mdl_Desc)ｽﾄｱされた整数のi番目のﾋﾞｯﾄを 0 にｸﾘｱします｡  ｽｹｰﾘﾝｸﾞは無視されます｡
<(sl.mdl_Desc)Set ith bit of the stored integer to 1.  Scaling is ignored.
>(sl.mdl_Desc)ｽﾄｱされた整数のi番目のﾋﾞｯﾄを 1 に設定します｡  ｽｹｰﾘﾝｸﾞは無視されます｡
<(sl.mdl_Desc)Perform the specified bitwise operation on the inputs. The output data type should represent zero exactly.
>(sl.mdl_Desc)入力に指定したﾋﾞｯﾄ単位の操作を行います｡ 出力ﾃﾞｰﾀﾀｲﾌﾟは 正確にｾﾞﾛを示す必要があります｡
<(sl.mdl_Desc)Determine how a signal compares to a constant.
>(sl.mdl_Desc)信号をどのように定数と比較するかを決めます。
<(sl.mdl_Desc)Determine how a signal compares to zero.
>(sl.mdl_Desc)信号をどのようにｾﾞﾛと比較するかを決めます。
<(sl.mdl_Desc)If the input does not equal its previous value, then output TRUE, otherwise output FALSE.  The initial condition determines the initial value of the previous input U/z.
>(sl.mdl_Desc)入力が前の値に等しくない場合､ 出力はTRUEとなり､ そうでない場合､ 出力はFALSEとなります｡ 初期条件は 前の入力 U/z の初期値を決定します｡
<(sl.mdl_Desc)If the input is strictly less than its previous value, then output TRUE, otherwise output FALSE.  The initial condition determines the initial value of the previous input U/z.
>(sl.mdl_Desc)入力が前の値より厳密に小さい場合､ 出力はTRUEとなり､ そうでない場合､ 出力はFALSEとなります｡  初期条件は 前の入力 U/z の初期値を決定します｡
<(sl.mdl_Desc)If the input is strictly greater than its previous value, then output TRUE, otherwise output FALSE.  The initial condition determines the initial value of the previous input U/z.
>(sl.mdl_Desc)入力が前の値より厳密に大きい場合､ 出力はTRUEとなり､ そうでない場合､ 出力は FALSE となります｡  初期条件は 前の入力 U/z の初期値を決定します｡
<(sl.mdl_Desc)If the input is strictly negative and its previous value was nonnegative, then output TRUE, otherwise output FALSE.  The initial condition determines the initial value of the boolean expression (U/z < 0).
>(sl.mdl_Desc)入力が厳密に負であり､ その前の値が負でない場合､ 出力はTRUEとなり､ そうでない場合､ 出力は FALSE となります｡  初期条件は ﾌﾞｰﾘｱﾝの式 (U/z < 0)の初期値を決定します｡
<(sl.mdl_Desc)If the input is nonpositive and its previous value was strictly positive, then output TRUE, otherwise output FALSE.  The initial condition determines the initial value of the boolean expression (U/z <= 0).
>(sl.mdl_Desc)入力が正ではなく､ その前の値が厳密に正の場合､ 出力はTRUEとなり､ そうでない場合､ 出力は FALSE となります｡ 初期条件は ﾌﾞｰﾘｱﾝの式 (U/z <= 0)の初期値を決定します｡
<(sl.mdl_Desc)If the input is nonnegative and its previous value was strictly negative, then output TRUE, otherwise output FALSE.  The initial condition determines the initial value of the boolean expression (U/z >= 0).
>(sl.mdl_Desc)入力が負ではなく､ その前の値が厳密に負の場合､ 出力はTRUEとなり､ そうでない場合､ 出力は FALSE となります｡ 初期条件は ﾌﾞｰﾘｱﾝの式 (U/z >= 0)の初期値を決定します｡ 
<(sl.mdl_Desc)If the input is strictly positive and its previous value was nonpositive, then output TRUE, otherwise output FALSE.  The initial condition determines the initial value of the boolean expression (U/z > 0).
>(sl.mdl_Desc)入力が厳密に正であり､ その前の値が正でない場合､ 出力はTRUEとなり､ そうでない場合､ 出力は FALSE となります｡ 初期条件はﾌﾞｰﾘｱﾝの式  (U/z > 0)の初期値を決定します｡ 
<(sl.mdl_Desc)Output selected bits from each of the fixed-point input samples. Selecting \"Upper half\" or \"Lower half\" results in a positive number of bits in the output word length, according to the equation numOutputBits = ceil(numInputBits / 2).
>(sl.mdl_Desc)固定小数点の入力ｻﾝﾌﾟﾙのそれぞれから選択したﾋﾞｯﾄを出力。'\"Upper half\"' または '\"Lower half\"' を選択すると、式 numOutputBits = ceil(numInputBits / 2) に従い、出力ﾜｰﾄﾞ長の正のﾋﾞｯﾄ数になります。
<(sl.mdl_Desc)If the input is in the interval between the lower limit and the upper limit, then the output is TRUE, otherwise it is FALSE.
>(sl.mdl_Desc)入力が下限と上限の間の区間にある場合､ 出力はTRUEとなり､ そうでない場合､ 出力は FALSE となります｡
<(sl.mdl_Desc)This block can arithmetically shift the bits and/or the binary point of a signal.\nThe effect of these actions can be interpreted as a combination of a multiplication by a power of two and a change in scaling.  The power of two multiplication term is\n  2^( NumBinaryPointShiftsRight - NumBitShiftsRight )\nNegative values for shifts right are actually positive shift lefts.\nIf the input is a floating point type, the power of two multiplication is carried out, but no change in scaling is applied.
>(sl.mdl_Desc)このﾌﾞﾛｯｸは､ 信号のﾋﾞｯﾄ および/または ﾊﾞｲﾅﾘﾎﾟｲﾝﾄをｼﾌﾄ演算をすることができます｡\nこれらのｱｸｼｮﾝの効果は､ 2のﾍﾞｷの乗の組合わせとｽｹｰﾙでの変更と解釈されます｡  2のﾍﾞｷの乗の項は､\n  2^( NumBinaryPointShiftsRight - NumBitShiftsRight )\n右へのｼﾌﾄの負の値は､ 実際は､ 左への正のｼﾌﾄです｡\n入力が浮動小数点ﾀｲﾌﾟの場合､ 2のﾍﾞｷの乗が実行されますが､ ｽｹｰﾘﾝｸﾞには変更が適用されません｡
<(sl.mdl_Desc)Implement a Cosine function in Fixed-Point using a lookup table approach that exploits quarter wave symmetry.  The output is normally a signed 16 bit number with 14 bits to the right of the binary point.\n\nThe most efficient implementation is obtained when the number of data points is a power of 2 plus 1.  For example, (2^5)+1.
>(sl.mdl_Desc)4分の1波長の対称性を利用するﾙｯｸｱｯﾌﾟﾃｰﾌﾞﾙを使用して､ 固定小数点での余弦関数を実現します｡ 出力は､ 通常14 ﾋﾞｯﾄがﾊﾞｲﾅﾘﾎﾟｲﾝﾄの右側にある､ 符号付き16ﾋﾞｯﾄ数です｡\n\n最も効果的な実現は､ ﾃﾞｰﾀ点数が､ 2のﾍﾞｷ乗に1を加えた数の場合に得られます｡  例えば､ (2^5)+1｡
<(sl.mdl_Desc)This is a PRIVATE helper block not intended for direct use by customers.\nThis block manages the four possible quandrants that the input signal can be in.  Combining this block with a look up table allows the Sine function to be implemented with 75% less table data.  Only data from the first quandrant is needed. 
>(sl.mdl_Desc)これはユーザの利用を想定していないPRIVATE補助ﾌﾞﾛｯｸです。\nこのﾌﾞﾛｯｸは入力信号が存在可能な4つの象限を管理します。ﾙｯｸｱｯﾌﾟﾃｰﾌﾞﾙとこのﾌﾞﾛｯｸを結合することでﾃｰﾌﾞﾙﾃﾞｰﾀよりも75%も少ないﾃｰﾌﾞﾙﾃﾞｰﾀでSine関数の実現が可能です。第1象限のみ必要となります。
<(sl.mdl_Desc)Table member selection.  Inputs are zero-based indices into the table, e.g., an input of 3 returns the fourth element in that dimension.  Block can also be used to select a column or 2-D matrix out of the table.  The first selection index corresponds to the top (or left) input port.
>(sl.mdl_Desc)ﾃｰﾌﾞﾙﾒﾝﾊﾞｰの選択｡  入力は､ ﾃｰﾌﾞﾙへのｾﾞﾛﾍﾞｰｽのｲﾝﾃﾞｯｸｽです｡ 例えば､ 入力 3 は､ そのdimensionの4番目の要素を返します｡  ﾌﾞﾛｯｸは､ﾃｰﾌﾞﾙから列または 2-D 行列を選択するためにも使用されます｡  1番目に選択されるｲﾝﾃﾞｯｸｽ は､  ﾄｯﾌﾟ(または 左)の入力ﾎﾟｰﾄに対応します｡
<(sl.mdl_Desc)Perform interpolation on an n-dimensional (n-D) table using precalculated indices and distance fractions.  An n-D Table is a sampled representation of a function in N variables.  This block's 'u' input ports are intended to be fed with the output of a PreLook-Up Index Search block.  Interpolation on a selected portion of the table can be optionally performed by specifying how many dimensions are to be used for sub-table selection.  Sub-table selection is performed starting with the highest (last) dimension.  The 'sel' input ports are fed with a uint32-typed value that is a table index in the corresponding dimension (zero-based indexing).  The first dimension input corresponds to the top (or left) input port.
>(sl.mdl_Desc)前もって計算されたｲﾝﾃﾞｯｸｽ と距離の端数を使ったn次元(n-D)ﾃｰﾌﾞﾙの補間を実行します｡ n次元ﾃｰﾌﾞﾙは､ N変数の関数をｻﾝﾌﾟﾙで表わします｡ このﾌﾞﾛｯｸの 'u' の入力ﾎﾟｰﾄは PreLook-Up Index Search ﾌﾞﾛｯｸの出力で与えられます｡  ﾃｰﾌﾞﾙの選択部分の補間は､ ｻﾌﾞﾃｰﾌﾞﾙの選択に対して使用される次元数を指定することにより､ ｵﾌﾟｼｮﾝにより実行が可能になります｡  ｻﾌﾞﾃｰﾌﾞﾙの選択は､ 最高(最後) の次元で始まり実行されます｡  'sel' 入力ﾎﾟｰﾄは､ 対応する次元(ｾﾞﾛﾍﾞｰｽのｲﾝﾃﾞｯｸｽ)のﾃｰﾌﾞﾙｲﾝﾃﾞｯｸｽであるuint32-typed valueが与えられます｡  最初の次元の入力は､ 入力ﾎﾟｰﾄの上(または 左)に対応します｡
<(sl.mdl_Desc)Approximate a one-dimensional function using a selected look-up method.
>(sl.mdl_Desc)選択したlook-upの手法を使用して1次元の関数を近似します｡
<(sl.mdl_Desc)Perform n-dimensional interpolated table lookup including index searches.  The table is a sampled representation of a function in N variables.  Breakpoint sets relate the input values to positions in the table.  The first dimension corresponds to the top (or left) input port.
>(sl.mdl_Desc)ｲﾝﾃﾞｯｸｽｻｰﾁを含む、n次元補間ﾃｰﾌﾞﾙﾙｯｸｱｯﾌﾟを実行します｡ ﾃｰﾌﾞﾙは N 変数関数をｻﾝﾌﾟﾙで表わします｡  ﾌﾞﾚｰｸﾎﾟｲﾝﾄ設定は､ 入力値をﾃｰﾌﾞﾙの位置に関連づけます｡  1番目の次元は､ 上(または 左) の入力ﾎﾟｰﾄに対応します｡
<(sl.mdl_Desc)Locate the input value's relative position within a range of numbers (the "breakpoint data" set).  Returns an array of the interval index "k"and distance fraction "f" that the input "u" reaches into the kth interval.
>(sl.mdl_Desc)入力値を関連した位置に配置します(範囲は"ﾌﾞﾚｰｸﾎﾟｲﾝﾄ ﾃﾞｰﾀ"に設定されます)。距離を示すｲﾝﾃﾞｯｸｽ "k"と、入力 "u" とk番目の距離にまでの距離の端数を示す "f"の配列を返します｡ 
<(sl.mdl_Desc)Implement a Sine function in Fixed-Point using a lookup table approach that exploits quarter wave symmetry.  The output is normally a signed 16 bit number with 14 bits to the right of the binary point.\n\nThe most efficient implementation is obtained when the number of data points is a power of 2 plus 1.  例えば､ (2^5)+1.
>(sl.mdl_Desc)4分の1波長の対称性を利用するﾙｯｸｱｯﾌﾟﾃｰﾌﾞﾙを使用して､ 固定小数点での正弦関数を実現します｡ 出力は､ 通常14 ﾋﾞｯﾄがﾊﾞｲﾅﾘﾎﾟｲﾝﾄの右側にある､ 符号付き16ﾋﾞｯﾄ数です｡\n\n最も効果的な実現は､ ﾃﾞｰﾀ点数が､ 2のﾍﾞｷ乗に1を加えた数の場合に得られます｡  例えば､ (2^5)+1｡
<(sl.mdl_Desc)Constrains input signal f(z) to zero and outputs an algebraic state z. This block outputs the value necessary to produce a zero at the input. The output must affect the input through some feedback path. Provide an initial guess of the output to improve algebraic loop solver efficiency.
>(sl.mdl_Desc)入力信号 f(z) をｾﾞﾛに制限し、代数的な状態 z を出力します｡ このﾌﾞﾛｯｸは､ 入力時にｾﾞﾛを生成するのに必要な値を出力します｡ 出力は､ いくつかのﾌｨｰﾄﾞﾊﾞｯｸﾊﾟｽを通じて入力に作用しなければなりません｡ 代数ﾙｰﾌﾟｿﾙﾊﾞの効率を改善するために､ 出力の初期推定を与えます｡
<(sl.mdl_Desc)Inner (dot) product.\ny = sum(conj(u1).*u2). The operand u1 corresponds to the top (or left) input port.	  MaskHelp		  "omputes the inner (dot) product of the inputs: sum(u1.*u2).  The inputs are vectors of the same length. Output is a scalar.
>(sl.mdl_Desc)内積 (ﾄﾞｯﾄ)｡ \ny = sum(conj(u1).*u2). 演算子u1は、入力ﾎﾟｰﾄの上(または 左) に対応します｡	  MaskHelp		  は 入力の内積 (ﾄﾞｯﾄ) を計算します: sum(u1.*u2).  入力は同じ長さのﾍﾞｸﾄﾙです｡ 出力はｽｶﾗです｡
<(sl.mdl_Desc)Perform horizontal or vertical concatenation.  1-D vector input signals are treated as column vectors, i.e., [Mx1] matrices.  The output is always a matrix.
>(sl.mdl_Desc)水平方向 または 垂直方向の連結を行います｡  1-D ﾍﾞｸﾄﾙ入力信号は､ 列ﾍﾞｸﾄﾙ､ すなわち､ [Mx1] 行列として取り扱われます｡  出力は常に行列です｡
<(sl.mdl_Desc)Output the max or min of all past inputs u.  The output is reset to the initial condition when the Reset input signal R is TRUE.  This reset action is vectorized and supports scalar expansion.
>(sl.mdl_Desc)過去のすべての入力uの最大値または最小値を出力します｡  出力は、Resetの入力信号 R が TRUE の場合､ 初期条件にﾘｾｯﾄされます｡  この reset ｱｸｼｮﾝはﾍﾞｸﾄﾙ化され､ ｽｶﾗ拡張をｻﾎﾟｰﾄします｡
<(sl.mdl_Desc)Polynomial evaluation.  Calculates P(u) given by the polynomial coefficient array P.  P is sorted highest order to lowest order, the form accepted by MATLAB's polyval function.
>(sl.mdl_Desc)多項式の評価｡  多項式係数の配列 P により与えられる P(u) を計算します｡  P は､ 最高次から最低次へと並べられます｡これは､ MATLAB の関数 polyval により受け入れられる形式です｡
<(sl.mdl_Desc)Change the dimensions of a vector or matrix input signal. Output\n - a one-dimensional array (vector), \n - a column vector (Mx1 matrix), \n - a row vector (1xN matrix), or \n - a matrix or vector with specified dimensions, e.g., [M, N] or [W].
>(sl.mdl_Desc)ﾍﾞｸﾄﾙ または 行列の入力信号の次元の変更｡ 出力\n - 1次元配列 (ﾍﾞｸﾄﾙ), \n - 列ﾍﾞｸﾄﾙ (Mx1 行列), \n - 行ﾍﾞkﾄﾙ (1xN 行列), または \n - 指定した次元をもつ行列または ﾍﾞｸﾄﾙ, 例えば､ [M, N] または [W].
<(sl.mdl_Desc)Unary Minus of a Signal.
>(sl.mdl_Desc)信号の単項ﾏｲﾅｽ
<(sl.mdl_Desc)Add, subtract, multiply, or divide the input signal by weighted sample time, or just output weighted sample time or weighted sample rate.\n\nThis block only works with fixed sample rates, so it will not work inside a triggered subsystem.
>(sl.mdl_Desc)入力信号を重み付きのｻﾝﾌﾟﾙ時間で加算､ 減算､ 乗算､ 除算､あるいは､ 重み付きのｻﾝﾌﾟﾙ時間または重み付きのｻﾝﾌﾟﾙﾚｰﾄを出力します｡\n\nこのﾌﾞﾛｯｸは 固定ｻﾝﾌﾟﾙﾚｰﾄにのみ有効なため､ ﾄﾘｶﾞｻﾌﾞｼｽﾃﾑ内では有効ではありません｡
<(sl.mdl_Desc)Assert that the absolute value of the difference between successive samples of a discrete signal is less than an upper bound.
>(sl.mdl_Desc)離散信号の連続したｻﾝﾌﾟﾙ間の差の絶対値が､指定した上限値よりも小さいことを主張(ｱｻｰｼｮﾝ)
<(sl.mdl_Desc)Assert that the input signal 'sig' is always less than the lower bound 'min' or greater than the upper bound 'max'.  The first input is the upper-bound of the gap; the second input, the lower-bound; the third input, the test signal.
>(sl.mdl_Desc)入力信号 'sig' が､ 常に下限 'min' よりも小さい､または､ 上限 'max' よりも大きいと主張(ｱｻｰｼｮﾝ)｡  1番目の入力は､ ｷﾞｬｯﾌﾟの上限; 2番目の入力は下限; 3番目の入力はﾃｽﾄ信号です｡
<(sl.mdl_Desc)Assert that one signal always lies between two other signals.  The first input is the upper-bound signal; the second input, the lower-bound; the third input, the test signal.
>(sl.mdl_Desc)1つの信号が､ 常に､ 他の2つの信号の間にあると主張(ｱｻｰｼｮﾝ)｡ 1番目の入力は上限の信号; 2番目の入力は下限; 3番目の入力はﾃｽﾄ信号です｡
<(sl.mdl_Desc)Assert that the input signal is less than (or optionally equal to) a static lower bound or greater than (or optionally equal to) a static upper bound.
>(sl.mdl_Desc)入力信号が､ 静的な下限値よりも小さい(または ｵﾌﾟｼｮﾝで等値も含む)か、あるいは静的な上限値よりも大きい(または ｵﾌﾟｼｮﾝで等値も含む)と主張(ｱｻｰｼｮﾝ)
<(sl.mdl_Desc)Assert that the input signal lies between a static lower and upper bound or optionally equals either bound. 
>(sl.mdl_Desc)入力信号が､ 性的な下限値と上限値の間､ または､ ｵﾌﾟｼｮﾝでいずれかの境界値に等しいと主張(ｱｻｰｼｮﾝ)
<(sl.mdl_Desc)Assert that one signal is always less than another signal.  The first input is the lower-bound signal.  The second input is the test signal.
>(sl.mdl_Desc)1つの信号が､他の信号よりも常に小さいと主張(ｱｻｰｼｮﾝ)｡  1番目の入力は下限の信号です｡  2番目の入力はﾃｽﾄ信号です｡
<(sl.mdl_Desc)Assert that one signal is always greater than another signal.  The first input is the upper-bound signal.  The second input is the test signal.
>(sl.mdl_Desc)1つの信号が､他の信号よりも常に大きいと主張(ｱｻｰｼｮﾝ)｡ 1番目の入力は上限の信号です｡ 2番目の入力はﾃｽﾄ信号です｡
<(sl.mdl_Desc)Assert that the input signal has a specified resolution.  If the resolution is a scalar, the input signal must be a multiple of the resultion within a 10e-3 tolerance.  If the resolution is a vector, the input signal must equal an element of the resolution vector.
>(sl.mdl_Desc)入力信号が指定した分解能をもつと主張(ｱｻｰｼｮﾝ)｡  分解能がｽｶﾗの場合､ 入力信号は指定した分解能の倍数である必要があり、許容誤差は10e-3でなければなりません。分解能がﾍﾞｸﾄﾙの場合､ 入力信号は分解能ﾍﾞｸﾄﾙの要素と等しくなければなりません。
<(sl.mdl_Desc)Assert that the input signal is greater than (or optionally equal to) a static lower bound.
>(sl.mdl_Desc)入力信号は静的な下限値よりも大きい(ｵﾌﾟｼｮﾝで等値も含む)と主張(ｱｻｰｼｮﾝ)。
<(sl.mdl_Desc)Assert that the input signal is less than (or optionally equal to) a static upper bound.\n
>(sl.mdl_Desc)入力信号が静的な上限値よりも小さい(ｵﾌﾟｼｮﾝで等値も含む)と主張(ｱｻｰｼｮﾝ)。\n
<(sl.mdl_Desc)Double-clicking the block will launch the Simulink Block Data Type Support Table.
>(sl.mdl_Desc)ﾌﾞﾛｯｸをﾀﾞﾌﾞﾙｸﾘｯｸすると､ Simulink Block Data Type Support Tableが起動します｡
<(sl.mdl_Desc)Use this block to save long descriptive text with the model.  Double-clicking the block will open an editor.
>(sl.mdl_Desc)ﾓﾃﾞﾙについて記述されたﾃｷｽﾄを保存するために､ このﾌﾞﾛｯｸを使用します｡ ﾌﾞﾛｯｸをﾀﾞﾌﾞﾙｸﾘｯｸすると､ ｴﾃﾞｨﾀが開きます｡
<(sl.mdl_Desc)Double-clicking the block will open the Model Advisor for the model containing this block.
>(sl.mdl_Desc)ﾌﾞﾛｯｸをﾀﾞﾌﾞﾙｸﾘｯｸすると､ このﾌﾞﾛｯｸを含むﾓﾃﾞﾙに対するModel Advisorが開きます｡
<(sl.mdl_Desc)This block allows revision control information to be displayed within the model.
>(sl.mdl_Desc)このﾌﾞﾛｯｸにより､ 最新の管理情報がﾓﾃﾞﾙ内に表示できるようになります｡
<(sl.mdl_Desc)Generate linear models in the base workspace at specific times.\n
>(sl.mdl_Desc)指定した時間に､ ﾍﾞｰｽﾜｰｸｽﾍﾟｰｽに線形ﾓﾃﾞﾙを作成します｡\n
<(sl.mdl_Desc)Generates linear models in the base workspace when triggered.
>(sl.mdl_Desc)ﾄﾘｶﾞされた場合､ ﾍﾞｰｽﾜｰｸｽﾍﾟｰｽに線形ﾓﾃﾞﾙを作成します｡
<(sl.mdl_Desc)A subsystem block template containing an inport and outport block.
>(sl.mdl_Desc)inport および outport ﾌﾞﾛｯｸを含むｻﾌﾞｼｽﾃﾑﾌﾞﾛｯｸのﾃﾝﾌﾟﾚｰﾄ｡
<(sl.mdl_Desc)A subsystem block template containing an enable port, inport and outport block.
>(sl.mdl_Desc)enable ﾎﾟｰﾄ, inport および outport ﾌﾞﾛｯｸを含むｻﾌﾞｼｽﾃﾑﾌﾞﾛｯｸのﾃﾝﾌﾟﾚｰﾄ｡
<(sl.mdl_Desc)A subsystem block template containing a for iterator, inport and outport block.
>(sl.mdl_Desc)for iterator, inport および outport ﾌﾞﾛｯｸを含むｻﾌﾞｼｽﾃﾑﾌﾞﾛｯｸのﾃﾝﾌﾟﾚｰﾄ｡
<(sl.mdl_Desc)This block implements an iterator operation. On each time-step as defined by the sample time field, this block will execute the function-call subsystem(s) that it drives for the specified number of iterations.\n\nDemux the block's output to execute multiple function-call subsystems in a prescribed order.   The system connected to first demux port is executed first, the system connected to second demux port is executed second, and so on.
>(sl.mdl_Desc)このﾌﾞﾛｯｸは､ 繰り返し演算を行います｡ ｻﾝﾌﾟﾙ時間のﾌｨｰﾙﾄﾞで定義された時間ｽﾃｯﾌﾟ毎に､ このﾌﾞﾛｯｸは､ Function-callｻﾌﾞｼｽﾃﾑを指定された繰り返し回数で実行します｡\n\nあらかじめ記述された順序で､ 複数のFunction-callｻﾌﾞｼｽﾃﾑを実行するために､ ﾌﾞﾛｯｸの出力を分離します｡ 1番目のdemuxﾎﾟｰﾄに接続されたｼｽﾃﾑが最初に実行され､ 2番目のdemuxﾎﾟｰﾄに接続されたｼｽﾃﾑは2番目に...という順になります。
<(sl.mdl_Desc)A subsystem block template containing a function-call trigger port, inport and outport block.
>(sl.mdl_Desc)Function-callﾄﾘｶﾞﾎﾟｰﾄ, inportおよびoutportﾌﾞﾛｯｸを含むｻﾌﾞｼｽﾃﾑﾌﾞﾛｯｸのﾃﾝﾌﾟﾚｰﾄ｡
<(sl.mdl_Desc)A subsystem block template containing an action port, inport and outport block.
>(sl.mdl_Desc)action ﾎﾟｰﾄ, inportおよびoutportﾌﾞﾛｯｸを含むｻﾌﾞｼｽﾃﾑﾌﾞﾛｯｸのﾃﾝﾌﾟﾚｰﾄ｡
<(sl.mdl_Desc)A subsystem block template containing an inport and outport block.
>(sl.mdl_Desc)inportおよびoutportﾌﾞﾛｯｸを含むｻﾌﾞｼｽﾃﾑﾌﾞﾛｯｸのﾃﾝﾌﾟﾚｰﾄ｡
<(sl.mdl_Desc)These are examples of how to use the different types of subsystems.
>(sl.mdl_Desc)様々なﾀｲﾌﾟのｻﾌﾞｼｽﾃﾑを利用する方法の例題が含まれています。
<(sl.mdl_Desc)A subsystem block template containing a trigger port, inport and outport block.
>(sl.mdl_Desc)ﾄﾘｶﾞﾎﾟｰﾄ, inportおよびoutportﾌﾞﾛｯｸを含むｻﾌﾞｼｽﾃﾑﾌﾞﾛｯｸのﾃﾝﾌﾟﾚｰﾄ｡
<(sl.mdl_Desc)A subsystem block template containing a while iterator, inport and outport block.
>(sl.mdl_Desc)while iterator, inportおよびoutportﾌﾞﾛｯｸを含むｻﾌﾞｼｽﾃﾑﾌﾞﾛｯｸのﾃﾝﾌﾟﾚｰﾄ｡
<(sl.mdl_Desc)Convert the second input to the data type and scaling of the first input.  \n\nThe conversion has two possible goals.  One goal is to have the Real World Values of the input and the output be equal.  The other goal is to have the Stored Integer Values of the input and the output be equal.  Overflows and quantization errors can prevent the goal from being fully achieved.  \n\nThe input and the output support all built-in and fixed point data types.  
>(sl.mdl_Desc)2番目の入力を､ 1番目の入力のﾃﾞｰﾀﾀｲﾌﾟやｽｹｰﾘﾝｸﾞに変換します｡  \n\nこの変換には､ 2つの目的があります｡ 目的の1つは､ 入力と出力のReal World Values を等しくすることです｡  別の目的は､ 入力と出力のStored Integer Valuesを等しくすることです｡  ｵｰﾊﾞｰﾌﾛｰ と 量子化誤差があると、この目的は完全には達成されることができません｡ \n\n入力と出力は､ 組み込み､ および､ 固定小数点ﾃﾞｰﾀﾀｲﾌﾟをすべてｻﾎﾟｰﾄします｡
<(sl.mdl_Desc)Force all inputs to have the exact same data type.
>(sl.mdl_Desc)すべての入力が厳密に同じﾃﾞｰﾀをもつようにする｡
<(sl.mdl_Desc)Set the Data Type and Scaling of the propagated signal based on information from the reference signals.\nNotes:\n1) Items closer to the top of the dialog have higher priority/precedence.\na) Reference inputs of type double have priority over all others.\nb) Singles have priority over integer and fixed point data types.\nc) Multiplicative adjustments are carried out before additive adjustments.\nd) Number-of-Bits is determined before the precision or positive-range is inherited from the reference signals.\n2) PosRange is one bit higher than the exact maximum positive range of the signal.\n3) The computed Number-of-Bits is promoted to the smallest allowable value that is greater than or equal.  If none exists, then error.
>(sl.mdl_Desc)参照信号からの情報に基づき､ 伝搬信号のﾃﾞｰﾀ ﾀｲﾌﾟとｽｹｰﾘﾝｸﾞを設定します｡\n注意:\n1) ﾀﾞｲｱﾛｸﾞのﾄｯﾌﾟにより近いｱｲﾃﾑは､ より高い priority/precedence をもちます｡ \na) doubleﾀｲﾌﾟの参照入力は､ 他のすべてのものに優先します\nb) single は､ 整数固定小数点ﾃﾞｰﾀﾀｲﾌﾟに優先します｡\nc) 乗算の調整は､ 加算の調整の前に実行されます｡\nd) ﾋﾞｯﾄ数は､ 精度または正の範囲が継承される前に参照信号から決定されます｡\n2) PosRange は､ 信号の厳密に最大の正の範囲よりも1ﾋﾞｯﾄ高くなります｡\n3) 計算されたﾋﾞｯﾄ数は､ それ以上の最小の許容値にﾌﾟﾛﾓｰﾄされます｡  何も存在しない場合はｴﾗｰになります｡
<(sl.mdl_Desc)Opens a model containing data type propagation examples.
>(sl.mdl_Desc)ﾃﾞｰﾀﾀｲﾌﾟ伝搬の例を含むﾓﾃﾞﾙを開きます。
<(sl.mdl_Desc)This block strips the scaling off a fixed point signal.  It maps the input data type to the smallest built-in data type that has sufficient bits to hold the input.  The stored Integer Value of the input will be the value of the output.  The output always has nominal scaling (slope = 1.0 and bias = 0.0), so the output does not have a distinction between Real World Value and Stored Integer Value.
>(sl.mdl_Desc)このﾌﾞﾛｯｸはｽｹｰﾘﾝｸﾞｵﾌした信号をｽﾄﾘｯﾌﾟします。入力のﾃﾞｰﾀﾀｲﾌﾟを入力を保持するのに十分なﾋﾞｯﾄである最小の組み込みﾃﾞｰﾀﾀｲﾌﾟにﾏｯﾋﾟﾝｸﾞします。入力のStoredInteger Valueは出力値になります。出力は常にﾉﾐﾅﾙなｽｹｰﾘﾝｸﾞ(slope = 1.0とbias = 0.0)のため、出力はReal World ValueとStored Integer Valueの区別を行いません。
<(sl.mdl_Desc)Add, subtract, multiply, or divide the input signal by weighted sample time, or just output weighted sample time or weighted sample rate.\n\nThis block only works with fixed sample rates, so it will not work inside a triggered subsystem.
>(sl.mdl_Desc)入力信号を重み付きのｻﾝﾌﾟﾙ時間で加算､ 減算､ 乗算､ 除算､あるいは､ 重み付きのｻﾝﾌﾟﾙ時間 または 重み付きのｻﾝﾌﾟﾙﾚｰﾄを出力します｡\n\nこのﾌﾞﾛｯｸは 固定ｻﾝﾌﾟﾙﾚｰﾄにのみ有効なため､ ﾄﾘｶﾞｻﾌﾞｼｽﾃﾑ内では有効ではありません｡
<(sl.mdl_Desc)Output the simulation (Sim) or Real-Time Workshop (RTW) port depending on the current environment.  With optimizations enabled, unnecessary blocks leading to the unused port are not executed.
>(sl.mdl_Desc)ｶﾚﾝﾄの環境に依存するｼﾐｭﾚｰｼｮﾝ(Sim)かReal-Time Workshop (RTW)ﾎﾟｰﾄを出力します。最適化が有効な場合、使われていないﾎﾟｰﾄは実行されないため、ﾌﾞﾛｯｸは必要ありません。｡
<(sl.mdl_Desc)Output toggles between two inputs by double-clicking on the block.\n
>(sl.mdl_Desc)ﾌﾞﾛｯｸをﾀﾞﾌﾞﾙｸﾘｯｸすることにより､ 2つの入力を切り替えて出力します｡\n
<(sl.mdl_Desc)XY scope using MATLAB graph window.  First input is used as time base.  Enter plotting ranges.
>(sl.mdl_Desc)MATLAB ｸﾞﾗﾌｳｨﾝﾄﾞｳを使用するXY ｽｺｰﾌﾟ｡  1番目の入力は､ 時間ﾍﾞｰｽとして使用されます｡ ﾌﾟﾛｯﾄの範囲を入力してください｡
<(sl.mdl_Desc)The Band-Limited White Noise block generates normally distributed random numbers that are suitable for use in continuous or hybrid systems.
>(sl.mdl_Desc)Band-Limited White Noise ﾌﾞﾛｯｸ は、連続またはﾊｲﾌﾞﾘｯﾄﾞｼｽﾃﾑの使用に適した正規分布する乱数を生成します｡
<(sl.mdl_Desc)Output a linear chirp signal (sine wave  whose frequency varies linearly with time).
>(sl.mdl_Desc)線形 chirp 信号の出力 (周波数が時間とともに線形に変化する正弦波)｡
<(sl.mdl_Desc)This block is a free-running counter that overflows back to zero after it has reached the maximum value possible for the specified number of bits. The count is always initialized to zero.  The output is normally an unsigned integer with the specified number of bits.
>(sl.mdl_Desc)このﾌﾞﾛｯｸは、指定したﾋﾞｯﾄ数に対して可能な最大値に達した後に、ｵｰﾊﾞｰﾌﾛｰをｾﾞﾛに戻すﾌﾘｰﾗﾝｶｳﾝﾀです。出力は、通常指定したﾋﾞｯﾄ数の符号なし整数です。
<(sl.mdl_Desc)This block is a counter that wraps back to zero after it has output the specified upper limit.  The count is always initialized to zero.  The output is normally an unsigned integer of 8, 16, or 32 bits.  The smallest number of bits needed to represent the upper limit is used.
>(sl.mdl_Desc)このﾌﾞﾛｯｸは指定した上限の出力の後にwrapをｾﾞﾛに戻すｶｳﾝﾀです。ｶｳﾝﾄは通にｾﾞﾛに初期化されます。出力は通常符号なしの8,16,32ﾋﾞｯﾄの整数です。上限を表すのに必要な最小のﾋﾞｯﾄ数が使用されます。
<(sl.mdl_Desc)Output a ramp signal starting at the specified time.
>(sl.mdl_Desc)指定時間ではじまるﾗﾝﾌﾟ信号を出力
<(sl.mdl_Desc)Output a repeating sequence of numbers specified in a table of time-value pairs. Values of time should be monotonically increasing.
>(sl.mdl_Desc)時間-値の組で指定されたﾃｰﾌﾞﾙを繰り返し出力します｡ 時間の値は､ 単調に増加である必要があります。
<(sl.mdl_Desc)Discrete time sequence is output, then repeated.  Between data points, the specified lookup method is used to determine the output.
>(sl.mdl_Desc)離散時間の列の出力を繰り返します｡ ﾃﾞｰﾀ点間では､ 出力を決めるために指定したﾙｯｸｱｯﾌﾟ手法が使われます。
<(sl.mdl_Desc)Discrete time sequence is output, then repeated.
>(sl.mdl_Desc)離散時間の列が出力され､ 繰り返されます｡
<(sl.mdl_Desc)Output boolean true (ON) or false (OFF).  Double-click to toggle the value during simulation.
>(sl.mdl_Desc)ﾌﾞｰﾘｱﾝのtrue (ON) または false (OFF)を出力｡   ｼﾐｭﾚｰｼｮﾝの間に値を切り替えるためには､ ﾀﾞﾌﾞﾙｸﾘｯｸします｡
<(sl.mdl_Desc)These are examples of how to use the different types of S-Functions.
>(sl.mdl_Desc)様々なﾀｲﾌﾟのS-functionを利用する方法いついての例題があります。
<(sl.mdl_Desc)Increase the Real World Value of Signal by 1.0\nOverflows will always wrap.
>(sl.mdl_Desc)Real World Value of Signal を1.0まで増加させます｡\nｵｰﾊﾞｰﾌﾛｰは 常にwrapします｡
<(sl.mdl_Desc)Increase the Stored Value of Signal by 1\nFloating Point signals are increased by 1.0\nOverflows will always wrap.
>(sl.mdl_Desc)信号のStored Value を1まで増加させます｡\n浮動小数点の信号は､ 1.0まで増加します｡\nｵｰﾊﾞｰﾌﾛｰは 常にwrapします｡
<(sl.mdl_Desc)Decrease the Real World Value of Signal by the Sample Time Ts,\nbut never go below zero.\n\nThis block only works with fixed sample rates, so it will not work inside a triggered subsystem.
>(sl.mdl_Desc)信号のReal World Value をｻﾝﾌﾟﾙ時間Tsまで減少させますが､ \nｾﾞﾛより小さくはなりません｡\n\nこのﾌﾞﾛｯｸは 固定ｻﾝﾌﾟﾙﾚｰﾄにのみ有効なため､ ﾄﾘｶﾞｻﾌﾞｼｽﾃﾑ内では有効ではありません｡
<(sl.mdl_Desc)Decrease the Real World Value of Signal by 1.0,\nbut never go below zero.
>(sl.mdl_Desc)信号のReal World Value を1.0まで減少させますが､ \nｾﾞﾛより小さくはなりません｡
<(sl.mdl_Desc)Normally, the output is the signal u delayed by one sample period.\nWhen the enable signal is false, the block is disabled, and the state and output values do not change except for resets.  The enable action is vectorized and supports scalar expansion.
>(sl.mdl_Desc)通常､ 出力は1ｻﾝﾌﾟﾙ時間遅延した信号uです｡\nenable信号がfalseの場合､ ﾌﾞﾛｯｸは使用できず､ 状態と出力値はﾘｾｯﾄ以外では変更しません｡ enable ｱｸｼｮﾝはﾍﾞｸﾄﾙ化されｽｶﾗ拡張をｻﾎﾟｰﾄします｡
<(sl.mdl_Desc)Normally, the output is the signal u delayed by one sample period.\nThe initial condition is given by the signal IC.
>(sl.mdl_Desc)通常､ 出力は1ｻﾝﾌﾟﾙ時間遅延した信号 u です｡\n初期条件は信号ICにより与えられます｡
<(sl.mdl_Desc)Normally, the output is the signal u delayed by one sample period.\nWhen the reset signal R is true, the state and the output are always set equal to the initial condition parameter.  This reset action is vectorized and supports scalar expansion.
>(sl.mdl_Desc)通常､ 出力は1ｻﾝﾌﾟﾙ時間遅延した信号 u です｡\nreset信号Rがtrueの場合、状態と出力値は常に初期条件ﾊﾟﾗﾒｰﾀに等しく設定されます｡ このresetｱｸｼｮﾝはﾍﾞｸﾄﾙ化されｽｶﾗ拡張をｻﾎﾟｰﾄします｡
<(sl.mdl_Desc)Normally, the output is the signal u delayed by one sample period.\nWhen the reset signal R is true, the state and the output are always set equal to the initial condition parameter.  This reset action is vectorized and supports scalar expansion.\nWhen the enable signal is false, the block is disabled, and the state and output values do not change except for resets.  The enable action is vectorized and supports scalar expansion.
>(sl.mdl_Desc)通常､ 出力は1ｻﾝﾌﾟﾙ時間遅延した信号 u です｡\nreset信号 R がtrueの場合､ 状態と出力値は常に初期条件ﾊﾟﾗﾒｰﾀに等しく設定されます｡ reset ｱｸｼｮﾝはﾍﾞｸﾄﾙ化されｽｶﾗ拡張をｻﾎﾟｰﾄします｡\nenable 信号がfalseの場合､ ﾌﾞﾛｯｸが表示され､ 状態と出力値は､ ﾘｾｯﾄ以外では変更しません｡ enable ｱｸｼｮﾝはﾍﾞｸﾄﾙ化されｽｶﾗ拡張をｻﾎﾟｰﾄします｡
<(sl.mdl_Desc)Normally, the output is the signal u delayed by one sample period.\nWhen the reset signal R is true, the state and the output are always set equal to the initial condition signal IC.  This reset action is vectorized and supports scalar expansion.
>(sl.mdl_Desc)通常､ 出力は1ｻﾝﾌﾟﾙ時間遅延した信号 u です｡\nreset 信号 R がtrueの場合､ 状態と出力は常に初期条件の信号 IC に等しく設定されます｡  このresetｱｸｼｮﾝはﾍﾞｸﾄﾙ化されｽｶﾗ拡張をｻﾎﾟｰﾄします｡
<(sl.mdl_Desc)Normally, the output is the signal u delayed by one sample period.\nThe initial condition is given by the signal IC.\nWhen the enable signal is false, the block is disabled, and the state and output values do not change except for resets.  The enable action is vectorized and supports scalar expansion.
>(sl.mdl_Desc)通常､ 出力は1ｻﾝﾌﾟﾙ時間遅延した信号 u です｡\n初期条件は､ 信号ICにより与えられます｡\nenable信号がfalseの場合､ ﾌﾞﾛｯｸが表示され､ 状態と出力の値は､ ﾘｾｯﾄ以外では変更しません｡  enableｱｸｼｮﾝはﾍﾞｸﾄﾙ化されｽｶﾗ拡張をｻﾎﾟｰﾄします｡
<(sl.mdl_Desc)Normally, the output is the signal u delayed by one sample period.\nWhen the reset signal R is true, the state and the output are always set equal to the initial condition signal IC.  This reset action is vectorized and supports scalar expansion.\nWhen the enable signal is false, the block is disabled, and the state and output values do not change except for resets.  The enable action is vectorized and supports scalar expansion.
>(sl.mdl_Desc)通常､ 出力は1ｻﾝﾌﾟﾙ時間遅延した信号 u です｡\nreset 信号 R が true の場合､ 状態と出力は 常に初期条件の信号 IC に等しく設定されます｡  このresetｱｸｼｮﾝは､ ﾍﾞｸﾄﾙ化されｽｶﾗの式をｻﾎﾟｰﾄします｡\nenable 信号がfalseの場合､ ﾌﾞﾛｯｸが使用できなくなり､ 状態と出力の値はﾘｾｯﾄ以外では変更しません｡ enable ｱｸｼｮﾝは､ ﾍﾞｸﾄﾙ化されｽｶﾗ拡張をｻﾎﾟｰﾄします｡
<(sl.mdl_Desc)Unit Delays With Preview have two outputs instead of just one.  Normally, the first output equals the signal u, and the second output is a unit delayed version of the first output.\n\nHaving both signals is useful for implementing recursive calculations where the result should include the most recent inputs.  The second output of a Unit Delay With Preview can be safely fed back into calculations of the block's inputs without causing an algebraic loop.  Meanwhile, the first output will show the most up to date calculations.\n\nWhen the enable signal is false, the block is disabled, and the state and output values do not change except for resets.  The enable action is vectorized and supports scalar expansion.
>(sl.mdl_Desc)Unit Delays With Preview は､ 1つではなく2つの出力をもちます｡通常､ 1番目の出力は信号 u に等しく､ 2番目の出力は 1番目の出力が1ｻﾝﾌﾟﾙ時間遅延したものです｡\n\n両方の信号をもつと､ 結果に最も最近の入力を必要とする再帰的計算を実行するために有効です｡ Unit Delay With Preview の2番目の出力は､ 代数ﾙｰﾌﾟを発生させることなく､ ﾌﾞﾛｯｸの入力の計算に確実にﾌｨｰﾄﾞﾊﾞｯｸできます｡  一方､ 1番目の出力は､ 最新の計算を示します｡ \n\nenable 信号がfalseの場合､  ﾌﾞﾛｯｸが使用できなくなり､ 状態と出力の値は､ ﾘｾｯﾄ以外では変更しません｡  enableｱｸｼｮﾝは ﾍﾞｸﾄﾙ化され､ ｽｶﾗ拡張をｻﾎﾟｰﾄします｡

% The following messages are from MaskPrompt in "simulink.mdl".
<(sl.mdl_Prompt)Main
>(sl.mdl_Prompt)ﾒｲﾝ
<(sl.mdl_Prompt)Data type:
>(sl.mdl_Prompt)ﾃﾞｰﾀ ﾀｲﾌﾟ:
<(sl.mdl_Prompt)Use Specified Scaling
>(sl.mdl_Prompt)指定したｽｹｰﾘﾝｸﾞの使用
<(sl.mdl_Prompt)Best Precision: Element-wise
>(sl.mdl_Prompt)最高精度: 要素について
<(sl.mdl_Prompt)Best Precision: Row-wise
>(sl.mdl_Prompt)最高精度: 行について
<(sl.mdl_Prompt)Best Precision: Column-wise
>(sl.mdl_Prompt)最高精度: 列について
<(sl.mdl_Prompt)Specify via dialog
>(sl.mdl_Prompt)ﾀﾞｲｱﾛｸﾞにより指定
<(sl.mdl_Prompt)Data store memory block: 
>(sl.mdl_Prompt)ﾃﾞｰﾀｽﾄｱﾒﾓﾘﾌﾞﾛｯｸ: 
<(sl.mdl_Prompt)Output data type and scaling:
>(sl.mdl_Prompt)ﾃﾞｰﾀﾀｲﾌﾟとｽｹｰﾘﾝｸﾞの出力:
<(sl.mdl_Prompt)Output data type and scaling:
>(sl.mdl_Prompt)ﾃﾞｰﾀﾀｲﾌﾟとｽｹｰﾘﾝｸﾞの出力:
<(sl.mdl_Prompt)Output data type:     ex.  sfix(16),  uint(8),  float('single')
>(sl.mdl_Prompt)ﾃﾞｰﾀﾀｲﾌﾟの出力:     例えば､  sfix(16),  uint(8),  float('single')
<(sl.mdl_Prompt)Vector of time values:
>(sl.mdl_Prompt)時間の値のﾍﾞｸﾄﾙ:
<(sl.mdl_Prompt)Look-Up Method:
>(sl.mdl_Prompt)ﾙｯｸｱｯﾌﾟの手法:
<(sl.mdl_Prompt)Number of Bits
>(sl.mdl_Prompt)ﾋﾞｯﾄ数
<(sl.mdl_Prompt)Number of delays:
>(sl.mdl_Prompt)遅延の数:
<(sl.mdl_Prompt)Initial condition for previous output:
>(sl.mdl_Prompt)前の出力に対する初期条件:
<(sl.mdl_Prompt)Round toward:
>(sl.mdl_Prompt)丸めの方向:
<(sl.mdl_Prompt)Saturate to max or min when overflows occur
>(sl.mdl_Prompt)ｵｰﾊﾞｰﾌﾛｰが起こる場合､ 上限または下限で飽和させる
<(sl.mdl_Prompt)Initial condition for previous weighted input K*u/Ts:
>(sl.mdl_Prompt)前の重み付き入力に対する初期条件 K*u/Ts:
<(sl.mdl_Prompt)Initial condition for previous output:
>(sl.mdl_Prompt)前の出力に対する初期条件:
<(sl.mdl_Prompt)Pole (in Z plane):
>(sl.mdl_Prompt)極 (Z 平面における):
<(sl.mdl_Prompt)Pole of compensator (in Z plane):
>(sl.mdl_Prompt)補償器の極 (Z 平面における):
<(sl.mdl_Prompt)Zero of compensator (in Z plane):
>(sl.mdl_Prompt)補償器の零点 (Z 平面における):
<(sl.mdl_Prompt)Initial condition for previous output:
>(sl.mdl_Prompt)前の出力に対する初期条件:
<(sl.mdl_Prompt)Initial condition for previous input:
>(sl.mdl_Prompt)前の入力に対する初期条件:
<(sl.mdl_Prompt)Zero (in Z plane):
>(sl.mdl_Prompt)ｾﾞﾛ (Z 平面における):
<(sl.mdl_Prompt)Weights:
>(sl.mdl_Prompt)重み:
<(sl.mdl_Prompt)Gain data type and scaling:
>(sl.mdl_Prompt)ﾃﾞｰﾀﾀｲﾌﾟとｽｹｰﾘﾝｸﾞの取得:
<(sl.mdl_Prompt)Coefficient of viscous friction (Gain):
>(sl.mdl_Prompt)粘性摩擦係数 (Gain):
<(sl.mdl_Prompt)Propagated scaling
>(sl.mdl_Prompt)伝搬 ｽｹｰﾘﾝｸﾞ
<(sl.mdl_Prompt)Propagated type
>(sl.mdl_Prompt)伝搬 ﾀｲﾌﾟ
<(sl.mdl_Prompt)1. Propagated data type:
>(sl.mdl_Prompt)1. 伝搬ﾃﾞｰﾀﾀｲﾌﾟ:
<(sl.mdl_Prompt)1.1. Propagated data type:     ex.  sfix(16),  uint(8),  float('single')
>(sl.mdl_Prompt)1.1. 伝搬ﾃﾞｰﾀﾀｲﾌﾟ:     例えば､  sfix(16),  uint(8),  float('single')
<(sl.mdl_Prompt)1.1. If any reference input is double, output is:
>(sl.mdl_Prompt)1.1. 参照入力がdoubleの場合の出力:
<(sl.mdl_Prompt)1.2. If any reference input is single, output is:
>(sl.mdl_Prompt)1.2. 参照入力がsingleの場合の出力:
<(sl.mdl_Prompt)1.3. Is-Signed:
>(sl.mdl_Prompt)1.3. Is-Signed:
<(sl.mdl_Prompt)1.4.1. Number-of-Bits: Base
>(sl.mdl_Prompt)1.4.1. ﾋﾞｯﾄ数: Base
<(sl.mdl_Prompt)1.4.2. Number-of-Bits: Multiplicative adjustment
>(sl.mdl_Prompt)1.4.2. ﾋﾞｯﾄ数: 乗算の調整
<(sl.mdl_Prompt)1.4.3. Number-of-Bits: Additive adjustment
>(sl.mdl_Prompt)1.4.3. ﾋﾞｯﾄ数: 加算の調整
<(sl.mdl_Prompt)1.4.4. Number-of-Bits: Allowable final values
>(sl.mdl_Prompt)1.4.4. ﾋﾞｯﾄ数: 許容可能な最終値
<(sl.mdl_Prompt)2. Propagated scaling:
>(sl.mdl_Prompt)2. 伝搬 ｽｹｰﾘﾝｸﾞ:
<(sl.mdl_Prompt)2.1. Propagated scaling:    Slope or [Slope Bias]    ex.  2^-9
>(sl.mdl_Prompt)2.1. 伝搬 ｽｹｰﾘﾝｸﾞ:    Slope または [Slope Bias]    例えば､  2^-9 
<(sl.mdl_Prompt)2.1. Values used to determine best precision scaling.
>(sl.mdl_Prompt)2.1. 最高精度のｽｹｰﾘﾝｸﾞの決定に使用される値
<(sl.mdl_Prompt)2.1.1. Slope: Base
>(sl.mdl_Prompt)2.1.1. ｽﾛｰﾌﾟ: Base
<(sl.mdl_Prompt)2.1.2. Slope: Multiplicative adjustment
>(sl.mdl_Prompt)2.1.2. ｽﾛｰﾌﾟ: 乗算の調整
<(sl.mdl_Prompt)2.1.3. Slope: Additive adjustment
>(sl.mdl_Prompt)2.1.3. ｽﾛｰﾌﾟ: 加算の調整
<(sl.mdl_Prompt)2.2.1. Bias: Base
>(sl.mdl_Prompt)2.2.1. ﾊﾞｲｱｽ: Base
<(sl.mdl_Prompt)2.2.2. Bias: Multiplicative adjustment:
>(sl.mdl_Prompt)2.2.2. ﾊﾞｲｱｽ: 乗算の調整:
<(sl.mdl_Prompt)2.2.3. Bias: Additive adjustment:
>(sl.mdl_Prompt)2.2.3. ﾊﾞｲｱｽ: 加算の調整:
<(sl.mdl_Prompt)Operation:
>(sl.mdl_Prompt)操作:
<(sl.mdl_Prompt)Weight value:
>(sl.mdl_Prompt)重みの値:
<(sl.mdl_Prompt)Implement using:
>(sl.mdl_Prompt)実行に使用:
<(sl.mdl_Prompt)Input and Output to have equal:
>(sl.mdl_Prompt)入力と出力は､ つぎの等しい値をもちます:
<(sl.mdl_Prompt)Round integer calculation toward:
>(sl.mdl_Prompt)丸めの整数計算の方向:
<(sl.mdl_Prompt)Interval closed on right
>(sl.mdl_Prompt)右側に近い区間
<(sl.mdl_Prompt)Interval closed on left
>(sl.mdl_Prompt)左側に近い区間
<(sl.mdl_Prompt)Index of bit (0 is least significant):
>(sl.mdl_Prompt)ﾋﾞｯﾄのｲﾝﾃﾞｯｸｽ (0 は最下位):
<(sl.mdl_Prompt)Use bit mask ...
>(sl.mdl_Prompt)ﾋﾞｯﾄﾏｽｸ の使用...
<(sl.mdl_Prompt)Bit Mask
>(sl.mdl_Prompt)ﾋﾞｯﾄﾏｽｸ
<(sl.mdl_Prompt)Treat mask as:
>(sl.mdl_Prompt)ﾏｽｸの取り扱い:
<(sl.mdl_Prompt)Number of bits to shift right (use negative value to shift left):
>(sl.mdl_Prompt)右にｼﾌﾄするﾋﾞｯﾄ数 (左にｼﾌﾄするためには負の値を使用します):
<(sl.mdl_Prompt)Number of places by which binary point shifts right (use negative value to shift left):
>(sl.mdl_Prompt)ﾊﾞｲﾅﾘ ﾎﾟｲﾝﾄが右にｼﾌﾄする数 (左にｼﾌﾄするためには負の値を使用します):
<(sl.mdl_Prompt)Bits to extract:
>(sl.mdl_Prompt)ﾋﾞｯﾄ展開:
<(sl.mdl_Prompt)Output scaling mode:
>(sl.mdl_Prompt)出力のｽｹｰﾘﾝｸﾞﾓｰﾄﾞ:
<(sl.mdl_Prompt)First input (row) breakpoint set:
>(sl.mdl_Prompt)1番目の入力(行)のﾌﾞﾚｰｸﾎﾟｲﾝﾄの設定:
<(sl.mdl_Prompt)Begin index searches using previous index results
>(sl.mdl_Prompt)前のｲﾝﾃﾞｯｸｽの結果を使用して、ｲﾝﾃﾞｯｸｽ検索を開始
<(sl.mdl_Prompt)Begin index search using previous index result
>(sl.mdl_Prompt)前のｲﾝﾃﾞｯｸｽの結果を使用して、ｲﾝﾃﾞｯｸｽ検索を開始
<(sl.mdl_Prompt)Process out of range input:
>(sl.mdl_Prompt)範囲外の入力の処理:
<(sl.mdl_Prompt)Number of sub-table selection dimensions:
>(sl.mdl_Prompt)ｻﾌﾞﾃｰﾌﾞﾙ選択次元数:
<(sl.mdl_Prompt)Make table an input
>(sl.mdl_Prompt)入力のﾃｰﾌﾞﾙの作成
<(sl.mdl_Prompt)Number of data points for lookup table:
>(sl.mdl_Prompt)ﾙｯｸｱｯﾌﾟﾃｰﾌﾞﾙに対するﾃﾞｰﾀ点の数:
<(sl.mdl_Prompt)Numerator coefficients:
>(sl.mdl_Prompt)分子係数:
<(sl.mdl_Prompt)Denominator coefficients excluding lead (which must be 1.0):
>(sl.mdl_Prompt)先頭を除く分母係数 (これは､ 1.0である必要があります):
<(sl.mdl_Prompt)State Matrix A:
>(sl.mdl_Prompt)状態行列 A:
<(sl.mdl_Prompt)Input Matrix B:
>(sl.mdl_Prompt)入力行列 B:
<(sl.mdl_Prompt)Output Matrix C:
>(sl.mdl_Prompt)出力行列 C:
<(sl.mdl_Prompt)Direct Feedthrough Matrix D:
>(sl.mdl_Prompt)ﾀﾞｲﾚｸﾄﾌｨｰﾄﾞｽﾙｰ行列 D:
<(sl.mdl_Prompt)Initial condition for state:
>(sl.mdl_Prompt)状態に対する初期条件:
<(sl.mdl_Prompt)Data type for internal calculations:     ex.  sfix(16),  uint(8),  float('single')
>(sl.mdl_Prompt)内部計算に対するﾃﾞｰﾀﾀｲﾌﾟ:     例えば､  sfix(16),  uint(8),  float('sin
<(sl.mdl_Prompt)Scaling for State Equation AX+BU:   ex.  2^-9
>(sl.mdl_Prompt)状態方程式 AX+BUに対するｽｹｰﾘﾝｸﾞ:   例えば､  2^-9
<(sl.mdl_Prompt)Scaling for Output Equation CX+DU:   ex.  2^-9
>(sl.mdl_Prompt)出力方程式 CX+DU に対するｽｹｰﾘﾝｸﾞ:   例えば､  2^-9
<(sl.mdl_Prompt)Lock output scaling so autoscaling tool can't change it
>(sl.mdl_Prompt)出力ｽｹｰﾘﾝｸﾞをﾛｯｸし､ 自動ｽｹｰﾘﾝｸﾞﾂｰﾙによる変更を防ぐ
<(sl.mdl_Prompt)Order output vector starting with:
>(sl.mdl_Prompt)つぎで始まる出力ﾍﾞｸﾄﾙを並べる:
<(sl.mdl_Prompt)Sample time mode:
>(sl.mdl_Prompt)ｻﾝﾌﾟﾙ時間ﾓｰﾄﾞ:

<(simulink_extras.mdl)Vector expressions for numerator, and denominator. Coefficients are in descending powers of z.
>(simulink_extras.mdl)分子と分母に対するﾍﾞｸﾄﾙ式｡ 係数は、z のベキの降順です。
<(simulink_extras.mdl)Vector expressions for numerator, denominator, and gain.
>(simulink_extras.mdl)分子、分母、ｹﾞｲﾝに対するﾍﾞｸﾄﾙ式｡
<(simulink_extras.mdl)Enter expressions for proportional, integral, and derivative terms.\nP+I/s+Ds
>(simulink_extras.mdl)比例､ 積分､ 微分の項に対する式の入力｡\nP+I/s+Ds
<(simulink_extras.mdl)Enter Proportional(P), Integral(I), and Derivative(D) and divisor (N) terms.\nP+I/s+Ds/(1/Ns+1)
>(simulink_extras.mdl)比例(P), 積分(I), 微分(D) divisor (N) termsを入力してください｡\nP+I/s+Ds/(1/Ns+1)
<(simulink_extras.mdl)State-Space model matrices:\ndx/dt = Ax + Bu\ny=Cx +Du
>(simulink_extras.mdl)状態空間ﾓﾃﾞﾙ行列:\ndx/dt = Ax + Bu\ny=Cx +Du
<(simulink_extras.mdl)Plots the auto correlation of the input.\nRequires signal processing toolbox.
>(simulink_extras.mdl)入力信号のcross correlationをﾌﾟﾛｯﾄします｡\nsignal processing toolbox が必要です｡
<(simulink_extras.mdl)Plots the averaged PSD of the input.
>(simulink_extras.mdl)入力の平均PSDをﾌﾟﾛｯﾄします｡
<(simulink_extras.mdl)Implements an Averaging Spectrum analyzer.\nHook input 1 to system input.\nHook input 2 to system output.
>(simulink_extras.mdl)平均化したｽﾍﾟｸﾄﾙ解析を実行します｡\n1番目の入力にｼｽﾃﾑの入力を結合。\n2番目の入力にｼｽﾃﾑの出力を結合。
<(simulink_extras.mdl)Plots the cross correlation of the input signals.\nRequires signal processing toolbox.
>(simulink_extras.mdl)入力信号の相互相関をﾌﾟﾛｯﾄします｡\nSignal processing toolbox が必要です｡
<(simulink_extras.mdl)Displays selected signals as bar plot while the simulation is running (i.e., click on signal lines to see their values displayed).  To select multiple signals use shift-click.  Each signal is displayed in its own axes, using the corresponding set of Y-Limits.
>(simulink_extras.mdl)ｼﾐｭﾚｰｼｮﾝの実行中､ 選択した信号をﾊﾞｰﾌﾟﾛｯﾄとして表示します｡ (すなわち､ 信号ﾗｲﾝ上をｸﾘｯｸして､ その値を表示させます)｡  複数の信号を選択するためには､ shift-clickを使用します｡  各信号は､ 対応するYの範囲を使用して､それぞれの軸に表示されています｡
<(simulink_extras.mdl)Plot the PSD of the input.
>(simulink_extras.mdl)入力のPSDをﾌﾟﾛｯﾄ｡
<(simulink_extras.mdl)Implements a Spectrum Analyzer.\nHook input 1 to system input.\nHook input 2 to system output.
>(simulink_extras.mdl)ｽﾍﾟｸﾄﾙ解析を実行します｡\n1番目の入力にｼｽﾃﾑの入力を結合｡\n2番目の入力にｼｽﾃﾑの出力を結合。
<(simulink_extras.mdl)Digital clock.\nOutput is set to 1 for the first half of the period.
>(simulink_extras.mdl)ﾃﾞｼﾞﾀﾙ ｸﾛｯｸ｡\n出力は､ 最初の半周期に対して､ 1に設定されます｡
<(simulink_extras.mdl)D Flip-Flop Block
>(simulink_extras.mdl)D Flip-Flop ﾌﾞﾛｯｸ
<(simulink_extras.mdl)J-K Flip-Flop Block (Negative Edge Triggered)
>(simulink_extras.mdl)J-K Flip-Flop ﾌﾞﾛｯｸ (立ち下り動作)
<(simulink_extras.mdl)Switched derivative with proper transfer function approximation for linearization.
>(simulink_extras.mdl)線形化に対するﾌﾟﾛﾊﾟｰな伝達関数の推定で切り替え可能な微分器
<(simulink_extras.mdl)Transformation from cartesian to polar coordinates.\n[x, y] -> [r, theta]\n\nr = sqrt(x^2 + y^2);\ntheta = atan(y/x);
>(simulink_extras.mdl)直交座標から極座標への変換｡\n[x, y] -> [r, theta]\n\nr = sqrt(x^2 + y^2);\ntheta = atan(y/x);
<(simulink_extras.mdl)Transformation from cartesian to spherical coordinates.\n[x, y, z] -> [r, theta, phi]\n\np = hypot(x,y); r = hypot(p,z);\ntheta = atan(y/x);\nphi = atan(p/z);
>(simulink_extras.mdl)直交座標から球座標への変換｡\n[x, y, z] -> [r, theta, phi]\n\np = hypot(x,y); r = hypot(p,z);\ntheta = atan(y/x);\nphi = atan(p/z);
<(simulink_extras.mdl)Conversion from degrees Celsius to degrees Fahrenheit.\n\nF=9/5*C+32
>(simulink_extras.mdl)摂氏から華氏への変換｡\n\nF=9/5*C+32
<(simulink_extras.mdl)Conversion from Degrees to Radians.\n\nR=pi/180*D
>(simulink_extras.mdl)度からﾗｼﾞｱﾝへの変換｡\n\nR=pi/180*D
<(simulink_extras.mdl)Conversion from degrees Fahrenheit to degrees Celsius.\n\nC=5/9*(F-32);
>(simulink_extras.mdl)華氏から摂氏への変換｡\n\nC=5/9*(F-32);
<(simulink_extras.mdl)Transformation from polar to cartesian coordinates.\n[r, theta] -> [x, y]\n\nx = r * cos(theta);\ny = r * sin(theta);\n
>(simulink_extras.mdl)極座標から直交座標への変換｡\n[r, theta] -> [x, y]\n\nx = r * cos(theta);\ny = r * sin(theta);\n
<(simulink_extras.mdl)Conversion from Radians to Degrees.\n\nD=180/pi*R
>(simulink_extras.mdl)ﾗｼﾞｱﾝから度への変換｡\n\nD=180/pi*R
<(simulink_extras.mdl)Transformation from spherical to cartesian coordinates.\n[r, theta, phi] -> [x, y, z]\n\nx = r * sin(phi) * cos(theta);\ny = r * sin(phi) * sin(theta);\nz = r * cos(phi);
>(simulink_extras.mdl)球座標から直交座標への変換｡\n[r, theta, phi] -> [x, y, z]\n\nx = r * sin(phi) * cos(theta);\ny = r * sin(phi) * sin(theta);\nz = r * cos(phi);
<(simulink_extras.mdl)XY scope using MATLAB graph window.  First input is used as time base.  Enter plotting ranges.
>(simulink_extras.mdl)MATLAB ｸﾞﾗﾌｳｨﾝﾄﾞｳを使用するXY ｽｺｰﾌﾟ｡ 1番目の入力は､ 時間ﾍﾞｰｽとして使用されます｡ ﾌﾟﾛｯﾄの範囲を入力してください｡

<(sltbledit)To create Lookup Table Editor, the second argument must be a model handle
>(sltbledit)Lookup Tableｴﾃﾞｨﾀを作成するには、2番目の引数がﾓﾃﾞﾙのﾊﾝﾄﾞﾙでなければなりません。
<(sltbledit)Internal error while opening Lookup Table Editor.
>(sltbledit)Lookup Tableｴﾃﾞｨﾀが開いている間の内部ｴﾗｰ。
<(sltbledit)There is no Simulink model currently open. Lookup Table Editor loading is stopped.
>(sltbledit)現在開いているSimulinkﾓﾃﾞﾙがありません。Lookup Tableｴﾃﾞｨﾀの読み込みを停止します。
<(sltbledit)Incorrect call to '%s' dialog function
>(sltbledit)%s ﾀﾞｲｱﾛｸﾞ関数の呼び出しが正しくありません
<(sltbledit)Error reported by block '%s': \nThe number of dimensions in the table data is %s while the number of dimensions specified in the block is %s. They must match.
>(sltbledit)ﾌﾞﾛｯｸ'%s'によるｴﾗｰが報告されました: \nﾃｰﾌﾞﾙﾃﾞｰﾀの次元数が %s であるにも拘わらず、ﾌﾞﾛｯｸに指定された次元数は %s です。これらは一致していなければなりません。
<(sltbledit)Error reported by block '%s': \nThe size of the %s dimension in the table data must equal to the size of the %s breakpoint data.
>(sltbledit)ﾌﾞﾛｯｸ '%s' でｴﾗｰが報告されました: \nﾃｰﾌﾞﾙﾃﾞｰﾀの%sの次元の大きさは、%s のﾌﾞﾚｰｸﾎﾟｲﾝﾄﾃﾞｰﾀの大きさに等しくなければなりません。
<(sltbledit)Breakpoints
>(sltbledit)ﾌﾞﾚｰｸﾎﾟｲﾝﾄ
<(sltbledit)Column
>(sltbledit)列
<(sltbledit)Row
>(sltbledit)行
<(sltbledit)Lookup Table Editor: 
>(sltbledit)Lookup Tableｴﾃﾞｨﾀ: 
<(sltbledit)Lookup Table Blocks Type Configuration has been updated.
>(sltbledit)Lookup Table Blocks Type Configurationが更新されました。
<(sltbledit)Please exit current MATLAB session to make change effective.
>(sltbledit)変更を有効にするためにｶﾚﾝﾄのMATLABｾｯｼｮﾝを終了してください。
<(sltbledit)Error occurred when adding preference on Lookup Table Blocks Type Configuration.
>(sltbledit)Lookup Table Blocks Type Configurationの設定を追加するときにｴﾗｰが発生しました。
<(sltbledit)Please check the entry format.
>(sltbledit)入力形式を確認してください。
<(sltbledit)You don't have Lookup Table Blocks Type Configuration preference set up.
>(sltbledit)Lookup Table Blocks Type Configurationが設定されていません。
<(sltbledit)To have it initialized, please open Lookup Table Editor to do it. Adding preference ignored.
>(sltbledit)初期化を行うためにLookup Tableｴﾃﾞｨﾀを開いてください。追加した設定は無視されます。
<(sltbledit)Table data and/or breakpoint data have changed. \nDo you want to update the block data?
>(sltbledit)ﾃｰﾌﾞﾙﾃﾞｰﾀおよび/またはﾌﾞﾚｰｸﾎﾟｲﾝﾄﾃﾞｰﾀが変更されました。 \nﾌﾞﾛｯｸﾃﾞｰﾀを更新しますか？
<(sltbledit)Lookup Table Editor Warning
>(sltbledit)Lookup Tableｴﾃﾞｨﾀ ﾜｰﾆﾝｸﾞ
<(sltbledit)Error loading help for Lookup Table Editor.
>(sltbledit)Lookup Tableｴﾃﾞｨﾀのﾍﾙﾌﾟの読み込み中にｴﾗｰ
<(sltbledit)Lookup Table Editor: No table data for this block.\n
>(sltbledit)Lookup Tableｴﾃﾞｨﾀ: このﾌﾞﾛｯｸのﾃｰﾌﾞﾙﾃﾞｰﾀがありません。\n
<(sltbledit)Annotations denote column breakpoints
>(sltbledit)注釈は列のﾌﾞﾚｰｸﾎﾟｲﾝﾄを表します
<(sltbledit)Table data
>(sltbledit)ﾃｰﾌﾞﾙﾃﾞｰﾀ
<(sltbledit)Row breakpoints
>(sltbledit)行 ﾌﾞﾚｰｸﾎﾟｲﾝﾄ
<(sltbledit)Table and breakpoints data for block:\n
>(sltbledit)ﾌﾞﾛｯｸのﾃｰﾌﾞﾙとﾌﾞﾚｰｸﾎﾟｲﾝﾄﾃﾞｰﾀ:\n
<(sltbledit)Row index
>(sltbledit)行 ｲﾝﾃﾞｯｸｽ
<(sltbledit)Column index
>(sltbledit)列 ｲﾝﾃﾞｯｸｽ
<(sltbledit)Table data for block:\n
>(sltbledit)ﾌﾞﾛｯｸのﾃｰﾌﾞﾙﾃﾞｰﾀ:\n
<(sltbledit)Selecting table data at:
>(sltbledit)ﾃｰﾌﾞﾙﾃﾞｰﾀの選択:
<(sltbledit)Row breakpoint: %s
>(sltbledit)行 ﾌﾞﾚｰｸﾎﾟｲﾝﾄ: %s
<(sltbledit)Column breakpoint: %s
>(sltbledit)列 ﾌﾞﾚｰｸﾎﾟｲﾝﾄ: %s
<(sltbledit)Table data: %s
>(sltbledit)ﾃｰﾌﾞﾙﾃﾞｰﾀ: %s
<(sltbledit)Lookup Table Blocks Type Configuration has been updated.
>(sltbledit)Lookup Table Blocks Type Configurationが更新されました。
<(sltbledit)Please exit current MATLAB session to make change effective.
>(sltbledit)変更を有効にするためにｶﾚﾝﾄのMATLABｾｯｼｮﾝを終了してください。
<(sltbledit)Error occurred when removing preference from Lookup Table Blocks Type Configuration.
>(sltbledit)Lookup Table Blocks Type Configurationから設定を移動するときにｴﾗｰが発生しました。
<(sltbledit)Please check the entry format.
>(sltbledit)入力形式を確認してください。
<(sltbledit)To have it initialized, please open Lookup Table Editor to do it. Removing preference ignored.
>(sltbledit)初期化を行うためにLookup Tableｴﾃﾞｨﾀを開いてください。追加した設定は無視されます。
<(sltbledit)Table data and/or breakpoint data have changed. \nDo you want to update the block data?
>(sltbledit)ﾃｰﾌﾞﾙﾃﾞｰﾀおよび/またはﾌﾞﾚｰｸﾎﾟｲﾝﾄﾃﾞｰﾀが変更されました。 \nﾌﾞﾛｯｸﾃﾞｰﾀを更新しますか？
<(sltbledit)Lookup Table Editor Warning
>(sltbledit)Lookup Tableｴﾃﾞｨﾀ ﾜｰﾆﾝｸﾞ
<(sltbledit)Plot window for Lookup Table Editor
>(sltbledit)Lookup Tableｴﾃﾞｨﾀのﾌﾟﾛｯﾄｳｨﾝﾄﾞｳ
<(sltbledit)Command you entered '%s' is not supported.
>(sltbledit)入力したｺﾏﾝﾄﾞ '%s' はｻﾎﾟｰﾄされません。
<(sltbledit)\nWarning: Lookup Table Editor can not resolve parameter '%s' in block '%s/%s'.\nTo have them displayed correctly, use Update diagram from Simulink Edit menu.\n
>(sltbledit)\nﾜｰﾆﾝｸﾞ: Lookup Tableｴﾃﾞｨﾀはﾌﾞﾛｯｸ '%s/%s' のﾊﾟﾗﾒｰﾀ '%s' を表示できません。\nこれらを正しく表示するために、Simulinkの編集ﾒﾆｭｰからﾓﾃﾞﾙの更新を選んでください。\n
<(sltbledit)Error occurs while retrieving data, check the selected block's parameter setting.
>(sltbledit)ﾃﾞｰﾀ検索中にｴﾗｰが発生しました。選択したﾌﾞﾛｯｸのﾊﾟﾗﾒｰﾀを確認してください。
<(sltbledit)Assertion failed: data is not numeric array.
>(sltbledit)Assertion failed: ﾃﾞｰﾀが数値配列ではありません。
<(sltbledit)Block parameter "%s" is an expression. Do you want it to be replaced by numeric data?
>(sltbledit)ﾌﾞﾛｯｸﾊﾟﾗﾒｰﾀ "%s" は式です。数値ﾃﾞｰﾀに置き換えますか？
<(sltbledit)The size of the data you are trying to set in the block is larger than 64K bytes. This will result in the corruption of the model when you save it.\nYou may use variables for desired block parameters and save the variables in MAT file.
>(sltbledit)ﾌﾞﾛｯｸに設定しようとしているﾃﾞｰﾀの大きさは64Kﾊﾞｲﾄ以上あります。これはﾓﾃﾞﾙの保存時に不正な結果になることがあります。\n所望のﾌﾞﾛｯｸﾊﾟﾗﾒｰﾀに対して変数を使用し、その変数をMATﾌｧｲﾙに保存するようにしてください。
<(sltbledit)Workspace variable "%s" is not empty and could be used by multiple places.\nDo you want to overwrite it?
>(sltbledit)ﾜｰｸｽﾍﾟｰｽ変数 "%s" は空ではなく、また複数の場所で使用することができます。\n上書きしますか？
<(sltbledit)Lookup Table Editor can only display two dimensional data in its numerical data table. Please select at most two "All"s from the dimension selector. Otherwise, only the first two will be displayed.'
>(sltbledit)Lookup Tableｴﾃﾞｨﾀは数値的なﾃﾞｰﾀﾃｰﾌﾞﾙ内にある2次元ﾃﾞｰﾀの表示のみ行えます。次元の選択から多くても2つの"All"を選択してください。そうしない場合、最初の2つのみ表示します。'

% $Revision: 1.3.2.3 $ $Date: 2004/03/21 23:04:55 $
