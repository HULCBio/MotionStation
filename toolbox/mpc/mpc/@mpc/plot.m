function [ho, hi] = plot(Obj, t, y, r, u, v, d, ho0, hi0, Resp)

% [ho, hi] = plot(Obj, t, y, r, u, v, d, ho0, hi0, Resp)
%
% Plot responses generated by MPC simulations.
%
% REQUIRED INPUTS:
% Obj   MPC object containing signal type definitions and labels.
% t     Vector of time values, length Nt.
% y     Matrix of output responses, size [Nt, Ny], Ny = number of outputs.
% r     Matrix of setpoints (if closed-loop), same size as y.  If open-loop
%       use r = [];
% u     Matrix of manipulated variable inputs, size [Nt, nu].
% v     Matrix of measured disturbance inputs, size [Nt, nv].
% d     Matrix of unmeasured disturbance inputs, size [Nt, nd].
%
% OPTIONAL INPUTS:
% ho0   Response plot for outputs (class = resppack.timeplot).  Assumed
%       to have been created in a previous call with the same Obj.
% hi0   Response plot for inputs (class = resppack.timeplot).  Assumed
%       to have been created in a previous call with the same Obj.
% Resp  Response name (string).  If ho0 and hi0 already contain a
%       response with this name, it will be replaced with the new data.
%       Otherwise, the new data will be plotted together with any existing
%       data (for comparisons).
%
% OPTIONAL OUTPUTS:
% ho,hi Response plot objects for possible reuse as ho0, hi0 inputs, or
%       for plot customization.
%
% See also SIM, MPC

%  Author(s):  Larry Ricker and James Owen
%  Copyright 1986-2004 The MathWorks, Inc.
%  $Revision: 1.1.8.7 $ $Date: 2004/04/16 22:08:57 $

if isempty(Obj),
    error('mpc:plot:empty','Empty MPC object');
end
if nargin<2 || length(t)<2
    error('mpc:plot:notime', ...
        'Simulation plots require a time vector of length at least 2')
end
    
    
Plant = Obj.Model.Plant;
InGrp = Plant.InputGroups;
InName = Plant.InputName;
Nin = length(InName);
Nmv = length(InGrp.Manipulated);
if isfield(InGrp, 'Measured')
    Nmd = length(InGrp.Measured);
else
    Nmd = 0;
end
if isfield(InGrp, 'Unmeasured')
    Nud = length(InGrp.Unmeasured);
else
    Nud = 0;
end
OutName = Plant.OutputName;
Nout = length(OutName);

% Error checking
SizeT = size(t);
if SizeT ~= 1
    error('mpc:plot:sizet', ...
        sprintf('size(t) = [%i, %i].  Must be a row or column vector.', ...
        SizeT));
end
Nt = max(SizeT);
if ~isempty(r)
    [n, ny] = size(r);
    if  ny ~= Nout
        error('mpc:plot:sizer', ...
            sprintf('size(r) = [:, %i].  Expected [:, %i].', ...
            ny, Nout));
    end
end
[n, ny] = size(y);
if n ~= Nt || ny ~= Nout
    error('mpc:plot:sizey', ...
        sprintf('size(y) = [%i, %i].  Expected [%i, %i].', ...
        n, ny, Nt, Nout));
end
[n, nu] = size(u);
if nu ~= Nmv
    error('mpc:plot:sizeu', ...
        sprintf('size(u) = [:, %i].  Expected [:, %i].', ...
        nu, Nmv));
end

if isempty(v)
    if Nmd ~= 0
        error('mpc:plot:sizev', ...
            sprintf('size(v) = [0, 0].  Expected [%i, %i].', Nt, Nmd));
    end
else
    [n, nv] = size(v);
    if nv ~= Nmd
        error('mpc:plot:sizev', ...
            sprintf('size(v) = [:, %i].  Expected [:, %i].', ...
            nv, Nmd));
    end
end
if isempty(d)
    if Nud ~= 0
        error('mpc:plot:sized', ...
            sprintf('size(d) = [0, 0].  Expected [%i, %i].', Nt, Nud));
    end
else
    [n, nd] = size(d);
    if nd ~= Nud
        error('mpc:plot:sized', ...
            sprintf('size(d) = [:, %i].  Expected [:, %i].', ...
            nd, Nud));
    end
end

Prefs = cstprefs.tbxprefs;
Pos = [];
axIn = [];

% Define response plot objects if necessary.
if nargin < 8 || isempty(ho0) || ~ishandle(ho0) || ...
        ~isa(ho0, 'mpcobjects.simplot')
    
    NewOut = true;
    [axIn,axOut] = LocalGetAxes(Prefs);
    for i = 1:Nout
        if isempty(OutName{i})
            OutName{i} = sprintf('Out(%i)', i);
        end
    end
    ho = mpcobjects.simplot(axOut, Nout, 'OutputName', OutName,...
        'Tag', 'mpc','Type','outputs');
    if ~isempty(r)
        ho.setInputWidth(Nout);
        SetpointName = cell(Nout,1);
        for i = 1:Nout
            SetpointName{i} = [OutName{i}, ' Setpoint'];
        end
        ho.Input.ChannelName = SetpointName; 
    end
    
    ho.Preferences = Prefs;

    % Delete datatips when the axis is clicked
    set(allaxes(ho),'ButtonDownFcn',{@LocalAxesButtonDownFcn ho});
    % Control cursor and datatip popups over characteristic markers
    % REVISIT: remove this code when MouseEntered/Exited event available
    fig = ho.AxesGrid.Parent;
    if isempty(get(fig,'WindowButtonMotionFcn'))
        set(fig,'WindowButtonMotionFcn',@hoverfig)
    end
    Pos = get(fig, 'Position');
else
    NewOut = false;
    ho = ho0;
end
if nargin < 9 || isempty(hi0) || ~ishandle(hi0) || ...
        ~isa(hi0, 'mpcobjects.simplot')
    
    NewIn = true;
    for i = 1:Nin
        if isempty(InName{i})
            InName{i} = sprintf('In(%i)', i);
        end
    end
    
    % If no input axes are created - create them
    if isempty(axIn)
        axIn = axes;
        LocalSetAxesPrefs(axIn,Prefs)
    end    
    hi = mpcobjects.simplot(axIn, Nin, 'OutputName', InName,...
        'Tag', 'mpc','Type', 'inputs','Preferences',Prefs);
    
    % Delete datatips when the axis is clicked
    set(allaxes(hi),'ButtonDownFcn',{@LocalAxesButtonDownFcn hi})
    % Control cursor and datatip popups over characteristic markers
    % REVISIT: remove this code when MouseEntered/Exited event available
    fig = hi.AxesGrid.Parent;
    if isempty(get(fig,'WindowButtonMotionFcn'))
        set(fig,'WindowButtonMotionFcn',@hoverfig)
    end
    if ~isempty(Pos)
        Pos1 = get(fig, 'Position');
        set(fig, 'Position', [Pos(1)-10, Pos(2)+20, Pos(3) Pos(4)]);
    end
else
    NewIn = false;
    hi = hi0;
end
if nargin < 10
    Resp = localDefaultName(hi,ho);
end

% Load output data
Duration = [t(1) t(end)];
Ro = LocalAddData(ho, t, y, LocalInputCheck(r, t), Resp);

if NewOut
    % Right-click menus
    mo = mpcplotmenu(ho);

    % Add characteristics
    ho.addCharMenu(mo.Characteristics, xlate('Peak Response'),...
        'wavepack.TimePeakAmpData', 'wavepack.TimePeakAmpView',...
        'resppack.SimInputPeakView');

    if ~isempty(r)
        ho.Input.Visible = 'on';
    end
    ho.Visible = 'on';    
end

% Load input data
U = zeros(Nt,Nin); 
iMV = sort(Obj.Model.Plant.InputGroup.Manipulated);
U(:, iMV) = LocalInputCheck(u, t); 
InUnits = cell(1,Nin);
for i = 1:length(iMV)
    InUnits{iMV(i)} = Obj.ManipulatedVariables(i).Units;
end
if Nmd > 0
    iMD = sort(Obj.Model.Plant.InputGroup.Measured);
    U(:, iMD) = LocalInputCheck(v, t);
    for i = 1:length(iMD)
        InUnits{iMD(i)} = Obj.DisturbanceVariables(i).Units;
    end
end
if Nud > 0
    iUD = sort(Obj.Model.Plant.InputGroup.Unmeasured);
    U(:, iUD) = LocalInputCheck(d, t);
    for i = 1:length(iUD)
        InUnits{iUD(i)} = Obj.DisturbanceVariables(i+Nmd).Units;
    end
end
[ts, Us] = stairs(t, U);
Ri = LocalAddData(hi, ts(:,1), Us, [], Resp);

if NewIn
    % Right-click menus for input plot
    mi = mpcplotmenu(hi);

    % Add characteristics
    hi.addCharMenu(mi.Characteristics, xlate('Peak Response'),...
        'wavepack.TimePeakAmpData', 'wavepack.TimePeakAmpView',...
        'resppack.SimInputPeakView');
    
    hi.Visible = 'on';
end  
if Duration(2) > Duration(1)
    hi.setfocus(Duration,'sec','Time');
end
A = hi.AxesGrid;
A.YLabel = '';
for i = 1:Nin
    if ~isempty(InUnits{i})
        InName{i} = sprintf('%s, %s', InName{i}, InUnits{i});
    end
end
if Nin == 1
    A.Title = sprintf('Plant Input:  %s', InName{1});
    A.RowLabel = {''};
else
    A.Title = 'Plant Inputs';
    A.RowLabel = InName;
end
hi.draw;
if Duration(2) > Duration(1)
    ho.setfocus(Duration,'sec','Time');
end
A = ho.AxesGrid;
A.YLabel = '';
for i = 1:Nout
    Units = Obj.OutputVariables(i).Units;
    if ~isempty(Units)
        OutName{i} = sprintf('%s, %s', OutName{i}, Units);
    end
end
if Nout == 1
    A.Title = sprintf('Plant Output:  %s', OutName{1});
    A.RowLabel = {''};
else
    A.Title = 'Plant Outputs';
    A.RowLabel = OutName;
end
ho.draw;

% Set the appdata so that grouped plots can find eachother
ho.Appdata = struct('inputs',hi);
hi.Appdata = struct('outputs',ho);

% ---------------------------------------------------------------------
% Purpose:  Add data to plot
% ---------------------------------------------------------------------
function R = LocalAddData(h, t, A, Ai, Resp)

% Determine whether or not Resp exists
Rs = h.Responses;
R = [];
for i = 1:length(Rs)
    if strcmp(Rs(i).Name, Resp)
        R = Rs(i);
        break
    end
end

% If a response alrwady exists modify it
if ~isempty(R) && ishandle(R) && ~strcmpi(h.axesgrid.NextPlot,'add')
    set(R.Data,'Amplitude',A,'Time',t);
    %R.Data.setTime(t);
else    
    R = h.plot(t, A);
    R.Name = Resp;
end
    
if ~isempty(Ai)
    setinput(h, t , Ai, 'TimeUnits', 'sec');
end


% ---------------------------------------------------------------------
% Purpose:  Extend or clip an input variable
% ---------------------------------------------------------------------
function NewInput = LocalInputCheck(Input, T);

if isempty(Input)
    NewInput = [];
else
    nT = length(T);
    nI = size(Input, 1);
    if nI < nT
        % Extend
        NewInput = [Input ; ones(nT-nI,1)*Input(end,:)];
    elseif nI == nT
        % Copy
        NewInput = Input;
    else
        % Clip
        NewInput = Input(1:nT,:);
    end
end
        
% ----------------------------------------------------------------------------%
% Purpose: Assign preferences to axes
% ----------------------------------------------------------------------------%
function [axIn,axOut] = LocalGetAxes(Prefs)

% Intialization
axIn = [];
axOut = [];
    
% If the user has selected the input axes but the output axes are needed or
% vice versa, switch to the other
ax = gca;
hOut = gcr(ax);
if isa(hOut,'mpcobjects.simplot') && ~isempty(hOut.Appdata)
    if strcmp(hOut.Type,'outputs')
        hIn = getfield(hOut.Appdata,'inputs');
    else
        hIn = hOut;
        hOut = getfield(hIn.Appdata,'outputs');        
    end
    % The other plot may be been deleted 
    if ishandle(hOut)
        axOuts = hOut.getaxes;
        axOut = axOuts(1);
    end        
    if ishandle(hIn)
        axIns = hIn.getaxes;
        axIn = axIns(1);
    end     
    % Build new axes to replace deleted ones
    if isempty(axIn)
        figure;
        axIn = axes;
        LocalSetAxesPrefs(axIn,Prefs)
    elseif isempty(axOut)
        figure;
        axOut = axes;
        LocalSetAxesPrefs(axOut,Prefs)
    end
    return
end

% Clean slate
axIn = ax;
LocalSetAxesPrefs(axIn,Prefs)
figure;
axOut = axes;
LocalSetAxesPrefs(axOut,Prefs)

   
% ----------------------------------------------------------------------------%
% Purpose: Axes callback to delete datatips when clicked
% ----------------------------------------------------------------------------%
function LocalAxesButtonDownFcn(EventSrc,EventData,RespPlot)
% Axes ButtonDown function
% Process event
switch get(get(EventSrc,'Parent'),'SelectionType')
   case 'normal'
      PropEdit = PropEditor(RespPlot,'current');  % handle of (unique) property editor
      if ~isempty(PropEdit) & PropEdit.isVisible
         % Left-click & property editor open: quick target change
         PropEdit.setTarget(RespPlot);
      end
      % Clear all data tips
      delete(find(handle(EventSrc), 'Tag', 'DataTipMarker'))
   case 'open'
      % Double-click: open editor
      if usejava('MWT')
         PropEdit = PropEditor(RespPlot);
         PropEdit.setTarget(RespPlot);
      end
end

function localManageHold(ax)

h = gcr(ax);  % is AX already associated with a response plot?
NewPlot = strcmp(get(ax,'NextPlot'),'replace');

if NewPlot
  % Clear any existing response plot upfront (otherwise style
  % settings below get erased by CLA in respplot/check_hold)
  if ~isempty(h)
    cla(h.AxesGrid,handle(ax))  % speed optimization
  end
  
  % Release manual limits and hide axis for optimal performance
  % RE: Manual negative Xlim can cause warning for BODE (not reset by clear)
  set(ax,'Visible','off','XlimMode','auto','YlimMode','auto')
end
  


function LocalSetAxesPrefs(ax,Prefs)

set(ax,...
   'XGrid',      Prefs.Grid,...
   'YGrid',      Prefs.Grid,...
   'XColor',     Prefs.AxesForegroundColor,...
   'YColor',     Prefs.AxesForegroundColor,...
   'FontSize',   Prefs.AxesFontSize,...
   'FontWeight', Prefs.AxesFontWeight,...
   'FontAngle',  Prefs.AxesFontAngle,...
   'Selected',   'off')
set(get(ax,'Title'),...
   'FontSize',  Prefs.TitleFontSize,...
   'FontWeight',Prefs.TitleFontWeight,...
   'FontAngle', Prefs.TitleFontAngle)
set(get(ax,'Title'),...
   'FontSize',  Prefs.TitleFontSize,...
   'FontWeight',Prefs.TitleFontWeight,...
   'FontAngle', Prefs.TitleFontAngle)
set([get(ax,'XLabel'),get(ax,'YLabel')],...
   'Color',[0 0 0],...
   'FontSize',  Prefs.XYLabelsFontSize,...
   'FontWeight',Prefs.XYLabelsFontWeight,...
   'FontAngle', Prefs.XYLabelsFontAngle)


function newName = localDefaultName(hi,ho)

currentNames = [get(hi.Responses,{'Name'}) get(ho.Responses,{'Name'})];
currentNames = [currentNames{:}];
n = 1;
while ~isempty(strfind(currentNames,sprintf('MPC response%d',n)))
      n = n+1;
end
newName = sprintf('MPC response%d',n);
