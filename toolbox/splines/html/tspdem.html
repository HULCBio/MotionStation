<!--
This HTML is auto-generated from an m-file.
Your changes will be overwritten.
--><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:x-large">The Tensor Product Construct</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Illustrate approximation to data on rectangular grid.
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd"> Copyright 1987-2003 C. de Boor and The MathWorks, Inc.
  $Revision: 1.2 $
</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium;">Overview</p><ul xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd"><li><a href="#Example: least-squares approximation to gridded data">Example: least-squares approximation to gridded data</a></li><li><a href="#NDGRID vs MESHGRID">NDGRID vs MESHGRID</a></li><li><a href="#Choice of spline space in y-direction">Choice of spline space in y-direction</a></li><li><a href="#Evaluation">Evaluation</a></li><li><a href="#From curves to a surface; choosing a spline space in the x-direction">From curves to a surface; choosing a spline space in the x-direction</a></li><li><a href="#Why does this evaluation work?">Why does this evaluation work?</a></li><li><a href="#More efficient alternatives">More efficient alternatives</a></li><li><a href="#Check this out">Check this out</a></li><li><a href="#Error">Error</a></li><li><a href="#Relative error">Relative error</a></li><li><a href="#Apparent bias of this approach">Apparent bias of this approach</a></li><li><a href="#Doing it the other way around">Doing it the other way around</a></li><li><a href="#Comparison with earlier plot of curves">Comparison with earlier plot of curves</a></li><li><a href="#Approximating to the coefficients">Approximating to the coefficients</a></li><li><a href="#Interpolation">Interpolation</a></li><li><a href="#Interpolation of resulting coefficients">Interpolation of resulting coefficients</a></li><li><a href="#Evaluation">Evaluation</a></li><li><a href="#Error">Error</a></li><li><a href="#Relative error">Relative error</a></li></ul><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;"><a name=""></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Since the toolbox can handle splines with  v e c t o r  coefficients, it is
easy to implement interpolation or approximation to gridded data by tensor
product splines. Most spline construction commands in the toolbox take
advantage of this.
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">However, you might be interested in seeing a detailed description of how
approximation to gridded data by tensor products is actually done for
bivariate data.  This will also come in handy when you need some tensor
product constructon not provided by the M-files in this toolbox.
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Example: least-squares approximation to gridded data<a name="Example: least-squares approximation to gridded data"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Consider, for example, least-squares approximation to given data
 z(i,j) = f(x(i),y(j)), i = 1,...,I, j = 1,...,J .
Here are some gridded data, taken from Franke's sample function.
Note that I have chosen the grid somewhat denser near the boundary, to help
pin down the approximation there.
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">x = sort([(0:10)/10,.03 .07, .93 .97]);
y = sort([(0:6)/6,.03 .07, .93 .97]);
[xx,yy] = ndgrid(x,y); z = franke(xx,yy);

<span style="color:green">% NOTE the use of NDGRID in preference to MESHGRID.</span>

mesh(x,y,z.'), view(150,50)
title(<span style="color:#B20000">'Data from Franke function'</span>)</pre><img xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" src="tspdem_img_03_01.gif"><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">NDGRID vs MESHGRID<a name="NDGRID vs MESHGRID"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Note that the statement
          [xx,yy] = ndgrid(x,y); z = franke(xx,yy);
used here makes certain that  Z(i,j)  is the value (of the function being
approximated) at the grid point (X(i),Y(j)).
However, the MATLAB command MESH(X,Y,Z) takes  Z(j,i)  as the value at the
grid point (X(i),Y(j)).
For that reason, the above plot is generated by
      mesh(x,y,z.')
i.e., using the transpose of the matrix Z .
Such transposing would not have been necessary, had I used MESHGRID instead
of NDGRID.
But the resulting Z would not have followed approximation theory standards.
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Choice of spline space in y-direction<a name="Choice of spline space in y-direction"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Next, I choose some knot sequence KNOTSY and spline order KY for the
y-direction, and then use the command
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">    sp = spap2(knotsy,ky,y,z);
</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">to obtain, in SP, a spline curve whose i-th component is an approximation to
the curve  (y,z(i,:)), i=1:I.
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">ky = 3; knotsy = augknt([0,.25,.5,.75,1],ky);

sp = spap2(knotsy,ky,y,z);</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Evaluation<a name="Evaluation"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">In particular,
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">  yy = -.1:.05:1.1;  vals = fnval(sp,yy);
</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">provides the array VALS whose entry VALS(i,j) can be taken as an
approximation to the value  f(X(i),YY(j))  of the underlying function
f  at the grid point (X(i),YY(j)) .  This is evident when we plot VALS
using MESH:
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">yy = -.1:.05:1.1;  vals = fnval(sp,yy);
mesh(x,yy,vals.'), view(150,50)
title(<span style="color:#B20000">'Simultaneous approximation to all curves in y-direction'</span>)</pre><img xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" src="tspdem_img_06_01.gif"><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;"><a name=""></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Note that, for each X(i), both the first two and the last two values
are zero since both the first two and the last two sites in YY are
outside the basic interval for the spline in SP.
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Note also the ridges. They confirm that we are plotting here smooth curves
in one direction only.
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">From curves to a surface; choosing a spline space in the x-direction<a name="From curves to a surface; choosing a spline space in the x-direction"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">To get an actual surface, we now have to go one step further.
Consider the coefficients COEFSY of the spline in SP, as obtained by
       coefsy = fnbrk(sp,'c');
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Abstractly, you can think of the spline in SP as the vector-valued function
      y |--&gt; sum_r COEFSY(:,r) B_{r,KY}(y)
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">with the i-th entry COEFSY(i,r) of the vector coefficient COEFSY(:,r)
corresponding to X(i) , i=1:I.  This suggests approximating each
curve  (X, COEFSY(:,r))  by a spline, using the same order KX and
the same appropriate knot sequence KNOTSX for every  r :
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">coefsy = fnbrk(sp,<span style="color:#B20000">'c'</span>);
kx = 4; knotsx = augknt(0:.2:1,kx);
sp2 = spap2(knotsx,kx,x,coefsy.');</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;"><a name=""></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">The command
        sp2 = spap2(knotsx,kx,x,coefsy.');
used here needs, perhaps, an explanation.
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Recall that  spap2(knots,k,x,fx)  treats  fx(:,j)  as the value at  x(j) ,
i.e., takes each  c o l u m n  of  fx  as a data value. Since we wanted to
fit the value COEFSY(i,:) at X(i), all  i , we have to present SPAP2 with
the  t r a n s p o s e  of COEFSY.
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;"><a name=""></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Now consider the transpose COEFS = CXY.'  of the coefficient matrix CXY
of the resulting spline `curve', as obtained by the command
     coefs = fnbrk(sp2,'c').';
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">COEFS provides the  b i v a r i a t e  spline approximation
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">   (x,y) |--&gt; sum_q sum_r COEFS(q,r) B_{q,KX}(x) B_{r,KY}(y)
</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">to the original data
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">  (X(i),Y(j)) |--&gt;  f(X(i),Y(j)) = Z(i,j) .
</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">We use SPCOL to provide the values B_{q,KX}(XV(i)) and B_{r,KY}(YV(j))
needed to evaluate this spline surface at some grid points (XV(i),YV(j))
and then use MESH to plot the values.
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">coefs = fnbrk(sp2,<span style="color:#B20000">'c'</span>).';
xv = 0:.025:1; yv = 0:.025:1;
values = spcol(knotsx,kx,xv)*coefs*spcol(knotsy,ky,yv).';
mesh(xv,yv,values.'), view(150,50)
title(<span style="color:#B20000">'The spline approximant'</span>)</pre><img xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" src="tspdem_img_10_01.gif"><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Why does this evaluation work?<a name="Why does this evaluation work?"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">The command
    values = spcol(knotsx,kx,xv)*coefs*spcol(knotsy,ky,yv).'
used here makes good sense since, e.g., SPCOL(KNOTSX,KX,XV) is the matrix
whose (i,q)-entry equals the value  B_{q,KX}(XV(i))  at XV(i) of the  q-th
B-spline of order KX for the knot sequence KNOTSX, while we want to evaluate
the expression
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">    sum_q sum_r COEFS(q,r) B_{q,KX}(x) B_{r,KY}(y) =
</pre><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">        = sum_q sum_r B_{q,KX}(x) COEFS(q,r) B_{r,KY}(y)
</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">at (x,y) = (XV(i),YV(j)).
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">More efficient alternatives<a name="More efficient alternatives"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Since the matrices SPCOL(KNOTSX,KX,XV) and SPCOL(KNOTSY,KY,YV) are
banded, it may be more efficient (though perhaps more memory-consuming)
for `large' XV and YV to make use of FNVAL, as follows:
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">   value2 = fnval(spmak(knotsx,fnval(spmak(knotsy,coefs),yv).'),xv).';
</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">In fact, FNVAL and SPMAK can deal directly with multivariate splines,
hence this statement can be replaced by
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">   value3 = fnval( spmak({knotsx,knotsy},coefs), {xv,yv} );
</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Better yet, the construction of the approximation can be done by  o n e
call to SPAP2, therefore we can obtain these values directly from the
given data by the statement
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">value4 = fnval( spap2({knotsx,knotsy},[kx ky],{x,y},z), {xv,yv} );
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">value2 = fnval(spmak(knotsx,fnval(spmak(knotsy,coefs),yv).'),xv).';
value3 = fnval( spmak({knotsx,knotsy},coefs), {xv,yv} );
value4 = fnval( spap2({knotsx,knotsy},[kx ky],{x,y},z), {xv,yv} );</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Check this out<a name="Check this out"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Here is a check, viz. the  r e l a t i v e  difference between the values
computed in these four different ways:
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">disp( <span style="color:blue">...</span>
     max(max(abs(values-value2)+abs(values-value3)+abs(values-value4)))/ <span style="color:blue">...</span>
     max(max(abs(values))) <span style="color:blue">...</span>
    )</pre><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:gray; font-style:italic;">  1.1206e-015

</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Error<a name="Error"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Here is also a plot of the error, i.e., the difference between the given data
value and the value of the approximation at those data sites:
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">errors = z -  spcol(knotsx,kx,x)*coefs*spcol(knotsy,ky,y).';
mesh(x,y,errors.'), view(150,50)
title(<span style="color:#B20000">'Error at the given data sites'</span>)</pre><img xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" src="tspdem_img_14_01.gif"><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Relative error<a name="Relative error"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">The  r e l a t i v e  error is
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">disp( max(max(abs(errors)))/max(max(abs(z))) )</pre><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:gray; font-style:italic;">    0.0539

</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;"><a name=""></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">This is perhaps not too impressive. On the other hand, the ratio of
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">              degrees of freedom used
               -----------------------
                number of data points
</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">is only
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">disp( prod(size(coefs))/prod(size(z)) )</pre><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:gray; font-style:italic;">    0.2909

</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Apparent bias of this approach<a name="Apparent bias of this approach"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">The approach followed here seems  b i a s e d :  We first think of the
given data values Z as describing a vector-valued function of  y , and then
we treat the matrix formed by the vector coefficients of the approximating
curve as describing a vector-valued function of  x .
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">What happens when we take things in the opposite order, i.e., think of
Z as describing a vector-valued function of  x , and then treat the matrix
made up from the vector coefficients of the approximating curve as describing
a vector-valued function of  y ?
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Perhaps surprisingly, the final approximation is the same (up to roundoff).
Here is the numerical experiment.
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Doing it the other way around<a name="Doing it the other way around"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">First, we fit a spline curve to the data, but this time with  x  as the
independent variable, hence it is the   r o w s  of Z which now become the
data values. Correspondingly, we must supply  Z.' (rather than Z) to SPAP2,
and obtain via the statement
               spb = spap2(knotsx,kx,x,z.');
a spline approximation to all the curves  (X,Z(:,j)), j=1:J.
In particular, the statement
               valsb = (fnval(spb,xv)).';
provides the array VALSB, whose entry VALSB(i,j) can be taken as an
approximation to the value  f(XV(i),Y(j))  of the underlying function
f  at the grid point (XV(i),Y(j)).  This is evident when we plot VALSB
using MESH :
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">spb = spap2(knotsx,kx,x,z.');
valsb = (fnval(spb,xv)).';
mesh(xv,y,valsb.'), view(150,50)
title(<span style="color:#B20000">'Simultaneous approximation to all curves in the x-direction'</span>)</pre><img xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" src="tspdem_img_18_01.gif"><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;"><a name=""></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Note the ridges. They confirm that we are plotting here smooth curves in
one direction only.
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Comparison with earlier plot of curves<a name="Comparison with earlier plot of curves"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Here, for a quick comparison is the earlier mesh of curves, with the smooth
curves running in the other direction:
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">mesh(x,yy,fnval(sp,yy).'), view(150,50)
title(<span style="color:#B20000">'Simultaneous approximation to all curves in y-direction'</span>)</pre><img xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" src="tspdem_img_20_01.gif"><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Approximating to the coefficients<a name="Approximating to the coefficients"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Now comes the second step, to get the actual surface.
Let COEFSX be the coefficients for SPB, i.e.,
      coefsx = fnbrk(spb,'c');
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Abstractly, you can think of the spline in SPB as the vector-valued function
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">     x |--&gt; sum_r coefsx(r,:) B_{r,kx}(x)
</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">with the j-th entry  COEFSX(r,j) of the vector coefficient COEFSX(r,:)
corresponding to Y(j) , all  j .  Thus we now fit each curve
(Y, COEFSX(r,:))  by a spline, using the same order KY and the same
(appropriate) knot sequence KNOTSY for each  r :
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">mesh(xv,y,valsb.'), view(150,50)
title(<span style="color:#B20000">'Simultaneous approximation to all curves in the x-direction'</span>)
coefsx = fnbrk(spb,<span style="color:#B20000">'c'</span>);
spb2 = spap2(knotsy,ky,y,coefsx.');</pre><img xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" src="tspdem_img_21_01.gif"><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;"><a name=""></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">In our construction of
          spb2 = spap2(knotsy,ky,y,coefsx.')
we need again to transpose the coefficient array from SPB, since SPAP2
takes the columns of its last input argument as the data values.
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">For this reason, there is now no need to transpose the coefficient array
COEFSB of the resulting `curve':
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">coefsb = fnbrk(spb2,<span style="color:#B20000">'c'</span>);</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;"><a name=""></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">I claim that COEFSB equals the earlier coefficient array COEFS
(up to round-off); see the discussion of the tensor product construct in the
spline toolbox Tutorial for a proof of this.
Here, I simply try the following test:
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">disp( max(max(abs(coefs - coefsb))) )</pre><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:gray; font-style:italic;">  1.6653e-015

</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;"><a name=""></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Thus, the  b i v a r i a t e  spline approximation
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">   (x,y) |--&gt; sum_q sum_r coefsb(q,r) B_{q,kx}(x) B_{r,ky}(y)
</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">to the original data
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">  (X(i),Y(j)) |--&gt;  f(X(i),Y(j)) = Z(i,j)
</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">obtained coincides with the earlier one (which generated COEFS rather than
COEFSB).
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;"><a name=""></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">As already observed earlier, you can carry out the entire construction we
just went through (even two ways) using just two commands,
one for the construction of the least-squares approximant,
the other for its evaluation at a rectangular mesh.
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">tsp = spap2({knotsx,knotsy},[kx,ky],{x,y},z);
valuet = fnval(tsp,{xv,yv});</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;"><a name=""></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Here, for another check, is the relative difference between the values
computed earlier and those computed now:
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">disp( max(max(abs(values-valuet)))/max(max(abs(values))) )</pre><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:gray; font-style:italic;">  3.7353e-016

</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Interpolation<a name="Interpolation"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Since the data come from a smooth function, we should be interpolating
it, i.e., use SPAPI instead of SPAP2, or, equivalently, use SPAP2
with the appropriate knot sequences. For illustration, here is the same
process done with SPAPI.
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">To recall, the data points were
x = sort([(0:10)/10,.03 .07, .93 .97]);
y = sort([(0:6)/6,.03 .07, .93 .97]);
</p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">We use again quadratic splines in  y , hence use knots midway between data
sites:
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">knotsy = augknt( [0 1 (y(2:(end-2))+y(3:(end-1)))/2 ], ky);

spi = spapi(knotsy,y,z);
coefsy = fnbrk(spi,<span style="color:#B20000">'c'</span>);</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Interpolation of resulting coefficients<a name="Interpolation of resulting coefficients"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">We use again cubics in  x , and use the not-a-knot condition, therefore use
all but the second and the second-last data point as knots:
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">knotsx = augknt( x([1,3:(end-2),end]), kx );
spi2 = spapi(knotsx,x,coefsy.');

icoefs = fnbrk(spi2,<span style="color:#B20000">'c'</span>).';</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Evaluation<a name="Evaluation"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">We are ready to evaluate and plot the interpolant at a fine mesh:
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">ivalues = spcol(knotsx,kx,xv)*icoefs*spcol(knotsy,ky,yv).';

mesh(xv,yv,ivalues.'), view(150,50)
title(<span style="color:#B20000">'The spline interpolant'</span>)</pre><img xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" src="tspdem_img_29_01.gif"><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Error<a name="Error"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">Its error, as an approximation to the Franke function, is computed next:
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">fvalues = franke(repmat(xv.',1,length(yv)),repmat(yv,length(xv),1));
error =  fvalues - ivalues;
mesh(xv,yv,error.'), view(150,50)
title(<span style="color:#B20000">'Interpolation error'</span>)</pre><img xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" src="tspdem_img_30_01.gif"><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;">Relative error<a name="Relative error"></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">The error is of  r e l a t i v e  size ...
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">disp( max(max(abs(error)))/max(max(abs(fvalues))) )</pre><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:gray; font-style:italic;">    0.0409

</pre><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:#990000; font-weight:bold; font-size:medium; page-break-before: auto;"><a name=""></a></p><p xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">The above steps can be carried out by just two commands, one for the
construction of the interpolant, the other for its evaluation
at a rectangular mesh, as shown below.
For a check, we also compute the relative difference between the values
computed earlier and those computed now:
</p><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="position: relative; left:30px">tsp = spapi({knotsx,knotsy},{x,y},z);
valuet = fnval(tsp,{xv,yv});
disp( max(max(abs(ivalues-valuet)))/max(max(abs(ivalues))) )</pre><pre xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" style="color:gray; font-style:italic;">  5.5068e-016

</pre><originalCode xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd" code="%% The Tensor Product Construct
&#xA;%
&#xA;% Illustrate approximation to data on rectangular grid.
&#xA;%
&#xA;%   Copyright 1987-2003 C. de Boor and The MathWorks, Inc.
&#xA;%   $Revision: 1.2 $
&#xA;
&#xA;%%
&#xA;% Since the toolbox can handle splines with  v e c t o r  coefficients, it is
&#xA;% easy to implement interpolation or approximation to gridded data by tensor
&#xA;% product splines. Most spline construction commands in the toolbox take
&#xA;% advantage of this.
&#xA;%
&#xA;% However, you might be interested in seeing a detailed description of how 
&#xA;% approximation to gridded data by tensor products is actually done for 
&#xA;% bivariate data.  This will also come in handy when you need some tensor 
&#xA;% product constructon not provided by the M-files in this toolbox.
&#xA;%
&#xA;%% Example: least-squares approximation to gridded data
&#xA;% Consider, for example, least-squares approximation to given data
&#xA;%  z(i,j) = f(x(i),y(j)), i = 1,...,I, j = 1,...,J .
&#xA;% Here are some gridded data, taken from Franke's sample function.
&#xA;% Note that I have chosen the grid somewhat denser near the boundary, to help 
&#xA;% pin down the approximation there.
&#xA;
&#xA;x = sort([(0:10)/10,.03 .07, .93 .97]);
&#xA;y = sort([(0:6)/6,.03 .07, .93 .97]);
&#xA;[xx,yy] = ndgrid(x,y); z = franke(xx,yy);
&#xA;
&#xA;% NOTE the use of NDGRID in preference to MESHGRID.
&#xA;
&#xA;mesh(x,y,z.'), view(150,50)
&#xA;title('Data from Franke function')
&#xA;%% NDGRID vs MESHGRID
&#xA;% Note that the statement
&#xA;%           [xx,yy] = ndgrid(x,y); z = franke(xx,yy);
&#xA;% used here makes certain that  Z(i,j)  is the value (of the function being
&#xA;% approximated) at the grid point (X(i),Y(j)).
&#xA;% However, the MATLAB command MESH(X,Y,Z) takes  Z(j,i)  as the value at the
&#xA;% grid point (X(i),Y(j)). 
&#xA;% For that reason, the above plot is generated by 
&#xA;%       mesh(x,y,z.')
&#xA;% i.e., using the transpose of the matrix Z .
&#xA;% Such transposing would not have been necessary, had I used MESHGRID instead
&#xA;% of NDGRID.
&#xA;% But the resulting Z would not have followed approximation theory standards.
&#xA;
&#xA;%% Choice of spline space in y-direction
&#xA;% Next, I choose some knot sequence KNOTSY and spline order KY for the
&#xA;% y-direction, and then use the command
&#xA;%
&#xA;%      sp = spap2(knotsy,ky,y,z);
&#xA;%
&#xA;% to obtain, in SP, a spline curve whose i-th component is an approximation to
&#xA;% the curve  (y,z(i,:)), i=1:I.
&#xA;
&#xA;ky = 3; knotsy = augknt([0,.25,.5,.75,1],ky);
&#xA;
&#xA;sp = spap2(knotsy,ky,y,z);
&#xA;
&#xA;%% Evaluation
&#xA;% In particular, 
&#xA;%
&#xA;%    yy = -.1:.05:1.1;  vals = fnval(sp,yy);
&#xA;%
&#xA;% provides the array VALS whose entry VALS(i,j) can be taken as an
&#xA;% approximation to the value  f(X(i),YY(j))  of the underlying function
&#xA;% f  at the grid point (X(i),YY(j)) .  This is evident when we plot VALS
&#xA;% using MESH:
&#xA;yy = -.1:.05:1.1;  vals = fnval(sp,yy);
&#xA;mesh(x,yy,vals.'), view(150,50)
&#xA;title('Simultaneous approximation to all curves in y-direction')
&#xA;
&#xA;%%
&#xA;% Note that, for each X(i), both the first two and the last two values
&#xA;% are zero since both the first two and the last two sites in YY are
&#xA;% outside the basic interval for the spline in SP.
&#xA;%
&#xA;% Note also the ridges. They confirm that we are plotting here smooth curves
&#xA;% in one direction only.
&#xA;
&#xA;%% From curves to a surface; choosing a spline space in the x-direction
&#xA;% To get an actual surface, we now have to go one step further.
&#xA;% Consider the coefficients COEFSY of the spline in SP, as obtained by
&#xA;%        coefsy = fnbrk(sp,'c');
&#xA;%
&#xA;% Abstractly, you can think of the spline in SP as the vector-valued function
&#xA;%       y |--&gt; sum_r COEFSY(:,r) B_{r,KY}(y)
&#xA;%
&#xA;% with the i-th entry COEFSY(i,r) of the vector coefficient COEFSY(:,r)
&#xA;% corresponding to X(i) , i=1:I.  This suggests approximating each
&#xA;% curve  (X, COEFSY(:,r))  by a spline, using the same order KX and
&#xA;% the same appropriate knot sequence KNOTSX for every  r :
&#xA;
&#xA;coefsy = fnbrk(sp,'c');
&#xA;kx = 4; knotsx = augknt(0:.2:1,kx);
&#xA;sp2 = spap2(knotsx,kx,x,coefsy.');
&#xA;
&#xA;%%
&#xA;% The command 
&#xA;%         sp2 = spap2(knotsx,kx,x,coefsy.');
&#xA;% used here needs, perhaps, an explanation.
&#xA;%
&#xA;% Recall that  spap2(knots,k,x,fx)  treats  fx(:,j)  as the value at  x(j) ,
&#xA;% i.e., takes each  c o l u m n  of  fx  as a data value. Since we wanted to
&#xA;% fit the value COEFSY(i,:) at X(i), all  i , we have to present SPAP2 with
&#xA;% the  t r a n s p o s e  of COEFSY.
&#xA;
&#xA;%%
&#xA;% Now consider the transpose COEFS = CXY.'  of the coefficient matrix CXY
&#xA;% of the resulting spline `curve', as obtained by the command
&#xA;%      coefs = fnbrk(sp2,'c').';
&#xA;%
&#xA;% COEFS provides the  b i v a r i a t e  spline approximation
&#xA;%
&#xA;%     (x,y) |--&gt; sum_q sum_r COEFS(q,r) B_{q,KX}(x) B_{r,KY}(y)
&#xA;%
&#xA;% to the original data
&#xA;%
&#xA;%    (X(i),Y(j)) |--&gt;  f(X(i),Y(j)) = Z(i,j) .
&#xA;%
&#xA;% We use SPCOL to provide the values B_{q,KX}(XV(i)) and B_{r,KY}(YV(j))
&#xA;% needed to evaluate this spline surface at some grid points (XV(i),YV(j))
&#xA;% and then use MESH to plot the values.
&#xA;
&#xA;coefs = fnbrk(sp2,'c').';
&#xA;xv = 0:.025:1; yv = 0:.025:1;
&#xA;values = spcol(knotsx,kx,xv)*coefs*spcol(knotsy,ky,yv).';
&#xA;mesh(xv,yv,values.'), view(150,50)
&#xA;title('The spline approximant')
&#xA;
&#xA;%% Why does this evaluation work?
&#xA;% The command 
&#xA;%     values = spcol(knotsx,kx,xv)*coefs*spcol(knotsy,ky,yv).'
&#xA;% used here makes good sense since, e.g., SPCOL(KNOTSX,KX,XV) is the matrix
&#xA;% whose (i,q)-entry equals the value  B_{q,KX}(XV(i))  at XV(i) of the  q-th
&#xA;% B-spline of order KX for the knot sequence KNOTSX, while we want to evaluate
&#xA;% the expression
&#xA;%
&#xA;%      sum_q sum_r COEFS(q,r) B_{q,KX}(x) B_{r,KY}(y) =
&#xA;%  
&#xA;%          = sum_q sum_r B_{q,KX}(x) COEFS(q,r) B_{r,KY}(y) 
&#xA;%     
&#xA;% at (x,y) = (XV(i),YV(j)).
&#xA;%%  More efficient alternatives
&#xA;% Since the matrices SPCOL(KNOTSX,KX,XV) and SPCOL(KNOTSY,KY,YV) are
&#xA;% banded, it may be more efficient (though perhaps more memory-consuming)
&#xA;% for `large' XV and YV to make use of FNVAL, as follows:
&#xA;%
&#xA;%     value2 = fnval(spmak(knotsx,fnval(spmak(knotsy,coefs),yv).'),xv).';
&#xA;%
&#xA;% In fact, FNVAL and SPMAK can deal directly with multivariate splines,
&#xA;% hence this statement can be replaced by
&#xA;%
&#xA;%     value3 = fnval( spmak({knotsx,knotsy},coefs), {xv,yv} );
&#xA;%
&#xA;% Better yet, the construction of the approximation can be done by  o n e 
&#xA;% call to SPAP2, therefore we can obtain these values directly from the
&#xA;% given data by the statement
&#xA;%
&#xA;% value4 = fnval( spap2({knotsx,knotsy},[kx ky],{x,y},z), {xv,yv} );
&#xA;%
&#xA;value2 = fnval(spmak(knotsx,fnval(spmak(knotsy,coefs),yv).'),xv).';
&#xA;value3 = fnval( spmak({knotsx,knotsy},coefs), {xv,yv} );
&#xA;value4 = fnval( spap2({knotsx,knotsy},[kx ky],{x,y},z), {xv,yv} );
&#xA;%% Check this out
&#xA;% Here is a check, viz. the  r e l a t i v e  difference between the values
&#xA;% computed in these four different ways:
&#xA;
&#xA;disp( ...
&#xA;     max(max(abs(values-value2)+abs(values-value3)+abs(values-value4)))/ ...
&#xA;     max(max(abs(values))) ...
&#xA;    )
&#xA;
&#xA;%% Error
&#xA;% Here is also a plot of the error, i.e., the difference between the given data
&#xA;% value and the value of the approximation at those data sites:
&#xA;
&#xA;errors = z -  spcol(knotsx,kx,x)*coefs*spcol(knotsy,ky,y).';
&#xA;mesh(x,y,errors.'), view(150,50)
&#xA;title('Error at the given data sites')
&#xA;
&#xA;%% Relative error
&#xA;% The  r e l a t i v e  error is
&#xA;disp( max(max(abs(errors)))/max(max(abs(z))) )
&#xA;
&#xA;%%
&#xA;% This is perhaps not too impressive. On the other hand, the ratio of
&#xA;% 
&#xA;%                degrees of freedom used
&#xA;%                -----------------------
&#xA;%                 number of data points
&#xA;%
&#xA;% is only
&#xA;disp( prod(size(coefs))/prod(size(z)) )
&#xA;
&#xA;%% Apparent bias of this approach
&#xA;% The approach followed here seems  b i a s e d :  We first think of the
&#xA;% given data values Z as describing a vector-valued function of  y , and then
&#xA;% we treat the matrix formed by the vector coefficients of the approximating
&#xA;% curve as describing a vector-valued function of  x .
&#xA;%
&#xA;% What happens when we take things in the opposite order, i.e., think of
&#xA;% Z as describing a vector-valued function of  x , and then treat the matrix
&#xA;% made up from the vector coefficients of the approximating curve as describing
&#xA;% a vector-valued function of  y ?
&#xA;%
&#xA;% Perhaps surprisingly, the final approximation is the same (up to roundoff).
&#xA;% Here is the numerical experiment.
&#xA;
&#xA;%% Doing it the other way around
&#xA;% First, we fit a spline curve to the data, but this time with  x  as the
&#xA;% independent variable, hence it is the   r o w s  of Z which now become the
&#xA;% data values. Correspondingly, we must supply  Z.' (rather than Z) to SPAP2,
&#xA;% and obtain via the statement
&#xA;%                spb = spap2(knotsx,kx,x,z.');
&#xA;% a spline approximation to all the curves  (X,Z(:,j)), j=1:J.
&#xA;% In particular, the statement
&#xA;%                valsb = (fnval(spb,xv)).';
&#xA;% provides the array VALSB, whose entry VALSB(i,j) can be taken as an
&#xA;% approximation to the value  f(XV(i),Y(j))  of the underlying function
&#xA;% f  at the grid point (XV(i),Y(j)).  This is evident when we plot VALSB
&#xA;% using MESH :
&#xA;
&#xA;spb = spap2(knotsx,kx,x,z.');
&#xA;valsb = (fnval(spb,xv)).';
&#xA;mesh(xv,y,valsb.'), view(150,50)
&#xA;title('Simultaneous approximation to all curves in the x-direction')
&#xA;
&#xA;%%
&#xA;% Note the ridges. They confirm that we are plotting here smooth curves in
&#xA;% one direction only.
&#xA;%
&#xA;%% Comparison with earlier plot of curves
&#xA;% Here, for a quick comparison is the earlier mesh of curves, with the smooth
&#xA;% curves running in the other direction:
&#xA;
&#xA;mesh(x,yy,fnval(sp,yy).'), view(150,50)
&#xA;title('Simultaneous approximation to all curves in y-direction')
&#xA;
&#xA;%% Approximating to the coefficients
&#xA;% Now comes the second step, to get the actual surface. 
&#xA;% Let COEFSX be the coefficients for SPB, i.e.,
&#xA;%       coefsx = fnbrk(spb,'c');
&#xA;%
&#xA;% Abstractly, you can think of the spline in SPB as the vector-valued function
&#xA;%
&#xA;%       x |--&gt; sum_r coefsx(r,:) B_{r,kx}(x)
&#xA;%
&#xA;% with the j-th entry  COEFSX(r,j) of the vector coefficient COEFSX(r,:)
&#xA;% corresponding to Y(j) , all  j .  Thus we now fit each curve
&#xA;% (Y, COEFSX(r,:))  by a spline, using the same order KY and the same 
&#xA;% (appropriate) knot sequence KNOTSY for each  r :
&#xA;
&#xA;mesh(xv,y,valsb.'), view(150,50)
&#xA;title('Simultaneous approximation to all curves in the x-direction')
&#xA;coefsx = fnbrk(spb,'c');
&#xA;spb2 = spap2(knotsy,ky,y,coefsx.');
&#xA;
&#xA;%%
&#xA;% In our construction of
&#xA;%           spb2 = spap2(knotsy,ky,y,coefsx.')
&#xA;% we need again to transpose the coefficient array from SPB, since SPAP2
&#xA;% takes the columns of its last input argument as the data values.
&#xA;% 
&#xA;% For this reason, there is now no need to transpose the coefficient array
&#xA;% COEFSB of the resulting `curve':
&#xA;
&#xA;coefsb = fnbrk(spb2,'c');
&#xA;
&#xA;%%
&#xA;% I claim that COEFSB equals the earlier coefficient array COEFS
&#xA;% (up to round-off); see the discussion of the tensor product construct in the
&#xA;% spline toolbox Tutorial for a proof of this.
&#xA;% Here, I simply try the following test:
&#xA;
&#xA;disp( max(max(abs(coefs - coefsb))) )
&#xA;
&#xA;%%
&#xA;% Thus, the  b i v a r i a t e  spline approximation
&#xA;%
&#xA;%     (x,y) |--&gt; sum_q sum_r coefsb(q,r) B_{q,kx}(x) B_{r,ky}(y)
&#xA;%
&#xA;% to the original data
&#xA;%
&#xA;%    (X(i),Y(j)) |--&gt;  f(X(i),Y(j)) = Z(i,j)
&#xA;%
&#xA;% obtained coincides with the earlier one (which generated COEFS rather than
&#xA;% COEFSB).
&#xA;
&#xA;%%
&#xA;% As already observed earlier, you can carry out the entire construction we
&#xA;% just went through (even two ways) using just two commands,
&#xA;% one for the construction of the least-squares approximant,
&#xA;% the other for its evaluation at a rectangular mesh.
&#xA;
&#xA;tsp = spap2({knotsx,knotsy},[kx,ky],{x,y},z);
&#xA;valuet = fnval(tsp,{xv,yv});
&#xA;%% 
&#xA;% Here, for another check, is the relative difference between the values
&#xA;% computed earlier and those computed now:
&#xA;disp( max(max(abs(values-valuet)))/max(max(abs(values))) )
&#xA;
&#xA;
&#xA;%% Interpolation
&#xA;% Since the data come from a smooth function, we should be interpolating
&#xA;% it, i.e., use SPAPI instead of SPAP2, or, equivalently, use SPAP2
&#xA;% with the appropriate knot sequences. For illustration, here is the same
&#xA;% process done with SPAPI.
&#xA;%
&#xA;% To recall, the data points were
&#xA;% x = sort([(0:10)/10,.03 .07, .93 .97]);
&#xA;% y = sort([(0:6)/6,.03 .07, .93 .97]);
&#xA;%
&#xA;% We use again quadratic splines in  y , hence use knots midway between data
&#xA;% sites:
&#xA;
&#xA;knotsy = augknt( [0 1 (y(2:(end-2))+y(3:(end-1)))/2 ], ky);
&#xA;
&#xA;spi = spapi(knotsy,y,z);
&#xA;coefsy = fnbrk(spi,'c');
&#xA;%% Interpolation of resulting coefficients
&#xA;% We use again cubics in  x , and use the not-a-knot condition, therefore use
&#xA;% all but the second and the second-last data point as knots:
&#xA;
&#xA;knotsx = augknt( x([1,3:(end-2),end]), kx );
&#xA;spi2 = spapi(knotsx,x,coefsy.');
&#xA;
&#xA;icoefs = fnbrk(spi2,'c').';
&#xA;
&#xA;%% Evaluation
&#xA;% We are ready to evaluate and plot the interpolant at a fine mesh:
&#xA;
&#xA;ivalues = spcol(knotsx,kx,xv)*icoefs*spcol(knotsy,ky,yv).';
&#xA;
&#xA;mesh(xv,yv,ivalues.'), view(150,50)
&#xA;title('The spline interpolant')
&#xA;
&#xA;%% Error
&#xA;% Its error, as an approximation to the Franke function, is computed next:
&#xA;
&#xA;fvalues = franke(repmat(xv.',1,length(yv)),repmat(yv,length(xv),1));
&#xA;error =  fvalues - ivalues;
&#xA;mesh(xv,yv,error.'), view(150,50)
&#xA;title('Interpolation error')
&#xA;
&#xA;%% Relative error
&#xA;% The error is of  r e l a t i v e  size ...
&#xA;disp( max(max(abs(error)))/max(max(abs(fvalues))) )
&#xA;
&#xA;%% 
&#xA;% The above steps can be carried out by just two commands, one for the
&#xA;% construction of the interpolant, the other for its evaluation
&#xA;% at a rectangular mesh, as shown below.
&#xA;% For a check, we also compute the relative difference between the values
&#xA;% computed earlier and those computed now:
&#xA;
&#xA;tsp = spapi({knotsx,knotsy},{x,y},z);
&#xA;valuet = fnval(tsp,{xv,yv});
&#xA;disp( max(max(abs(ivalues-valuet)))/max(max(abs(ivalues))) )
&#xA;
&#xA;"></originalCode>