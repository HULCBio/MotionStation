%%
%% SDSPFILTER2.TLC
%%
%% Abstract: Performs digital filtering on input signal (for dsparch4 Digital Filter block).
%%
%% Copyright 1995-2002 The MathWorks, Inc.
%% $Revision: 1.6.4.9 $ $Date: 2004/04/20 23:16:19 $

%implements sdspfilter2 "C"

%% Function: BlockTypeSetup ==================================================
%%
%function BlockTypeSetup(block, system) void

  %<Include_rt_header(block, "dspfilter_rt")>

%endfunction %% BlockTypeSetup

%% Function: BlockInstanceSetup ==================================================
%%
%function BlockInstanceSetup(block, system) void
  %%
  %% All fixed-point blocks call the fixed-point setup function
  %%
  %<FixPt_Setup(block, system)>
  %%
  %% assign various enums for filter type and filter structure
  %% NOTE:: IF THESE CHANGE, UPDATE S-FUNCTION ENUM ACCORDINGLY
  %%
  %% valid values for FilterTypeID:
  %%
  %assign ::DSP_IIR     = 0
  %assign ::DSP_FIR     = 1
  %assign ::DSP_ALLPOLE = 2
  %assign ::DSP_BIQUAD  = 3
  %%
  %% valid values for FilterStructureID:
  %%
  %assign ::DSP_DF            = 0
  %assign ::DSP_TDF           = 1
  %assign ::DSP_DF1           = 2
  %assign ::DSP_DF1T          = 3
  %assign ::DSP_DF2           = 4
  %assign ::DSP_DF2T          = 5
  %assign ::DSP_LATTICE       = 6
  %assign ::DSP_DF_SYM        = 7
  %assign ::DSP_DF_ASYM       = 8
  %%
  %%
  %assign INPORT       = 0
  %assign OUTPORT      = 0
  %assign COEFF1PORT   = 1
  %assign COEFF2PORT   = 2
  %%
  %assign block        = block + INPORT + OUTPORT + COEFF1PORT + COEFF2PORT
  %%
  %assign inDims            = LibBlockInputSignalDimensions(INPORT)
  %assign inFrame           = LibBlockInputSignalIsFrameData(INPORT)
  %assign numChans          = (inFrame) ? inDims[1] : LibBlockInputSignalWidth(INPORT)
  %assign numSamps          = (inFrame) ? inDims[0] : 1
  %assign outportIsComplex  = (LibBlockOutputSignalIsComplex(OUTPORT) != 0)
  %assign FilterTypeID      = SFcnParamSettings.FILTER_TYPE_ID
  %assign FilterStructureID = SFcnParamSettings.FILTER_STRUCTURE_ID
  %% I/O port data types
  %assign inDT  = FixPt_GetInputDataType(INPORT)
  %assign outDT = FixPt_GetOutputDataType(OUTPORT)
  %if FixPt_DataTypeIsFloat(inDT)
    %if SFcnParamSettings.A0COEFF_IS_UNITY
      %assign a0CoeffString = " (a0 == 1)"
    %else
      %assign a0CoeffString = " (a0 ~= 1)"
    %endif
  %else
    %% Fixed-point filters do not support non-unity a0 coefficients,
    %% so simply ignore the A0COEFF_IS_UNITY checkbox
    %assign a0CoeffString = ""
  %endif
  %switch (FilterTypeID)
    %case DSP_ALLPOLE
      %assign FilterTypeString = "All-pole"
      %switch (FilterStructureID)
        %case DSP_DF
          %assign FilterStructString = "Direct-form" + a0CoeffString
          %break
        %case DSP_TDF
          %assign FilterStructString = "Direct-form transposed" + a0CoeffString
          %break
        %case DSP_LATTICE
          %assign FilterStructString = "Lattice (AR)"
          %break
        %default
          %error "Code generation not supported for selected all-pole filter structure."
          %break
      %endswitch
      %break
    %case DSP_FIR
      %assign FilterTypeString = "FIR"
      %switch (FilterStructureID)
        %case DSP_DF
          %assign FilterStructString = "Direct-form"
          %break
        %case DSP_TDF
          %assign FilterStructString = "Direct-form transposed"
          %break
        %case DSP_LATTICE
          %assign FilterStructString = "Lattice (MA)"
          %break
        %case DSP_DF_SYM
          %assign FilterStructString = "Direct-form symmetric"
          %break
        %case DSP_DF_ASYM
          %assign FilterStructString = "Direct-form antisymmetric"
          %break
        %default
          %error "Code generation not supported for selected FIR filter structure."
          %break
      %endswitch
      %break
    %case DSP_BIQUAD
    %case DSP_IIR
      %if (FilterTypeID == DSP_BIQUAD)
        %assign FilterTypeString = "Biquad (second order sections)"
      %else
        %assign FilterTypeString = "IIR"
      %endif
      %switch (FilterStructureID)
        %case DSP_DF1
          %assign FilterStructString = "Direct-form I" + a0CoeffString
          %break
        %case DSP_DF1T
          %assign FilterStructString = "Direct-form I transposed" + a0CoeffString
          %break
        %case DSP_DF2
          %assign FilterStructString = "Direct-form II" + a0CoeffString
          %break
        %case DSP_DF2T
          %assign FilterStructString = "Direct-form II transposed" + a0CoeffString
          %break
        %default
          %error "Code generation not supported for selected IIR filter structure."
          %break
      %endswitch
      %break
  %endswitch
  %%
  %assign inportIsComplex  = LibBlockInputSignalIsComplex(INPORT)
  %assign inportDataTypeID = LibBlockInputSignalDataTypeId(INPORT)
  %%
  %if SFcnParamSettings.COEFFS_ARE_FROM_MASK
    %assign coeff1DataTypeID = LibBlockParameterDataTypeId(RTP1COEFF)
    %assign coeff1IsComplex  = LibBlockParameterIsComplex(RTP1COEFF)
    %if ((FilterTypeID == DSP_IIR) || (FilterTypeID == DSP_BIQUAD))
      %assign coeff2DataTypeID = LibBlockParameterDataTypeId(RTP2COEFF)
      %assign coeff2IsComplex  = LibBlockParameterIsComplex(RTP2COEFF)
    %endif
  %else
    %assign coeff1DataTypeID = LibBlockInputSignalDataTypeId(COEFF1PORT)
    %assign coeff1IsComplex  = LibBlockInputSignalIsComplex(COEFF1PORT)
    %if (FilterTypeID == DSP_IIR)
      %assign coeff2DataTypeID = LibBlockInputSignalDataTypeId(COEFF2PORT)
      %assign coeff2IsComplex  = LibBlockInputSignalIsComplex(COEFF2PORT)
    %endif
  %endif
  %if !((FilterTypeID == DSP_IIR) || (FilterTypeID == DSP_BIQUAD))
    %assign coeff2DataTypeID = 0
    %assign coeff2IsComplex  = 0
  %endif
  %assign str            = (inportDataTypeID == 0) ? "" : "F"
  %assign div            = (inportDataTypeID == 0) ? "" : "32"
  %assign block = block + numChans + numSamps + outportIsComplex + FilterStructureID + FilterTypeID \
                  + inportIsComplex + inportDataTypeID + coeff1DataTypeID + coeff1IsComplex \
                  + coeff2DataTypeID + coeff2IsComplex \
                  + str + div + inDT + outDT + FilterTypeString + FilterStructString
%endfunction %%BlockInstanceSetup


%% Function: fillExtraStateElemWithZero ================================================
%%
%function fillExtraStateElemWithZero(statePtr,isStateCplx,realZeroVal,numChans) Output
  %% Fill extra state element with scalar zero
  %if (isStateCplx)
    (*%<statePtr>).re = %<realZeroVal>;
    (*%<statePtr>++).im = %<realZeroVal>;
  %else
    *%<statePtr>++ = %<realZeroVal>;
  %endif
%endfunction %% fillExtraStateElemWithZero

%% Function: InitFixedPointDF1orDF1T ==============================================
%% Fixed-point DF1/DF1T implementation uses two separate state DWorks
%% for zeros and poles states.  To make things simple(r) use a
%% separate TLC function to initialize fixed-point DF1 states.
%function InitFixedPointDF1orDF1T(block, system) Output
  %assign zerosDWorkDTID        = LibBlockDWorkDataTypeId(DF1_ZERO_STATES)
  %assign zerosStateZeroVal     = LibGetGroundValueFromId(zerosDWorkDTID)
  %assign zerosDWorkDTypeName   = LibBlockDWorkDataTypeName(DF1_ZERO_STATES,"")
  %assign zerosStateIsComplex   = LibBlockDWorkIsComplex(DF1_ZERO_STATES)
  %assign bytesPerZerosElemStr  = "sizeof(%<zerosDWorkDTypeName>)"
  %assign polesDWorkDTID       = LibBlockDWorkDataTypeId(DF1_POLE_STATES)
  %assign polesStateZeroVal    = LibGetGroundValueFromId(polesDWorkDTID)
  %assign polesDWorkDTypeName  = LibBlockDWorkDataTypeName(DF1_POLE_STATES,"")
  %assign polesStateIsComplex  = LibBlockDWorkIsComplex(DF1_POLE_STATES)
  %assign bytesPerPolesElemStr = "sizeof(%<polesDWorkDTypeName>)"
  %if (SFcnParamSettings.COEFFS_ARE_FROM_MASK)
    %% Coeffs are from mask - stored in RTP always
    %assign Coeff1Size = LibBlockParameterSize(RTP1COEFF)
    %assign numCoeffs1 = (Coeff1Size[0] * Coeff1Size[1])
    %assign Coeff2Size = LibBlockParameterSize(RTP2COEFF)
    %assign numCoeffs2 = (Coeff2Size[0] * Coeff2Size[1])
  %else
    %% Coeffs are from ports: determine where and how many
    %assign numCoeffs1 = LibBlockInputSignalWidth(COEFF1PORT)
    %assign numCoeffs2 = LibBlockInputSignalWidth(COEFF2PORT)
    %if (!SFcnParamSettings.COEFFS_UPDATE_PER_FRAME)
      %assign numCoeffs1 = numCoeffs1 / numSamps
      %assign numCoeffs2 = numCoeffs2 / numSamps
    %endif
  %endif
  %assign ordCoeffs1  = numCoeffs1 - 1
  %assign ordCoeffs2  = numCoeffs2 - 1
  %%
  %%
  %% The following declarations are inconsistent with their floating point counterparts. In the floating point
  %% case, they are declared and incremented as byte_T.
  %<zerosDWorkDTypeName> *zerosStatePtr  = %<LibBlockDWorkAddr(DF1_ZERO_STATES, "", "", 0)>;
  %<polesDWorkDTypeName> *polesStatePtr = %<LibBlockDWorkAddr(DF1_POLE_STATES, "", "", 0)>;
  %% Initializing states for DF1T and DF1 filter structures.
  %if (ordCoeffs1 > 0)
    %<zerosDWorkDTypeName> *IC_zeros_ptr = (%<zerosDWorkDTypeName> *)%<LibBlockParameterAddr(ICRTP, "", "", 0)>;
  %endif
  %assign IC_zeros_dims = LibBlockParameterDimensions(ICRTP)
  %assign IC_zeros_rows = IC_zeros_dims[0]
  %assign IC_zeros_cols = IC_zeros_dims[1]
  %assign num_zeros_ICs = IC_zeros_rows * IC_zeros_cols
  %if (ordCoeffs2 > 0)
    %<polesDWorkDTypeName> *IC_poles_ptr = (%<polesDWorkDTypeName> *)%<LibBlockParameterAddr(IC2RTP, "", "", 0)>;
  %endif
  %assign IC_poles_dims = LibBlockParameterDimensions(IC2RTP)
  %assign IC_poles_rows = IC_poles_dims[0]
  %assign IC_poles_cols = IC_poles_dims[1]
  %assign num_poles_ICs = IC_poles_rows * IC_poles_cols
  %if (numChans > 1)
    int_T chanCount = %<numChans>;
    while (chanCount--) {
    %endif
    %if (num_poles_ICs == 1)
      %if (ordCoeffs2 > 1)
        int_T numElems2 = %<ordCoeffs2>;
      %endif
    %endif
    %if (num_zeros_ICs == 1)
      %% Scalar expansion of zeros side ICs.
      %if (ordCoeffs1 > 1)
        int_T numElems1 = %<ordCoeffs1>;
        while (numElems1--) {
      %endif
        %if (ordCoeffs1 > 0)
          *zerosStatePtr++ = *IC_zeros_ptr;
        %endif
      %if (ordCoeffs1 > 1)
        }
      %endif
      %if (FilterStructureID == DSP_DF1T)
        %<fillExtraStateElemWithZero("zerosStatePtr",zerosStateIsComplex,zerosStateZeroVal,numChans)>\
      %endif
    %else
%% We have a vector IC which has to be filled in the state vector.
      memcpy(zerosStatePtr, IC_zeros_ptr, %<ordCoeffs1> * %<bytesPerZerosElemStr>);
      zerosStatePtr += %<ordCoeffs1>;
      %if (num_zeros_ICs == (numChans*ordCoeffs1))
        IC_zeros_ptr += %<ordCoeffs1>;
      %endif
      %if (FilterStructureID == DSP_DF1T)
        %<fillExtraStateElemWithZero("zerosStatePtr",zerosStateIsComplex,zerosStateZeroVal,numChans)>\
      %endif
    %endif  %% (num_zeros_ICs == 1)
    %%
    %if (num_poles_ICs == 1)
      %% Scalar expansion of zeros side ICs.
      %if (ordCoeffs2 > 1)
        while (numElems2--) {
      %endif
        %if (ordCoeffs2 > 0)
          *polesStatePtr++ = *IC_poles_ptr;
        %endif
      %if (ordCoeffs2 > 1)
        }
      %endif
      %if (FilterStructureID == DSP_DF1T)
        %<fillExtraStateElemWithZero("polesStatePtr",polesStateIsComplex,polesStateZeroVal,numChans)>\
      %endif
    %else
      %% We have a vector IC which has to be filled in the state vector.
      memcpy(polesStatePtr, IC_poles_ptr, %<ordCoeffs2> * %<bytesPerPolesElemStr>);
      polesStatePtr += %<ordCoeffs2>;
      %if (num_poles_ICs == (numChans*ordCoeffs2))
        IC_poles_ptr += %<ordCoeffs2>;
      %endif
      %if (FilterStructureID == DSP_DF1T)
        %<fillExtraStateElemWithZero("polesStatePtr",polesStateIsComplex,polesStateZeroVal,numChans)>\
      %endif
    %endif  %% (num_zeros_ICs == 1)
  %if (numChans > 1)
    }
  %endif
%endfunction %% InitFixedPointDF1orDF1T


%% Function: InitializeConditions ==============================================
%%
%function InitializeConditions(block, system) Output
/* Signal Processing Blockset Filter Implementation (%<ParamSettings.FunctionName>) - '%<Name>' */
/* %<FilterTypeString>, %<FilterStructString> */
{
  %if (FilterTypeID == DSP_BIQUAD)
    %<InitSOSStates(block,system)>\
  %else
    %<InitConditions(block,system)>\
  %endif
}
%endfunction %% InitializeConditions

%function InitSOSStates(block,system) Output
  %assign CoeffSize  = LibBlockParameterSize(RTP1COEFF)
  %assign numCoeffs  = (CoeffSize[0] * CoeffSize[1])
  %if FixPt_DataTypeIsFloat(inDT)
    %assign numSections = numCoeffs / 5
  %else
    %assign numSections = numCoeffs / 3
  %endif
  %assign statesPerChan = 2 * numSections
  %assign numStates = statesPerChan * numChans
  %if ((FilterStructureID == DSP_DF2) || (FilterStructureID == DSP_DF2T))
    %% DF2/DF2T: one state buffer, one IC RTP
    byte_T       *statePtr   = (byte_T *) %<LibBlockDWorkAddr(FILT_STATES,"","",0)>;
    const byte_T *icPtr      = (byte_T *) %<LibBlockParameterAddr(ICRTP,"","",0)>;
    %assign dWorkDTypeName   = LibBlockDWorkDataTypeName(FILT_STATES,"")
    %assign bytesPerElemStr  = "sizeof(%<dWorkDTypeName>)"
    %assign IC_dims          = LibBlockParameterDimensions(ICRTP)
    %assign numICs           = IC_dims[0] * IC_dims[1]
    const int_T bytesPerElem = %<bytesPerElemStr>;

    %if numICs == 1
      %% scalar expansion
      int_T numElems = %<numStates>;
      while (numElems--) {
        memcpy(statePtr,icPtr,bytesPerElem);
        statePtr += bytesPerElem;
      }
    %elseif numICs == statesPerChan
      %% Vector ICs, same vector for all channels
      const int_T bytesPerChan = %<statesPerChan> * bytesPerElem;
      int_T chanCount = %<numChans>;
      while (chanCount--) {
        memcpy(statePtr,icPtr,bytesPerChan);
        statePtr += bytesPerChan;
      }
    %elseif numICs == numStates
      %% Matrix ICs
      memcpy(statePtr,icPtr, %<numStates> * bytesPerElem);
    %else
      %error "Initial condition vector has incorrect dimensions"
    %endif
  %else
    %% DF1/DF1T: two state buffers, two IC RTPs
    byte_T       *zerosStatePtr  = (byte_T *) %<LibBlockDWorkAddr(DF1_ZERO_STATES,"","",0)>;
    byte_T       *polesStatePtr  = (byte_T *) %<LibBlockDWorkAddr(DF1_POLE_STATES,"","",0)>;
    const byte_T *zerosICPtr     = (byte_T *) %<LibBlockParameterAddr(ICRTP,"","",0)>;
    const byte_T *polesICPtr     = (byte_T *) %<LibBlockParameterAddr(IC2RTP,"","",0)>;
    %assign zerosDWorkDTypeName  = LibBlockDWorkDataTypeName(DF1_ZERO_STATES,"")
    %assign bytesPerZeroElemStr  = "sizeof(%<zerosDWorkDTypeName>)"
    %assign IC_zero_dims         = LibBlockParameterDimensions(ICRTP)
    %assign numZeroICs           = IC_zero_dims[0] * IC_zero_dims[1]
    const int_T bytesPerZeroElem = %<bytesPerZeroElemStr>;
    %assign polesDWorkDTypeName  = LibBlockDWorkDataTypeName(DF1_POLE_STATES,"")
    %assign bytesPerPoleElemStr  = "sizeof(%<polesDWorkDTypeName>)"
    %assign IC_pole_dims         = LibBlockParameterDimensions(IC2RTP)
    %assign numPoleICs           = IC_pole_dims[0] * IC_pole_dims[1]
    const int_T bytesPerPoleElem = %<bytesPerPoleElemStr>;

    {
      /* Initialize zero-side states */
      %if numZeroICs == 1
        int_T numElems = %<numStates>;
        while (numElems--) {
          memcpy(zerosStatePtr,zerosICPtr,bytesPerZeroElem);
          zerosStatePtr += bytesPerZeroElem;
        }
      %elseif numZeroICs == statesPerChan
        %% Vector ICs, same vector for all channels
        const int_T bytesPerChan = %<statesPerChan> * bytesPerZeroElem;
        int_T chanCount = %<numChans>;
        while (chanCount--) {
          memcpy(zerosStatePtr,zerosICPtr,bytesPerChan);
          zerosStatePtr += bytesPerChan;
        }
      %elseif numZeroICs == numStates
        %% Matrix ICs
        memcpy(zerosStatePtr,zerosICPtr, %<numStates> * bytesPerZeroElem);
      %else
        %error "Initial condition vector has incorrect dimensions"
      %endif
    }
    {
      /* Initialize pole-side states */
      %if numPoleICs == 1
        int_T numElems = %<numStates>;
        while (numElems--) {
          memcpy(polesStatePtr,polesICPtr,bytesPerPoleElem);
          polesStatePtr += bytesPerPoleElem;
        }
      %elseif numPoleICs == statesPerChan
        %% Vector ICs, same vector for all channels
        const int_T bytesPerChan = %<statesPerChan> * bytesPerPoleElem;
        int_T chanCount = %<numChans>;
        while (chanCount--) {
          memcpy(polesStatePtr,polesICPtr,bytesPerChan);
          polesStatePtr += bytesPerChan;
        }
      %elseif numPoleICs == numStates
        %% Matrix ICs
        memcpy(polesStatePtr,polesICPtr, %<numStates> * bytesPerPoleElem);
      %else
        %error "Initial condition vector has incorrect dimensions"
      %endif
    }
  %endif
%endfunction %% InitSOSStates

%function InitConditions(block,system) Output
  %if (!FixPt_DataTypeIsFloat(inDT) && ((FilterStructureID == DSP_DF1) || (FilterStructureID == DSP_DF1T)))
    %% Fixed-point DF1/DF1T implementation uses two separate state DWorks
    %% for input and output states.  To make things simple(r) call a
    %% separate TLC function.
    %<InitFixedPointDF1orDF1T(block,system)>\
  %else
    %assign filtStatePtr     = LibBlockDWorkAddr(FILT_STATES, "", "", 0)
    %assign numStates        = LibBlockDWorkWidth(FILT_STATES) / numChans
    %assign dWorkDTypeName   = LibBlockDWorkDataTypeName(FILT_STATES,"")
    %assign bytesPerElemStr  = "sizeof(%<dWorkDTypeName>)"
    %assign chanDelays       = numStates
    %% Certain filter structures are implemented in run-time functions with an extra
    %% state element per channel to simplify loops.  The number of actual delay
    %% elements per channel for those structures will be one less than the number
    %% of declared states per channel.
    %switch FilterTypeID
      %case DSP_IIR
        %switch FilterStructureID
          %case DSP_DF2T
          %case DSP_DF2
          %case DSP_DF1
            %assign chanDelays = chanDelays - 1
            %break
        %endswitch
        %break
      %case DSP_FIR
      %case DSP_ALLPOLE
        %switch FilterStructureID
          %case DSP_TDF
          %case DSP_DF
            %assign chanDelays = chanDelays - 1
            %break
        %endswitch
        %break
    %endswitch
    %assign needExtraState = (chanDelays != numStates) ? 1 : 0
    %% DF2 has extra state at the beginning
    %assign extraStateLast = 1
    %if !FixPt_DataTypeIsFloat(inDT) && (FilterStructureID == DSP_DF2)
      %assign extraStateLast = 0
    %endif
    %if (SFcnParamSettings.COEFFS_ARE_FROM_MASK)
      %% Coeffs are from mask - stored in RTP always
      %assign Coeff1Size = LibBlockParameterSize(RTP1COEFF)
      %assign numCoeffs1 = (Coeff1Size[0] * Coeff1Size[1])
      %if (FilterTypeID == DSP_IIR)
        %assign Coeff2Size = LibBlockParameterSize(RTP2COEFF)
        %assign numCoeffs2 = (Coeff2Size[0] * Coeff2Size[1])
      %endif
    %else
      %% Coeffs are from ports: determine where and how many
      %assign numCoeffs1 = LibBlockInputSignalWidth(COEFF1PORT)
      %if (FilterTypeID == DSP_IIR)
        %assign numCoeffs2 = LibBlockInputSignalWidth(COEFF2PORT)
      %endif
    %endif
    %if (!SFcnParamSettings.COEFFS_UPDATE_PER_FRAME)
      %assign numCoeffs1 = numCoeffs1 / numSamps
      %if (FilterTypeID == DSP_IIR)
        %assign numCoeffs2 = numCoeffs2 / numSamps
      %endif
    %endif
    %assign ordCoeffs1  = numCoeffs1 - 1
    %if (FilterTypeID == DSP_IIR)
      %assign ordCoeffs2  = numCoeffs2 - 1
    %endif
    %%
    %% Initializing condition is done seperately for DF1/DF1T cases
    %if (FilterStructureID == DSP_DF1T) || (FilterStructureID == DSP_DF1)
      %%
      byte_T *statePtr = (byte_T *) %<filtStatePtr>;
      %% Initializing states for DF1T and DF1 filter structures.
      %if (ordCoeffs1 > 0)
        byte_T *IC_zeros_ptr  =    (byte_T *)%<LibBlockParameterAddr(ICRTP, "", "", 0)>;
      %endif
      %assign IC_zeros_dims          = LibBlockParameterDimensions(ICRTP)
      %assign IC_zeros_rows          = IC_zeros_dims[0]
      %assign IC_zeros_cols          = IC_zeros_dims[1]
      %assign num_zeros_ICs          = IC_zeros_rows * IC_zeros_cols
      %if (ordCoeffs2 > 0)
        byte_T *IC_poles_ptr  =    (byte_T *)%<LibBlockParameterAddr(IC2RTP, "", "", 0)>;
      %endif
      %assign IC_poles_dims          = LibBlockParameterDimensions(IC2RTP)
      %assign IC_poles_rows          = IC_poles_dims[0]
      %assign IC_poles_cols          = IC_poles_dims[1]
      %assign num_poles_ICs          = IC_poles_rows * IC_poles_cols
      %if (num_poles_ICs > 1)
        const int_T           bytesPerChan2 = %<ordCoeffs2> * %<bytesPerElemStr>;
      %endif
      %if (num_zeros_ICs > 1)
        const int_T           bytesPerChan1 = %<ordCoeffs1> * %<bytesPerElemStr>;
      %endif
      %<dWorkDTypeName> outZeroValPtr[1];
      %if (numChans > 1)
        int_T chanCount = %<numChans>;
        while (chanCount--) {
        %endif
        %if (num_poles_ICs == 1)
          %if (ordCoeffs2 > 1)
            int_T numElems2 = %<ordCoeffs2>;
          %endif
        %endif
        %if (num_zeros_ICs == 1)
          %% Scalar expansion of zeros side ICs.
          %if (ordCoeffs1 > 1)
            int_T numElems1 = %<ordCoeffs1>;
            while (numElems1--) {
            %endif
            %if (ordCoeffs1 > 0)
              memcpy(statePtr, IC_zeros_ptr, %<bytesPerElemStr>);
              statePtr += %<bytesPerElemStr>;
            %endif
            %if (ordCoeffs1 > 1)
            }
          %endif
          %<fillExtraStateElemWithZeroforDF1T(block,bytesPerElemStr)>
        %else
          %% We have a vector IC which has to be filled in the state vector.
          memcpy(statePtr, IC_zeros_ptr, bytesPerChan1);
          statePtr += bytesPerChan1;
          %if (num_zeros_ICs == (numChans*ordCoeffs1))
            IC_zeros_ptr += bytesPerChan1;
          %endif
          %<fillExtraStateElemWithZeroforDF1T(block,bytesPerElemStr)>
        %endif  %% (num_zeros_ICs == 1)
        %%
        %if (num_poles_ICs == 1)
          %% Scalar expansion of zeros side ICs.
          %if (ordCoeffs2 > 1)
            while (numElems2--) {
            %endif
            %if (ordCoeffs2 > 0)
              memcpy(statePtr, IC_poles_ptr, %<bytesPerElemStr>);
              statePtr += %<bytesPerElemStr>;
            %endif
            %if (ordCoeffs2 > 1)
            }
          %endif
          %<fillExtraStateElemWithZeroforDF1T(block,bytesPerElemStr)>
        %else
          %% We have a vector IC which has to be filled in the state vector.
          memcpy(statePtr, IC_poles_ptr, bytesPerChan2);
          statePtr += bytesPerChan2;
          %if (num_poles_ICs == (numChans*ordCoeffs2))
            IC_poles_ptr += bytesPerChan2;
          %endif
          %<fillExtraStateElemWithZeroforDF1T(block,bytesPerElemStr)>
        %endif  %% (num_zeros_ICs == 1)
        %if (numChans > 1)
        }
      %endif
    %else
      %% Initializing states for non-DF1T filter structures.
      %<dWorkDTypeName> *statePtr = (%<dWorkDTypeName> *) %<filtStatePtr>;
      %assign stateIsCplx      = LibBlockDWorkIsComplex(FILT_STATES)
      %assign stateDTID        = LibBlockDWorkDataTypeId(FILT_STATES)
      %assign stateRealZeroVal = LibGetGroundValueFromId(stateDTID)
      %assign IC_Ptr           = "(const %<dWorkDTypeName> *)" + LibBlockParameterAddr(ICRTP, "", "", 0)
      %assign IC_dims          = LibBlockParameterDimensions(ICRTP)
      %assign IC_rows          = IC_dims[0]
      %assign IC_cols          = IC_dims[1]
      %assign numICs           = IC_rows * IC_cols
      %if (numICs == 1)
        /* Scalar expansion of ICs with extra zero element per channel */
        %if (numChans > 1)
          int_T chanCount = %<numChans>;
          while (chanCount--) {
        %endif
        %if (chanDelays > 1)
          int_T numElems=%<chanDelays>;
        %endif
        %% Fill state buffer with IC elements
        %if (needExtraState && !extraStateLast)
          %<fillExtraStateElemWithZero("statePtr",stateIsCplx,stateRealZeroVal,numChans)>\
        %endif
        %if (chanDelays > 1)
          while (numElems--) {
        %endif
        %% In the case when there are no ICs we don't want to store IC_Ptr in statePtr
        %if (FilterTypeID == DSP_IIR)
          %if ((ordCoeffs1 > 0) || (ordCoeffs2 > 0))
            *statePtr++ = *%<IC_Ptr>;
          %endif
        %else
          %if (ordCoeffs1 > 0)
            *statePtr++ = *%<IC_Ptr>;
          %endif
        %endif
        %if (chanDelays > 1)
          }
        %endif
        %if (needExtraState && extraStateLast)
          %<fillExtraStateElemWithZero("statePtr",stateIsCplx,stateRealZeroVal,numChans)>\
        %endif
        %if (numChans > 1)
          }
        %endif
      %elseif (numICs == chanDelays)
        /* Vector ICs, same vector for all channels */
        const int_T bytesPerChan = %<chanDelays> * %<bytesPerElemStr>;
        %if (numChans > 1)
          int_T chanCount = %<numChans>;
          while (chanCount--) {
          %endif
          %if (needExtraState && !extraStateLast)
            %<fillExtraStateElemWithZero("statePtr",stateIsCplx,stateRealZeroVal,numChans)>
          %endif
          %% Fill state buffer with IC elements
          memcpy(statePtr, %<IC_Ptr>, bytesPerChan);
          statePtr += %<chanDelays>;
          %if (needExtraState && extraStateLast)
            %<fillExtraStateElemWithZero("statePtr",stateIsCplx,stateRealZeroVal,numChans)>
          %endif
          %if (numChans > 1)
          }
        %endif
      %elseif (numICs == numChans * chanDelays)
        /*  Matrix ICs */
        const %<dWorkDTypeName> *ICPtr        = %<IC_Ptr>;
        const int_T           bytesPerChan = %<chanDelays> * %<bytesPerElemStr>;
        int_T                 chanCount    = %<numChans>;
        while (chanCount--) {
          %% Fill state buffer with IC elements
          %if (needExtraState && !extraStateLast)
            %<fillExtraStateElemWithZero("statePtr",stateIsCplx,stateRealZeroVal,numChans)>
          %endif
          memcpy(statePtr, ICPtr, bytesPerChan);
          statePtr += %<chanDelays>;
          ICPtr    += %<chanDelays>;
          %if (needExtraState && extraStateLast)
            %<fillExtraStateElemWithZero("statePtr",stateIsCplx,stateRealZeroVal,numChans)>
          %endif
        }
      %endif
    %endif
    %if !FixPt_DataTypeIsFloat(inDT)
      %% Special fixed-point only initialization of CIRCBUFFIDX to zero
      %switch (FilterTypeID)
        %case DSP_FIR
          %% FIR Filter
          %switch (FilterStructureID)
            %case DSP_DF
            %case DSP_DF_SYM
            %case DSP_DF_ASYM
              %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)> = 0;
              %break
          %endswitch
          %break
      %endswitch
    %endif
  %endif
%endfunction %% InitializeConditions

%% Function: Outputs ==================================================
%%
%function Outputs(block, system) Output
  /* Signal Processing Blockset Filter Implementation (%<ParamSettings.FunctionName>) - '%<Name>' */
  /* %<FilterTypeString>, %<FilterStructString> */
  %%
  %if FixPt_DataTypeIsFloat(inDT)
    %%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% FLOATING POINT CODE GENERATION             %%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %if (FilterTypeID == DSP_BIQUAD)
      %<FltptSOS(block)>
    %elseif ((FilterTypeID == DSP_FIR) && ((FilterStructureID == DSP_DF_SYM) || (FilterStructureID == DSP_DF_ASYM)))
      %<FltptFIRSym(block)>
    %else
    %<FltptRunTimeFcn(block)>
    %endif
    %%
  %else
    %%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% FIXED-POINT CODE GENERATION                %%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%
    %createrecord rndSat { roundingMode FixPtRoundingMode; ...
                            overflowMode FixPtSaturationMode}
    %assign accumDT    = FixPt_GetParameterDataType(ACCUM_DATA_TYPE, 0, 0)
    %assign prodDT     = FixPt_GetParameterDataType(PROD_DATA_TYPE, 0, 0)
    %assign accumLabel = "accum"
    %assign prodLabel  = "prod"
    %assign block      = block + rndSat + accumDT + accumLabel + prodDT + prodLabel
    %if (FilterTypeID == DSP_BIQUAD)
      %<FixptSOS(block)>
    %else
      %<FixptInlineCode(block)>
    %endif
    %%
  %endif
%%
%endfunction %% Outputs

%%
%% BEGIN FixptSOS modules
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptSOS
%%
%% Fixed-point code generation for SOS filters
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptSOS(block) Output
%%
{
  %% create in record
  %assign inLabel = LibBlockInputSignal(INPORT,"io_Idx","","0")
  %assign inName  = (inportIsComplex) ? inDT.ComplexName : inDT.Name
  %createrecord in { label     inLabel; ...
                        dTypeRec  inDT; ...
                        isComplex inportIsComplex; ...
                        dTypeName inName }
  %% create out record
  %assign outLabel = LibBlockOutputSignal(OUTPORT, "io_Idx", "", "0")
  %createrecord out { label     outLabel; ...
                         dTypeRec  outDT; ...
                         isComplex outportIsComplex }
  %% create stageIn record
  %assign stageInLabel     = "stageIn"
  %assign stageInIsComplex = outportIsComplex
  %assign stageInDT        = FixPt_GetParameterDataType(STAGE_IN_DATA_TYPE,0,0)
  %assign stageInDTName    = (stageInIsComplex) ? stageInDT.ComplexName : stageInDT.Name
  %createrecord stageIn { label     stageInLabel; ...
                             dTypeRec  stageInDT; ...
                             isComplex stageInIsComplex; ...
                             dTypeName stageInDTName }
  %% create stageOut record
  %assign stageOutLabel     = "stageOut"
  %assign stageOutIsComplex = outportIsComplex
  %assign stageOutDT        = FixPt_GetParameterDataType(STAGE_OUT_DATA_TYPE,0,0)
  %assign stageOutDTName    = (stageOutIsComplex) ? stageOutDT.ComplexName : stageOutDT.Name
  %createrecord stageOut { label     stageOutLabel; ...
                              dTypeRec  stageOutDT; ...
                              isComplex stageOutIsComplex; ...
                              dTypeName stageOutDTName }
  %% create numCoeff record
  %assign numCoeffLabel = LibBlockParameter(RTP1COEFF,"numIdx","","0")
  %assign numCoeffDT    = DSPFixPt_GetParameterDataType(RTP1COEFF)
  %createrecord numCoeff { label     numCoeffLabel; ...
                              dTypeRec  numCoeffDT; ...
                              isComplex coeff1IsComplex }
  %% create denCoeff record
  %assign denCoeffLabel = LibBlockParameter(RTP2COEFF,"denIdx","","0")
  %assign denCoeffDT    = DSPFixPt_GetParameterDataType(RTP2COEFF)
  %createrecord denCoeff { label     denCoeffLabel; ...
                              dTypeRec  denCoeffDT; ...
                              isComplex coeff2IsComplex }
  %% create scaleVal record
  %assign scaleValLabel = LibBlockParameter(RTP3COEFF,"0","","0")
  %assign scaleValIsComplex = LibBlockParameterIsComplex(RTP3COEFF)
  %assign scaleValDT    = DSPFixPt_GetParameterDataType(RTP3COEFF)
  %createrecord scaleVal { label     scaleValLabel; ...
                              dTypeRec  scaleValDT; ...
                              isComplex scaleValIsComplex }
  %assign CoeffSize  = LibBlockParameterSize(RTP1COEFF)
  %assign nNumCoeffs = (CoeffSize[0] * CoeffSize[1])
  %assign nSections  = nNumCoeffs / 3
  %assign block = block + in + out + stageIn + stageOut \
                + numCoeff + denCoeff + scaleVal \
                + nSections
  %if ((numSamps * numChans) > 1)
    int_T io_Idx = 0;
  %endif
  %if numChans > 1
  int_T k;
  /* Loop over each input channel */
  for (k=0; k < %<numChans>; k++) {
  %endif
    %if numSamps > 1
    int_T i;
    /* Loop over each frame */
    for (i = 0; i < %<numSamps>; i++) {
    %endif
    %switch (FilterStructureID)
      %case DSP_DF1
        %<FixptSOSDF1(block)>
        %break
      %case DSP_DF1T
        %<FixptSOSDF1T(block)>
        %break
      %case DSP_DF2
        %<FixptSOSDF2(block)>
        %break
      %case DSP_DF2T
        %<FixptSOSDF2T(block)>
        %break
      %default
        %error "Fixed-point code generation is not supported for the specified SOS filter structure."
        %break
    %endswitch
    %if numSamps > 1
    } /* frame loop */
    %endif
  %if numChans > 1
  } /* channel loop */
  %endif
}
%endfunction %% FixptSOS


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptSOSDF1
%%
%% Fixed-point code generation for SOS DF1
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptSOSDF1(block) Output
%%
%% create numAcc record
%assign numAccIsCplx = outportIsComplex
%assign numAccDT     = accumDT
%assign numAccDTName = (numAccIsCplx) ? numAccDT.ComplexName : numAccDT.Name
%createrecord numAcc { label    "numAcc"; ...
                          dTypeRec  numAccDT; ...
                          isComplex numAccIsCplx; ...
                          dTypeName numAccDTName }
%% create denAcc record
%assign denAccIsCplx = outportIsComplex
%assign denAccDT     = accumDT
%assign denAccDTName = (denAccIsCplx) ? denAccDT.ComplexName : denAccDT.Name
%createrecord denAcc { label    "denAcc"; ...
                          dTypeRec  denAccDT; ...
                          isComplex denAccIsCplx; ...
                          dTypeName denAccDTName }
%% create prod record
%createrecord prod { label     prodLabel; ...
                        dTypeRec  prodDT; ...
                        isComplex 0 }
%% create inputState record
%assign inputStateLabel  = LibBlockDWork(DF1_ZERO_STATES,"memIdx","","0")
%assign inputStateIsCplx = LibBlockDWorkIsComplex(DF1_ZERO_STATES)
%assign inputStateDTID   = LibBlockDWorkDataTypeId(DF1_ZERO_STATES)
%assign inputStateDT     = FixPt_GetDataTypeFromIndex(inputStateDTID)
%createrecord inputState { label     inputStateLabel; ...
                              dTypeRec  inputStateDT; ...
                              isComplex inputStateIsCplx }
%% create outputState record
%assign outputStateLabel  = LibBlockDWork(DF1_POLE_STATES,"memIdx","","0")
%assign outputStateIsCplx = LibBlockDWorkIsComplex(DF1_POLE_STATES)
%assign outputStateDTID   = LibBlockDWorkDataTypeId(DF1_POLE_STATES)
%assign outputStateDT     = FixPt_GetDataTypeFromIndex(outputStateDTID)
%createrecord outputState { label     outputStateLabel; ...
                               dTypeRec  outputStateDT; ...
                               isComplex outputStateIsCplx }
%<stageIn.dTypeName>  %<stageIn.label>;
%<stageOut.dTypeName> %<stageOut.label>;
%<numAcc.dTypeName>   %<numAcc.label>;
%<denAcc.dTypeName>   %<denAcc.label>;
%<prodDT.Name>           %<prod.label>;
%if nSections > 1
  %% MULTI-SECTION CASE
  %assign inputState0  = LibBlockDWork(DF1_ZERO_STATES,"memIdx","","0")
  %assign inputState1  = LibBlockDWork(DF1_ZERO_STATES,"memIdx+1","","0")
  %assign outputState0 = LibBlockDWork(DF1_POLE_STATES,"memIdx","","0")
  %assign outputState1 = LibBlockDWork(DF1_POLE_STATES,"memIdx+1","","0")
  %assign b0           = LibBlockParameter(RTP1COEFF,"numIdx","","0")
  %assign b1           = LibBlockParameter(RTP1COEFF,"numIdx+1","","0")
  %assign b2           = LibBlockParameter(RTP1COEFF,"numIdx+2","","0")
  %% denCoeffs[] stores only a(1) and a(2), i.e. a(0) is
  %% explicitly left out (assumed to be unity).  So,
  %% denCoeffs[denIdx] is really a(1) and
  %% denCoeffs[denIdx+1] is really a(2)
  %assign a1     = LibBlockParameter(RTP2COEFF,"denIdx","","0")
  %assign a2     = LibBlockParameter(RTP2COEFF,"denIdx+1","","0")
  %assign scaleVal0   = LibBlockParameter(RTP3COEFF,"0","","0")
  %assign scaleValjp1 = LibBlockParameter(RTP3COEFF,"j+1","","0")
  %assign scaleValN   = LibBlockParameter(RTP3COEFF,"%<nSections>","","0")
  %if numChans > 1
    int_T memOffset = %<2 * nSections> * k; /* state memory offset for this channel */
  %endif
  int_T j;
%else
  %%
  %% SINGLE SECTION CASE
  %%
  %assign b0     = LibBlockParameter(RTP1COEFF,"0","","0")
  %assign b1     = LibBlockParameter(RTP1COEFF,"1","","0")
  %assign b2     = LibBlockParameter(RTP1COEFF,"2","","0")
  %% denCoeffs[] stores only a(1) and a(2), i.e. a(0) is
  %% explicitly left out (assumed to be unity).  So,
  %% denCoeffs[0] is really a(1) and
  %% denCoeffs[1] is really a(2)
  %assign a1     = LibBlockParameter(RTP2COEFF,"0","","0")
  %assign a2     = LibBlockParameter(RTP2COEFF,"1","","0")
  %assign scaleVal0   = LibBlockParameter(RTP3COEFF,"0","","0")
  %assign scaleValN   = LibBlockParameter(RTP3COEFF,"1","","0")
  %if numChans > 1
    int_T memIdx = 2 * k; /* state memory offset for this channel */
    %assign inputState0  = LibBlockDWork(DF1_ZERO_STATES,"memIdx","","0")
    %assign inputState1  = LibBlockDWork(DF1_ZERO_STATES,"memIdx+1","","0")
    %assign outputState0 = LibBlockDWork(DF1_POLE_STATES,"memIdx","","0")
    %assign outputState1 = LibBlockDWork(DF1_POLE_STATES,"memIdx+1","","0")
  %else
    %assign inputState0  = LibBlockDWork(DF1_ZERO_STATES,"0","","0")
    %assign inputState1  = LibBlockDWork(DF1_ZERO_STATES,"1","","0")
    %assign outputState0 = LibBlockDWork(DF1_POLE_STATES,"0","","0")
    %assign outputState1 = LibBlockDWork(DF1_POLE_STATES,"1","","0")
  %endif
%endif
  %% stageIn = inputs[io_Idx] * scaleVals[0];
  %assign scaleVal.label = scaleVal0
  %if (in.isComplex && scaleVal.isComplex)
    %<FixptMAC(numAcc,"=",prod,in,scaleVal,rndSat)>\
    %<DSPFixptLibEquals(stageIn,numAcc,rndSat)>\
  %else
    %<FixptMAC(stageIn,"=",prod,in,scaleVal,rndSat)>\
  %endif
%if nSections > 1
  /* Loop over sections */
  for (j = 0; j < %<nSections>; j++) {
    %if numChans > 1
      int_T memIdx = memOffset + 2 * j; /* memory index for this section */
    %else
      int_T memIdx = 2 * j; /* memory index for this section */
    %endif
    int_T numIdx = 3 * j; /* Numerator coefficient offset for this section */
    int_T denIdx = 2 * j; /* Denominator coefficient offset for this section */
%endif

    /* Compute the output value */
    %% numAcc  = b0 * stageIn
    %% numAcc += b1 * inputState0
    %% numAcc += b2 * inputState1
    %% denAcc  = numAcc
    %% denAcc -= a1 * outputState0
    %% denAcc -= a2 * outputState1
    %% stageOut= denAcc
    %assign numCoeff.label = b0
    %<FixptMAC(numAcc,"=",prod,numCoeff,stageIn,rndSat)>\
    %assign numCoeff.label   = b1
    %assign inputState.label = inputState0
    %<FixptMAC(numAcc,"+=",prod,numCoeff,inputState,rndSat)>\
    %assign numCoeff.label   = b2
    %assign inputState.label = inputState1
    %<FixptMAC(numAcc,"+=",prod,numCoeff,inputState,rndSat)>\
    %<DSPFixptLibEquals(denAcc,numAcc,rndSat)>\
    %assign denCoeff.label    = a1
    %assign outputState.label = outputState0
    %<FixptMAC(denAcc,"-=",prod,denCoeff,outputState,rndSat)>\
    %assign denCoeff.label    = a2
    %assign outputState.label = outputState1
    %<FixptMAC(denAcc,"-=",prod,denCoeff,outputState,rndSat)>\
    %<DSPFixptLibEquals(stageOut,denAcc,rndSat)>\

    /* update states */
    %% inputState1 = inputState0
    %% inputState0 = stageIn
    %% outputState1 = outputState0
    %% outputState0 = stageOut
    %<inputState1>  = %<inputState0>;
    %<inputState0>  = %<stageIn.label>;
    %<outputState1> = %<outputState0>;
    %<outputState0> = %<stageOut.label>;

%if nSections > 1
    /* Prepare stage input for next stage */
    %% stageIn = stageOut * scaleVals[j+1];
    %assign scaleVal.label = scaleValjp1
    %if (stageOut.isComplex && scaleVal.isComplex)
      %<FixptMAC(numAcc,"=",prod,stageOut,scaleVal,rndSat)>\
      %<DSPFixptLibEquals(stageIn,numAcc,rndSat)>\
    %else
      %<FixptMAC(stageIn,"=",prod,stageOut,scaleVal,rndSat)>\
    %endif
  } /* section loop */
%endif

  %% Compute final product for output
  %assign scaleVal.label = scaleValN
  %if (stageOut.isComplex && scaleVal.isComplex)
    %<FixptMAC(numAcc,"=",prod,stageOut,scaleVal,rndSat)>\
    %<DSPFixptLibEquals(out,numAcc,rndSat)>\
  %else
    %<FixptMAC(out,"=",prod,stageOut,scaleVal,rndSat)>\
  %endif
%if ((numSamps * numChans) > 1)
  io_Idx++;
%endif
%endfunction %% FixptSOSDF1


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptSOSDF1T
%%
%% Fixed-point code generation for SOS DF1T
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptSOSDF1T(block) Output
%%
%% create zeroAcc record
%assign zeroAccIsCplx = outportIsComplex
%assign zeroAccDT     = accumDT
%assign zeroAccDTName = (zeroAccIsCplx) ? zeroAccDT.ComplexName : zeroAccDT.Name
%createrecord zeroAcc { label    "zeroAcc"; ...
                           dTypeRec  zeroAccDT; ...
                           isComplex zeroAccIsCplx; ...
                           dTypeName zeroAccDTName }
%% create poleAcc record
%assign poleAccIsCplx = outportIsComplex
%assign poleAccDT     = accumDT
%assign poleAccDTName = (poleAccIsCplx) ? poleAccDT.ComplexName : poleAccDT.Name
%createrecord poleAcc { label    "poleAcc"; ...
                           dTypeRec  poleAccDT; ...
                           isComplex poleAccIsCplx; ...
                           dTypeName poleAccDTName }
%% create prod record
%createrecord prod { label     prodLabel; ...
                        dTypeRec  prodDT; ...
                        isComplex 0 }
%% create zeroState record
%assign zeroStateLabel  = LibBlockDWork(DF1_ZERO_STATES,"memIdx","","0")
%assign zeroStateIsCplx = LibBlockDWorkIsComplex(DF1_ZERO_STATES)
%assign zeroStateDTID   = LibBlockDWorkDataTypeId(DF1_ZERO_STATES)
%assign zeroStateDT     = FixPt_GetDataTypeFromIndex(zeroStateDTID)
%createrecord zeroState { label     zeroStateLabel; ...
                             dTypeRec  zeroStateDT; ...
                             isComplex zeroStateIsCplx }
%% create poleState record
%assign poleStateLabel  = LibBlockDWork(DF1_POLE_STATES,"memIdx","","0")
%assign poleStateIsCplx = LibBlockDWorkIsComplex(DF1_POLE_STATES)
%assign poleStateDTID   = LibBlockDWorkDataTypeId(DF1_POLE_STATES)
%assign poleStateDT     = FixPt_GetDataTypeFromIndex(poleStateDTID)
%createrecord poleState { label     poleStateLabel; ...
                             dTypeRec  poleStateDT; ...
                             isComplex poleStateIsCplx }
%% create multIn record
%assign multInLabel  = "multIn"
%assign multInIsCplx = outportIsComplex
%assign multInDT     = outDT
%assign multInDTName = (multInIsCplx) ? multInDT.ComplexName : multInDT.Name
%createrecord multIn { label     multInLabel; ...
                          dTypeRec  multInDT; ...
                          dTypeName multInDTName; ...
                          isComplex multInIsCplx }
%<stageIn.dTypeName>  %<stageIn.label>;
%<stageOut.dTypeName> %<stageOut.label>;
%<multIn.dTypeName>   %<multIn.label>;
%<zeroAcc.dTypeName>  %<zeroAcc.label>;
%<poleAcc.dTypeName>  %<poleAcc.label>;
%<prodDT.Name>           %<prod.label>;
%if nSections > 1
  %% MULTI-SECTION CASE
  %assign zeroState0 = LibBlockDWork(DF1_ZERO_STATES,"memIdx","","0")
  %assign zeroState1 = LibBlockDWork(DF1_ZERO_STATES,"memIdx+1","","0")
  %assign poleState0 = LibBlockDWork(DF1_POLE_STATES,"memIdx","","0")
  %assign poleState1 = LibBlockDWork(DF1_POLE_STATES,"memIdx+1","","0")
  %assign b0         = LibBlockParameter(RTP1COEFF,"numIdx","","0")
  %assign b1         = LibBlockParameter(RTP1COEFF,"numIdx+1","","0")
  %assign b2         = LibBlockParameter(RTP1COEFF,"numIdx+2","","0")
  %% denCoeffs[] stores only a(1) and a(2), i.e. a(0) is
  %% explicitly left out (assumed to be unity).  So,
  %% denCoeffs[denIdx] is really a(1) and
  %% denCoeffs[denIdx+1] is really a(2)
  %assign a1     = LibBlockParameter(RTP2COEFF,"denIdx","","0")
  %assign a2     = LibBlockParameter(RTP2COEFF,"denIdx+1","","0")
  %assign scaleVal0   = LibBlockParameter(RTP3COEFF,"0","","0")
  %assign scaleValjp1 = LibBlockParameter(RTP3COEFF,"j+1","","0")
  %assign scaleValN   = LibBlockParameter(RTP3COEFF,"%<nSections>","","0")
  %if numChans > 1
    int_T memOffset = %<2 * nSections> * k; /* state memory offset for this channel */
  %endif
  int_T j;
%else
  %%
  %% SINGLE SECTION CASE
  %%
  %assign b0     = LibBlockParameter(RTP1COEFF,"0","","0")
  %assign b1     = LibBlockParameter(RTP1COEFF,"1","","0")
  %assign b2     = LibBlockParameter(RTP1COEFF,"2","","0")
  %% denCoeffs[] stores only a(1) and a(2), i.e. a(0) is
  %% explicitly left out (assumed to be unity).  So,
  %% denCoeffs[0] is really a(1) and
  %% denCoeffs[1] is really a(2)
  %assign a1     = LibBlockParameter(RTP2COEFF,"0","","0")
  %assign a2     = LibBlockParameter(RTP2COEFF,"1","","0")
  %assign scaleVal0   = LibBlockParameter(RTP3COEFF,"0","","0")
  %assign scaleValN   = LibBlockParameter(RTP3COEFF,"1","","0")
  %if numChans > 1
    int_T memIdx = 2 * k; /* state memory offset for this channel */
    %assign zeroState0 = LibBlockDWork(DF1_ZERO_STATES,"memIdx","","0")
    %assign zeroState1 = LibBlockDWork(DF1_ZERO_STATES,"memIdx+1","","0")
    %assign poleState0 = LibBlockDWork(DF1_POLE_STATES,"memIdx","","0")
    %assign poleState1 = LibBlockDWork(DF1_POLE_STATES,"memIdx+1","","0")
  %else
    %assign zeroState0 = LibBlockDWork(DF1_ZERO_STATES,"0","","0")
    %assign zeroState1 = LibBlockDWork(DF1_ZERO_STATES,"1","","0")
    %assign poleState0 = LibBlockDWork(DF1_POLE_STATES,"0","","0")
    %assign poleState1 = LibBlockDWork(DF1_POLE_STATES,"1","","0")
  %endif
%endif
  %% stageIn = inputs[io_Idx] * scaleVals[0];
  %assign scaleVal.label = scaleVal0
  %if (in.isComplex && scaleVal.isComplex)
    %<FixptMAC(zeroAcc,"=",prod,in,scaleVal,rndSat)>\
    %<DSPFixptLibEquals(stageIn,zeroAcc,rndSat)>\
  %else
    %<FixptMAC(stageIn,"=",prod,in,scaleVal,rndSat)>\
  %endif
%if nSections > 1
  /* Loop over sections */
  for (j = 0; j < %<nSections>; j++) {
    %if numChans > 1
      int_T memIdx = memOffset + 2 * j; /* memory index for this section */
    %else
      int_T memIdx = 2 * j; /* memory index for this section */
    %endif
    int_T numIdx = 3 * j; /* Numerator coefficient offset for this section */
    int_T denIdx = 2 * j; /* Denominator coefficient offset for this section */
%endif

    /* Compute the output value */
    %% poleAcc   = stageIn
    %% poleAcc  -= poleState0
    %% multIn    = poleAcc
    %% zeroAcc   = b0 * multIn
    %% zeroAcc  += zeroState0
    %% stageOut  = zeroAcc
    %<DSPFixptLibEquals(poleAcc,stageIn,rndSat)>\
    %assign poleState.label = poleState0
    %<DSPFixptLibMinusEquals(poleAcc,poleState,rndSat)>\
    %<DSPFixptLibEquals(multIn,poleAcc,rndSat)>\
    %assign numCoeff.label = b0
    %<FixptMAC(zeroAcc,"=",prod,numCoeff,multIn,rndSat)>\
    %assign zeroState.label = zeroState0
    %<DSPFixptLibPlusEquals(zeroAcc,zeroState,rndSat)>\
    %<DSPFixptLibEquals(stageOut,zeroAcc,rndSat)>\

    /* Update zero-side states */
    %% zeroAcc    = zeroState1
    %% zeroAcc   += b1 * multIn
    %% zeroState0 = zeroAcc
    %assign zeroState.label = zeroState1
    %<DSPFixptLibEquals(zeroAcc,zeroState,rndSat)>\
    %assign numCoeff.label = b1
    %<FixptMAC(zeroAcc,"+=",prod,numCoeff,multIn,rndSat)>\
    %assign zeroState.label = zeroState0
    %<DSPFixptLibEquals(zeroState,zeroAcc,rndSat)>\

    %% zeroState1 = b2 * multIn
    %assign zeroState.label = zeroState1
    %assign numCoeff.label  = b2
    %if (numCoeff.isComplex && multIn.isComplex)
      %<FixptMAC(zeroAcc,"=",prod,numCoeff,multIn,rndSat)>\
      %<DSPFixptLibEquals(zeroState,zeroAcc,rndSat)>\
    %else
      %<FixptMAC(zeroState,"=",prod,numCoeff,multIn,rndSat)>\
    %endif

    /* Update pole-side states */
    %% poleAcc    = poleState1
    %% poleAcc   += a1 * multIn
    %% poleState0 = poleAcc
    %assign poleState.label = poleState1
    %<DSPFixptLibEquals(poleAcc,poleState,rndSat)>\
    %assign denCoeff.label = a1
    %<FixptMAC(poleAcc,"+=",prod,denCoeff,multIn,rndSat)>\
    %assign poleState.label = poleState0
    %<DSPFixptLibEquals(poleState,poleAcc,rndSat)>\

    %% poleAcc = a2 * multIn
    %% poleState1 = poleAcc
    %assign poleState.label = poleState1
    %assign denCoeff.label  = a2
    %<FixptMAC(poleAcc,"=",prod,denCoeff,multIn,rndSat)>\
    %<DSPFixptLibEquals(poleState,poleAcc,rndSat)>\

%if nSections > 1
    /* Prepare stage input for next stage */
    %% stageIn = stageOut * scaleVals[j+1];
    %assign scaleVal.label = scaleValjp1
    %if (stageOut.isComplex && scaleVal.isComplex)
      %<FixptMAC(zeroAcc,"=",prod,stageOut,scaleVal,rndSat)>\
      %<DSPFixptLibEquals(stageIn,zeroAcc,rndSat)>\
    %else
      %<FixptMAC(stageIn,"=",prod,stageOut,scaleVal,rndSat)>\
    %endif
  } /* section loop */
%endif

  %% out = stageOut * scaleVals[N]
  %assign scaleVal.label = scaleValN
  %if (stageOut.isComplex && scaleVal.isComplex)
    %<FixptMAC(zeroAcc,"=",prod,stageOut,scaleVal,rndSat)>\
    %<DSPFixptLibEquals(out,zeroAcc,rndSat)>\
  %else
    %<FixptMAC(out,"=",prod,stageOut,scaleVal,rndSat)>\
  %endif
%if ((numSamps * numChans) > 1)
  io_Idx++;
%endif
%endfunction %% FixptSOSDF1T


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptSOSDF2
%%
%% Fixed-point code generation for SOS DF2
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptSOSDF2(block) Output
%%
%% create numAcc record
%assign numAccIsCplx = outportIsComplex
%assign numAccDT     = accumDT
%assign numAccDTName = (numAccIsCplx) ? numAccDT.ComplexName : numAccDT.Name
%createrecord numAcc { label    "numAcc"; ...
                       dTypeRec  numAccDT; ...
                       isComplex numAccIsCplx; ...
                       dTypeName numAccDTName }
%% create denAcc record
%assign denAccIsCplx = outportIsComplex
%assign denAccDT     = accumDT
%assign denAccDTName = (denAccIsCplx) ? denAccDT.ComplexName : denAccDT.Name
%createrecord denAcc { label    "denAcc"; ...
                       dTypeRec  denAccDT; ...
                       isComplex denAccIsCplx; ...
                       dTypeName denAccDTName }
%% create prod record
%createrecord prod { label     prodLabel; ...
                     dTypeRec  prodDT; ...
                     isComplex 0 }
%% create mem record
%assign memLabel  = LibBlockDWork(FILT_STATES,"memIdx","","0")
%assign memIsCplx = LibBlockDWorkIsComplex(FILT_STATES)
%assign memDTID   = LibBlockDWorkDataTypeId(FILT_STATES)
%assign memDT     = FixPt_GetDataTypeFromIndex(memDTID)
%assign memDTName = (memIsCplx) ? memDT.ComplexName : memDT.Name
%createrecord mem { label     memLabel; ...
                       dTypeRec  memDT; ...
                       dTypeName memDTName; ...
                       isComplex memIsCplx }
%createrecord tempMem { label     "tempState"; ...
                           dTypeRec  memDT; ...
                           dTypeName memDTName; ...
                           isComplex memIsCplx }
%<stageIn.dTypeName>    %<stageIn.label>;
%<stageOut.dTypeName>   %<stageOut.label>;
%<tempMem.dTypeName>    %<tempMem.label>;
%<numAcc.dTypeName>     %<numAcc.label>;
%<denAcc.dTypeName>     %<denAcc.label>;
%<prodDT.Name>          %<prod.label>;
%if nSections > 1
  %% MULTI-SECTION CASE
  %assign state0 = LibBlockDWork(FILT_STATES,"memIdx","","0")
  %assign state1 = LibBlockDWork(FILT_STATES,"memIdx+1","","0")
  %assign b0     = LibBlockParameter(RTP1COEFF,"numIdx","","0")
  %assign b1     = LibBlockParameter(RTP1COEFF,"numIdx+1","","0")
  %assign b2     = LibBlockParameter(RTP1COEFF,"numIdx+2","","0")
  %% denCoeffs[] stores only a(1) and a(2), i.e. a(0) is
  %% explicitly left out (assumed to be unity).  So,
  %% denCoeffs[denIdx] is really a(1) and
  %% denCoeffs[denIdx+1] is really a(2)
  %assign a1     = LibBlockParameter(RTP2COEFF,"denIdx","","0")
  %assign a2     = LibBlockParameter(RTP2COEFF,"denIdx+1","","0")
  %assign scaleVal0   = LibBlockParameter(RTP3COEFF,"0","","0")
  %assign scaleValjp1 = LibBlockParameter(RTP3COEFF,"j+1","","0")
  %assign scaleValN   = LibBlockParameter(RTP3COEFF,"%<nSections>","","0")
  %if numChans > 1
    int_T memOffset = %<2 * nSections> * k; /* state memory offset for this channel */
  %endif
  int_T j;
%else
  %%
  %% SINGLE SECTION CASE
  %%
  %assign b0     = LibBlockParameter(RTP1COEFF,"0","","0")
  %assign b1     = LibBlockParameter(RTP1COEFF,"1","","0")
  %assign b2     = LibBlockParameter(RTP1COEFF,"2","","0")
  %% denCoeffs[] stores only a(1) and a(2), i.e. a(0) is
  %% explicitly left out (assumed to be unity).  So,
  %% denCoeffs[0] is really a(1) and
  %% denCoeffs[1] is really a(2)
  %assign a1     = LibBlockParameter(RTP2COEFF,"0","","0")
  %assign a2     = LibBlockParameter(RTP2COEFF,"1","","0")
  %assign scaleVal0   = LibBlockParameter(RTP3COEFF,"0","","0")
  %assign scaleValN   = LibBlockParameter(RTP3COEFF,"1","","0")
  %if numChans > 1
    int_T memIdx = 2 * k; /* state memory offset for this channel */
    %assign state0 = LibBlockDWork(FILT_STATES,"memIdx","","0")
    %assign state1 = LibBlockDWork(FILT_STATES,"memIdx+1","","0")
  %else
    %assign state0 = LibBlockDWork(FILT_STATES,"0","","0")
    %assign state1 = LibBlockDWork(FILT_STATES,"1","","0")
  %endif
%endif
  %% stageIn = inputs[io_Idx] * scaleVals[0];
  %assign scaleVal.label = scaleVal0
  %if (in.isComplex && scaleVal.isComplex)
    %<FixptMAC(numAcc,"=",prod,in,scaleVal,rndSat)>\
    %<DSPFixptLibEquals(stageIn,numAcc,rndSat)>\
  %else
    %<FixptMAC(stageIn,"=",prod,in,scaleVal,rndSat)>\
  %endif
%if nSections > 1
  /* Loop over sections */
  for (j = 0; j < %<nSections>; j++) {
    %if numChans > 1
      int_T memIdx = memOffset + 2 * j; /* memory index for this section */
    %else
      int_T memIdx = 2 * j; /* memory index for this section */
    %endif
    int_T numIdx = 3 * j; /* Numerator coefficient offset for this section */
    int_T denIdx = 2 * j; /* Denominator coefficient offset for this section */
%endif

    /* Accumulate denominator side products:
     * denAcc = stageIn - a(1) * state(0) - a(2) * state(1)
     */
    %% denAcc  = stageIn
    %% denAcc -= a1 * state0;
    %% denAcc -= a2 * state1;
    %<DSPFixptLibEquals(denAcc,stageIn,rndSat)>\
    %assign denCoeff.label = a1
    %assign mem.label = state0
    %<FixptMAC(denAcc,"-=",prod,denCoeff,mem,rndSat)>\
    %assign denCoeff.label = a2
    %assign mem.label = state1
    %<FixptMAC(denAcc,"-=",prod,denCoeff,mem,rndSat)>\
    %% tempState = denAcc
    %<DSPFixptLibEquals(tempMem,denAcc,rndSat)>\
    /* Accumulate numerator side products:
     * numAcc = b(0) * tempState + b(1) * state(0) + b(2) * state(1)
     */
    %% numAcc  = b0 * tempState;
    %% numAcc += b1 * state0;
    %% numAcc += b2 * state1;
    %% stageOut = numAcc

    %assign numCoeff.label = b0
    %<FixptMAC(numAcc,"=",prod,numCoeff,tempMem,rndSat)>\
    %assign numCoeff.label = b1
    %assign mem.label = state0
    %<FixptMAC(numAcc,"+=",prod,numCoeff,mem,rndSat)>\
    %assign numCoeff.label = b2
    %assign mem.label = state1
    %<FixptMAC(numAcc,"+=",prod,numCoeff,mem,rndSat)>\
    %<DSPFixptLibEquals(stageOut,numAcc,rndSat)>\

    /* update states */
    %% state1 = state0
    %% state0 = tempState
    %<state1> = %<state0>;
    %<state0> = %<tempMem.label>;

%if nSections > 1
    /* Prepare stage input for next stage */
    %% stageIn = stageOut * scaleVals[j+1];
    %assign scaleVal.label = scaleValjp1
    %if (stageOut.isComplex && scaleVal.isComplex)
      %<FixptMAC(numAcc,"=",prod,stageOut,scaleVal,rndSat)>\
      %<DSPFixptLibEquals(stageIn,numAcc,rndSat)>\
    %else
      %<FixptMAC(stageIn,"=",prod,stageOut,scaleVal,rndSat)>\
    %endif
  } /* section loop */
%endif

  %% out = stageOut * scaleVals[N];
  %assign scaleVal.label = scaleValN
  %if (stageOut.isComplex && scaleVal.isComplex)
    %<FixptMAC(numAcc,"=",prod,stageOut,scaleVal,rndSat)>\
    %<DSPFixptLibEquals(out,numAcc,rndSat)>\
  %else
    %<FixptMAC(out,"=",prod,stageOut,scaleVal,rndSat)>\
  %endif
%if ((numSamps * numChans) > 1)
  io_Idx++;
%endif
%endfunction %% FixptSOSDF2


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptSOSDF2T
%%
%% Fixed-point code generation for SOS DF2T
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptSOSDF2T(block) Output
%%
%% create acc record
%assign accumIsCplx = outportIsComplex
%assign accumDTName = (accumIsCplx) ? accumDT.ComplexName : accumDT.Name
%createrecord accum { label     accumLabel; ...
                         dTypeRec  accumDT; ...
                         isComplex accumIsCplx; ...
                         dTypeName accumDTName }
%% Also, only one product type needs to be used, and it is always real:
%createrecord prod { label     prodLabel; ...
                        dTypeRec  prodDT; ...
                        isComplex 0 }
%% create mem record
%assign memLabel  = LibBlockDWork(FILT_STATES,"memIdx","","0")
%assign memIsCplx = LibBlockDWorkIsComplex(FILT_STATES)
%assign memDTID   = LibBlockDWorkDataTypeId(FILT_STATES)
%assign memDT     = FixPt_GetDataTypeFromIndex(memDTID)
%createrecord mem { label     memLabel; ...
                       dTypeRec  memDT; ...
                       isComplex memIsCplx }
%<stageIn.dTypeName>  %<stageIn.label>;
%<stageOut.dTypeName> %<stageOut.label>;
%<accum.dTypeName>    %<accum.label>;
%<prodDT.Name>        %<prod.label>;
%if nSections > 1
  %% MULTI-SECTION CASE
  %assign state0 = LibBlockDWork(FILT_STATES,"memIdx","","0")
  %assign state1 = LibBlockDWork(FILT_STATES,"memIdx+1","","0")
  %assign b0     = LibBlockParameter(RTP1COEFF,"numIdx","","0")
  %assign b1     = LibBlockParameter(RTP1COEFF,"numIdx+1","","0")
  %assign b2     = LibBlockParameter(RTP1COEFF,"numIdx+2","","0")
  %% denCoeffs[] stores only a(1) and a(2), i.e. a(0) is
  %% explicitly left out (assumed to be unity).  So,
  %% denCoeffs[denIdx] is really a(1) and
  %% denCoeffs[denIdx+1] is really a(2)
  %assign a1     = LibBlockParameter(RTP2COEFF,"denIdx","","0")
  %assign a2     = LibBlockParameter(RTP2COEFF,"denIdx+1","","0")
  %assign scaleVal0   = LibBlockParameter(RTP3COEFF,"0","","0")
  %assign scaleValjp1 = LibBlockParameter(RTP3COEFF,"j+1","","0")
  %assign scaleValN   = LibBlockParameter(RTP3COEFF,"%<nSections>","","0")
  %if numChans > 1
    int_T memOffset = %<2 * nSections> * k; /* state memory offset for this channel */
  %endif
  int_T j;
%else
  %%
  %% SINGLE SECTION CASE
  %%
  %assign b0     = LibBlockParameter(RTP1COEFF,"0","","0")
  %assign b1     = LibBlockParameter(RTP1COEFF,"1","","0")
  %assign b2     = LibBlockParameter(RTP1COEFF,"2","","0")
  %% denCoeffs[] stores only a(1) and a(2), i.e. a(0) is
  %% explicitly left out (assumed to be unity).  So,
  %% denCoeffs[0] is really a(1) and
  %% denCoeffs[1] is really a(2)
  %assign a1     = LibBlockParameter(RTP2COEFF,"0","","0")
  %assign a2     = LibBlockParameter(RTP2COEFF,"1","","0")
  %assign scaleVal0   = LibBlockParameter(RTP3COEFF,"0","","0")
  %assign scaleValN   = LibBlockParameter(RTP3COEFF,"1","","0")
  %if numChans > 1
    int_T memIdx = 2 * k; /* state memory offset for this channel */
    %assign state0 = LibBlockDWork(FILT_STATES,"memIdx","","0")
    %assign state1 = LibBlockDWork(FILT_STATES,"memIdx+1","","0")
  %else
    %assign state0 = LibBlockDWork(FILT_STATES,"0","","0")
    %assign state1 = LibBlockDWork(FILT_STATES,"1","","0")
  %endif
%endif
  %% stageIn = inputs[io_Idx] * scaleVals[0];
  %assign scaleVal.label = scaleVal0
  %if (in.isComplex && scaleVal.isComplex)
    %<FixptMAC(accum,"=",prod,in,scaleVal,rndSat)>\
    %<DSPFixptLibEquals(stageIn,accum,rndSat)>\
  %else
    %<FixptMAC(stageIn,"=",prod,in,scaleVal,rndSat)>\
  %endif
%if nSections > 1
  /* Loop over sections */
  for (j = 0; j < %<nSections>; j++) {
    %if numChans > 1
      int_T memIdx = memOffset + 2 * j; /* memory index for this section */
    %else
      int_T memIdx = 2 * j; /* memory index for this section */
    %endif
    int_T numIdx = 3 * j; /* Numerator coefficient offset for this section */
    int_T denIdx = 2 * j; /* Denominator coefficient offset for this section */
%endif

    /* Compute the output value
     * out = b(0) * in + state(0)
     */
    %% acc = state(0)
    %assign mem.label = state0
    %<DSPFixptLibEquals(accum,mem,rndSat)>\
    %% acc += b(0) * stageIn;
    %assign numCoeff.label = b0
    %<FixptMAC(accum,"+=",prod,numCoeff,stageIn,rndSat)>\
    %% stageOut = acc
    %<DSPFixptLibEquals(stageOut,accum,rndSat)>\

    /* Update states:
     * state(0) = state(1) + b(1) * in - a(1) * out
     */
    %% acc = state(1)
    %assign mem.label = state1
    %<DSPFixptLibEquals(accum,mem,rndSat)>\
    %% acc += b(1) * stageIn
    %assign numCoeff.label = b1
    %<FixptMAC(accum,"+=",prod,numCoeff,stageIn,rndSat)>\
    %% acc -= a(1) * stageOut
    %assign denCoeff.label = a1
    %<FixptMAC(accum,"-=",prod,denCoeff,stageOut,rndSat)>\
    %% state(0) = acc
    %assign mem.label = state0
    %<DSPFixptLibEquals(mem,accum,rndSat)>\

    /* state(1) = b(2) * in - a(2) * out */
    %% acc  = b(2) * in
    %assign numCoeff.label = b2
    %<FixptMAC(accum,"=",prod,numCoeff,stageIn,rndSat)>\
    %% acc -= a(2) * out
    %assign denCoeff.label = a2
    %<FixptMAC(accum,"-=",prod,denCoeff,stageOut,rndSat)>\
    %% state(1) = acc
    %assign mem.label = state1
    %<DSPFixptLibEquals(mem,accum,rndSat)>\

%if nSections > 1
    /* Prepare stage input for next stage */
    %% stageIn = stageOut * scaleVals[j+1];
    %assign scaleVal.label = scaleValjp1
    %if (stageOut.isComplex && scaleVal.isComplex)
      %<FixptMAC(accum,"=",prod,stageOut,scaleVal,rndSat)>\
      %<DSPFixptLibEquals(stageIn,accum,rndSat)>\
    %else
      %<FixptMAC(stageIn,"=",prod,stageOut,scaleVal,rndSat)>\
    %endif
  } /* section loop */
%endif

  %% out = stageOut * scaleVals[N]
  %assign scaleVal.label = scaleValN
  %if (stageOut.isComplex && scaleVal.isComplex)
    %<FixptMAC(accum,"=",prod,stageOut,scaleVal,rndSat)>\
    %<DSPFixptLibEquals(out,accum,rndSat)>\
  %else
    %<FixptMAC(out,"=",prod,stageOut,scaleVal,rndSat)>\
  %endif
%if ((numSamps * numChans) > 1)
  io_Idx++;
%endif
%endfunction %% FixptSOSDF2T

%%
%% END FixptSOS modules
%%


%%
%% BEGIN FltptSOS modules
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FltptSOS
%%
%% Floating-point code generation for SOS filters
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FltptSOS(block) Output
%%
{
  %assign inCplx       = inportIsComplex
  %assign outCplx      = outportIsComplex
  %assign coeffCplx    = coeff1IsComplex
  %assign coeffDT      = DSPFixPt_GetParameterDataType(RTP1COEFF)
  %assign inDTypeName    = (inCplx) ? inDT.ComplexName : inDT.Name
  %assign outDTypeName   = (outCplx) ? outDT.ComplexName : outDT.Name
  %assign coeffDTypeName = (coeffCplx) ? coeffDT.ComplexName : coeffDT.Name
  %<inDTypeName>    *inputs    = (%<inDTypeName> *)%<LibBlockInputSignalAddr(INPORT,"","",0)>;
  %<outDTypeName>   *outputs   = (%<outDTypeName> *)%<LibBlockOutputSignalAddr(OUTPORT,"","",0)>;
  %<coeffDTypeName> *coeffs    = (%<coeffDTypeName> *)%<LibBlockParameterAddr(RTP1COEFF, "", "", 0)>;
  %<coeffDTypeName> *scaleVals = (%<coeffDTypeName> *)%<LibBlockParameterAddr(RTP2COEFF, "", "", 0)>;
  %assign CoeffSize  = LibBlockParameterSize(RTP1COEFF)
  %assign numCoeffs  = (CoeffSize[0] * CoeffSize[1])
  %assign numSections = numCoeffs / 5
  %assign block = block + inCplx + outCplx + coeffCplx \
                + inDTypeName + outDTypeName + coeffDTypeName \
                + numSections
  %if (numChans * numSamps) > 1
    int_T io_Idx = 0;
  %endif

  %if numChans > 1
  int_T k;
  /* Loop over each input channel */
  for (k=0; k < %<numChans>; k++) {
  %endif
    %if numSamps > 1
    int_T i;
    /* Loop over each frame */
    for (i = 0; i < %<numSamps>; i++) {
    %endif
    %switch (FilterStructureID)
      %case DSP_DF1
        %<FltptSOSDF1(block)>
        %break
      %case DSP_DF1T
        %<FltptSOSDF1T(block)>
        %break
      %case DSP_DF2
        %<FltptSOSDF2(block)>
        %break
      %case DSP_DF2T
        %<FltptSOSDF2T(block)>
        %break
      %default
        %error "Floating-point code generation is not supported for the specified SOS filter structure."
        %break
    %endswitch
    %if (numChans * numSamps) > 1
      io_Idx++;
    %endif
    %if numSamps > 1
    } /* frame loop */
    %endif
  %if numChans > 1
  } /* channel loop */
  %endif
}
%endfunction %% FltptSOS


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FltptSOSDF1
%%
%% Floating-point code generation for SOS DF1
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FltptSOSDF1(block) Output
%%
%<outDTypeName> *inputStates = (%<outDTypeName> *)%<LibBlockDWorkAddr(DF1_ZERO_STATES,"","",0)>;
%<outDTypeName> *outputStates = (%<outDTypeName> *)%<LibBlockDWorkAddr(DF1_POLE_STATES,"","",0)>;
%<outDTypeName> stageIn, stageOut;
%if numSections > 1
  %% MULTI-SECTION CASE
  %assign inputState0  = "inputStates[memIdx]"
  %assign inputState1  = "inputStates[memIdx+1]"
  %assign outputState0 = "outputStates[memIdx]"
  %assign outputState1 = "outputStates[memIdx+1]"
  %assign b0          = "coeffs[numIdx]"
  %assign b1          = "coeffs[numIdx+1]"
  %assign b2          = "coeffs[numIdx+2]"
  %assign a1          = "coeffs[denIdx]"
  %assign a2          = "coeffs[denIdx+1]"
  %assign scaleVal0   = "scaleVals[0]"
  %assign scaleValjp1 = "scaleVals[j+1]"
  %if numChans > 1
    int_T memOffset = %<2 * numSections> * k; /* state memory offset for this channel */
  %endif
  int_T j;
%else
  %% SINGLE SECTION CASE
  %assign b0        = "coeffs[0]"
  %assign b1        = "coeffs[1]"
  %assign b2        = "coeffs[2]"
  %assign a1        = "coeffs[3]"
  %assign a2        = "coeffs[4]"
  %assign scaleVal0 = "scaleVals[0]"
  %assign scaleVal1 = "scaleVals[1]"
  %if numChans > 1
    int_T memIdx = 2 * k; /* state memory offset for this channel */
    %assign inputState0  = "inputStates[memIdx]"
    %assign inputState1  = "inputStates[memIdx+1]"
    %assign outputState0 = "outputStates[memIdx]"
    %assign outputState1 = "outputStates[memIdx+1]"
  %else
    %assign inputState0  = "inputStates[0]"
    %assign inputState1  = "inputStates[1]"
    %assign outputState0 = "outputStates[0]"
    %assign outputState1 = "outputStates[1]"
  %endif
%endif
  %% stageIn = inputs[io_Idx] * scaleVals[0];
  %if (numChans * numSamps) > 1
    %<FltptMAC("stageIn","=","inputs[io_Idx]",scaleVal0, outCplx,inCplx,coeffCplx)>\
  %else
    %<FltptMAC("stageIn","=","inputs[0]",scaleVal0, outCplx,inCplx,coeffCplx)>\
  %endif
%if numSections > 1
  /* Loop over sections */
  for (j = 0; j < %<numSections>; j++) {
    %if numChans > 1
      int_T memIdx = memOffset + 2 * j; /* memory index for this section */
    %else
      int_T memIdx = 2 * j; /* memory index for this section */
    %endif
    int_T coeffIdx = 5 * j; /* Coefficient offset for this section */
    int_T numIdx   = coeffIdx;
    int_T denIdx   = numIdx + 3;
%endif
    %% stageOut  = b0 * stageIn;
    %% stageOut += b1 * inputState0;
    %% stageOut += b2 * inputState1;
    %% stageOut -= a1 * outputState0;
    %% stageOut -= a2 * outputState1;
    %<FltptMAC("stageOut","=",  b0, "stageIn",   outCplx,coeffCplx,outCplx)>\
    %<FltptMAC("stageOut","+=", b1, inputState0, outCplx,coeffCplx,outCplx)>\
    %<FltptMAC("stageOut","+=", b2, inputState1, outCplx,coeffCplx,outCplx)>\
    %<FltptMAC("stageOut","-=", a1, outputState0,outCplx,coeffCplx,outCplx)>\
    %<FltptMAC("stageOut","-=", a2, outputState1,outCplx,coeffCplx,outCplx)>\

    /* update states */
    %<inputState1> = %<inputState0>;
    %<inputState0> = stageIn;
    %<outputState1> = %<outputState0>;
    %<outputState0> = stageOut;
%if numSections > 1
    /* update stage input for next stage */
    %% stageIn = stageOut * scaleVals[j+1];
    %<FltptMAC("stageIn","=","stageOut",scaleValjp1,outCplx,outCplx,coeffCplx)>\
  } /* section loop */
  %% outputs[io_Idx] = stageIn
  %if (numChans * numSamps) > 1
    outputs[io_Idx] = stageIn;
  %else
    outputs[0] = stageIn;
  %endif
%else
  %% outputs[io_Idx] = stageOut * scaleVal1;
  %if (numChans * numSamps) > 1
    %<FltptMAC("outputs[io_Idx]","=","stageOut",scaleVal1,outCplx,outCplx,coeffCplx)>\
  %else
    %<FltptMAC("outputs[0]","=","stageOut",scaleVal1,outCplx,outCplx,coeffCplx)>\
  %endif
%endif
%endfunction %% FltptSOSDF1


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FltptSOSDF1T
%%
%% Floating-point code generation for SOS DF1T
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FltptSOSDF1T(block) Output
%%
%<outDTypeName> *zeroStates = (%<outDTypeName> *)%<LibBlockDWorkAddr(DF1_ZERO_STATES,"","",0)>;
%<outDTypeName> *poleStates = (%<outDTypeName> *)%<LibBlockDWorkAddr(DF1_POLE_STATES,"","",0)>;
%<outDTypeName> stageIn, stageOut;
%if numSections > 1
  %% MULTI-SECTION CASE
  %assign zeroState0  = "zeroStates[memIdx]"
  %assign zeroState1  = "zeroStates[memIdx+1]"
  %assign poleState0  = "poleStates[memIdx]"
  %assign poleState1  = "poleStates[memIdx+1]"
  %assign b0          = "coeffs[numIdx]"
  %assign b1          = "coeffs[numIdx+1]"
  %assign b2          = "coeffs[numIdx+2]"
  %assign a1          = "coeffs[denIdx]"
  %assign a2          = "coeffs[denIdx+1]"
  %assign scaleVal0   = "scaleVals[0]"
  %assign scaleValjp1 = "scaleVals[j+1]"
  %if numChans > 1
    int_T memOffset = %<2 * numSections> * k; /* state memory offset for this channel */
  %endif
  int_T j;
%else
  %% SINGLE SECTION CASE
  %assign b0        = "coeffs[0]"
  %assign b1        = "coeffs[1]"
  %assign b2        = "coeffs[2]"
  %assign a1        = "coeffs[3]"
  %assign a2        = "coeffs[4]"
  %assign scaleVal0 = "scaleVals[0]"
  %assign scaleVal1 = "scaleVals[1]"
  %if numChans > 1
    int_T memIdx = 2 * k; /* state memory offset for this channel */
    %assign zeroState0 = "zeroStates[memIdx]"
    %assign zeroState1 = "zeroStates[memIdx+1]"
    %assign poleState0 = "poleStates[memIdx]"
    %assign poleState1 = "poleStates[memIdx+1]"
  %else
    %assign zeroState0 = "zeroStates[0]"
    %assign zeroState1 = "zeroStates[1]"
    %assign poleState0 = "poleStates[0]"
    %assign poleState1 = "poleStates[1]"
  %endif
%endif
  %% stageIn = inputs[io_Idx] * scaleVals[0];
  %if (numChans * numSamps) > 1
    %<FltptMAC("stageIn","=","inputs[io_Idx]",scaleVal0, outCplx,inCplx,coeffCplx)>\
  %else
    %<FltptMAC("stageIn","=","inputs[0]",scaleVal0, outCplx,inCplx,coeffCplx)>\
  %endif
%if numSections > 1
  /* Loop over sections */
  for (j = 0; j < %<numSections>; j++) {
    %if numChans > 1
      int_T memIdx = memOffset + 2 * j; /* memory index for this section */
    %else
      int_T memIdx = 2 * j; /* memory index for this section */
    %endif
    int_T coeffIdx = 5 * j; /* Coefficient offset for this section */
    int_T numIdx   = coeffIdx;
    int_T denIdx   = numIdx + 3;
%endif
    /* Compute the output value */
    %% stageIn  -= poleState0
    %% stageOut  = b0 * stageIn;
    %% stageOut += zeroState0;

    %if outCplx
      stageIn.re -= %<poleState0>.re;
      stageIn.im -= %<poleState0>.im;
    %else
      stageIn -= %<poleState0>;
    %endif
    %<FltptMAC("stageOut","=",b0,"stageIn",outCplx,coeffCplx,outCplx)>\
    %if outCplx
      stageOut.re += %<zeroState0>.re;
      stageOut.im += %<zeroState0>.im;
    %else
      stageOut += %<zeroState0>;
    %endif

    /* Update states */
    %<zeroState0>  = %<zeroState1>;
    %% zeroState0 += b1 * stageIn;
    %<FltptMAC(zeroState0,"+=",b1,"stageIn",outCplx,coeffCplx,outCplx)>\

    %% zeroState1 = b2 * stageIn;
    %<FltptMAC(zeroState1,"=",b2,"stageIn",outCplx,coeffCplx,outCplx)>\

    %<poleState0>  = %<poleState1>;
    %% poleState0 += a1 * stageIn;
    %<FltptMAC(poleState0,"+=",a1,"stageIn",outCplx,coeffCplx,outCplx)>\

    %% poleState1 = a2 * stageIn;
    %<FltptMAC(poleState1,"=",a2,"stageIn",outCplx,coeffCplx,outCplx)>\

%if numSections > 1
    /* update stage input for next stage */
    %% stageIn = stageOut * scaleVals[j+1];
    %<FltptMAC("stageIn","=","stageOut",scaleValjp1,outCplx,outCplx,coeffCplx)>\
  } /* section loop */
  %% outputs[io_Idx] = stageIn
  %if (numChans * numSamps) > 1
    outputs[io_Idx] = stageIn;
  %else
    outputs[0] = stageIn;
  %endif
%else
  %% outputs[io_Idx] = stageOut * scaleVal1;
  %if (numChans * numSamps) > 1
    %<FltptMAC("outputs[io_Idx]","=","stageOut",scaleVal1,outCplx,outCplx,coeffCplx)>\
  %else
    %<FltptMAC("outputs[0]","=","stageOut",scaleVal1,outCplx,outCplx,coeffCplx)>\
  %endif
%endif
%endfunction %% FltptSOSDF1T


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FltptSOSDF2
%%
%% Floating-point code generation for SOS DF2
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FltptSOSDF2(block) Output
%%
%<outDTypeName> *states = (%<outDTypeName> *)%<LibBlockDWorkAddr(FILT_STATES,"","",0)>;
%<outDTypeName> stageIn, stageOut;
%if numSections > 1
  %% MULTI-SECTION CASE
  %assign state0    = "states[memIdx]"
  %assign state1    = "states[memIdx+1]"
  %assign b0        = "coeffs[numIdx]"
  %assign b1        = "coeffs[numIdx+1]"
  %assign b2        = "coeffs[numIdx+2]"
  %assign a1        = "coeffs[denIdx]"
  %assign a2        = "coeffs[denIdx+1]"
  %assign scaleVal0 = "scaleVals[0]"
  %assign scaleValjp1 = "scaleVals[j+1]"
  %if numChans > 1
    int_T memOffset = %<2 * numSections> * k; /* state memory offset for this channel */
  %endif
  int_T j;
%else
  %% SINGLE SECTION CASE
  %assign b0        = "coeffs[0]"
  %assign b1        = "coeffs[1]"
  %assign b2        = "coeffs[2]"
  %assign a1        = "coeffs[3]"
  %assign a2        = "coeffs[4]"
  %assign scaleVal0 = "scaleVals[0]"
  %assign scaleVal1 = "scaleVals[1]"
  %if numChans > 1
    int_T memIdx = 2 * k; /* state memory offset for this channel */
    %assign state0 = "states[memIdx]"
    %assign state1 = "states[memIdx+1]"
  %else
    %assign state0 = "states[0]"
    %assign state1 = "states[1]"
  %endif
%endif
  %% stageIn = inputs[io_Idx] * scaleVals[0];
  %if (numChans * numSamps) > 1
    %<FltptMAC("stageIn","=","inputs[io_Idx]",scaleVal0, outCplx,inCplx,coeffCplx)>\
  %else
    %<FltptMAC("stageIn","=","inputs[0]",scaleVal0, outCplx,inCplx,coeffCplx)>\
  %endif
%if numSections > 1
  /* Loop over sections */
  for (j = 0; j < %<numSections>; j++) {
    %if numChans > 1
      int_T memIdx = memOffset + 2 * j; /* memory index for this section */
    %else
      int_T memIdx = 2 * j; /* memory index for this section */
    %endif
    int_T coeffIdx = 5 * j; /* Coefficient offset for this section */
    int_T numIdx   = coeffIdx;
    int_T denIdx   = numIdx + 3;
%endif
    /* Accumulate denominator side products:
     * stageIn -= a(1) * state(0) - a(2) * state(1)
     */
    %% stageIn -= a1 * state0;
    %% stageIn -= a2 * state1;

    %<FltptMAC("stageIn","-=",a1,state0,outCplx,coeffCplx,outCplx)>\
    %<FltptMAC("stageIn","-=",a2,state1,outCplx,coeffCplx,outCplx)>\

    /* Accumulate numerator side products:
     * stageOut = b(0) * stageIn + b(1) * state(0) + b(2) * state(1)
     */
    %% stageOut  = b0 * stageIn;
    %% stageOut += b1 * state0;
    %% stageOut += b2 * state1;

    %<FltptMAC("stageOut","=", b0,"stageIn", outCplx,coeffCplx,outCplx)>\
    %<FltptMAC("stageOut","+=",b1,state0,    outCplx,coeffCplx,outCplx)>\
    %<FltptMAC("stageOut","+=",b2,state1,    outCplx,coeffCplx,outCplx)>\

    /* update states */
    %<state1> = %<state0>;
    %<state0> = stageIn;

%if numSections > 1
    /* update stage input for next stage */
    %% stageIn = stageOut * scaleVals[j+1];
    %<FltptMAC("stageIn","=","stageOut",scaleValjp1,outCplx,outCplx,coeffCplx)>\
  } /* section loop */
  %% outputs[io_Idx] = stageIn
  %if (numChans * numSamps) > 1
    outputs[io_Idx] = stageIn;
  %else
    outputs[0] = stageIn;
  %endif
%else
  %% outputs[io_Idx] = stageOut * scaleVal1;
  %if (numChans * numSamps) > 1
    %<FltptMAC("outputs[io_Idx]","=","stageOut",scaleVal1,outCplx,outCplx,coeffCplx)>\
  %else
    %<FltptMAC("outputs[0]","=","stageOut",scaleVal1,outCplx,outCplx,coeffCplx)>\
  %endif
%endif
%endfunction %% FltptSOSDF2


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FltptSOSDF2T
%%
%% Floating-point code generation for SOS DF2T
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FltptSOSDF2T(block) Output
%%
%<outDTypeName> *states = (%<outDTypeName> *)%<LibBlockDWorkAddr(FILT_STATES,"","",0)>;
%<outDTypeName> stageIn, stageOut;
%if numSections > 1
  %% MULTI-SECTION CASE
  %assign state0    = "states[memIdx]"
  %assign state1    = "states[memIdx+1]"
  %assign b0        = "coeffs[numIdx]"
  %assign b1        = "coeffs[numIdx+1]"
  %assign b2        = "coeffs[numIdx+2]"
  %assign a1        = "coeffs[denIdx]"
  %assign a2        = "coeffs[denIdx+1]"
  %assign scaleVal0 = "scaleVals[0]"
  %assign scaleValjp1 = "scaleVals[j+1]"
  %if numChans > 1
    int_T memOffset = %<2 * numSections> * k; /* state memory offset for this channel */
  %endif
  int_T j;
%else
  %% SINGLE SECTION CASE
  %assign b0        = "coeffs[0]"
  %assign b1        = "coeffs[1]"
  %assign b2        = "coeffs[2]"
  %assign a1        = "coeffs[3]"
  %assign a2        = "coeffs[4]"
  %assign scaleVal0 = "scaleVals[0]"
  %assign scaleVal1 = "scaleVals[1]"
  %if numChans > 1
    int_T memIdx = 2 * k; /* state memory offset for this channel */
    %assign state0 = "states[memIdx]"
    %assign state1 = "states[memIdx+1]"
  %else
    %assign state0 = "states[0]"
    %assign state1 = "states[1]"
  %endif
%endif
  %% stageIn = inputs[io_Idx] * scaleVals[0];
  %if (numChans * numSamps) > 1
    %<FltptMAC("stageIn","=","inputs[io_Idx]",scaleVal0, outCplx,inCplx,coeffCplx)>\
  %else
    %<FltptMAC("stageIn","=","inputs[0]",scaleVal0, outCplx,inCplx,coeffCplx)>\
  %endif
%if numSections > 1
  /* Loop over sections */
  for (j = 0; j < %<numSections>; j++) {
    %if numChans > 1
      int_T memIdx = memOffset + 2 * j; /* memory index for this section */
    %else
      int_T memIdx = 2 * j; /* memory index for this section */
    %endif
    int_T coeffIdx = 5 * j; /* Coefficient offset for this section */
    int_T numIdx   = coeffIdx;
    int_T denIdx   = numIdx + 3;
%endif
    /* Compute the output value
     * out = b(0) * in + state(0)
     */
    stageOut = %<state0>;
    %% stageOut += b0 * stageIn;
    %<FltptMAC("stageOut","+=",b0,"stageIn",outCplx,coeffCplx,outCplx)>\

    /* Update states:
     * state(0) = state(1) + b(1) * in - a(1) * out
     */
    %<state0> = %<state1>;
    %% state0 += b1 * stageIn;
    %<FltptMAC(state0,"+=",b1,"stageIn",outCplx,coeffCplx,outCplx)>\
    %% state0 -= a1 * stageOut;
    %<FltptMAC(state0,"-=",a1,"stageOut",outCplx,coeffCplx,outCplx)>\

    /* state(1) = b(2) * in - a(2) * out */
    %% state1  = b2 * stageIn;
    %<FltptMAC(state1,"=",b2,"stageIn",outCplx,coeffCplx,outCplx)>\
    %% state1 -= a2 * stageOut;
    %<FltptMAC(state1,"-=",a2,"stageOut",outCplx,coeffCplx,outCplx)>\

%if numSections > 1
    /* update stage input for next stage */
    %% stageIn = stageOut * scaleVals[j+1];
    %<FltptMAC("stageIn","=","stageOut",scaleValjp1,outCplx,outCplx,coeffCplx)>\
  } /* section loop */
  %% outputs[io_Idx] = stageIn
  %if (numChans * numSamps) > 1
    outputs[io_Idx] = stageIn;
  %else
    outputs[0] = stageIn;
  %endif
%else
  %% outputs[io_Idx] = stageOut * scaleVal1;
  %if (numChans * numSamps) > 1
    %<FltptMAC("outputs[io_Idx]","=","stageOut",scaleVal1,outCplx,outCplx,coeffCplx)>\
  %else
    %<FltptMAC("outputs[0]","=","stageOut",scaleVal1,outCplx,outCplx,coeffCplx)>\
  %endif
%endif
%endfunction %% FltptSOSDF2T

%%
%% END FltptSOS modules
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FltptEquals(y,opStr,x,yCplx,xCplx)
%%
%% Generates code for y %<opStr> x, taking into account mixed
%% complexities.  opStr can be "=", "+=", "-="
%%
%% y and x are strings holding variable names
%% yCplx and xCplx are complexity flags
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FltptEquals(y,opStr,x,yCplx,xCplx) Output
  %if (xCplx && !yCplx)
    %error "Cannot assign complex x into real y in call to FltptEquals function."
    %return
  %endif
  %% Create operator list:
  %assign opPlusEquals = 1
  %assign opMinusEquals = 2
  %assign opEquals = 3
  %if ISEQUAL(opStr,"+=")
    %% Generate code for y += x
    %assign op = opPlusEquals
  %elseif ISEQUAL(opStr,"-=")
    %% Generate code for y -= x
    %assign op = opMinusEquals
  %elseif ISEQUAL(opStr,"=")
    %% Generate code for y = x
    %assign op = opEquals
  %else
    %error "Invalid operation string passed to FltptEquals function.  Valid choices are '+=', '-=', and '='"
    %return
  %endif
  %if (xCplx)
    %% x is complex, y must also be complex
    %if (op == opEquals)
      %% structure assignment okay
      %<y> = %<x>;
    %else
      %<y>.re %<opStr> %<x>.re;
      %<y>.im %<opStr> %<x>.im;
    %endif
  %else
    %% x is real, y may be real or complex
    %if (yCplx)
      %% y is complex, but x is real
      %% modify only y.re
      %% leave y.im alone, unless opStr is "="
      %% in which case set y.im to 0
      %<y>.re %<opStr> %<x>;
      %if (op == opEquals)
        %<y>.im = 0;
      %endif
    %else
      %% both x and y are real
      %<y> %<opStr> %<x>;
    %endif
  %endif
%endfunction %% FltptEquals


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FltptMAC(y,opStr,u1,u2,yCplx,u1Cplx,u2Cplx)
%%
%% Computes the product u1 * u2 and stores the result in y
%% based on opStr:
%% opStr: "+=" --> y += u1 * u2
%% opStr: "-=" --> y -= u1 * u2
%% opStr: "="  --> y  = u1 * u2
%%
%% Takes into account mixed complexities.
%% y, u1, and u2 are strings holding variable names
%% yCplx, u1Cplx, and u2Cplx are complexity flags
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FltptMAC(y,opStr,u1,u2,yCplx,u1Cplx,u2Cplx) Output
  %% Create operator list:
  %assign opMACPlusEquals = 1
  %assign opMACMinusEquals = 2
  %assign opMACEquals = 3
  %if ISEQUAL(opStr,"+=")
    %% Generate code for y += u1 * u2
    %assign opMAC = opMACPlusEquals
  %elseif ISEQUAL(opStr,"-=")
    %% Generate code for y -= u1 * u2
    %assign opMAC = opMACMinusEquals
  %elseif ISEQUAL(opStr,"=")
    %% Generate code for y = u1 * u2
    %assign opMAC = opMACEquals
  %else
    %error "Invalid operation string passed to FltptMAC function.  Valid choices are '+=', '-=', and '='"
    %return
  %endif
  %assign yIsComplex = yCplx
  %assign yIsReal    = !(yIsComplex)
  %if (yIsComplex)
    %assign yRe = y + ".re"
    %assign yIm = y + ".im"
  %endif
  %assign u1IsComplex = u1Cplx
  %assign u1IsReal    = !(u1IsComplex)
  %if (u1IsComplex)
    %assign u1Re = u1 + ".re"
    %assign u1Im = u1 + ".im"
  %endif
  %assign u2IsComplex = u2Cplx
  %assign u2IsReal    = !(u2IsComplex)
  %if (u2IsComplex)
    %assign u2Re = u2 + ".re"
    %assign u2Im = u2 + ".im"
  %endif
  %% Three cases:
  %% 1: u1 and u2 are both real
  %% 2: u1 is real, u2 is complex OR u1 is complex, u2 is real
  %% 3: u1 and u2 are both complex
  %if (u1IsReal && u2IsReal)
    %% Case 1: u1 and u2 are both real
    %% y can be real, but if a complex y variable is passed
    %% in, use only the real part.
    %if (yIsComplex)
      %assign y = yRe
    %endif
    %<y> %<opStr> %<u1> * %<u2>;
    %if (yIsComplex)
      %% If y is complex, use only the real part and set the imag part to zero
      %<yIm> = 0;
    %endif
  %else
    %% y must be complex when either u1 or u2 (or both) are complex
    %% therefore, error out if y is real
    %if yIsReal
      %error "y must be complex when multiplying and accumulating complex numbers using the FltptMAC function"
    %endif
    %if ((u1IsReal && u2IsComplex) || (u1IsComplex && u2IsReal))
      %% Case 2: mixed-complexity case
      %% Generate code that looks like this:
      %%  opStr: "+="              opStr: "-="              opStr: "="
      %%  -------------            -------------            -------------
      %%  y.re += u1 * u2.re;      y.re -= u1 * u2.re;      y.re = u1 * u2.re;
      %%  y.im += u1 * u2.im;      y.im -= u1 * u2.im;      y.im = u1 * u2.im;
      %% If u1 is complex, swap with u2:
      %if (u1IsComplex)
        %assign u1   = u2
        %assign u2Re = u1Re
        %assign u2Im = u1Im
      %endif
      %<yRe> %<opStr> %<u1> * %<u2Re>;
      %<yIm> %<opStr> %<u1> * %<u2Im>;
    %else
      %% Case 3: u1 and u2 are both complex
      %% Generate code that looks like this
      %%  opStr: "+="               opStr: "-="               opStr: "="
      %%  -------------             -------------             -------------
      %%  y.re += u1.re * u2.re;    y.re -= u1.re * u2.re;    y.re  = u1.re * u2.re;
      %%  y.re -= u1.im * u2.im;    y.re += u1.im * u2.im;    y.re -= u1.im * u2.im;
      %%  y.im += u1.re * u2.im;    y.im -= u1.re * u2.im;    y.im  = u1.re * u2.im;
      %%  y.im += u1.im * u2.re;    y.im -= u1.im * u2.re;    y.im += u1.im * u2.re;
      %switch opMAC
        %case opMACPlusEquals
          %<yRe> += %<u1Re> * %<u2Re>;
          %<yRe> -= %<u1Im> * %<u2Im>;
          %<yIm> += %<u1Re> * %<u2Im>;
          %<yIm> += %<u1Im> * %<u2Re>;
          %break
        %case opMACMinusEquals
          %<yRe> -= %<u1Re> * %<u2Re>;
          %<yRe> += %<u1Im> * %<u2Im>;
          %<yIm> -= %<u1Re> * %<u2Im>;
          %<yIm> -= %<u1Im> * %<u2Re>;
          %break
        %case opMACEquals
          %<yRe>  = %<u1Re> * %<u2Re>;
          %<yRe> -= %<u1Im> * %<u2Im>;
          %<yIm>  = %<u1Re> * %<u2Im>;
          %<yIm> += %<u1Im> * %<u2Re>;
          %break
      %endswitch
    %endif
  %endif
%endfunction %% FltptMAC


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FltptFIRSym
%%
%% Floating-point code generation for FIR DF Sym/Asym filters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FltptFIRSym(block) Output
{
  %assign inCplx         = inportIsComplex
  %assign outCplx        = outportIsComplex
  %assign coeffCplx      = coeff1IsComplex
  %assign coeffDT        = DSPFixPt_GetParameterDataType(RTP1COEFF)
  %assign inDTypeName    = (inCplx) ? inDT.ComplexName : inDT.Name
  %assign outDTypeName   = (outCplx) ? outDT.ComplexName : outDT.Name
  %assign coeffDTypeName = (coeffCplx) ? coeffDT.ComplexName : coeffDT.Name
  %assign CoeffSize  = LibBlockParameterSize(RTP1COEFF)
  %assign numCoeffs    = (CoeffSize[0] * CoeffSize[1])
  %assign block = block + inCplx + outCplx + coeffCplx \
                + inDTypeName + outDTypeName + coeffDTypeName
  %assign numStates = LibBlockDWorkWidth(FILT_STATES) / numChans
  %assign ordNum    = numCoeffs - 1
  %assign ordNumMinusOne = ordNum - 1
  %assign ordNumMinusTwo = ordNum - 2
  %assign evenOrder = ( (ordNum % 2) == 0 )
  %if (evenOrder)
    %assign nPairs = (ordNum/2)-1     %% EVEN order
  %else
    %assign nPairs = (ordNum-1)/2     %% ODD order
  %endif
  %if ordNum == 0
    %if (numSamps * numChans) > 1
      %assign idx = "i"
      int_T i;
      for (i=0; i < %<numSamps * numChans>; i++) {
    %else
      %assign idx = "0"
    %endif
    %assign out = LibBlockOutputSignal(OUTPORT,idx,"",0)
    %assign in  = LibBlockInputSignal(INPORT,idx,"",0)
    %if SFcnParamSettings.COEFFS_ARE_FROM_MASK
      %assign b0  = LibBlockParameter(RTP1COEFF,"0","",0)
    %else
      %assign b0  = LibBlockInputSignal(COEFF1PORT,"0","",0)
    %endif
    %<FltptMAC(out,"=",in,b0,outCplx,inCplx,coeffCplx)>\
    %if (numSamps * numChans) > 1
      }
    %endif
  %else
    %<inDTypeName>    *inputs  = (%<inDTypeName> *)%<LibBlockInputSignalAddr(INPORT,"","",0)>;
    %<inDTypeName>    *states  = (%<inDTypeName> *)%<LibBlockDWorkAddr(FILT_STATES,"","",0)>;
    %<outDTypeName>   *outputs = (%<outDTypeName> *)%<LibBlockOutputSignalAddr(OUTPORT,"","",0)>;
    %if SFcnParamSettings.COEFFS_ARE_FROM_MASK
      %<coeffDTypeName> *coeffs  = (%<coeffDTypeName> *)%<LibBlockParameterAddr(RTP1COEFF, "", "", 0)>;
    %else
      %<coeffDTypeName> *coeffs  = (%<coeffDTypeName> *)%<LibBlockInputSignalAddr(COEFF1PORT, "", "", 0)>;
    %endif
    %<inDTypeName> tapSum;
    int_T j = 0;
    int_T coeffIdx = 0;
    %assign coeff = "coeffs[coeffIdx]"
    int_T dataIdx = 0;
    int_T indexN;
    %if ((numSamps > 1) || (numChans > 1))
      %assign output = "outputs[io_Idx]"
      %assign input  = "inputs[io_Idx]"
      int_T io_Idx = 0;
      %if numSamps > 1
        int_T i;
      %endif
    %else
      %assign output = "outputs[0]"
      %assign input  = "inputs[0]"
    %endif
    %if numChans > 1
      int_T k;
      /* Loop over each input channel */
      for (k=0; k < %<numChans>; k++) {
        int_T memIdx = k * %<numStates>;
        %assign state  = "states[memIdx+dataIdx]"
        %assign stateN = "states[memIdx+indexN]"
    %else
      %assign state  = "states[dataIdx]"
      %assign stateN = "states[indexN]"
    %endif
        indexN  = %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)>;
      %if numSamps > 1
        /* Loop over each frame */
        for (i = 0; i < %<numSamps>; i++) {
      %endif
      %if ((numSamps > 1) || (numChans > 1))
        /* reset coefIdx */ %% (only one filter per frame is supported)
        coeffIdx = 0;
      %endif
      /* load tapSum variable with product term from first and last filter coefficients */
      tapSum = %<input>;
      dataIdx = (indexN-1) + %<ordNum>;
      if (dataIdx >= %<ordNum>) dataIdx -= %<ordNum>;

      %if (FilterStructureID == DSP_DF_SYM)
        %<FltptEquals("tapSum","+=",state,inCplx,inCplx)>\
      %else
        %<FltptEquals("tapSum","-=",state,inCplx,inCplx)>\
      %endif
      %<FltptMAC(output,"=","tapSum",coeff,outCplx,inCplx,coeffCplx)>\
      coeffIdx++;

      %if (nPairs > 0)
        /* sum product terms from corresponding filter coefficient pairs */
        for (j=0; j < %<nPairs>; j++) {
          dataIdx = j+indexN;
          if (dataIdx >= %<ordNum>) dataIdx -= %<ordNum>;
          tapSum = %<state>;

          dataIdx += (%<ordNumMinusTwo> - 2*j);
          if (dataIdx >= %<ordNum>) dataIdx -= %<ordNum>;

          %if (FilterStructureID == DSP_DF_SYM)
            %<FltptEquals("tapSum","+=",state,inCplx,inCplx)>\
          %else
            %<FltptEquals("tapSum","-=",state,inCplx,inCplx)>\
          %endif
          %<FltptMAC(output,"+=","tapSum",coeff,outCplx,inCplx,coeffCplx)>\
          coeffIdx++;
        }
      %endif

      %if (evenOrder)
        /* add product term from center tap */
        dataIdx = j + indexN;
        if (dataIdx >= %<ordNum>) dataIdx -= %<ordNum>;
        %<FltptMAC(output,"+=",state,coeff,outCplx,inCplx,coeffCplx)>\
      %endif

      /* update circular buffer */
      if (--indexN<0) indexN=%<ordNumMinusOne>;

      /* read in data */
      %<stateN> = %<input>;
      %if ((numSamps > 1) || (numChans > 1))
        io_Idx++;
      %endif
      %if numSamps > 1
        } /* frame loop */
      %endif
    %if numChans > 1
      } /* channel loop */
    %endif
    %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)> = indexN;
  %endif
}
%endfunction %% FltptFIRSym


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptInlineCode
%%
%% FIXED POINT CODE GENERATION
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptInlineCode(block) Output
%%
  %switch (FilterTypeID)
    %case DSP_ALLPOLE
      %% ALLPOLE Filter
      %switch (FilterStructureID)
        %case DSP_DF
        %case DSP_TDF
          %<FixptAllPole(block)>
          %break
        %case DSP_LATTICE
          %<FixptLatticeAR(block)>
          %break
        %default
          %error "Fixed-point code generation is not supported for the specified all-pole filter structure."
          %break
      %endswitch
      %break
    %case DSP_FIR
      %% FIR Filter
      %switch (FilterStructureID)
        %case DSP_DF
        %case DSP_TDF
          %<FixptFIR(block)>
          %break
        %case DSP_LATTICE
          %<FixptLatticeMA(block)>
          %break
        %case DSP_DF_SYM
        %case DSP_DF_ASYM
          %<FixptFIRSym(block)>
        %break
        %default
          %error "Fixed-point code generation is not supported for the specified FIR filter structure."
          %break
      %endswitch
      %break
    %case DSP_IIR
      %% IIR Filter
      %switch (FilterStructureID)
        %case DSP_DF1
          %<FixptIIRDF1(block)>
          %break
        %case DSP_DF1T
          %<FixptIIRDF1T(block)>
          %break
        %case DSP_DF2
          %<FixptIIRDF2(block)>
          %break
        %case DSP_DF2T
          %<FixptIIRDF2T(block)>
          %break
        %default
          %error "Fixed-point code generation is not supported for the specified IIR filter structure."
          %break
      %endswitch
      %break
    %default
      %error "Fixed-point code generation is not supported for the specified filter type."
      %break
  %endswitch
%endfunction    %%FixptInlineCode


%%
%function FixptAllPoleOrder0(block) Output
%%
%% Optimization for scalar denominator coeffs:
%% In fixed-point we completely ignore the a0 coeff, so simply
%% do the following:
%% out = in
%% Did not use memcpy because a cast may occur.
/* Order zero all-pole. Assuming unity a0 and copying input to output. */
  int_T i = %<numChans * numSamps>;
  %assign in.label  = LibBlockInputSignal(INPORT,"i","","0")
  %assign out.label = LibBlockOutputSignal(OUTPORT,"i","","0")
  while (i--) {
    %<DSPFixptLibEquals(out,in,rndSat)>\
  }
%% Don't need filter per sample code in this case since the single
%% coeff is ignored anyway.
%endfunction

%%
%function FixptAllPoleOrder1(block, coeff, mem, prod, accum) Output
%%
%% Optimization for order 1 filters (den coeffs 2x1)
%% In fixed-point we completely ignore the a0 coeff, so simply
%% do the following:
%% out(n) = in(n) + a*out(n-1)
    /* Order one. Assuming unity a0. */
  %if SFcnParamSettings.COEFFS_ARE_FROM_MASK
    %assign coeff.label = LibBlockParameter(RTP1COEFF,"1","","0")
  %else
    %if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME || (numSamps == 1)
      %assign coeff.label = LibBlockInputSignal(COEFF1PORT,"1","","0")
    %else
      %assign coeff.label = LibBlockInputSignal(COEFF1PORT,"2*i+1","","0")
    %endif
  %endif
  %<accum.dTypeName> %<accum.label>;
  %<prodDT.Name> %<prod.label>;
  %if numSamps > 1
    %copyrecord outm1 out
    %if numChans > 1
      %assign outm1.label = LibBlockOutputSignal(OUTPORT,"io_Idx-1","","0")
      %assign out.label = LibBlockOutputSignal(OUTPORT,"io_Idx","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"io_Idx","","0")
      int_T i,io_Idx=0;
    %else
      %assign outm1.label = LibBlockOutputSignal(OUTPORT,"i-1","","0")
      %assign out.label = LibBlockOutputSignal(OUTPORT,"i","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"i","","0")
      %if (FilterStructureID == DSP_DF)
        int_T i=0;
      %else
        int_T i;
      %endif
    %endif
  %else
    %if numChans > 1
      %assign out.label = LibBlockOutputSignal(OUTPORT,"io_Idx","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"io_Idx","","0")
      int_T io_Idx=0;
    %endif
  %endif
  %if numChans > 1
    %assign mem.label = LibBlockDWork(FILT_STATES,"2*k","","0")
    int_T k;
    for (k=0; k<%<numChans>; k++) {
      %if (numSamps > 1) && (FilterStructureID == DSP_DF) && !SFcnParamSettings.COEFFS_UPDATE_PER_FRAME
        i=0;
      %endif
  %else
    %assign mem.label = LibBlockDWork(FILT_STATES,"0","","0")
  %endif
  %if (FilterStructureID == DSP_DF)
    %<DSPFixptLibEquals(accum,in,rndSat)>\
    %<FixptMAC(accum, "-=", prod, mem, coeff, rndSat)>\
    %<DSPFixptLibEquals(out,accum,rndSat)>\
    %if numSamps > 1
      %if numChans > 1
        io_Idx++;
        for (i=1; i< %<numSamps>; i++, io_Idx++) {
      %else
        for (i=1; i< %<numSamps>; i++) {
      %endif
      %<DSPFixptLibEquals(accum,in,rndSat)>\
      %% acc -= out(n-1) * coeff
      %<FixptMAC(accum, "-=", prod, outm1, coeff, rndSat)>\
      %<DSPFixptLibEquals(out,accum,rndSat)>\
      }
      %<mem.label> = %<outm1.label>;
    %else
      %<mem.label> = %<out.label>;
      %if numChans > 1
        io_Idx++;
      %endif
    %endif
  %else %% DSP_TDF
    %if numSamps > 1
      %if numChans > 1
        for (i=0; i< %<numSamps>; i++, io_Idx++) {
      %else
        for (i=0; i< %<numSamps>; i++) {
      %endif
    %endif
      %<DSPFixptLibEquals(accum,in,rndSat)>\
      %<DSPFixptLibPlusEquals(accum,mem,rndSat)>\
      %<DSPFixptLibEquals(out,accum,rndSat)>\
      %<FixptMAC(accum, "=", prod, out, coeff, rndSat)>\
      %<DSPFixptNegate(mem,accum,rndSat)>\
    %if numSamps > 1
      }
    %endif
    %if numSamps==1 && numChans > 1
      io_Idx++;
    %endif
  %endif
  %if numChans > 1
    }
  %endif
%endfunction


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptFIRSym
%%
%% FIXED POINT CODE GENERATION FOR SYMMETRIC FIR
%% ( Symmetric     Even Order FIR
%%   Symmetric     Odd  Order FIR
%%   Antisymmetric Even Order FIR
%%   Antisymmetric Odd Order FIR )
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptFIRSym(block) Output
%%
%assign memIsCplx = LibBlockDWorkIsComplex(FILT_STATES)
%assign memDTID   = LibBlockDWorkDataTypeId(FILT_STATES)
%assign memDT     = FixPt_GetDataTypeFromIndex(memDTID)
%assign memDTName = (memIsCplx) ? memDT.ComplexName : memDT.Name
%% create memData record
%if (numChans > 1)
  %assign memLabel = LibBlockDWork(FILT_STATES,"memIdx+dataIdx","","0")
%else
  %assign memLabel = LibBlockDWork(FILT_STATES,"dataIdx","","0")
%endif
%createrecord memDataIdx { label     memLabel; ...
                              dTypeRec  memDT; ...
                              isComplex memIsCplx }
%copyrecord memIndexN memDataIdx
%if (numChans > 1)
  %assign memIndexN.label = LibBlockDWork(FILT_STATES,"memIdx+indexN","","0")
%else
  %assign memIndexN.label = LibBlockDWork(FILT_STATES,"indexN","","0")
%endif
%% create acc record
%assign accumIsCplx = outportIsComplex
%assign accumDTName = (accumIsCplx) ? accumDT.ComplexName : accumDT.Name
%createrecord accum { label     accumLabel; ...
                         dTypeRec  accumDT; ...
                         isComplex accumIsCplx; ...
                         dTypeName accumDTName }
%% create tapSum record
%assign tapSumLabel = "tapSum"
%assign tapSumIsComplex = inportIsComplex
%assign tapSumDT = FixPt_GetParameterDataType(TAP_SUM_DATA_TYPE, 0, 0)
%assign tapSumDTName = (tapSumIsComplex) ? tapSumDT.ComplexName : tapSumDT.Name
%createrecord tapSum { label     tapSumLabel; ...
                       dTypeRec  tapSumDT; ...
                       isComplex tapSumIsComplex; ...
                       dTypeName tapSumDTName }
%% create prod record (always real)
%createrecord prod { label     prodLabel; ...
                        dTypeRec  prodDT; ...
                        isComplex 0 }
%% create coeff record
%if SFcnParamSettings.COEFFS_ARE_FROM_MASK
  %assign coeffLabel = LibBlockParameter(RTP1COEFF,"coeffIdx","","0")
  %assign coeffDT    = DSPFixPt_GetParameterDataType(RTP1COEFF)
%else
  %assign coeffLabel = LibBlockInputSignal(COEFF1PORT,"coeffIdx","","0")
  %assign coeffDT    = FixPt_GetInputDataType(COEFF1PORT)
%endif
%createrecord coeff { label     coeffLabel; ...
                         dTypeRec  coeffDT; ...
                         isComplex coeff1IsComplex }
%% create in record
%assign inLabel = LibBlockInputSignal(INPORT,"ioIdx","","0")
%createrecord in { label     inLabel; ...
                      dTypeRec  inDT; ...
                      isComplex inportIsComplex }
%% create out record
%assign outLabel = LibBlockOutputSignal(OUTPORT, "ioIdx", "", "0")
%createrecord out { label     outLabel; ...
                       dTypeRec  outDT; ...
                       isComplex outportIsComplex }
%assign numStates      = LibBlockDWorkWidth(FILT_STATES) / numChans
%assign ordNum         = numStates
%assign numCoeffs      = ordNum + 1
%assign ordNumMinusOne = ordNum - 1
%assign ordNumMinusTwo = ordNum - 2
%assign evenOrder = ( (ordNum % 2) == 0 )
%if (evenOrder)
  %assign nPairs = (ordNum/2)-1     %% EVEN order
%else
  %assign nPairs = (ordNum-1)/2     %% ODD order
%endif
%if ordNum == 0
  %assign block = block + in + out
  %<FixptFirOrIirOrder0(block, coeff, prod, accum)>\
%else
  {
%if (numChans > 1)
    int_T k = 0;
    int_T memIdx  = 0;
%endif
%if (numSamps > 1)
    int_T n = %<numSamps>;
%endif
%if ( (numChans > 1) || (numSamps > 1) )
    int_T ioIdx = 0;
%endif
    int_T j = 0;
    int_T indexN  = %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)>;
    int_T dataIdx = 0;
    int_T coeffIdx = 0;
    %<accum.dTypeName> %<accum.label>;
    %<tapSum.dTypeName> %<tapSum.label>;
    %<prodDT.Name> %<prod.label>;

%if (numChans > 1)
    for (k=0; k<%<numChans>; k++) {
	    memIdx = k * %<numStates>;
	    indexN = %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)>;
  %if (numSamps > 1)
        n = %<numSamps>;
  %endif
%endif
%if (numSamps > 1)
	    while (n--) {
%endif
%if ((numSamps > 1) || (numChans > 1))
	        /* reset coefIdx */ %%(only one filter per frame is supported)
	        coeffIdx = 0;
%endif
            /* load accumulator with product term from first and last filter coefficients */
            %<DSPFixptLibEquals(tapSum, in, rndSat)>\
            dataIdx = (indexN-1) + %<ordNum>;
            if (dataIdx >= %<ordNum>) dataIdx -= %<ordNum>;
%if (FilterStructureID == DSP_DF_SYM)
            %<DSPFixptLibPlusEquals(tapSum, memDataIdx, rndSat)>\
%else
            %<DSPFixptLibMinusEquals(tapSum, memDataIdx, rndSat)>\
%endif
            %<FixptMAC(accum, "=", prod, tapSum, coeff, rndSat)>\
            coeffIdx++;

%if (nPairs > 0)
            /* sum product term from corresponding filter coefficient pairs */
            for (j=0; j< %<nPairs>; j++) {
                dataIdx = j+indexN;
                if (dataIdx >= %<ordNum>) dataIdx -= %<ordNum>;
                %<DSPFixptLibEquals(tapSum, memDataIdx, rndSat)>\
                dataIdx += (%<ordNumMinusTwo> - 2*j);
                if (dataIdx >= %<ordNum>) dataIdx -= %<ordNum>;
  %if (FilterStructureID == DSP_DF_SYM)
                %<DSPFixptLibPlusEquals(tapSum, memDataIdx, rndSat)>\
  %else
                %<DSPFixptLibMinusEquals(tapSum, memDataIdx, rndSat)>\
  %endif
                %<FixptMAC(accum, "+=", prod, tapSum, coeff, rndSat)>\
                coeffIdx++;
            }
%endif

%if (evenOrder)
            /* add product term from center tap */
            dataIdx = j+indexN;
            if (dataIdx >= %<ordNum>) dataIdx -= %<ordNum>;
            %<FixptMAC(accum, "+=", prod, memDataIdx, coeff, rndSat)>\
%endif

	        /* update circular buffer */
	        if (--indexN<0) indexN=%<ordNumMinusOne>;

	        /* read in data */
	        %%mMemArray[memIdx+indexN] = mInpArray[ioIdx];
            %<DSPFixptLibEquals(memIndexN, in, rndSat)>\

            /* output result */
            %%mOutArray[ioIdx++] = mAccArray[0];
            %<DSPFixptLibEquals(out, accum, rndSat)>\
%if ( (numChans > 1) || (numSamps > 1) )
            ioIdx++;
%endif
%if (numSamps > 1)
	    }
%endif
%if (numChans > 1)
    }
%endif
    %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)> = indexN;
  }
%endif
%endfunction    %%FixptFIRSym



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptLatticeMA
%%
%% FIXED POINT CODE GENERATION FOR LATTICE MA
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptLatticeMA(block) Output
%%
%% create acc record
%assign accumIsCplx = outportIsComplex
%assign accumDTName = (accumIsCplx) ? accumDT.ComplexName : accumDT.Name
%createrecord F { label     "F"; ...
                     dTypeRec  accumDT; ...
                     isComplex accumIsCplx; ...
                     dTypeName accumDTName }
%copyrecord Gprev F
%assign Gprev.label = "Gprev"
%copyrecord G F
%assign G.label = "G"
%% create prod record (always real)
%createrecord prod { label     prodLabel; ...
                        dTypeRec  prodDT; ...
                        isComplex 0 }
%% create coeff record
%if SFcnParamSettings.COEFFS_ARE_FROM_MASK
  %assign coeffLabel = LibBlockParameter(RTP1COEFF,"coeffIdx","","0")
  %assign coeffDT    = DSPFixPt_GetParameterDataType(RTP1COEFF)
%else
  %assign coeffLabel = LibBlockInputSignal(COEFF1PORT,"coeffIdx","","0")
  %assign coeffDT    = FixPt_GetInputDataType(COEFF1PORT)
%endif
%createrecord coeff { label     coeffLabel; ...
                         dTypeRec  coeffDT; ...
                         isComplex coeff1IsComplex }
%% create in record
%assign inLabel = LibBlockInputSignal(INPORT,"ioIdx","","0")
%createrecord in { label     inLabel; ...
                      dTypeRec  inDT; ...
                      isComplex inportIsComplex }
%% create out record
%assign outLabel = LibBlockOutputSignal(OUTPORT, "ioIdx", "", "0")
%createrecord out { label     outLabel; ...
                       dTypeRec  outDT; ...
                       isComplex outportIsComplex }
%%
%assign memIsCplx = LibBlockDWorkIsComplex(FILT_STATES)
%assign memDTID   = LibBlockDWorkDataTypeId(FILT_STATES)
%assign memDT     = FixPt_GetDataTypeFromIndex(memDTID)
%assign memDTName = (memIsCplx) ? memDT.ComplexName : memDT.Name
%% create mem record
%assign memLabel = LibBlockDWork(FILT_STATES,"memIdx","","0")
%createrecord mem { label     memLabel; ...
                       dTypeRec  memDT; ...
                       isComplex memIsCplx }
%copyrecord state mem
%assign state.label = "state"
%%
%assign ordK         = LibBlockDWorkWidth(FILT_STATES) / numChans
%assign ordKMinusOne = ordK - 1
%if (ordK == 1)
  %assign block = block + in + out
  %<FixptLatticeOrder1(block,coeff,mem,prod,F)>\
%else
{
  %if (numChans > 1)
    int_T k        = 0;
  %endif
  %if ( (numChans > 1) || (numSamps > 1) )
    int_T ioIdx    = 0;
  %endif
    int_T memIdx   = 0;
    %<accumDTName> %<F.label>, %<G.label>, %<Gprev.label>;
    %<memDTName> %<state.label>;
    %<prodDT.Name> %<prod.label>;
  %if (coeff.isComplex)
    %copyrecord coeffConj coeff
    %assign coeffConj.label = "conjCoeff"
    %<coeffDT.ComplexName> %<coeffConj.label>;
  %endif

  %if numChans > 1
    /* Loop over each channel */
    for (k=0; k < %<numChans>; k++) {
  %endif
      int_T coeffIdx = 0;
  %if (numSamps > 1)
        /* Loop over each sample */
        int_T i  = %<numSamps>;
        while (i--) {
  %endif
            int  j = %<ordKMinusOne>;
  %if (numChans > 1)
            memIdx = k * %<ordK>;
  %elseif (numSamps > 1)
            memIdx = 0;
  %endif

            %<DSPFixptLibEquals(F, in, rndSat)>\
            %<DSPFixptLibEquals(Gprev, in, rndSat)>\

            while(j--) {
                %<DSPFixptLibEquals(state, F, rndSat)>\
                %<DSPFixptLibEquals(G, mem, rndSat)>\
                %if (coeff.isComplex)
                  %<DSPFixptLibConjugate(coeffConj, coeff, rndSat)>
                  %<FixptMAC(G, "+=", prod, coeffConj, state, rndSat)>\
                %else
                  %<FixptMAC(G, "+=", prod, coeff, state, rndSat)>\
                %endif
                %<FixptMAC(F, "+=", prod, mem, coeff, rndSat)>\
                coeffIdx++;
                %<DSPFixptLibEquals(mem, Gprev, rndSat)>\
                memIdx++;
                %<DSPFixptLibEquals(Gprev, G, rndSat)>\
            }
            %<FixptMAC(F, "+=", prod, coeff, mem, rndSat)>\
            coeffIdx++;
            %<DSPFixptLibEquals(out, F, rndSat)>\
  %if ( (numChans > 1) || (numSamps > 1) )
            ioIdx++;
  %endif
            %<DSPFixptLibEquals(mem, G, rndSat)>\
  %if (numSamps > 1)
    %if (SFcnParamSettings.COEFFS_UPDATE_PER_FRAME)
              /* reset filter coefficient index */
              coeffIdx -= %<ordK>;
    %endif
        }
  %endif
  %if numChans > 1
    } /* channel loop */
  %endif
}
%endif
%endfunction    %%FixptLatticeMA


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptLatticeAR
%%
%% FIXED POINT CODE GENERATION FOR LATTICE AR
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptLatticeAR(block) Output
%%
%%
%% create acc record
%assign accumIsCplx = outportIsComplex
%assign accumDTName = (accumIsCplx) ? accumDT.ComplexName : accumDT.Name
%createrecord F { label     "F"; ...
                     dTypeRec  accumDT; ...
                     isComplex accumIsCplx; ...
                     dTypeName accumDTName }
%copyrecord G F
%assign G.label = "G"
%% create prod record (always real)
%createrecord prod { label     prodLabel; ...
                        dTypeRec  prodDT; ...
                        isComplex 0 }
%% create coeff record
%if SFcnParamSettings.COEFFS_ARE_FROM_MASK
  %assign coeffLabel = LibBlockParameter(RTP1COEFF,"coeffIdx","","0")
  %assign coeffDT    = DSPFixPt_GetParameterDataType(RTP1COEFF)
%else
  %assign coeffLabel = LibBlockInputSignal(COEFF1PORT,"coeffIdx","","0")
  %assign coeffDT    = FixPt_GetInputDataType(COEFF1PORT)
%endif
%createrecord coeff { label     coeffLabel; ...
                         dTypeRec  coeffDT; ...
                         isComplex coeff1IsComplex }
%% create in record
%assign inLabel = LibBlockInputSignal(INPORT,"ioIdx","","0")
%createrecord in { label     inLabel; ...
                      dTypeRec  inDT; ...
                      isComplex inportIsComplex }
%% create out record
%assign outLabel = LibBlockOutputSignal(OUTPORT, "ioIdx", "", "0")
%createrecord out { label     outLabel; ...
                       dTypeRec  outDT; ...
                       isComplex outportIsComplex }
%%
%assign memIsCplx = LibBlockDWorkIsComplex(FILT_STATES)
%assign memDTID   = LibBlockDWorkDataTypeId(FILT_STATES)
%assign memDT     = FixPt_GetDataTypeFromIndex(memDTID)
%assign memDTName = (memIsCplx) ? memDT.ComplexName : memDT.Name
%% create mem record
%assign memLabel = LibBlockDWork(FILT_STATES,"memIdx","","0")
%createrecord mem { label     memLabel; ...
                       dTypeRec  memDT; ...
                       isComplex memIsCplx }
%copyrecord state mem
%assign state.label = "state"
%%
%assign ordK         = LibBlockDWorkWidth(FILT_STATES) / numChans
%assign ordKMinusOne = ordK - 1
%if (ordK == 1)
  %assign block = block + in + out
  %<FixptLatticeOrder1(block,coeff,mem,prod,F)>\
%else
{
  %if numChans > 1
    int_T k = 0;
  %endif
  %if ( (numSamps > 1) || (numChans > 1) )
    int_T ioIdx    = 0;
  %endif
    int_T memIdx   = %<ordKMinusOne>;
    %<accumDTName> %<F.label>, %<G.label>;
    %<memDTName> %<state.label>;
    %<prodDT.Name> %<prod.label>;
  %if (coeff.isComplex)
    %copyrecord coeffConj coeff
    %assign coeffConj.label = "conjCoeff"
    %<coeffDT.ComplexName> %<coeffConj.label>;
  %endif

  %if (numChans > 1)
    /* Loop over each channel */
    for (k=0; k < %<numChans>; k++) {
  %endif
        int_T coeffIdx = %<ordKMinusOne>;
  %if (numSamps > 1)
        /* Loop over each sample */
        int_T i  = %<numSamps>;
        while (i--) {
  %endif
            int j = %<ordKMinusOne>;
  %if (numChans > 1)
            memIdx = %<ordKMinusOne> + k * %<ordK>;
  %elseif (numSamps > 1)
            memIdx = %<ordKMinusOne>;
  %endif

            %<DSPFixptLibEquals(F, in, rndSat)>\
            %<FixptMAC(F, "-=", prod, coeff, mem, rndSat)>\
            coeffIdx--;

            while(j--) {
                --memIdx;
                %<FixptMAC(F, "-=", prod, coeff, mem, rndSat)>\
                %<DSPFixptLibEquals(G, mem, rndSat)>\
                %<DSPFixptLibEquals(state, F, rndSat)>\
                %if (coeff.isComplex)
                  %<DSPFixptLibConjugate(coeffConj, coeff, rndSat)>
                  %<FixptMAC(G, "+=", prod, state, coeffConj, rndSat)>\
                %else
                  %<FixptMAC(G, "+=", prod, state, coeff, rndSat)>\
                %endif
                coeffIdx--;
                %copyrecord mem1 mem
                %assign mem1.label = LibBlockDWork(FILT_STATES,"memIdx+1","","0")
                %<DSPFixptLibEquals(mem1, G, rndSat)>\
            }
            %<DSPFixptLibEquals(mem, F, rndSat)>\
            %<DSPFixptLibEquals(out, F, rndSat)>\
  %if ( (numSamps > 1) || (numChans > 1) )
            ioIdx++;
  %endif
  %if (numSamps > 1)
            /* points to last coefficient in next filter set */
  %if (SFcnParamSettings.COEFFS_UPDATE_PER_FRAME)
              coeffIdx = %<ordKMinusOne>;
  %else
              coeffIdx += 2*%<ordK>;
  %endif
        }
  %endif
  %if (numChans > 1)
    } /* channel loop */
  %endif
}
%endif
%endfunction    %%FixptLatticeAR


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptLatticeOrder1
%%
%% FIXED POINT CODE GENERATION FOR ORDER ONE
%% LATTICE MA and LATTICE AR FILTERS
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptLatticeOrder1(block,coeff,mem,prod,F) Output
%%
%assign accumDTName = (F.isComplex) ? F.dTypeRec.ComplexName : F.dTypeRec.Name
{
%if numChans > 1
    int_T k = 0;
%endif
%if ( (numSamps > 1) || (numChans > 1) )
    int_T ioIdx    = 0;
    int_T memIdx   = 0;
%endif
    %<accumDTName> %<F.label>;
    %<prodDT.Name> %<prod.label>;

%if (numChans > 1)
    /* Loop over each channel */
    for (k=0; k < %<numChans>; k++) {
%endif
%if (numSamps > 1)
        /* Loop over each sample */
        int_T i  = %<numSamps>;
        while (i--) {
%endif
%if (numChans > 1)
            memIdx = k;
%elseif (numSamps > 1)
            memIdx = 0;
%endif
            %<DSPFixptLibEquals(F, in, rndSat)>\
  %if (FilterTypeID == DSP_FIR)
            %<FixptMAC(F, "+=", prod, coeff, mem, rndSat)>\
    %if mem.isComplex
            %assign memReValStr = mem.label + ".re"
            %assign memImValStr = mem.label + ".im"
            %<memReValStr> = 0;
            %<memImValStr> = 0;
    %else
            %<mem.label> = 0;
    %endif
  %else
            %<FixptMAC(F, "-=", prod, coeff, mem, rndSat)>\
            %<DSPFixptLibEquals(mem, F, rndSat)>\
  %endif
            %<DSPFixptLibEquals(out, F, rndSat)>\
%if ( (numSamps > 1) || (numChans > 1) )
            ioIdx++;
%endif
%if (numSamps > 1)
        }
%endif
%if (numChans > 1)
    } /* channel loop */
%endif
}
%endfunction    %%FixptLatticeOrder1


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptAllPole
%%
%% FIXED POINT CODE GENERATION FOR ALLPOLE
%% (Both direct-form and transposed direct-form)
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptAllPole(block) Output
%%
%% create acc record
%assign accumIsCplx = outportIsComplex
%assign accumDTName = (accumIsCplx) ? accumDT.ComplexName : accumDT.Name
%createrecord accum { label     accumLabel; ...
                         dTypeRec  accumDT; ...
                         isComplex accumIsCplx; ...
                         dTypeName accumDTName }
%% create prod record (always real)
%createrecord prod { label     prodLabel; ...
                        dTypeRec  prodDT; ...
                        isComplex 0 }
%% create coeff record
%if SFcnParamSettings.COEFFS_ARE_FROM_MASK
  %assign coeffLabel = LibBlockParameter(RTP1COEFF,"coeffIdx","","0")
  %assign coeffDT    = DSPFixPt_GetParameterDataType(RTP1COEFF)
%else
  %assign coeffLabel = LibBlockInputSignal(COEFF1PORT,"coeffIdx","","0")
  %assign coeffDT    = FixPt_GetInputDataType(COEFF1PORT)
%endif
%createrecord coeff { label     coeffLabel; ...
                         dTypeRec  coeffDT; ...
                         isComplex coeff1IsComplex }
%% create in record
%if (numSamps > 1) || (numChans > 1)
  %assign labelStr = "io_Idx"
%else
  %assign labelStr = ""
%endif
%assign inLabel = LibBlockInputSignal(INPORT,labelStr,"","0")
%createrecord in { label     inLabel; ...
                      dTypeRec  inDT; ...
                      isComplex inportIsComplex }
%% create out record
%assign outLabel = LibBlockOutputSignal(OUTPORT,labelStr,"","0")
%createrecord out { label     outLabel; ...
                       dTypeRec  outDT; ...
                       isComplex outportIsComplex }
%%
%assign memIsCplx = LibBlockDWorkIsComplex(FILT_STATES)
%assign memDTID   = LibBlockDWorkDataTypeId(FILT_STATES)
%assign memDT     = FixPt_GetDataTypeFromIndex(memDTID)
%% create mem record
%assign memLabel = LibBlockDWork(FILT_STATES,"memIdx","","0")
%createrecord mem { label     memLabel; ...
                       dTypeRec  memDT; ...
                       isComplex memIsCplx }
%%
%assign numStates = LibBlockDWorkWidth(FILT_STATES) / numChans
%assign ordDEN = numStates - 1
%assign block      = block + in + out
%%
{
  %if (ordDEN == 0)
    %<FixptAllPoleOrder0(block)>\
  %elseif (ordDEN == 1)
    %<FixptAllPoleOrder1(block, coeff, mem, prod, accum)>\
  %else
    %if (numSamps > 1) || (numChans > 1)
      int_T io_Idx = 0;
    %endif
    %if (FilterStructureID == DSP_DF)
      /* Circular buffer index */
      int_T indexN = 0;
    %endif
    %<accum.dTypeName> %<accum.label>;
    %<prodDT.Name> %<prod.label>;
    %if numChans > 1
      int_T k;

      /* Loop over each input channel */
      for (k=0; k < %<numChans>; k++) {
        int_T memIdx = k * %<numStates>;  /* Set state memory index for this channel */
    %else
      int_T memIdx = 0; /* Set state memory index */
    %endif
      int_T coeffIdx = 0; /* Re-start coefficient index */
      %if numSamps > 1
        int_T i = %<numSamps>; /* Frame loop counter */
      %endif
      int_T j;
      %if (FilterStructureID == DSP_DF)
        /* Set circular buffer offset relative to root in each channel */
        indexN = %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)>;
      %else
        int_T currMemIdx;
      %endif
      %if numSamps > 1
        while (i--) {
        %endif
        %if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME
          /* During one-filter-per-frame process reset denominator coeffs pointer for each sample */
          coeffIdx = 1; /* re-start index */
        %else
          coeffIdx++; /* skip a0 (assume a0 == 1) for fixed-point filters */
        %endif

        %if (FilterStructureID == DSP_DF)
          %% Code for All-Pole Direct-Form structure:
          %<DSPFixptLibEquals(accum, in, rndSat)>\

          %assign mem.label = LibBlockDWork(FILT_STATES,"memIdx+j","","0")
          /* NOTE: using circular buffer for memory, hence 2 loops. */
          for (j=indexN; j < %<ordDEN>; j++, coeffIdx++) {
            %% acc -= mem * coeff
            %<FixptMAC(accum, "-=", prod, mem, coeff, rndSat)>\
          }
          for (j=0; j < indexN; j++, coeffIdx++) {
            %% acc -= mem * coeff
            %<FixptMAC(accum, "-=", prod, mem, coeff, rndSat)>\
          }

          /* Compute output value (cast) */
          %<DSPFixptLibEquals(out, accum, rndSat)>\

          /* update entire circ buffer by writing to only one element */
          if (--indexN < 0) indexN = %<ordDEN-1>;
          %assign mem.label = LibBlockDWork(FILT_STATES,"memIdx+indexN","","0")
          %<DSPFixptLibEquals(mem, out, rndSat)>\
        %else
          %% Code for All-Pole Transposed Direct-Form structure:
          currMemIdx = memIdx;
          /* Compute the output value
           * y[n] = x[n] + D0[n]
           */
          %<DSPFixptLibEquals(accum, in, rndSat)>\
          %assign mem.label = LibBlockDWork(FILT_STATES,"currMemIdx","","0")
          %<DSPFixptLibPlusEquals(accum,mem,rndSat)>\
          %<DSPFixptLibEquals(out, accum, rndSat)>\

          /* Update filter states
           *   D0[n+1] = D1[n] - y[n]*a1
           *   D1[n+1] = D2[n] - y[n]*a2
           *   ...
           */
          j = %<ordDEN>;
          while (j--) {
            %assign mem.label = LibBlockDWork(FILT_STATES,"currMemIdx+1","","0")
            %<DSPFixptLibEquals(accum, mem, rndSat)>\
            %<FixptMAC(accum, "-=", prod, out, coeff, rndSat)>\
            %assign mem.label = LibBlockDWork(FILT_STATES,"currMemIdx","","0")
            %<DSPFixptLibEquals(mem, accum, rndSat)>\
            coeffIdx++;
            currMemIdx++;
          }
        %endif
        %if (numSamps > 1) || (numChans > 1)
          io_Idx++;
        %endif
        %if numSamps > 1
        } /* frame loop */
      %endif
      %if numChans > 1
      } /* channel loop */
    %endif

    %if (FilterStructureID == DSP_DF)
      %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)> = indexN;
    %endif
  %endif
}

%endfunction    %%FixptAllPole


%%
%function FixptFirOrIirOrder0(block, coeff, prod, accum) Output
%%
%% Optimization for order 0 filters. This means b coeffs are a scalar (b0
%% only) and likewise for a coefficients, except that a is not only assumed
%% to be a scalar, but a0 is also assumed to be unity.
%% In fixed-point we completely ignore the a0 coeff, so simply
%% do the following:
%% out = b0 * in
%%
%assign in.label  = LibBlockInputSignal(INPORT,"i","","0")
%assign out.label = LibBlockOutputSignal(OUTPORT,"i","","0")
%%
/* Order zero filter. Assuming unity a0. */
{
  %assign inAndCoeffComplex = (in.isComplex) && (coeff.isComplex)
  %if ((SFcnParamSettings.COEFFS_UPDATE_PER_FRAME) || (numSamps == 1))
    %if inAndCoeffComplex
      %<accum.dTypeName> %<accum.label>;
    %endif
    %<prodDT.Name> %<prod.label>;
    %if ((numChans * numSamps) > 1)
    int_T i = %<numChans * numSamps>;
    while (i--) {
    %else
      %assign in.label  = LibBlockInputSignal(INPORT,"0","","0")
      %assign out.label = LibBlockOutputSignal(OUTPORT,"0","","0")
    %endif
      %if inAndCoeffComplex
        %<FixptMAC(accum, "=", prod, in, coeff, rndSat)>\
        %<DSPFixptLibEquals(out, accum, rndSat)>\
      %else
        %<FixptMAC(out, "=", prod, in, coeff, rndSat)>\
      %endif
    %if ((numChans * numSamps) > 1)
    }
    %endif
  %else  %% Update Filter per Sample
    %if inAndCoeffComplex
      %<accum.dTypeName> %<accum.label>;
    %endif
    %<prodDT.Name> %<prod.label>;
    int_T coeffIdx;
    %if numChans > 1
      int_T i=0,l=%<numChans>;
      while (l--) {
    %else
      %assign in.label  = LibBlockInputSignal(INPORT,"coeffIdx","","0")
      %assign out.label = LibBlockOutputSignal(OUTPORT,"coeffIdx","","0")
    %endif
        for (coeffIdx=0; coeffIdx<%<numSamps>; coeffIdx++) {
    %if inAndCoeffComplex
          %<FixptMAC(accum, "=", prod, in, coeff, rndSat)>\
          %<DSPFixptLibEquals(out, accum, rndSat)>\
    %else
          %<FixptMAC(out, "=", prod, in, coeff, rndSat)>\
    %endif
    %if numChans > 1
          i++;
        }
    %endif
    }
  %endif
}
%endfunction

%%
%function FixptFIROrder1(block, coeff, mem, prod, accum) Output
%%
%% Optimization for order 1 FIR filters (num coeffs 2x1)
%% out(n) = b0*in(n) + b1*in(n-1)
  %copyrecord coeffm1 coeff
  %if SFcnParamSettings.COEFFS_ARE_FROM_MASK
    %assign coeff.label = LibBlockParameter(RTP1COEFF,"0","","0")
    %assign coeffm1.label = LibBlockParameter(RTP1COEFF,"1","","0")
  %else
    %if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME || (numSamps == 1)
      %assign coeff.label = LibBlockInputSignal(COEFF1PORT,"0","","0")
      %assign coeffm1.label = LibBlockInputSignal(COEFF1PORT,"1","","0")
    %else
      %assign coeff.label = LibBlockInputSignal(COEFF1PORT,"2*i","","0")
      %assign coeffm1.label = LibBlockInputSignal(COEFF1PORT,"2*i+1","","0")
    %endif
  %endif
  %<accum.dTypeName> %<accum.label>;
  %<prodDT.Name> %<prod.label>;
  %if numSamps > 1
    %copyrecord inm1 in
    %if numChans > 1
      %assign out.label = LibBlockOutputSignal(OUTPORT,"io_Idx","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"io_Idx","","0")
      %assign inm1.label = LibBlockInputSignal(INPORT,"io_Idx-1","","0")
      int_T i,io_Idx=0;
    %else
      %assign out.label = LibBlockOutputSignal(OUTPORT,"i","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"i","","0")
      %assign inm1.label = LibBlockInputSignal(INPORT,"i-1","","0")
      %if (FilterStructureID == DSP_DF)
        int_T i=0;
      %else
        int_T i;
      %endif
    %endif
  %else
    %if numChans > 1
      %assign out.label = LibBlockOutputSignal(OUTPORT,"io_Idx","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"io_Idx","","0")
      int_T io_Idx=0;
    %endif
  %endif
  %if numChans > 1
    %assign mem.label = LibBlockDWork(FILT_STATES,"2*k","","0")
    int_T k;
    for (k=0; k<%<numChans>; k++) {
      %if (numSamps > 1) && (FilterStructureID == DSP_DF) && !SFcnParamSettings.COEFFS_UPDATE_PER_FRAME
        i=0;
      %endif
  %else
    %assign mem.label = LibBlockDWork(FILT_STATES,"0","","0")
  %endif
  %if (FilterStructureID == DSP_DF)
    %<FixptMAC(accum, "=", prod, in, coeff, rndSat)>\
    %<FixptMAC(accum, "+=", prod, mem, coeffm1, rndSat)>\
    %<DSPFixptLibEquals(out,accum,rndSat)>\
    %if numSamps > 1
      %if numChans > 1
        io_Idx++;
        for (i=1; i< %<numSamps>; i++, io_Idx++) {
      %else
        for (i=1; i< %<numSamps>; i++) {
      %endif
      %<FixptMAC(accum, "=", prod, in, coeff, rndSat)>\
      %% acc += in(n-1) * coeff(1)
      %<FixptMAC(accum, "+=", prod, inm1, coeffm1, rndSat)>\
      %<DSPFixptLibEquals(out,accum,rndSat)>\
      }
      %if numChans > 1
        %<mem.label> = %<inm1.label>;
      %else
        %% Single channel, numSamps > 1, can directly reference
        %% the "i-1"th sample:
        %assign lastInput = LibBlockInputSignal(INPORT,"%<numSamps-1>","","")
        %<mem.label> = %<lastInput>;
      %endif
    %else
      %<mem.label> = %<in.label>;
      %if numChans > 1
        io_Idx++;
      %endif
    %endif
  %else %% DSP_TDF
    %if numSamps > 1
      %if numChans > 1
        for (i=0; i< %<numSamps>; i++, io_Idx++) {
      %else
        for (i=0; i< %<numSamps>; i++) {
      %endif
    %endif
      %<FixptMAC(accum, "=", prod, in, coeff, rndSat)>\
      %<DSPFixptLibPlusEquals(accum,mem,rndSat)>\
      %<DSPFixptLibEquals(out,accum,rndSat)>\
      %<FixptMAC(accum, "=", prod, in, coeffm1, rndSat)>\
      %<DSPFixptLibEquals(mem,accum,rndSat)>\
    %if numSamps > 1
      }
    %endif
    %if numSamps==1 && numChans > 1
      io_Idx++;
    %endif
  %endif
  %if numChans > 1
    }
  %endif
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptFIR
%%
%% FIXED POINT CODE GENERATION FOR FIR
%% (Both direct-form and transposed direct-form)
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptFIR(block) Output
%%
%% create acc record
%assign accumIsCplx = outportIsComplex
%assign accumDTName = (accumIsCplx) ? accumDT.ComplexName : accumDT.Name
%createrecord accum { label     accumLabel; ...
                         dTypeRec  accumDT; ...
                         isComplex accumIsCplx; ...
                         dTypeName accumDTName }
%% create prod record (always real)
%createrecord prod { label     prodLabel; ...
                        dTypeRec  prodDT; ...
                        isComplex 0 }
%% create coeff record
%if SFcnParamSettings.COEFFS_ARE_FROM_MASK
  %assign coeffLabel = LibBlockParameter(RTP1COEFF,"coeffIdx","","0")
  %assign coeffDT    = DSPFixPt_GetParameterDataType(RTP1COEFF)
%else
  %assign coeffLabel = LibBlockInputSignal(COEFF1PORT,"coeffIdx","","0")
  %assign coeffDT    = FixPt_GetInputDataType(COEFF1PORT)
%endif
%createrecord coeff { label     coeffLabel; ...
                         dTypeRec  coeffDT; ...
                         isComplex coeff1IsComplex }
%% create in record
%assign inLabel = LibBlockInputSignal(INPORT,"io_Idx","","0")
%createrecord in { label     inLabel; ...
                      dTypeRec  inDT; ...
                      isComplex inportIsComplex }
%% create out record
%assign outLabel = LibBlockOutputSignal(OUTPORT, "io_Idx", "", "0")
%createrecord out { label     outLabel; ...
                       dTypeRec  outDT; ...
                       isComplex outportIsComplex }
%%
%assign memIsCplx = LibBlockDWorkIsComplex(FILT_STATES)
%assign memDTID   = LibBlockDWorkDataTypeId(FILT_STATES)
%assign memDT     = FixPt_GetDataTypeFromIndex(memDTID)
%% create mem record
%assign memLabel = LibBlockDWork(FILT_STATES,"memIdx","","0")
%createrecord mem { label     memLabel; ...
                       dTypeRec  memDT; ...
                       isComplex memIsCplx }
%%
%assign numStates = LibBlockDWorkWidth(FILT_STATES) / numChans
%assign ordNUM = numStates - 1
%assign block      = block + in + out
%if ordNUM == 0
  %<FixptFirOrIirOrder0(block, coeff, prod, accum)>\
%elseif ordNUM == 1
{
  %<FixptFIROrder1(block, coeff, mem, prod, accum)>\
}
%else
 %%
 {
  int_T io_Idx = 0;
  %if (FilterStructureID == DSP_DF)
    /* Circular buffer index */
    int_T indexN = 0;
  %endif
  %<accum.dTypeName> %<accum.label>;
  %<prodDT.Name> %<prod.label>;
  %if numChans > 1
  int_T k;

  /* Loop over each input channel */
  for (k=0; k < %<numChans>; k++) {
    int_T memIdx = k * %<numStates>;  /* Set state memory index for this channel */
  %else
    int_T memIdx = 0; /* Set state memory index */
  %endif
    int_T coeffIdx = 0; /* Re-start coefficient index */
    %if numSamps > 1
    int_T i = %<numSamps>; /* Frame loop counter */
    %endif
    int_T j;
    %if (FilterStructureID == DSP_DF)
      /* Set circular buffer offset relative to root in each channel */
      indexN = %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)>;
    %else
      int_T currMemIdx;
    %endif
    %if numSamps > 1
    while (i--) {
    %endif
      %if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME
        /* During one-filter-per-frame process reset numerator coeffs pointer for each sample */
        coeffIdx = 0; /* re-start index */
      %endif

      %if (FilterStructureID == DSP_DF)
        %% Code for FIR Direct-Form structure:
        /* Compute initial product (cast) */
        %<FixptMAC(accum, "=", prod, in, coeff, rndSat)>\
        coeffIdx++;

        %assign mem.label = LibBlockDWork(FILT_STATES,"memIdx+j","","0")
        /* NOTE: using circular buffer for memory, hence 2 loops. */
        for (j=indexN; j < %<ordNUM>; j++, coeffIdx++) {
          %% acc += mem * coeff
          %<FixptMAC(accum, "+=", prod, mem, coeff, rndSat)>\
        }
        for (j=0; j < indexN; j++, coeffIdx++) {
          %% acc += mem * coeff
          %<FixptMAC(accum, "+=", prod, mem, coeff, rndSat)>\
        }
        %if (ordNUM > 0)
          if (--indexN < 0) indexN = %<ordNUM-1>;
        %endif

        /* update entire circ buffer by writing to only one element */
        %assign mem.label = LibBlockDWork(FILT_STATES,"memIdx+indexN","","0")
        %<DSPFixptLibEquals(mem, in, rndSat)>\

        /* Compute output value (cast) */
        %<DSPFixptLibEquals(out, accum, rndSat)>\
      %else
        %% Code for FIR Transposed Direct-Form structure:
        currMemIdx = memIdx;
        /* Compute the output value
         * y[n] = x[n]*b0 + D0[n]
         */
        %assign mem.label = LibBlockDWork(FILT_STATES,"currMemIdx","","0")
        %<DSPFixptLibEquals(accum, mem, rndSat)>\
        %<FixptMAC(accum, "+=", prod, in, coeff, rndSat)>\
        %<DSPFixptLibEquals(out, accum, rndSat)>\
        coeffIdx++;

        /* Update filter states
         *   D0[n+1] = D1[n] + x[n]*b1
         *   D1[n+1] = D2[n] + x[n]*b2
         *   ...
         */
        j = %<ordNUM>;
        while (j--) {
          %assign mem.label = LibBlockDWork(FILT_STATES,"currMemIdx+1","","0")
          %<DSPFixptLibEquals(accum, mem, rndSat)>\
          %<FixptMAC(accum, "+=", prod, in, coeff, rndSat)>\
          %assign mem.label = LibBlockDWork(FILT_STATES,"currMemIdx","","0")
          %<DSPFixptLibEquals(mem, accum, rndSat)>\
          coeffIdx++;
          currMemIdx++;
        }
      %endif
    %if (numSamps > 1) || (numChans > 1)
      io_Idx++;
    %endif
    %if numSamps > 1
    } /* frame loop */
    %endif
  %if numChans > 1
  } /* channel loop */
  %endif

  %if (FilterStructureID == DSP_DF)
    %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)> = indexN;
  %endif
}
%endif
%endfunction    %%FixptFIR


%%
%function FixptIIRDF1_Order1(block, numCoeff, numProd, numAccum, denCoeff, denProd, denAccum, numState, denState) Output
%%
%% Optimization for order 1 IIR DF1 filters (num coeffs 2x1 or 1x1, den coeffs 2x1 or 1x1
%% but not both 1x1).
%% XXX For now, both num coeffs and den coeffs are 2x1, until S-function allows 1x1
%%     coeffs for either num or den.
%% out(n) = b0*in(n) + b1*in(n-1) - a1*out(n-1)
  %copyrecord numCoeffm1 numCoeff
  %if SFcnParamSettings.COEFFS_ARE_FROM_MASK
    %assign numCoeff.label = LibBlockParameter(RTP1COEFF,"0","","0")
    %assign denCoeff.label = LibBlockParameter(RTP2COEFF,"1","","0")
    %assign numCoeffm1.label = LibBlockParameter(RTP1COEFF,"1","","0")
  %else
    %if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME || (numSamps == 1)
      %assign numCoeff.label = LibBlockInputSignal(COEFF1PORT,"0","","0")
      %assign denCoeff.label = LibBlockInputSignal(COEFF2PORT,"1","","0")
      %assign numCoeffm1.label = LibBlockInputSignal(COEFF1PORT,"1","","0")
    %else
      %assign numCoeff.label = LibBlockInputSignal(COEFF1PORT,"2*i","","0")
      %assign denCoeff.label = LibBlockInputSignal(COEFF2PORT,"2*i+1","","0")
      %assign numCoeffm1.label = LibBlockInputSignal(COEFF1PORT,"2*i+1","","0")
    %endif
  %endif
  %<numAccum.dTypeName> %<numAccum.label>; /* accum variable for numerator side sums */
  %<denAccum.dTypeName> %<denAccum.label>; /* accum variable for denominator side sums */
  %<numProdDT.Name> %<numProd.label>; /* product variable for numerator side multiplies */
  %if nCoeffsDen == 2
    %<denProdDT.Name> %<denProd.label>; /* product variable for denominator side multiplies */
  %endif
  %if numSamps > 1
    %copyrecord inm1 in
    %copyrecord outm1 out
    %if numChans > 1
      %assign out.label = LibBlockOutputSignal(OUTPORT,"io_Idx","","0")
      %assign outm1.label = LibBlockOutputSignal(OUTPORT,"io_Idx-1","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"io_Idx","","0")
      %assign inm1.label = LibBlockInputSignal(INPORT,"io_Idx-1","","0")
      int_T i,io_Idx=0;
    %else
      %assign out.label = LibBlockOutputSignal(OUTPORT,"i","","0")
      %assign outm1.label = LibBlockOutputSignal(OUTPORT,"i-1","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"i","","0")
      %assign inm1.label = LibBlockInputSignal(INPORT,"i-1","","0")
      int_T i=0;
    %endif
  %else
    %if numChans > 1
      %assign out.label = LibBlockOutputSignal(OUTPORT,"io_Idx","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"io_Idx","","0")
      int_T io_Idx=0;
    %endif
  %endif
  %if numChans > 1
%%    %assign numState.label = LibBlockDWork(DF1_ZERO_STATES,"2*k","","0")
%%    %assign denState.label = LibBlockDWork(DF1_POLE_STATES,"2*k","","0")
%% IIR DF1 is the only case that does NOT have extra state per channel
    %assign numState.label = LibBlockDWork(DF1_ZERO_STATES,"k","","0")
    %assign denState.label = LibBlockDWork(DF1_POLE_STATES,"k","","0")
    int_T k;
    for (k=0; k<%<numChans>; k++) {
      %if (numSamps > 1) && !SFcnParamSettings.COEFFS_UPDATE_PER_FRAME
        i=0;
      %endif
  %else
    %assign numState.label = LibBlockDWork(DF1_ZERO_STATES,"0","","0")
    %assign denState.label = LibBlockDWork(DF1_POLE_STATES,"0","","0")
  %endif
  %if nCoeffsNum == 1
    %% XXX Unreachable code until scalars allowed for DF1 coeffs
    %<FixptMAC(denAccum, "=", numProd, in, numCoeff, rndSat)>\
  %else %% nCoeffsNum == 2
    %<FixptMAC(numAccum, "=", numProd, in, numCoeff, rndSat)>\
    %<FixptMAC(numAccum, "+=", numProd, numState, numCoeffm1, rndSat)>\
    %<DSPFixptLibEquals(denAccum,numAccum,rndSat)>\
  %endif
  %if nCoeffsDen == 2
    %<FixptMAC(denAccum, "-=", denProd, denState, denCoeff, rndSat)>\
  %endif
  %<DSPFixptLibEquals(out,denAccum,rndSat)>\
  %if numSamps > 1
    %if numChans > 1
      io_Idx++;
      for (i=1; i< %<numSamps>; i++, io_Idx++) {
    %else
      for (i=1; i< %<numSamps>; i++) {
    %endif
    %if nCoeffsNum == 1
      %<FixptMAC(denAccum, "=", numProd, in, numCoeff, rndSat)>\
    %else %% nCoeffsNum == 2
      %<FixptMAC(numAccum, "=", numProd, in, numCoeff, rndSat)>\
      %<FixptMAC(numAccum, "+=", numProd, inm1, numCoeffm1, rndSat)>\
      %<DSPFixptLibEquals(denAccum,numAccum,rndSat)>\
    %endif
    %if nCoeffsDen == 2
      %<FixptMAC(denAccum, "-=", denProd, outm1, denCoeff, rndSat)>\
    %endif
    %<DSPFixptLibEquals(out,denAccum,rndSat)>\
    }
    %if nCoeffsNum == 2
      %if numChans > 1
        %<numState.label> = %<inm1.label>;
      %else
        %% Single channel, numSamps > 1, can directly reference
        %% the "i-1"th sample:
        %assign lastInput = LibBlockInputSignal(INPORT,"%<numSamps-1>","","")
        %<numState.label> = %<lastInput>;
      %endif
    %endif
    %if nCoeffsDen == 2
      %if numChans > 1
        %<denState.label> = %<outm1.label>;
      %else
        %% Single channel, numSamps > 1, can directly reference
        %% the "i-1"th sample:
        %assign lastOutput = LibBlockOutputSignal(OUTPORT,"%<numSamps-1>","","")
        %<denState.label> = %<lastOutput>;
      %endif
    %endif
  %else
    %if nCoeffsNum == 2
      %<numState.label> = %<in.label>;
    %endif
    %if nCoeffsDen == 2
      %<denState.label> = %<out.label>;
    %endif
    %if numChans > 1
      io_Idx++;
    %endif
  %endif
  %if numChans > 1
    }
  %endif
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptIIRDF1
%%
%% FIXED POINT CODE GENERATION FOR IIR DF1
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptIIRDF1(block) Output
%%
%assign inputStateIsComplex = inportIsComplex
%assign outputStateIsComplex = outportIsComplex
%% Numerator and denominator coeffs *must* have the same complexity
%assign coeffIsComplex = coeff1IsComplex
%% create numAccum record for numerator side sums
%% create denAccum record for denominator side sums
%% numAccum and denAccum could have different fraction lengths
%% numAccum and denAccum could have different complexities
%assign numAccumIsCplx = (inputStateIsComplex || coeffIsComplex)
%assign numAccumDT     = accumDT
%assign numAccumDTName = (numAccumIsCplx) ? numAccumDT.ComplexName : numAccumDT.Name
%createrecord numAccum { label     "numAccum"; ...
                            dTypeRec  numAccumDT; ...
                            isComplex numAccumIsCplx; ...
                            dTypeName numAccumDTName }
%assign denAccumIsCplx = (outputStateIsComplex || coeffIsComplex)
%assign denAccumDT     = accumDT
%assign denAccumDTName = (denAccumIsCplx) ? denAccumDT.ComplexName : denAccumDT.Name
%createrecord denAccum { label     "denAccum"; ...
                            dTypeRec  denAccumDT; ...
                            isComplex denAccumIsCplx; ...
                            dTypeName denAccumDTName }
%% create numProd record for numerator side products
%% create denProd record for denominator side products
%% numProd and denProd could have different fraction lengths
%% numProd and denProd have the same complexity (both are real)
%assign numProdDT     = prodDT
%createrecord numProd { label     "numProd"; ...
                           dTypeRec  numProdDT; ...
                           isComplex 0 }
%assign denProdDT     = prodDT
%createrecord denProd { label     "denProd"; ...
                           dTypeRec  denProdDT; ...
                           isComplex 0 }
%% create numCoeff record for numerator coefficients
%% create denCoeff record for denominator coefficients
%assign sampsPerChan = numSamps
%% Note: we're going to need a separate b[0] record.
%if SFcnParamSettings.COEFFS_ARE_FROM_MASK
  %assign numCoeffLabel = LibBlockParameter(RTP1COEFF,"numCoeffIdx","","0")
  %assign numCoeffZeroLabel = LibBlockParameter(RTP1COEFF,"0","","0")
  %assign numCoeffDT    = DSPFixPt_GetParameterDataType(RTP1COEFF)
  %assign numCoeffSize  = LibBlockParameterSize(RTP1COEFF)
  %assign nCoeffsNum    = (numCoeffSize[0] * numCoeffSize[1])
  %%
  %assign denCoeffLabel = LibBlockParameter(RTP2COEFF,"denCoeffIdx","","0")
  %assign denCoeffDT    = DSPFixPt_GetParameterDataType(RTP2COEFF)
  %assign denCoeffSize  = LibBlockParameterSize(RTP2COEFF)
  %assign nCoeffsDen    = (denCoeffSize[0] * denCoeffSize[1])
%else
  %assign numCoeffLabel = LibBlockInputSignal(COEFF1PORT,"numCoeffIdx","","0")
  %assign numCoeffZeroLabel = LibBlockInputSignal(COEFF1PORT,"0","","0")
  %assign numCoeffDT    = FixPt_GetInputDataType(COEFF1PORT)
  %assign nCoeffsNum    = LibBlockInputSignalWidth(COEFF1PORT)
  %%
  %assign denCoeffLabel = LibBlockInputSignal(COEFF2PORT,"denCoeffIdx","","0")
  %assign denCoeffDT    = FixPt_GetInputDataType(COEFF2PORT)
  %assign nCoeffsDen    = LibBlockInputSignalWidth(COEFF2PORT)
  %if (!SFcnParamSettings.COEFFS_UPDATE_PER_FRAME)
    %assign nCoeffsNum    = nCoeffsNum / sampsPerChan
    %assign nCoeffsDen    = nCoeffsDen / sampsPerChan
    %assign numCoeffZeroLabel = LibBlockInputSignal(COEFF1PORT,"i*%<nCoeffsNum>","","0")
  %endif
%endif
%createrecord numCoeff { label     numCoeffLabel; ...
                            dTypeRec  numCoeffDT; ...
                            isComplex coeffIsComplex }
%createrecord numCoeffZero { label     numCoeffZeroLabel; ...
                                dTypeRec  numCoeffDT; ...
                                isComplex coeffIsComplex }
%createrecord denCoeff { label     denCoeffLabel; ...
                            dTypeRec  denCoeffDT; ...
                            isComplex coeffIsComplex }
%% create in record
%assign inputLabel = LibBlockInputSignal(INPORT,"io_Idx","","0")
%createrecord in { label     inputLabel; ...
                         dTypeRec  inDT; ...
                         isComplex inportIsComplex }
%% create out record
%assign outputLabel = LibBlockOutputSignal(OUTPORT, "io_Idx", "", "0")
%createrecord out { label     outputLabel; ...
                          dTypeRec  outDT; ...
                          isComplex outportIsComplex }
%%
%assign inputStateDTID  = LibBlockDWorkDataTypeId(DF1_ZERO_STATES)
%assign inputStateDT    = FixPt_GetDataTypeFromIndex(inputStateDTID)
%assign outputStateDTID = LibBlockDWorkDataTypeId(DF1_POLE_STATES)
%assign outputStateDT   = FixPt_GetDataTypeFromIndex(outputStateDTID)
%assign nChans          = numChans
%% create inputState record
%% if nChans = 1, there is one single circular buffer and a single index is needed
%% if nChans > 1, we need an offset for each channel to index into the circular buffer
%if nChans > 1
  %assign inputStateIdxStr  = "inputStateOffset+j"
  %assign outputStateIdxStr = "outputStateOffset+j"
%else
  %assign inputStateIdxStr  = "j"
  %assign outputStateIdxStr = "j"
%endif
%assign inputStateLabel = LibBlockDWork(DF1_ZERO_STATES,"%<inputStateIdxStr>","","0")
%createrecord inputState { label     inputStateLabel; ...
                              dTypeRec  inputStateDT; ...
                              isComplex inputStateIsComplex }
%assign outputStateLabel = LibBlockDWork(DF1_POLE_STATES,"%<outputStateIdxStr>","","0")
%createrecord outputState { label     outputStateLabel; ...
                               dTypeRec  outputStateDT; ...
                               isComplex outputStateIsComplex }
%%
%assign nInputStates  = LibBlockDWorkWidth(DF1_ZERO_STATES) / nChans
%assign nOutputStates = LibBlockDWorkWidth(DF1_POLE_STATES) / nChans
%assign block      = block + in + out + nCoeffsNum + nCoeffsDen + numProdDT + denProdDT
%%
%if nCoeffsNum == 1 && nCoeffsDen == 1
%% Order 0
  %if SFcnParamSettings.COEFFS_ARE_FROM_MASK
    %assign numCoeffLabel = LibBlockParameter(RTP1COEFF,"0","","0")
  %else
    %assign numCoeffLabel = LibBlockInputSignal(COEFF1PORT,"coeffIdx","","0")
  %endif
  %assign numCoeff.label = numCoeffLabel
  %<FixptFirOrIirOrder0(block, numCoeff, numProd, numAccum)>\
%elseif (nCoeffsNum <= 2 && nCoeffsDen <= 2)
%% Order 1
{
  %<FixptIIRDF1_Order1(block, numCoeff, numProd, numAccum, denCoeff, denProd, denAccum, inputState, outputState)>\
}
%else
%% Order > 1
 {
  int_T io_Idx = 0;                         /* Input/output port index */
  %if nChans > 1
    int_T inputStateIdx;  /* Input state circular buffer index */
    int_T outputStateIdx; /* Output state circular buffer index */
  %else
    int_T inputStateIdx = %<LibBlockDWork(CIRCBUFFIDX, "0", "", 0)>; /* Input state circular buffer index */
    int_T outputStateIdx = %<LibBlockDWork(CIRCBUFFIDX, "1", "", 0)>; /* Output state circular buffer index */
  %endif
  %<numAccum.dTypeName> %<numAccum.label>; /* accum variable for numerator side sums */
  %<denAccum.dTypeName> %<denAccum.label>; /* accum variable for denominator side sums */
  %<numProdDT.Name> %<numProd.label>; /* product variable for numerator side multiplies */
  %<denProdDT.Name> %<denProd.label>; /* product variable for denominator side multiplies */
  %if nChans > 1
  int_T k;

  for (k=0; k < %<nChans>; k++) {      /* Loop over each input channel */
    int_T inputStateOffset = k * %<nInputStates>;  /* input state memory offset for this channel */
    int_T outputStateOffset = k * %<nOutputStates>;  /* output state memory offset for this channel */
  %endif
    int_T numCoeffIdx;
    int_T denCoeffIdx;
    %if sampsPerChan > 1
    int_T i;
    %else
    int_T j;
    %endif
    %if nChans > 1
      /* Set circular buffer offset relative to root in each channel */
      inputStateIdx = %<LibBlockDWork(CIRCBUFFIDX, "0", "", 0)>;
      outputStateIdx = %<LibBlockDWork(CIRCBUFFIDX, "1", "", 0)>;
    %endif
    %if sampsPerChan > 1
    for (i = 0; i < %<sampsPerChan>; i++) { /* Loop over samples in channel */
      int_T j;
    %endif
      %if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME
        /* When coefficients update once per frame of input samples,
         * reset coefficient indices processing each input sample
         */
        numCoeffIdx = 1; /* Sum "down" from the first coefficient product */
        denCoeffIdx = 1;
      %else
        numCoeffIdx = i*%<nCoeffsNum> + 1;
        denCoeffIdx = i*%<nCoeffsDen> + 1;
      %endif
      %% Initialize numerator accumulator
      %% numAcc = b[0] * input[io_idx]
      %% numCoeffZero below is automagically the right b[0]:
      %% i.e:
      %%  if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME
      %%    numCoeffZero -->   LibBlockParameter(RTP1COEFF,"0","","0")
      %%                     (OR) LibBlockInputSignal(COEFF1PORT,"0","","0")
      %%  else
      %%    numCoeffZero -->   LibBlockInputSignal(COEFF1PORT,"i*%<nCoeffsNum>","","0")
      %%
      %<FixptMAC(numAccum,"=",numProd,numCoeffZero,in,rndSat)>\
      /* Calculate partial sum for numerator side products */
      %assign inputState.label = inputStateLabel
      for (j = inputStateIdx; j < %<nInputStates>; j++, numCoeffIdx++) {
        %% numAcc += b[numCoeffIdx] * inputState[j]
        %<FixptMAC(numAccum,"+=",numProd,numCoeff,inputState,rndSat)>\
      }
      for (j = 0; j < inputStateIdx; j++, numCoeffIdx++) {
        %% numAcc += b[numCoeffIdx] * inputState[j]
        %<FixptMAC(numAccum,"+=",numProd,numCoeff,inputState,rndSat)>\
      }
      %% Initialize denominator accumulator
      %% denAcc = numAcc
      %<DSPFixptLibEquals(denAccum,numAccum,rndSat)>\
      /* Calculate partial sum for denominator side products */
      %assign outputState.label = outputStateLabel
      for (j = outputStateIdx; j < %<nOutputStates>; j++, denCoeffIdx++) {
        %% denAcc -= a[denCoeffIdx] * outputState[j];
        %<FixptMAC(denAccum,"-=",denProd,denCoeff,outputState,rndSat)>\
      }
      for (j = 0; j < outputStateIdx; j++, denCoeffIdx++) {
        %% denAcc -= a[denCoeffIdx] * outputState[j];
        %<FixptMAC(denAccum,"-=",denProd,denCoeff,outputState,rndSat)>\
      }
      %% output = denAcc
      %<DSPFixptLibEquals(out,denAccum,rndSat)>\
      /* Update circular buffer indices */
      if (--inputStateIdx  < 0) inputStateIdx  = %<nInputStates-1>;
      if (--outputStateIdx < 0) outputStateIdx = %<nOutputStates-1>;
      /* Update states */
      %if nChans > 1
        %assign inputState.label = LibBlockDWork(DF1_ZERO_STATES,"inputStateOffset+inputStateIdx","","0")
        %assign outputState.label = LibBlockDWork(DF1_POLE_STATES,"outputStateOffset+outputStateIdx","","0")
      %else
        %assign inputState.label = LibBlockDWork(DF1_ZERO_STATES,"inputStateIdx","","0")
        %assign outputState.label = LibBlockDWork(DF1_POLE_STATES,"outputStateIdx","","0")
      %endif
      %% inputState[inputStateIdx] = input[io_Idx]
      %<DSPFixptLibEquals(inputState,in,rndSat)>\
      %% outputState[outputStateIdx] = output[io_Idx]
      %<DSPFixptLibEquals(outputState,out,rndSat)>\
    %if (sampsPerChan > 1) || (nChans > 1)
      io_Idx++;
    %endif
    %if (sampsPerChan > 1)
    } /* sample loop */
    %endif
  %if nChans > 1
  } /* channel loop */
  %endif

  %<LibBlockDWork(CIRCBUFFIDX, "0", "", 0)> = inputStateIdx;
  %<LibBlockDWork(CIRCBUFFIDX, "1", "", 0)> = outputStateIdx;
 }
%endif
%endfunction    %%FixptIIRDF1


%%
%function FixptIIRDF1T_Order1(block, numCoeff, numProd, numAccum, denCoeff, denProd, denAccum, numState, denState, multIn) Output
%%
%% Optimization for order 1 IIR DF1 filters (num coeffs 2x1 or 1x1, den coeffs 2x1 or 1x1
%% but not both 1x1)
%% out(n) = b0*in(n) + b1*in(n-1) - a1*out(n-1)
  %copyrecord numCoeffm1 numCoeff
  %if SFcnParamSettings.COEFFS_ARE_FROM_MASK
    %assign numCoeff.label = LibBlockParameter(RTP1COEFF,"0","","0")
    %assign denCoeff.label = LibBlockParameter(RTP2COEFF,"1","","0")
    %assign numCoeffm1.label = LibBlockParameter(RTP1COEFF,"1","","0")
  %else
    %if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME || (numSamps == 1)
      %assign numCoeff.label = LibBlockInputSignal(COEFF1PORT,"0","","0")
      %assign denCoeff.label = LibBlockInputSignal(COEFF2PORT,"1","","0")
      %assign numCoeffm1.label = LibBlockInputSignal(COEFF1PORT,"1","","0")
    %else
      %assign numCoeff.label = LibBlockInputSignal(COEFF1PORT,"2*i","","0")
      %assign denCoeff.label = LibBlockInputSignal(COEFF2PORT,"2*i+1","","0")
      %assign numCoeffm1.label = LibBlockInputSignal(COEFF1PORT,"2*i+1","","0")
    %endif
  %endif
  %<numProd.dTypeName> %<numProd.label>; /* product variable for numerator side multiplies */
  %if nCoeffsNum == 2
    %<numAccum.dTypeName> %<numAccum.label>; /* accum variable for numerator side sums */
  %endif
  %if nCoeffsDen == 2
    %<denAccum.dTypeName> %<denAccum.label>; /* accum variable for denominator side sums */
    %<denProd.dTypeName> %<denProd.label>; /* product variable for denominator side multiplies */
  %endif
  %<multIn.dTypeName> %<multIn.label>; /* multiplicand */
  %if numSamps > 1
    int_T i;
    %if numChans > 1
      %assign out.label = LibBlockOutputSignal(OUTPORT,"io_Idx","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"io_Idx","","0")
      int_T io_Idx=0;
    %else
      %assign out.label = LibBlockOutputSignal(OUTPORT,"i","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"i","","0")
    %endif
  %else
    %if numChans > 1
      %assign out.label = LibBlockOutputSignal(OUTPORT,"io_Idx","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"io_Idx","","0")
      int_T io_Idx=0;
    %endif
  %endif
  %if numChans > 1
    %assign numState.label = LibBlockDWork(DF1_ZERO_STATES,"2*k","","0")
    %assign denState.label = LibBlockDWork(DF1_POLE_STATES,"2*k","","0")
    int_T k;
    for (k=0; k<%<numChans>; k++) {
  %else
    %assign numState.label = LibBlockDWork(DF1_ZERO_STATES,"0","","0")
    %assign denState.label = LibBlockDWork(DF1_POLE_STATES,"0","","0")
  %endif
  %if numSamps > 1
    %if numChans > 1
      for (i=0; i< %<numSamps>; i++, io_Idx++) {
    %else
      for (i=0; i< %<numSamps>; i++) {
    %endif
  %endif
  %if nCoeffsDen == 1
    %<DSPFixptLibEquals(multIn,in,rndSat)>\
  %else %% nCoeffsDen == 2
    %<DSPFixptLibEquals(denAccum,in,rndSat)>\
    %<DSPFixptLibPlusEquals(denAccum,denState,rndSat)>\
    %<DSPFixptLibEquals(multIn,denAccum,rndSat)>\
  %endif
  %if nCoeffsNum == 1
    %if (multIn.isComplex && numCoeff.isComplex)
      %<FixptMAC(numAccum,"=",numProd,multIn,numCoeff,rndSat)>\
      %<DSPFixptLibEquals(out,numAccum,rndSat)>\
    %else
      %<FixptMAC(out,"=",numProd,multIn,numCoeff,rndSat)>\
    %endif
  %else %% nCoeffsNum == 2
    %<FixptMAC(numAccum,"=",numProd,multIn,numCoeff,rndSat)>\
    %<DSPFixptLibPlusEquals(numAccum,numState,rndSat)>\
    %<DSPFixptLibEquals(out,numAccum,rndSat)>\
  %endif
  %if nCoeffsNum == 2
    %if (multIn.isComplex && numCoeffm1.isComplex)
      %<FixptMAC(numAccum,"=",numProd,multIn,numCoeffm1,rndSat)>\
      %<DSPFixptLibEquals(numState,numAccum,rndSat)>\
    %else
      %<FixptMAC(numState,"=",numProd,multIn,numCoeffm1,rndSat)>\
    %endif
  %endif
  %if nCoeffsDen == 2
    %<FixptMAC(denAccum, "=", denProd, multIn, denCoeff, rndSat)>\
    %<DSPFixptNegate(denState,denAccum,rndSat)>\
  %endif
  %if numSamps > 1
    }
  %endif
  %if numChans > 1
    %if numSamps == 1
      io_Idx++;
    %endif
    }
  %endif
%endfunction %% FixptIIRDF1T_Order1

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptIIRDF1T
%%
%% FIXED POINT CODE GENERATION FOR IIR DF1T
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptIIRDF1T(block) Output
%%
%% DF1T input, state, and output complexity:
%%  - input real, coeff real ==>  state: real, output: real
%%  - input real, coeff cplx ==>  state: cplx, output: cplx
%%  - input cplx, coeff real ==>  state: cplx, output: cplx
%%  - input cplx, coeff cplx ==>  state: cplx, output: cplx
%assign stateIsComplex = outportIsComplex
%% Numerator and denominator coeffs *must* have the same complexity
%assign coeffIsComplex = coeff1IsComplex
%% create zeroAccum record for zero-side sums
%% create poleAccum record for pole-side sums
%assign zeroAccumIsCplx = stateIsComplex
%assign zeroAccumDT     = accumDT
%assign zeroAccumDTName = (zeroAccumIsCplx) ? zeroAccumDT.ComplexName : zeroAccumDT.Name
%createrecord zeroAccum { label     "zeroAccum"; ...
                             dTypeRec  zeroAccumDT; ...
                             isComplex zeroAccumIsCplx; ...
                             dTypeName zeroAccumDTName }
%assign poleAccumIsCplx = stateIsComplex
%assign poleAccumDT     = accumDT
%assign poleAccumDTName = (poleAccumIsCplx) ? poleAccumDT.ComplexName : poleAccumDT.Name
%createrecord poleAccum { label     "poleAccum"; ...
                             dTypeRec  poleAccumDT; ...
                             isComplex poleAccumIsCplx; ...
                             dTypeName poleAccumDTName }
%% create zeroProd record for zero-side products
%% create poleProd record for pole-side products
%% zeroProd and poleProd could have different fraction lengths
%% zeroProd and poleProd have the same complexity (both are real)
%assign zeroProdDT = prodDT
%createrecord zeroProd { label     "zeroProd"; ...
                            dTypeRec  zeroProdDT; ...
                            isComplex 0 ; ...
                            dTypeName zeroProdDT.Name }
%assign poleProdDT = prodDT
%createrecord poleProd { label     "poleProd"; ...
                            dTypeRec  poleProdDT; ...
                            isComplex 0  ; ...
                            dTypeName poleProdDT.Name }
%% create numCoeff record for numerator coefficients
%% create denCoeff record for denominator coefficients
%assign sampsPerChan = numSamps
%% Note: we're going to need a separate b[0] record.
%if SFcnParamSettings.COEFFS_ARE_FROM_MASK
  %assign numCoeffLabel = LibBlockParameter(RTP1COEFF,"coeffIdx","","0")
  %assign numCoeffZeroLabel = LibBlockParameter(RTP1COEFF,"0","","0")
  %assign numCoeffDT    = DSPFixPt_GetParameterDataType(RTP1COEFF)
  %assign numCoeffSize  = LibBlockParameterSize(RTP1COEFF)
  %assign nCoeffsNum    = (numCoeffSize[0] * numCoeffSize[1])
  %%
  %assign denCoeffLabel = LibBlockParameter(RTP2COEFF,"coeffIdx","","0")
  %assign denCoeffDT    = DSPFixPt_GetParameterDataType(RTP2COEFF)
  %assign denCoeffSize  = LibBlockParameterSize(RTP2COEFF)
  %assign nCoeffsDen    = (denCoeffSize[0] * denCoeffSize[1])
%else
  %assign numCoeffLabel = LibBlockInputSignal(COEFF1PORT,"coeffIdx","","0")
  %assign numCoeffZeroLabel = LibBlockInputSignal(COEFF1PORT,"0","","0")
  %assign numCoeffDT    = FixPt_GetInputDataType(COEFF1PORT)
  %assign nCoeffsNum    = LibBlockInputSignalWidth(COEFF1PORT)
  %%
  %assign denCoeffLabel = LibBlockInputSignal(COEFF2PORT,"coeffIdx","","0")
  %assign denCoeffDT    = FixPt_GetInputDataType(COEFF2PORT)
  %assign nCoeffsDen    = LibBlockInputSignalWidth(COEFF2PORT)
  %if (sampsPerChan > 1) && (!SFcnParamSettings.COEFFS_UPDATE_PER_FRAME)
    %assign nCoeffsNum    = nCoeffsNum / sampsPerChan
    %assign nCoeffsDen    = nCoeffsDen / sampsPerChan
    %assign numCoeffZeroLabel = LibBlockInputSignal(COEFF1PORT,"i*%<nCoeffsNum>","","0")
  %endif
%endif
%createrecord numCoeff { label     numCoeffLabel; ...
                            dTypeRec  numCoeffDT; ...
                            isComplex coeffIsComplex }
%createrecord numCoeffZero { label     numCoeffZeroLabel; ...
                                dTypeRec  numCoeffDT; ...
                                isComplex coeffIsComplex }
%createrecord denCoeff { label     denCoeffLabel; ...
                            dTypeRec  denCoeffDT; ...
                            isComplex coeffIsComplex }
%% create in record
%if (LibBlockInputSignalWidth(INPORT) > 1)
  %assign ioIdxStr = "io_Idx"
%else
  %assign ioIdxStr = "0"
%endif
%assign inLabel = LibBlockInputSignal(INPORT,"%<ioIdxStr>","","0")
%createrecord in { label     inLabel; ...
                      dTypeRec  inDT; ...
                      isComplex inportIsComplex }
%% create out record
%assign outLabel = LibBlockOutputSignal(OUTPORT, "%<ioIdxStr>", "", "0")
%createrecord out { label     outLabel; ...
                       dTypeRec  outDT; ...
                       isComplex outportIsComplex }
%% create multIn record
%assign multInDTName = (outportIsComplex) ? outDT.ComplexName : outDT.Name
%createrecord multIn { label     "multIn"; ...
                          dTypeRec  outDT; ...
                          isComplex outportIsComplex; ...
                          dTypeName multInDTName }
%%
%%
%assign zeroStateDTID  = LibBlockDWorkDataTypeId(DF1_ZERO_STATES)
%assign zeroStateDT    = FixPt_GetDataTypeFromIndex(zeroStateDTID)
%assign poleStateDTID = LibBlockDWorkDataTypeId(DF1_POLE_STATES)
%assign poleStateDT   = FixPt_GetDataTypeFromIndex(poleStateDTID)
%% create zeroState and poleState records
%assign zeroStateLabel = LibBlockDWork(DF1_ZERO_STATES,"zeroMemIdx","","0")
%createrecord zeroState { label     zeroStateLabel; ...
                             dTypeRec  zeroStateDT; ...
                             isComplex stateIsComplex }
%assign poleStateLabel = LibBlockDWork(DF1_POLE_STATES,"poleMemIdx","","0")
%createrecord poleState { label     poleStateLabel; ...
                             dTypeRec  poleStateDT; ...
                             isComplex stateIsComplex }
%%
%assign nChans      = numChans
%assign nZeroStates = LibBlockDWorkWidth(DF1_ZERO_STATES) / nChans
%assign nPoleStates = LibBlockDWorkWidth(DF1_POLE_STATES) / nChans
%%
%% create nextZeroState and nextPoleState records
%assign nextZeroStateLabel = LibBlockDWork(DF1_ZERO_STATES,"zeroMemIdx+1","","0")
%createrecord nextZeroState { label     nextZeroStateLabel; ...
                                 dTypeRec  zeroStateDT; ...
                                 isComplex stateIsComplex }
%assign nextPoleStateLabel = LibBlockDWork(DF1_POLE_STATES,"poleMemIdx+1","","0")
%createrecord nextPoleState { label     nextPoleStateLabel; ...
                                 dTypeRec  poleStateDT; ...
                                 isComplex stateIsComplex }
%%
%assign ordNUM  = nCoeffsNum - 1
%assign ordDEN  = nCoeffsDen - 1
%assign lenMIN  = (ordNUM < ordDEN) ? ordNUM : ordDEN
%assign nonScalarNumCoeffs = (ordNUM > 0)
%assign nonScalarDenCoeffs = (ordDEN > 0)
%assign nonScalarCoeffs    = (nonScalarNumCoeffs || nonScalarDenCoeffs)
%assign block      = block + in + out + nCoeffsNum + nCoeffsDen
%%
%if !nonScalarCoeffs %% Not nonscalar == scalar
%% Order 0 case
  %<FixptFirOrIirOrder0(block, numCoeff, zeroProd, zeroAccum)>\
%elseif (ordNUM < 2) && (ordDEN < 2)
%% Order 1 case
{
  %<FixptIIRDF1T_Order1(block, numCoeff, zeroProd, zeroAccum, denCoeff, poleProd, poleAccum, zeroState, poleState, multIn)>\
}
%else
%% Order > 1 cases
 {
  %if (LibBlockInputSignalWidth(INPORT) > 1)
    int_T io_Idx = 0;                         /* Input/output port index */
  %endif
  %<zeroAccum.dTypeName> %<zeroAccum.label>; /* zero-side accumulator */
  %<poleAccum.dTypeName> %<poleAccum.label>; /* pole-side accumulator */
  %<multIn.dTypeName> %<multIn.label>; /* multiplicand */
  %<zeroProdDT.Name> %<zeroProd.label>; /* product variable for zero-side multiplies */
  %if nonScalarDenCoeffs
    %<poleProdDT.Name> %<poleProd.label>; /* product variable for pole-side multiplies */
  %endif
  %if nChans > 1
  int_T k;
  for (k=0; k < %<nChans>; k++) {      /* Loop over each input channel */
  %endif
    %if nonScalarCoeffs
      int_T coeffIdx = 1;
    %endif
    %if sampsPerChan > 1
    int_T i;
    for (i = 0; i < %<sampsPerChan>; i++) { /* Loop over samples in channel */
    %endif
    %if nonScalarCoeffs
      %if nChans > 1
        int_T zeroMemIdx = k * %<nZeroStates>;  /* Zero-side state memory offset for this channel */
        int_T poleMemIdx = k * %<nPoleStates>;  /* Pole-side state memory offset for this channel */
      %else
        int_T zeroMemIdx = 0; /* Zero-side state memory index */
        int_T poleMemIdx = 0; /* Pole-side state memory index */
      %endif
      int_T j = 0;
    %endif
      /* Compute output value */
      %% poleAcc  = input[io_Idx]
      %% poleAcc += poleState[poleMemIdx]
      %% multIn   = poleAcc
      %% zeroAcc  = multIn * b[0]
      %% zeroAcc += zeroState[zeroMemIdx]
      %% out      = zeroAcc
      %<DSPFixptLibEquals(poleAccum,in,rndSat)>\
      %if nonScalarDenCoeffs
        %<DSPFixptLibPlusEquals(poleAccum,poleState,rndSat)>\
      %endif
      %<DSPFixptLibEquals(multIn,poleAccum,rndSat)>\
      %<FixptMAC(zeroAccum,"=",zeroProd,multIn,numCoeffZero,rndSat)>\
      %if nonScalarNumCoeffs
        %<DSPFixptLibPlusEquals(zeroAccum,zeroState,rndSat)>\
      %endif
      %<DSPFixptLibEquals(out,zeroAccum,rndSat)>\
      %if (LibBlockInputSignalWidth(INPORT) > 1)
        io_Idx++;
      %endif
      %if lenMIN > 0
      /* Update states for numerator and denominator sides */
      for (j = 0; j < %<lenMIN>; j++) {
        %% zeroAcc  = zeroState[zeroMemIdx+1]
        %% zeroAcc += numCoeff[coeffIdx] * multIn
        %% zeroState[zeroMemIdx] = zeroAcc
        %<DSPFixptLibEquals(zeroAccum,nextZeroState,rndSat)>\
        %<FixptMAC(zeroAccum,"+=",zeroProd,numCoeff,multIn,rndSat)>\
        %<DSPFixptLibEquals(zeroState,zeroAccum,rndSat)>\
        zeroMemIdx++;

        %% poleAcc  = poleState[poleMemIdx+1]
        %% poleAcc -= denCoeff[coeffIdx] * multIn
        %% poleState[poleMemIdx] = poleAcc
        %<DSPFixptLibEquals(poleAccum,nextPoleState,rndSat)>\
        %<FixptMAC(poleAccum,"-=",poleProd,denCoeff,multIn,rndSat)>\
        %<DSPFixptLibEquals(poleState,poleAccum,rndSat)>\
        poleMemIdx++;
        coeffIdx++;
      }
      %endif
      %if (ordNUM > lenMIN)
      /* Numerator order is greater than denominator order (more zeros than poles),
       * so update rest of zero-side states
       */
      for ( ; j < %<ordNUM>; j++) {
        %% zeroAcc  = zeroState[zeroMemIdx+1]
        %% zeroAcc += numCoeff[coeffIdx] * multIn
        %% zeroState[zeroMemIdx] = zeroAcc
        %<DSPFixptLibEquals(zeroAccum,nextZeroState,rndSat)>\
        %<FixptMAC(zeroAccum,"+=",zeroProd,numCoeff,multIn,rndSat)>\
        %<DSPFixptLibEquals(zeroState,zeroAccum,rndSat)>\
        zeroMemIdx++;
        coeffIdx++;
      }
      %elseif (ordDEN > lenMIN)
      /* Denominator order is greater than numerator order (more poles than zeros),
       * so, update rest of pole-side states
       */
      for ( ; j < %<ordDEN>; j++) {
        %% poleAcc  = poleState[poleMemIdx+1]
        %% poleAcc -= denCoeff[coeffIdx] * multIn
        %% poleState[poleMemIdx] = poleAcc
        %<DSPFixptLibEquals(poleAccum,nextPoleState,rndSat)>\
        %<FixptMAC(poleAccum,"-=",poleProd,denCoeff,multIn,rndSat)>\
        %<DSPFixptLibEquals(poleState,poleAccum,rndSat)>\
        poleMemIdx++;
        coeffIdx++;
      }
      %endif
    %if sampsPerChan > 1
      %if nonScalarCoeffs
        %if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME
          /* During frame-based processing and one-filter-per-frame
           * reset num and den for each sample of the same frame
           */
          coeffIdx = 1;
        %else
          coeffIdx++;
        %endif
      %endif
    } /* sample loop */
    %endif
  %if nChans > 1
  } /* channel loop */
  %endif
 }
%endif
%endfunction    %%FixptIIRDF1T


%%
%function FixptIIRDF2_Order1(block, numCoeff, numProd, numAccum, denCoeffp1, denProd, denAccum, state) Output
%%
%% Optimization for order 1 IIR DF2 filters (num coeffs 2x1 or 1x1, den coeffs 2x1 or 1x1
%% but not both 1x1)
%% out(n) = b0*in(n) + b1*in(n-1) - a1*out(n-1)
  %copyrecord numCoeffp1 numCoeff
  %copyrecord statep1 state
  %if SFcnParamSettings.COEFFS_ARE_FROM_MASK
    %assign numCoeff.label = LibBlockParameter(RTP1COEFF,"0","","0")
    %assign denCoeffp1.label = LibBlockParameter(RTP2COEFF,"1","","0")
    %assign numCoeffp1.label = LibBlockParameter(RTP1COEFF,"1","","0")
  %else
    %if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME || (numSamps == 1)
      %assign numCoeff.label = LibBlockInputSignal(COEFF1PORT,"0","","0")
      %assign denCoeffp1.label = LibBlockInputSignal(COEFF2PORT,"1","","0")
      %assign numCoeffp1.label = LibBlockInputSignal(COEFF1PORT,"1","","0")
    %else
      %assign numCoeff.label = LibBlockInputSignal(COEFF1PORT,"2*i","","0")
      %assign denCoeffp1.label = LibBlockInputSignal(COEFF2PORT,"2*i+1","","0")
      %assign numCoeffp1.label = LibBlockInputSignal(COEFF1PORT,"2*i+1","","0")
    %endif
  %endif
  %if nCoeffsNum == 2
    %<numAccum.dTypeName> %<numAccum.label>; /* accum variable for numerator side sums */
  %endif
  %<numProdDT.Name> %<numProd.label>; /* product variable for numerator side multiplies */
  %if nCoeffsDen == 2
    %<denAccum.dTypeName> %<denAccum.label>; /* accum variable for denominator side sums */
    %<denProdDT.Name> %<denProd.label>; /* product variable for denominator side multiplies */
  %endif
  %if numSamps > 1
    int_T i;
    %if numChans > 1
      %assign out.label = LibBlockOutputSignal(OUTPORT,"io_Idx","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"io_Idx","","0")
      int_T io_Idx=0;
    %else
      %assign out.label = LibBlockOutputSignal(OUTPORT,"i","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"i","","0")
    %endif
  %else
    %if numChans > 1
      %assign out.label = LibBlockOutputSignal(OUTPORT,"io_Idx","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"io_Idx","","0")
      int_T io_Idx=0;
    %endif
  %endif
  %if numChans > 1
    %assign state.label = LibBlockDWork(FILT_STATES,"2*k","","0")
    %assign statep1.label = LibBlockDWork(FILT_STATES,"2*k+1","","0")
    int_T k;
    for (k=0; k<%<numChans>; k++) {
  %else
    %assign state.label = LibBlockDWork(FILT_STATES,"0","","0")
    %assign statep1.label = LibBlockDWork(FILT_STATES,"1","","0")
  %endif
  %if numSamps > 1
    %if numChans > 1
      for (i=0; i< %<numSamps>; i++, io_Idx++) {
    %else
      for (i=0; i< %<numSamps>; i++) {
    %endif
  %endif
  %if nCoeffsDen == 1
    %<DSPFixptLibEquals(state,in,rndSat)>\
  %else %% nCoeffsDen == 2
    %<DSPFixptLibEquals(denAccum,in,rndSat)>\
    %<FixptMAC(denAccum,"-=",denProd,statep1,denCoeffp1,rndSat)>\
    %<DSPFixptLibEquals(state,denAccum,rndSat)>\
  %endif
  %if nCoeffsNum == 1
    %if (state.isComplex && numCoeff.isComplex)
      %<FixptMAC(numAccum,"=",numProd,state,numCoeff,rndSat)>\
      %<DSPFixptLibEquals(out,numAccum,rndSat)>\
    %else
      %<FixptMAC(out,"=",numProd,state,numCoeff,rndSat)>\
    %endif
  %else %% nCoeffsNum == 2
    %<FixptMAC(numAccum,"=",numProd,state,numCoeff,rndSat)>\
    %<FixptMAC(numAccum,"+=",numProd,statep1,numCoeffp1,rndSat)>\
    %<DSPFixptLibEquals(out,numAccum,rndSat)>\
  %endif
  %<DSPFixptLibEquals(statep1,state,rndSat)>\
  %if numSamps > 1
    }
  %endif
  %if numChans > 1
    %if numSamps == 1
      io_Idx++;
    %endif
    }
  %endif
%endfunction %% FixptIIRDF2_Order1

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptIIRDF2
%%
%% FIXED POINT CODE GENERATION FOR IIR DF2
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptIIRDF2(block) Output
%%
%% DF2 input, state, and output complexity:
%%  - input real, coeff real ==>  state: real, output: real
%%  - input real, coeff cplx ==>  state: cplx, output: cplx
%%  - input cplx, coeff real ==>  state: cplx, output: cplx
%%  - input cplx, coeff cplx ==>  state: cplx, output: cplx
%assign stateIsComplex = outportIsComplex
%% Numerator and denominator coeffs *must* have the same complexity
%assign coeffIsComplex = coeff1IsComplex
%% create numAccum record for numerator side sums
%% create denAccum record for denominator side sums
%% numAccum and denAccum could have different fraction lengths, but
%% numAccum and denAccum have the same complexity
%assign accumIsCplx    = stateIsComplex
%assign numAccumDT     = accumDT
%assign numAccumDTName = (accumIsCplx) ? numAccumDT.ComplexName : numAccumDT.Name
%createrecord numAccum { label     "numAccum"; ...
                            dTypeRec  numAccumDT; ...
                            isComplex accumIsCplx; ...
                            dTypeName numAccumDTName }
%assign denAccumDT     = accumDT
%assign denAccumDTName = (accumIsCplx) ? denAccumDT.ComplexName : denAccumDT.Name
%createrecord denAccum { label     "denAccum"; ...
                            dTypeRec  denAccumDT; ...
                            isComplex accumIsCplx; ...
                            dTypeName denAccumDTName }
%% create numProd record for numerator side products
%% create denProd record for denominator side products
%% numProd and denProd could have different fraction lengths, but
%% numProd and denProd have the same complexity
%assign numProdDT     = prodDT
%createrecord numProd { label     "numProd"; ...
                           dTypeRec  numProdDT; ...
                           isComplex 0 }
%assign denProdDT     = prodDT
%createrecord denProd { label     "denProd"; ...
                           dTypeRec  denProdDT; ...
                           isComplex 0 }
%% create numCoeff record for numerator coefficients
%% create denCoeff record for denominator coefficients
%assign sampsPerChan = numSamps
%% Note: we're going to need a separate b[0] record.
%if SFcnParamSettings.COEFFS_ARE_FROM_MASK
  %assign numCoeffLabel = LibBlockParameter(RTP1COEFF,"numIdx","","0")
  %assign numCoeffZeroLabel = LibBlockParameter(RTP1COEFF,"0","","0")
  %assign numCoeffDT    = DSPFixPt_GetParameterDataType(RTP1COEFF)
  %assign numCoeffSize  = LibBlockParameterSize(RTP1COEFF)
  %assign nCoeffsNum    = (numCoeffSize[0] * numCoeffSize[1])
  %%
  %assign denCoeffLabel = LibBlockParameter(RTP2COEFF,"denIdx","","0")
  %assign denCoeffDT    = DSPFixPt_GetParameterDataType(RTP2COEFF)
  %assign denCoeffSize  = LibBlockParameterSize(RTP2COEFF)
  %assign nCoeffsDen    = (denCoeffSize[0] * denCoeffSize[1])
%else
  %assign numCoeffLabel = LibBlockInputSignal(COEFF1PORT,"numIdx","","0")
  %assign numCoeffZeroLabel = LibBlockInputSignal(COEFF1PORT,"0","","0")
  %assign numCoeffDT    = FixPt_GetInputDataType(COEFF1PORT)
  %assign nCoeffsNum    = LibBlockInputSignalWidth(COEFF1PORT)
  %%
  %assign denCoeffLabel = LibBlockInputSignal(COEFF2PORT,"denIdx","","0")
  %assign denCoeffDT    = FixPt_GetInputDataType(COEFF2PORT)
  %assign nCoeffsDen    = LibBlockInputSignalWidth(COEFF2PORT)
  %if (!SFcnParamSettings.COEFFS_UPDATE_PER_FRAME)
    %assign nCoeffsNum    = nCoeffsNum / sampsPerChan
    %assign nCoeffsDen    = nCoeffsDen / sampsPerChan
    %assign numCoeffZeroLabel = LibBlockInputSignal(COEFF1PORT,"i*%<nCoeffsNum>","","0")
  %endif
%endif
%createrecord numCoeff { label     numCoeffLabel; ...
                            dTypeRec  numCoeffDT; ...
                            isComplex coeffIsComplex }
%createrecord numCoeffZero { label     numCoeffZeroLabel; ...
                                dTypeRec  numCoeffDT; ...
                                isComplex coeffIsComplex }
%createrecord denCoeff { label     denCoeffLabel; ...
                            dTypeRec  denCoeffDT; ...
                            isComplex coeffIsComplex }
%% create in record
%assign inLabel = LibBlockInputSignal(INPORT,"io_Idx","","0")
%createrecord in { label     inLabel; ...
                      dTypeRec  inDT; ...
                      isComplex inportIsComplex }
%% create out record
%assign outLabel = LibBlockOutputSignal(OUTPORT, "io_Idx", "", "0")
%createrecord out { label     outLabel; ...
                       dTypeRec  outDT; ...
                       isComplex outportIsComplex }
%%
%assign stateDTID = LibBlockDWorkDataTypeId(FILT_STATES)
%assign stateDT   = FixPt_GetDataTypeFromIndex(stateDTID)
%assign nChans  = numChans
%% create state record for marching through the states
%% create d0state record for pointing to the D[0] state
%% if nChans = 1, there is one single circular buffer and a single index is needed
%% if nChans > 1, we need an offset for each channel to index into the circular buffer
%if nChans > 1
  %assign d0stateIdxStr = "memOffset+indexN"
  %assign stateIdxStr   = "memOffset+tempIndex"
%else
  %assign d0stateIdxStr = "indexN"
  %assign stateIdxStr   = "tempIndex"
%endif
%assign stateLabel = LibBlockDWork(FILT_STATES,"%<stateIdxStr>","","0")
%createrecord state { label     stateLabel; ...
                         dTypeRec  stateDT; ...
                         isComplex stateIsComplex }
%assign d0stateLabel = LibBlockDWork(FILT_STATES,"%<d0stateIdxStr>","","0")
%createrecord d0state { label     d0stateLabel; ...
                           dTypeRec  stateDT; ...
                           isComplex stateIsComplex }
%%
%assign nStates = LibBlockDWorkWidth(FILT_STATES) / nChans
%assign nDelays = nStates - 1
%assign ordNUM  = nCoeffsNum - 1
%assign ordDEN  = nCoeffsDen - 1
%assign lenMIN  = (ordNUM < ordDEN) ? ordNUM : ordDEN
%assign block      = block + in + out + nCoeffsNum + nCoeffsDen + numProdDT + denProdDT
%%
%if nCoeffsNum == 1 && nCoeffsDen == 1
  %if SFcnParamSettings.COEFFS_ARE_FROM_MASK
    %assign numCoeffLabel = LibBlockParameter(RTP1COEFF,"0","","0")
  %else
    %assign numCoeffLabel = LibBlockInputSignal(COEFF1PORT,"coeffIdx","","0")
  %endif
  %assign numCoeff.label = numCoeffLabel
  %<FixptFirOrIirOrder0(block, numCoeff, numProd, numAccum)>\
%elseif (ordNUM < 2) && (ordDEN < 2)
%% Order 1 case
{
  %<FixptIIRDF2_Order1(block, numCoeff, numProd, numAccum, denCoeff, denProd, denAccum, state)>\
}
%else
 {
  int_T io_Idx = 0;                         /* Input/output port index */
  %if nChans > 1
  int_T indexN; /* Circular buffer index */
  %else
  int_T indexN = %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)>; /* Circular buffer index */
  %endif
  %<numAccum.dTypeName> %<numAccum.label>; /* accum variable for numerator side sums */
  %<denAccum.dTypeName> %<denAccum.label>; /* accum variable for denominator side sums */
  %<numProdDT.Name> %<numProd.label>; /* product variable for numerator side multiplies */
  %<denProdDT.Name> %<denProd.label>; /* product variable for denominator side multiplies */
  %if nChans > 1
  int_T k;

  for (k=0; k < %<nChans>; k++) {      /* Loop over each input channel */
    int_T memOffset = k * %<nStates>;  /* state memory offset for this channel */
  %endif
    int_T numIdx = 1; /* b[0] not used until we calculate y */
    int_T denIdx = 1; /* a[0] is assumed to be unity */
    %if sampsPerChan > 1
    int_T i;
    %else
    int_T j;
    int_T tempIndex;
    %endif
    %if nChans > 1
      /* Set circular buffer offset relative to root in each channel */
      indexN = %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)>;
    %endif
    %if sampsPerChan > 1
    for (i = 0; i < %<sampsPerChan>; i++) { /* Loop over samples in channel */
      int_T j;
      int_T tempIndex;
    %endif

    /* Accumulate denominator (pole side) products */
    %<DSPFixptLibEquals(denAccum,in,rndSat)>\
    tempIndex = indexN;
    for (j=%<ordDEN>; j--; denIdx++) {
      if (++tempIndex > %<nDelays>) tempIndex = 0;
      %<FixptMAC(denAccum,"-=",denProd,state,denCoeff,rndSat)>\
    }

    /* Update states by storing computed pole side accumulation result */
    %<DSPFixptLibEquals(d0state,denAccum,rndSat)>\

    /* Accumulate numerator (zero side) products */
    %% numAcc = b[0] * d0state[%<d0stateIdxStr>]
    %% numCoeffZero below is automagically the right b[0]:
    %% i.e:
    %%  if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME
    %%    numCoeffZero -->   LibBlockParameter(RTP1COEFF,"0","","0")
    %%                     (OR) LibBlockInputSignal(COEFF1PORT,"0","","0")
    %%  else
    %%    numCoeffZero -->   LibBlockInputSignal(COEFF1PORT,"i*%<nCoeffsNum>","","0")
    %%
    %<FixptMAC(numAccum,"=",numProd,d0state,numCoeffZero,rndSat)>\
    tempIndex = indexN;
    for (j=%<ordNUM>; j--; numIdx++) {
      if (++tempIndex > %<nDelays>) tempIndex = 0;
      %<FixptMAC(numAccum,"+=",numProd,state,numCoeff,rndSat)>\
    }

    /* Compute output value */
    %<DSPFixptLibEquals(out,numAccum,rndSat)>\

    /* Adjust circular buffer index for next sample */
    if (--indexN < 0) indexN = %<nDelays>;

    %if (sampsPerChan > 1) || (nChans > 1)
      io_Idx++;
    %endif
    %if sampsPerChan > 1
      %if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME
      /* During frame-based processing and one-filter-per-frame
       * reset num and den for each sample of the same frame
       */
        numIdx = 1;
        denIdx = 1;
      %else
        numIdx++; /* b[0] not used until we calculate y */
        denIdx++; /* a[0] is assumed to be unity */
      %endif
    } /* sample loop */
    %endif
  %if nChans > 1
  } /* channel loop */
  %endif

  %<LibBlockDWork(CIRCBUFFIDX, "", "", 0)> = indexN;
 }
%endif
%endfunction    %%FixptIIRDF2


%%
%function FixptIIRDF2T_Order1(block, numCoeff, numProd, denCoeffp1, denProd, accum, state) Output
%%
%% Optimization for order 1 IIR DF2T filters (num coeffs 2x1 or 1x1, den coeffs 2x1 or 1x1
%% but not both 1x1)
%% out(n) = b0*in(n) + b1*in(n-1) - a1*out(n-1)
  %copyrecord numCoeffp1 numCoeff
  %if SFcnParamSettings.COEFFS_ARE_FROM_MASK
    %assign numCoeff.label = LibBlockParameter(RTP1COEFF,"0","","0")
    %assign denCoeffp1.label = LibBlockParameter(RTP2COEFF,"1","","0")
    %assign numCoeffp1.label = LibBlockParameter(RTP1COEFF,"1","","0")
  %else
    %if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME || (numSamps == 1)
      %assign numCoeff.label = LibBlockInputSignal(COEFF1PORT,"0","","0")
      %assign denCoeffp1.label = LibBlockInputSignal(COEFF2PORT,"1","","0")
      %assign numCoeffp1.label = LibBlockInputSignal(COEFF1PORT,"1","","0")
    %else
      %assign numCoeff.label = LibBlockInputSignal(COEFF1PORT,"2*i","","0")
      %assign denCoeffp1.label = LibBlockInputSignal(COEFF2PORT,"2*i+1","","0")
      %assign numCoeffp1.label = LibBlockInputSignal(COEFF1PORT,"2*i+1","","0")
    %endif
  %endif
  %<accum.dTypeName> %<accum.label>; /* accum variable for numerator side sums */
  %<numProdDT.Name> %<numProd.label>; /* product variable for numerator side multiplies */
  %if nCoeffsDen > 1
    %<denProdDT.Name> %<denProd.label>; /* product variable for denominator side multiplies */
  %endif
  %if numSamps > 1
    int_T i;
    %if numChans > 1
      %assign out.label = LibBlockOutputSignal(OUTPORT,"io_Idx","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"io_Idx","","0")
      int_T io_Idx=0;
    %else
      %assign out.label = LibBlockOutputSignal(OUTPORT,"i","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"i","","0")
    %endif
  %else
    %if numChans > 1
      %assign out.label = LibBlockOutputSignal(OUTPORT,"io_Idx","","0")
      %assign in.label = LibBlockInputSignal(INPORT,"io_Idx","","0")
      int_T io_Idx=0;
    %endif
  %endif
  %if numChans > 1
    %assign state.label = LibBlockDWork(FILT_STATES,"2*k","","0")
    int_T k;
    for (k=0; k<%<numChans>; k++) {
  %else
    %assign state.label = LibBlockDWork(FILT_STATES,"0","","0")
  %endif
  %if numSamps > 1
    %if numChans > 1
      for (i=0; i< %<numSamps>; i++, io_Idx++) {
    %else
      for (i=0; i< %<numSamps>; i++) {
    %endif
  %endif
  %<FixptMAC(accum,"=",numProd,numCoeff,in,rndSat)>\
  %<DSPFixptLibPlusEquals(accum,state,rndSat)>\
  %<DSPFixptLibEquals(out,accum,rndSat)>\
  %if nCoeffsDen == 1
    %if (numCoeffp1.isComplex && in.isComplex)
      %<FixptMAC(accum,"=",numProd,numCoeffp1,in,rndSat)>\
      %<DSPFixptLibEquals(state,accum,rndSat)>\
    %else
      %<FixptMAC(state,"=",numProd,numCoeffp1,in,rndSat)>\
    %endif
  %elseif nCoeffsNum == 1
    %<FixptMAC(accum, "=", denProd, denCoeffp1, out, rndSat)>\
    %<DSPFixptNegate(state,accum,rndSat)>\
  %else
    %<FixptMAC(accum,"=",numProd,numCoeffp1,in,rndSat)>\
    %<FixptMAC(accum,"-=",denProd,denCoeffp1,out,rndSat)>\
    %<DSPFixptLibEquals(state,accum,rndSat)>\
  %endif
  %if numSamps > 1
    }
  %endif
  %if numChans > 1
    %if numSamps == 1
      io_Idx++;
    %endif
    }
  %endif
%endfunction %% FixptIIRDF2T_Order1

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FixptIIRDF2T
%%
%% FIXED POINT CODE GENERATION FOR IIR DF2T
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FixptIIRDF2T(block) Output
%%
%% DF2T input, state, and output complexity:
%%  - input real, coeff real ==>  state: real, output: real
%%  - input real, coeff cplx ==>  state: cplx, output: cplx
%%  - input cplx, coeff real ==>  state: cplx, output: cplx
%%  - input cplx, coeff cplx ==>  state: cplx, output: cplx
%assign stateIsComplex = outportIsComplex
%% Numerator and denominator coeffs *must* have the same complexity
%assign coeffIsComplex = coeff1IsComplex
%% create accum record
%assign accumIsCplx = stateIsComplex
%assign accumDTName = (accumIsCplx) ? accumDT.ComplexName : accumDT.Name
%createrecord accum { label     accumLabel; ...
                         dTypeRec  accumDT; ...
                         isComplex accumIsCplx; ...
                         dTypeName accumDTName }
%% create numProd record for numerator side products
%% create denProd record for denominator side products
%% numProd and denProd could have different fraction lengths, but
%% numProd and denProd have the same complexity
%assign numProdDT     = prodDT
%createrecord numProd { label     "numProd"; ...
                           dTypeRec  numProdDT; ...
                           isComplex 0 }
%assign denProdDT     = prodDT
%createrecord denProd { label     "denProd"; ...
                           dTypeRec  denProdDT; ...
                           isComplex 0 }
%% create numCoeff record for numerator coefficients
%% create denCoeff record for denominator coefficients
%assign sampsPerChan = numSamps
%% Note: we're going to need a separate b[0] record.
%if SFcnParamSettings.COEFFS_ARE_FROM_MASK
  %assign numCoeffLabel = LibBlockParameter(RTP1COEFF,"coeffIdx","","0")
  %assign numCoeffZeroLabel = LibBlockParameter(RTP1COEFF,"0","","0")
  %assign numCoeffDT    = DSPFixPt_GetParameterDataType(RTP1COEFF)
  %assign numCoeffSize  = LibBlockParameterSize(RTP1COEFF)
  %assign nCoeffsNum    = (numCoeffSize[0] * numCoeffSize[1])
  %%
  %assign denCoeffLabel = LibBlockParameter(RTP2COEFF,"coeffIdx","","0")
  %assign denCoeffDT    = DSPFixPt_GetParameterDataType(RTP2COEFF)
  %assign denCoeffSize  = LibBlockParameterSize(RTP2COEFF)
  %assign nCoeffsDen    = (denCoeffSize[0] * denCoeffSize[1])
%else
  %assign numCoeffLabel = LibBlockInputSignal(COEFF1PORT,"coeffIdx","","0")
  %assign numCoeffZeroLabel = LibBlockInputSignal(COEFF1PORT,"0","","0")
  %assign numCoeffDT    = FixPt_GetInputDataType(COEFF1PORT)
  %assign nCoeffsNum    = LibBlockInputSignalWidth(COEFF1PORT)
  %%
  %assign denCoeffLabel = LibBlockInputSignal(COEFF2PORT,"coeffIdx","","0")
  %assign denCoeffDT    = FixPt_GetInputDataType(COEFF2PORT)
  %assign nCoeffsDen    = LibBlockInputSignalWidth(COEFF2PORT)
  %if (sampsPerChan > 1) && (!SFcnParamSettings.COEFFS_UPDATE_PER_FRAME)
    %assign nCoeffsNum    = nCoeffsNum / sampsPerChan
    %assign nCoeffsDen    = nCoeffsDen / sampsPerChan
    %assign numCoeffZeroLabel = LibBlockInputSignal(COEFF1PORT,"i*%<nCoeffsNum>","","0")
  %endif
%endif
%createrecord numCoeff { label     numCoeffLabel; ...
                            dTypeRec  numCoeffDT; ...
                            isComplex coeffIsComplex }
%createrecord numCoeffZero { label     numCoeffZeroLabel; ...
                                dTypeRec  numCoeffDT; ...
                                isComplex coeffIsComplex }
%createrecord denCoeff { label     denCoeffLabel; ...
                            dTypeRec  denCoeffDT; ...
                            isComplex coeffIsComplex }
%% create in record
%if (LibBlockInputSignalWidth(INPORT) > 1)
  %assign ioIdxStr = "io_Idx"
%else
  %assign ioIdxStr = "0"
%endif
%assign inLabel = LibBlockInputSignal(INPORT,"%<ioIdxStr>","","0")
%createrecord in { label     inLabel; ...
                      dTypeRec  inDT; ...
                      isComplex inportIsComplex }
%% create out record
%assign outLabel = LibBlockOutputSignal(OUTPORT, "%<ioIdxStr>", "", "0")
%createrecord out { label     outLabel; ...
                       dTypeRec  outDT; ...
                       isComplex outportIsComplex }
%%
%assign stateDTID = LibBlockDWorkDataTypeId(FILT_STATES)
%assign stateDT   = FixPt_GetDataTypeFromIndex(stateDTID)
%% create state record
%assign stateLabel = LibBlockDWork(FILT_STATES,"memIdx","","0")
%createrecord state { label     stateLabel; ...
                         dTypeRec  stateDT; ...
                         isComplex stateIsComplex }
%% create nextState record
%assign nextStateLabel = LibBlockDWork(FILT_STATES,"memIdx+1","","0")
%createrecord nextState { label     nextStateLabel; ...
                             dTypeRec  stateDT; ...
                             isComplex stateIsComplex }
%%
%assign nChans  = numChans
%assign nStates = LibBlockDWorkWidth(FILT_STATES) / nChans
%assign ordNUM  = nCoeffsNum - 1
%assign ordDEN  = nCoeffsDen - 1
%assign lenMIN  = (ordNUM < ordDEN) ? ordNUM : ordDEN
%assign nonScalarCoeffs = ((ordNUM > 0) || (ordDEN > 0))
%assign block      = block + in + out + nCoeffsNum + nCoeffsDen + numProdDT + denProdDT
%%
%if nCoeffsNum == 1 && nCoeffsDen == 1
  %<FixptFirOrIirOrder0(block, numCoeff, numProd, accum)>\
%elseif ordNUM < 2 && ordDEN < 2
{
  %<FixptIIRDF2T_Order1(block, numCoeff, numProd, denCoeff, denProd, accum, state)>\
}
%else
 {
  %if (LibBlockInputSignalWidth(INPORT) > 1)
    int_T io_Idx = 0;                         /* Input/output port index */
  %endif
  %<accum.dTypeName> %<accum.label>; /* accumulator variable */
  %<numProdDT.Name> %<numProd.label>; /* product variable for numerator side multiplies */
  %if nonScalarCoeffs
    %<denProdDT.Name> %<denProd.label>; /* product variable for denominator side multiplies */
  %endif
  %if nChans > 1
  int_T k;

  for (k=0; k < %<nChans>; k++) {      /* Loop over each input channel */
  %endif
    %if nonScalarCoeffs
      int_T coeffIdx = 1;
    %endif
    %if sampsPerChan > 1
    int_T i;
    for (i = 0; i < %<sampsPerChan>; i++) { /* Loop over samples in channel */
    %endif
    %if nonScalarCoeffs
      %if nChans > 1
        int_T memIdx = k * %<nStates>;  /* state memory offset for this channel */
      %else
        int_T memIdx = 0; /* state memory index */
      %endif
      int_T j = 0;
    %endif
      /* Compute output value */
      %% acc = b[0] * input[io_Idx]
      %% acc += state[memIdx]
      %% out = acc
      %<FixptMAC(accum,"=",numProd,numCoeffZero,in,rndSat)>\
      %if nonScalarCoeffs
        %<DSPFixptLibPlusEquals(accum,state,rndSat)>\
      %endif
      %<DSPFixptLibEquals(out,accum,rndSat)>\

      %if lenMIN > 0
      /* Update states for numerator and denominator sides */
      for (j = 0; j < %<lenMIN>; j++) {
        %% acc  = state[memIdx+1]
        %% acc += b[coeffIdx] * input[io_Idx]
        %% acc -= a[coeffIdx] * output[io_Idx]
        %% state[memIdx] = acc
        %<DSPFixptLibEquals(accum,nextState,rndSat)>\
        %<FixptMAC(accum,"+=",numProd,numCoeff,in,rndSat)>\
        %<FixptMAC(accum,"-=",denProd,denCoeff,out,rndSat)>\
        %<DSPFixptLibEquals(state,accum,rndSat)>\
        coeffIdx++;
        memIdx++;
      }
      %endif

      %if (ordDEN > lenMIN)
      /* Denominator order is greater than numerator order,
       * Update rest of states for denominator side
       */
      for ( ; j < %<ordDEN>; j++) {
        %% acc = state[memIdx+1]
        %% acc -= a[coeffIdx] * output[io_Idx]
        %% state[memIdx] = acc
        %<DSPFixptLibEquals(accum,nextState,rndSat)>\
        %<FixptMAC(accum,"-=",denProd,denCoeff,out,rndSat)>\
        %<DSPFixptLibEquals(state,accum,rndSat)>\
        coeffIdx++;
        memIdx++;
      }
      %elseif (ordNUM > lenMIN)
      /* Numerator order is greater than denominator order,
       * Update rest of states for numerator side
       */
      for ( ; j < %<ordNUM>; j++) {
        %% acc = state[memIdx+1]
        %% acc += b[coeffIdx] * input[io_Idx]
        %% state[memIdx] = acc
        %<DSPFixptLibEquals(accum,nextState,rndSat)>\
        %<FixptMAC(accum,"+=",numProd,numCoeff,in,rndSat)>\
        %<DSPFixptLibEquals(state,accum,rndSat)>\
        coeffIdx++;
        memIdx++;
      }
      %endif

    %if (LibBlockInputSignalWidth(INPORT) > 1)
      io_Idx++;
    %endif
    %if sampsPerChan > 1
      %if nonScalarCoeffs
        %if SFcnParamSettings.COEFFS_UPDATE_PER_FRAME
          /* During frame-based processing and one-filter-per-frame
          * reset num and den for each sample of the same frame
          */
          coeffIdx = 1;
        %else
          coeffIdx++;
        %endif
      %endif
    } /* sample loop */
    %endif
  %if nChans > 1
  } /* channel loop */
  %endif
 }
%endif
%endfunction    %%FixptIIRDF2T


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subfunction: FltptRunTimeFcn
%%
%% FLOATING POINT CODE GENERATION
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%function FltptRunTimeFcn(block) Output
%%
  %%
  %switch (inportDataTypeID)
     %case 0
       %% Double precision floating-point
       %assign datatypeStr = "double precision floating-point"
       %break
     %case 1
       %% Single precision floating-point
       %assign datatypeStr = "single precision floating-point"
       %break
     %default
       %% Unsupported
       %assign datatypeStr = "unsupported"
  %endswitch
  %assign inpCplxStr = (inportIsComplex) ? "complex" : "real"
  %assign FilterFcnNameStr = "MWDSP"
  %%
  %switch (FilterTypeID)
    %case DSP_IIR
      %% IIR Filter
      %switch (FilterStructureID)
        %case DSP_DF2T
          %if (SFcnParamSettings.A0COEFF_IS_UNITY)
            %assign FilterFcnNameStr = FilterFcnNameStr + "_IIR_DF2T"
          %else
            %assign FilterFcnNameStr = FilterFcnNameStr + "_IIR_DF2T_A0Scale"
          %endif
          %break
        %case DSP_DF1T
          %if (SFcnParamSettings.COEFFS_ARE_FROM_MASK)
            %% Coeffs are from mask - stored in RTP always
            %assign Coeff1Size = LibBlockParameterSize(RTP1COEFF)
            %assign numCoeffs1 = (Coeff1Size[0] * Coeff1Size[1])
            %assign Coeff2Size = LibBlockParameterSize(RTP2COEFF)
            %assign numCoeffs2 = (Coeff2Size[0] * Coeff2Size[1])
          %else
            %% Coeffs are from ports: determine where and how many
            %assign numCoeffs1 = LibBlockInputSignalWidth(COEFF1PORT)
            %assign numCoeffs2 = LibBlockInputSignalWidth(COEFF2PORT)
          %endif
          %if (!SFcnParamSettings.COEFFS_UPDATE_PER_FRAME)
            %assign numCoeffs1 = numCoeffs1 / numSamps
            %assign numCoeffs2 = numCoeffs2 / numSamps
          %endif
          %%
          %if (SFcnParamSettings.A0COEFF_IS_UNITY)
            %assign FilterFcnNameStr = FilterFcnNameStr + "_IIR_DF1T"
          %else
            %assign FilterFcnNameStr = FilterFcnNameStr + "_IIR_DF1T_A0Scale"
          %endif
          %break
        %case DSP_DF2
          %if (SFcnParamSettings.A0COEFF_IS_UNITY)
            %assign FilterFcnNameStr = FilterFcnNameStr + "_IIR_DF2"
          %else
            %assign FilterFcnNameStr = FilterFcnNameStr + "_IIR_DF2_A0Scale"
          %endif
          %break
        %case DSP_DF1
          %%
          %if (SFcnParamSettings.A0COEFF_IS_UNITY)
            %assign FilterFcnNameStr = FilterFcnNameStr + "_IIR_DF1"
          %else
            %assign FilterFcnNameStr = FilterFcnNameStr + "_IIR_DF1_A0Scale"
          %endif
          %break
        %case DSP_LATTICE
        %default
          %error "The specified structure is not supported for IIR filters."
          %break
      %endswitch
      %break
    %case DSP_FIR
      %% FIR Filter
      %switch (FilterStructureID)
        %case DSP_TDF
          %assign FilterFcnNameStr = FilterFcnNameStr + "_FIR_TDF"
          %break
        %case DSP_LATTICE
          %assign FilterFcnNameStr = FilterFcnNameStr + "_FIR_Lat"
          %break
        %case DSP_DF
          %assign FilterFcnNameStr = FilterFcnNameStr + "_FIR_DF"
          %break
        %default
          %error "The specified structure is not supported for FIR filters."
          %break
      %endswitch
      %break
    %case DSP_ALLPOLE
      %% ALLPOLE Filter
      %switch (FilterStructureID)
        %case DSP_DF
          %if (SFcnParamSettings.A0COEFF_IS_UNITY)
            %assign FilterFcnNameStr = FilterFcnNameStr + "_AllPole_DF"
          %else
            %assign FilterFcnNameStr = FilterFcnNameStr + "_AllPole_DF_A0Scale"
          %endif
          %break
        %case DSP_TDF
          %if (SFcnParamSettings.A0COEFF_IS_UNITY)
            %assign FilterFcnNameStr = FilterFcnNameStr + "_AllPole_TDF"
          %else
            %assign FilterFcnNameStr = FilterFcnNameStr + "_AllPole_TDF_A0Scale"
          %endif
          %break
        %case DSP_LATTICE
          %assign FilterFcnNameStr = FilterFcnNameStr + "_AllPole_Lat"
          %break
        %default
          %error "The specified structure is not supported for All-Pole filters."
          %break
      %endswitch
      %break
    %default
      %% Invalid/unsupported filter type
      %error "The specified filter type is not supported."
  %endswitch
  %% Append single-letter prefix for input datatype
  %if (inportDataTypeID == 0)
    %% input datatype is double-precision floating point
    %if (inportIsComplex)
      %assign FilterFcnNameStr = FilterFcnNameStr + "_Z"
    %else
      %assign FilterFcnNameStr = FilterFcnNameStr + "_D"
    %endif
  %else
    %% input datatype is single-precision floating point
    %if (inportIsComplex)
      %assign FilterFcnNameStr = FilterFcnNameStr + "_C"
    %else
      %assign FilterFcnNameStr = FilterFcnNameStr + "_R"
    %endif
  %endif
  %% for the DSP_DF1T, DSP_DF2T, DSP_DF1 and DSP_DF2 filter structure, we have  1 run-time function for the case when both
  %% numerator and denominator filter coefficients are real, otherwise we choose the other when
  %% where any or both coefficients can be complex.
  %%
  %% Append single-letter prefix for first coefficient set datatype
  %if (coeff1DataTypeID == 0)
    %% first coeff set datatype is double-precision floating point
    %if (coeff1IsComplex)
      %assign FilterFcnNameStr = FilterFcnNameStr + "Z"
    %else
      %assign FilterFcnNameStr = FilterFcnNameStr + "D"
    %endif
  %else
    %% first coeff set datatype is single-precision floating point
    %if (coeff1IsComplex)
      %assign FilterFcnNameStr = FilterFcnNameStr + "C"
    %else
      %assign FilterFcnNameStr = FilterFcnNameStr + "R"
    %endif
  %endif
  %%
   %<FilterFcnNameStr>(%<genFilterArgsList(block)>);
%endfunction   %% FltptRunTimeFcn


%% ======================================================================
%% Local helper sub-functions
%% ======================================================================


%% Function: genFilterArgsList
%%
%% Abstract: Constructs and returns a comma-separated list of input arguments
%%           to be used during calls to filter run-time functions.
%%
%function genFilterArgsList(block) void
%%
  %assign U_Ptr     = LibBlockInputSignalAddr(INPORT, "", "", 0)
  %assign Y_Ptr     = LibBlockOutputSignalAddr(OUTPORT, "", "", 0)
  %assign State_Ptr = LibBlockDWorkAddr(FILT_STATES, "", "", 0)
  %assign numStates = LibBlockDWorkWidth(FILT_STATES) / numChans
  %if (SFcnParamSettings.COEFFS_ARE_FROM_MASK)
    %% Coeffs are from mask - stored in RTP always
    %assign Coeff1_Ptr = LibBlockParameterAddr(RTP1COEFF, "", "", 0)
    %assign Coeff1Size = LibBlockParameterSize(RTP1COEFF)
    %assign numCoeffs1 = (Coeff1Size[0] * Coeff1Size[1])
    %%
    %if (FilterTypeID == DSP_IIR)
      %assign Coeff2_Ptr = LibBlockParameterAddr(RTP2COEFF, "", "", 0)
      %assign Coeff2Size = LibBlockParameterSize(RTP2COEFF)
      %assign numCoeffs2 = (Coeff2Size[0] * Coeff2Size[1])
    %endif
    %%
  %else
    %assign Coeff1_Ptr = LibBlockInputSignalAddr(COEFF1PORT, "", "", 0)
    %assign numCoeffs1 = LibBlockInputSignalWidth(COEFF1PORT)
    %if (FilterTypeID == DSP_IIR)
      %assign Coeff2_Ptr = LibBlockInputSignalAddr(COEFF2PORT, "", "", 0)
      %assign numCoeffs2 = LibBlockInputSignalWidth(COEFF2PORT)
    %endif
    %if (!SFcnParamSettings.COEFFS_UPDATE_PER_FRAME)
      %assign numCoeffs1 = numCoeffs1 / numSamps
      %if (FilterTypeID == DSP_IIR)
        %assign numCoeffs2 = numCoeffs2 / numSamps
      %endif
    %endif
  %endif
  %if !(FilterTypeID == DSP_IIR)
    %assign Coeff2_Ptr = "NULL"
    %assign numCoeffs2 = 0
  %endif
  %assign filterArgsListStr = "%<U_Ptr>" + ", %<Y_Ptr>" + ", %<State_Ptr>"
  %switch FilterTypeID
    %case DSP_IIR
      %switch FilterStructureID
        %case DSP_DF2T
        %case DSP_DF1T
        %case DSP_DF2
        %case DSP_DF1
          %assign numCoeffs1 = numCoeffs1 - 1
          %assign numCoeffs2 = numCoeffs2 - 1
          %break
        %default
          %error "Unable to generate argument list for specified IIR filter structure.  Update genFilterArgsList function in sdspfilter.tlc."
      %endswitch
      %if ((FilterStructureID == DSP_DF2) || (FilterStructureID == DSP_DF1))
        %assign DF_CurrIndx = LibBlockDWorkAddr(CIRCBUFFIDX, "", "", 0)
        %if (FilterStructureID == DSP_DF2)
          %assign filterArgsListStr = filterArgsListStr + ",(int32_T *)%<DF_CurrIndx>" + ", %<numStates-1>" + ", %<numSamps>" + ", %<numChans>"
        %else
          %assign filterArgsListStr = filterArgsListStr + ",(int32_T *)%<DF_CurrIndx>" + ", %<numStates>" + ", %<numSamps>" + ", %<numChans>"
        %endif
      %else
        %assign filterArgsListStr = filterArgsListStr + ", %<numStates>" + ", %<numSamps>" + ", %<numChans>"
      %endif
      %assign filterArgsListStr = filterArgsListStr + ", %<Coeff1_Ptr>" + ", %<numCoeffs1>"
      %assign filterArgsListStr = filterArgsListStr + ", %<Coeff2_Ptr>" + ", %<numCoeffs2>"
      %assign filterArgsListStr = filterArgsListStr + ", %<SFcnParamSettings.COEFFS_UPDATE_PER_FRAME>"
    %break
    %case DSP_FIR
      %switch FilterStructureID
        %case DSP_DF
          %assign numCoeffs1 = numCoeffs1 - 1
          %assign filterArgsListStr = filterArgsListStr + ", %<LibBlockDWorkAddr(CIRCBUFFIDX, "", "", 0)>"
          %assign filterArgsListStr = filterArgsListStr + ", %<numStates>" + ", %<numSamps>" + ", %<numChans>"
          %assign filterArgsListStr = filterArgsListStr + ", %<Coeff1_Ptr>" + ", %<SFcnParamSettings.COEFFS_UPDATE_PER_FRAME>"
          %break
        %case DSP_TDF
          %assign numCoeffs1 = numCoeffs1 - 1
          %assign filterArgsListStr = filterArgsListStr + ", %<numStates>" + ", %<numSamps>" + ", %<numChans>"
          %assign filterArgsListStr = filterArgsListStr + ", %<Coeff1_Ptr>" + ", %<numCoeffs1>" + ", %<SFcnParamSettings.COEFFS_UPDATE_PER_FRAME>"
          %break
        %case DSP_LATTICE
          %assign filterArgsListStr = filterArgsListStr + ", %<numSamps>" + ", %<numChans>"
          %assign filterArgsListStr = filterArgsListStr + ", %<Coeff1_Ptr>" + ", %<numCoeffs1>" + ", %<SFcnParamSettings.COEFFS_UPDATE_PER_FRAME>"
          %break
        %default
          %error "Unable to generate argument list for specified FIR filter structure.  Update genFilterArgsList function in sdspfilter.tlc."
      %endswitch
    %break
    %case DSP_ALLPOLE
      %switch FilterStructureID
        %case DSP_DF
          %assign numCoeffs1 = numCoeffs1 - 1
          %assign filterArgsListStr = filterArgsListStr + ", %<LibBlockDWorkAddr(CIRCBUFFIDX, "", "", 0)>"
          %assign filterArgsListStr = filterArgsListStr + ", %<numStates-1>" + ", %<numSamps>" + ", %<numChans>"
          %assign filterArgsListStr = filterArgsListStr + ", %<Coeff1_Ptr>"  + ", %<SFcnParamSettings.COEFFS_UPDATE_PER_FRAME>"
          %break
        %case DSP_TDF
          %assign numCoeffs1 = numCoeffs1 - 1
          %assign filterArgsListStr = filterArgsListStr + ", %<numStates>" + ", %<numSamps>" + ", %<numChans>"
          %assign filterArgsListStr = filterArgsListStr + ", %<Coeff1_Ptr>" + ", %<numCoeffs1>" + ", %<SFcnParamSettings.COEFFS_UPDATE_PER_FRAME>"
          %break
        %case DSP_LATTICE
          %assign filterArgsListStr = filterArgsListStr + ", %<numSamps>" + ", %<numChans>"
          %assign filterArgsListStr = filterArgsListStr + ", %<Coeff1_Ptr>" + ", %<numCoeffs1>" + ", %<SFcnParamSettings.COEFFS_UPDATE_PER_FRAME>"
          %break
        %default
          %error "Unable to generate argument list for specified All-Pole filter structure.  Update genFilterArgsList function in sdspfilter.tlc."
      %endswitch
      %break
    %default
      %error "Unable to generate argument list for specified filter.  Update genFilterArgsList function in sdspfilter.tlc."
  %endswitch
  %return filterArgsListStr
%endfunction  %% genFilterArgsList


%% Function: fillExtraStateElemWithZeroforDF1T   ================================================
%%
%function fillExtraStateElemWithZeroforDF1T(block,bytesPerElemStr) Output
  %assign outID      = LibBlockOutputSignalDataTypeId(OUTPORT)
  %if (outportIsComplex)
    outZeroValPtr->re = %<LibGetGroundValueFromId(outID)>;
    outZeroValPtr->im = %<LibGetGroundValueFromId(outID)>;
  %else
    *outZeroValPtr = %<LibGetGroundValueFromId(outID)>;
  %endif
  memcpy(statePtr, (byte_T *)outZeroValPtr, %<bytesPerElemStr>);
  statePtr += %<bytesPerElemStr>;
%endfunction %% fillExtraStateElemWithZeroforDF1T


%% [EOF] sdspfilter2.tlc
