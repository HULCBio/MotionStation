%% ============================================================================
%% File : setuplib.tlc
%%
%% Abstract:
%%   This file includes a number of functions that are called from commonsetup
%%   to setup various TLC globals and CompiledModel fields. The functions
%%   help setup:
%%   o Basic global defaults
%%   o Default settings for various code-generation fields on CompiledModel
%%   o Memory allocation and data-visibility flags for the different code
%%     formats
%%   o Variables for keeping track of the headers and sources
%%   o Variables for keeping track of RTW Identifiers common to all code formats
%%   o Variables for keeping track of RTW Identifiers that depend on the
%%     specific code format
%%   o Variables for keeping track of RTW function names
%%   o Variables for supporting datatypes
%%   o Variables that pertian to specific code formats
%%   o Variables pertaining to logging
%%   o Variables for supporting Ada math and block code
%%   o Variables for setting up C-APIs to track block IO and run-time params
%%
%%   Additionally, the file also contains a function that validates the
%%   CompiledModel by checking if:
%%   o Datatypes have been set up
%%   o Model has no Algebraic Loops
%%
%% $Revision: 1.1.8.23 $ 
%% Copyright 1994-2004 The MathWorks, Inc.
%%
%% ============================================================================

%if EXISTS("_SETUPLIB_") == 0
%assign _SETUPLIB_ = 1

%% Function: SLibSetupBasicDefaults ============================================
%% Abstract:
%%   Set up defaults for basic code generation options. These need to be setup
%%   even before we begin loading funclib.tlc.
%%
%function SLibSetupBasicDefaults() void
  %%
  %% Set language
  %%
  %language "C"

  %%
  %% Matrix Dimensions
  %%
  %assign ::matrixDimensionThreshhold = 2

  %%
  %% Invalid Counter
  %%
  %assign ::INVALID_COUNTER = -1

  %%
  %% Invalid Buffer
  %%
  %assign ::INVALID_BUFFER = -1

  %%
  %% MatFileLogging comes early as possible
  %assign ::MatFileLogging = CompiledModel.ConfigSet.MatFileLogging

%endfunction %% SLibSetupBasicDefaults


%% Function: SLibERTFeatureSetup ============================================
%% Abstract:
%%   Assert that feature settings are consistent with target settings
%%   (i.e., a feature is not inappripriately enabled).  If inconsistant,
%%   Simulink is out of sync with RTW and the build must be terminated.
%%
%function SLibERTFeatureSetup() void

  %assign ::ConfigSet = CompiledModel.ConfigSet

  %if !EXISTS("IgnoreCustomStorageClasses")
    %assign ::IgnoreCustomStorageClasses = ConfigSet.IgnoreCustomStorageClasses
  %endif
  %<LibAddToCompiledModel("IgnoreCustomStorageClasses",IgnoreCustomStorageClasses)>

  %if !EXISTS("IncludeHyperlinkInReport")
    %assign ::IncludeHyperlinkInReport = ConfigSet.IncludeHyperlinkInReport
  %endif
  %<LibAddToCompiledModel("IncludeHyperlinkInReport",IncludeHyperlinkInReport)>

  %if !EXISTS("IncludeMdlTerminateFcn")
    %assign ::IncludeMdlTerminateFcn = ConfigSet.IncludeMdlTerminateFcn
  %endif
  %<LibAddToCompiledModel("IncludeMdlTerminateFcn",IncludeMdlTerminateFcn)>

  %if !EXISTS("CombineOutputUpdateFcns")
    %assign ::CombineOutputUpdateFcns = ConfigSet.CombineOutputUpdateFcns
  %endif
  %<LibAddToCompiledModel("CombineOutputUpdateFcns",CombineOutputUpdateFcns)>

  %if !EXISTS("SuppressErrorStatus")
    %assign ::SuppressErrorStatus = ConfigSet.SuppressErrorStatus
  %endif
  %<LibAddToCompiledModel("SuppressErrorStatus",SuppressErrorStatus)>

  %if !EXISTS("ZeroExternalMemoryAtStartup")
    %assign ::ZeroExternalMemoryAtStartup = ConfigSet.ZeroExternalMemoryAtStartup
  %endif
  %<LibAddToCompiledModel("ZeroExternalMemoryAtStartup",ZeroExternalMemoryAtStartup)>

  %if !EXISTS("ZeroInternalMemoryAtStartup")
    %assign ::ZeroInternalMemoryAtStartup = ConfigSet.ZeroInternalMemoryAtStartup
  %endif
  %<LibAddToCompiledModel("ZeroInternalMemoryAtStartup",ZeroInternalMemoryAtStartup)>

  %if !EXISTS("InitFltsAndDblsToZero")
    %assign ::InitFltsAndDblsToZero = ConfigSet.InitFltsAndDblsToZero
  %endif
  %<LibAddToCompiledModel("InitFltsAndDblsToZero",InitFltsAndDblsToZero)>

  %if !EXISTS("InsertBlockDesc")
    %assign ::InsertBlockDesc = ConfigSet.InsertBlockDesc
  %endif
  %<LibAddToCompiledModel("InsertBlockDesc",InsertBlockDesc)>

  %if !EXISTS("SFDataObjDesc")
    %assign ::SFDataObjDesc = ConfigSet.SFDataObjDesc
  %endif
  %<LibAddToCompiledModel("SFDataObjDesc",SFDataObjDesc)>

  %if !EXISTS("SimulinkDataObjDesc")
    %assign ::SimulinkDataObjDesc = ConfigSet.SimulinkDataObjDesc
  %endif
  %<LibAddToCompiledModel("SimulinkDataObjDesc",SimulinkDataObjDesc)>

  %if !EXISTS("ERTCustomFileBanners")
    %assign ::ERTCustomFileBanners = ConfigSet.ERTCustomFileBanners
  %endif
  %% Model Reference Sim Target does not use the Custom File Banners
  %if IsModelReferenceSimTarget()
    %assign ::ERTCustomFileBanners = TLC_FALSE
  %endif
  %<LibAddToCompiledModel("ERTCustomFileBanners",ERTCustomFileBanners)>

  %if !EXISTS("DefineNamingRule")
    %assign ::DefineNamingRule = ConfigSet.DefineNamingRule
  %endif
  %<LibAddToCompiledModel("DefineNamingRule",DefineNamingRule)>

  %if !EXISTS("SignalNamingRule")
    %assign ::SignalNamingRule = ConfigSet.SignalNamingRule
  %endif
  %<LibAddToCompiledModel("SignalNamingRule",SignalNamingRule)>

  %if !EXISTS("ParamNamingRule")
    %assign ::ParamNamingRule = ConfigSet.ParamNamingRule
  %endif
  %<LibAddToCompiledModel("ParamNamingRule",ParamNamingRule)>

  %if !EXISTS("InlinedPrmAccess")
    %assign ::InlinedPrmAccess = ConfigSet.InlinedPrmAccess
  %endif
  %<LibAddToCompiledModel("InlinedPrmAccess",InlinedPrmAccess)>

  %if !EXISTS("GenerateSampleERTMain")
    %assign ::GenerateSampleERTMain = ConfigSet.GenerateSampleERTMain
  %endif
  %<LibAddToCompiledModel("GenerateSampleERTMain",GenerateSampleERTMain)>

  %if !EXISTS("MultiInstanceERTCode")
    %assign ::MultiInstanceERTCode = ConfigSet.MultiInstanceERTCode
  %endif
  %<LibAddToCompiledModel("MultiInstanceERTCode",MultiInstanceERTCode)>

  %if !EXISTS("PurelyIntegerCode")
    %assign ::PurelyIntegerCode = ConfigSet.PurelyIntegerCode
  %endif
  %<LibAddToCompiledModel("PurelyIntegerCode",PurelyIntegerCode)>

  %if !EXISTS("SupportNonFinite")
    %assign ::SupportNonFinite = ConfigSet.SupportNonFinite
  %endif
  %<LibAddToCompiledModel("SupportNonFinite",SupportNonFinite)>

  %if !EXISTS("SupportComplex")
    %assign ::SupportComplex = ConfigSet.SupportComplex
  %endif
  %<LibAddToCompiledModel("SupportComplex",SupportComplex)>

  %if !EXISTS("SupportContinuousTime")
    %assign ::SupportContinuousTime = ConfigSet.SupportContinuousTime
  %endif
  %<LibAddToCompiledModel("SupportContinuousTime",SupportContinuousTime)>

  %if !EXISTS("SupportNonInlinedSFcns")
    %assign ::SupportNonInlinedSFcns = ConfigSet.SupportNonInlinedSFcns
  %endif
  %<LibAddToCompiledModel("SupportNonInlinedSFcns",SupportNonInlinedSFcns)>

  %if !EXISTS("NoFixptDivByZeroProtection")
    %assign ::NoFixptDivByZeroProtection = ConfigSet.NoFixptDivByZeroProtection
  %endif
  %<LibAddToCompiledModel("NoFixptDivByZeroProtection",NoFixptDivByZeroProtection)>

  %if !EXISTS("CustomSymbolStr")
    %assign ::CustomSymbolStr = ConfigSet.CustomSymbolStr
  %endif
  %<LibAddToCompiledModel("CustomSymbolStr",CustomSymbolStr)>

  %if !EXISTS("ReqsInCode")
    %assign ::ReqsInCode = ConfigSet.ReqsInCode
  %endif
  %<LibAddToCompiledModel("ReqsInCode",ReqsInCode)>

  %if (ConfigSet.IsERTTarget == 0)

    %%
    %% Ignore custom storage = true
    %%
    %if (IgnoreCustomStorageClasses == 0)
      %assign errMsg = "To support custom storage classes, you need to " ...
        "use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% Back link to html report = false
    %%
    %if (IncludeHyperlinkInReport == 1)
      %assign errMsg = "To support back links to html report, you need to use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% Generate terminate function = true
    %%
    %if (IncludeMdlTerminateFcn == 0)
      %assign errMsg = "To suppress generating model terminate function, you need to use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% Combine output update function = false
    %%
    %if (CombineOutputUpdateFcns == 1 && !IsModelReferenceSimTarget())
      %assign errMsg = "To combine output and update functions, you need to use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% Suppress error status = false
    %%
    %if (SuppressErrorStatus == 1)
      %assign errMsg = "To suppress error status codes, you need to use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% zero external memory at startup = true
    %%
    %if (ZeroExternalMemoryAtStartup == 0)
      %assign errMsg = "To remove root i/o zero initialization, you need to use an "...
        "ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% zero internal memory at startup = true
    %%
    %if (ZeroInternalMemoryAtStartup == 0)
      %assign errMsg = "To remove internal state zero initialization, you need to "...
        "use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% init floats and doubles to zero individually = true
    %%
    %if (InitFltsAndDblsToZero == 0)
      %assign errMsg = "To use memset to initialize float and double data to zero, "...
        "you need to use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% insert block description = false
    %%
    %if (InsertBlockDesc == 1)
      %assign errMsg = "To include block description in the generated code, you "...
        "need to use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% insert stateflow data description = false
    %%
    %if (SFDataObjDesc == 1)
      %assign errMsg = "To include description for stateflow data object in the "...
        "generated code, you need to use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% insert Simulink data description = false
    %%
    %if (SimulinkDataObjDesc == 1)
      %assign errMsg = "To include description for Simulink data object in the "...
        "generated code, you need to use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% ert custom file banners = false
    %%
    %if (ERTCustomFileBanners == 1)
      %assign errMsg = "To generate customize file banners, you need to use an ERT "...
        "or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% define naming rule = "None"
    %%
    %if (DefineNamingRule != "None")
      %assign errMsg = "To apply naming rule to #define declaration, you need to "...
        "use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% signal naming rule = "None"
    %%
    %if (SignalNamingRule != "None")
      %assign errMsg = "To apply naming rule to signal declaration, you need to use "...
        "an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% parameter naming rule = "None"
    %%
    %if (ParamNamingRule != "None")
      %assign errMsg = "To apply naming rule to parameter declaration, you need to "...
        "use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% inlined parameter access = "Literals"
    %%
    %if (InlinedPrmAccess != "Literals")
      %assign errMsg = "To access inlined parameters through macros, you need to "...
        "use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% generate sample main = false
    %%
    %if (GenerateSampleERTMain == 1)
      %assign errMsg = "To generate sample ert main, you need to use an ERT or "...
        "ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% MultiInstanceERTCode = false
    %%
    %if (MultiInstanceERTCode == 1)
      %assign errMsg = "To generate multi-instantiable codes, you need to use an "...
        "ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% PurelyIntegerCode = false
    %%
    %if (PurelyIntegerCode == 1)
      %assign errMsg = "To generate purely integer code, you need to use an ERT "...
        "or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% SupportNonFinite = true
    %%
    %if (SupportNonFinite == 0)
      %assign errMsg = "To suppress non-finite math support, you need to use an "...
        "ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% SupportComplex = true
    %%
    %if (SupportComplex == 0)
      %assign errMsg = "To suppress complex math support, you need to use an "...
        "ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% SupportContinuousTime = true
    %%
    %if (SupportContinuousTime == 0)
      %assign errMsg = "To suppress continuous time support, you need to use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% SupportNonInlinedSFcns = true
    %%
    %if (SupportNonInlinedSFcns == 0)
      %assign errMsg = "To suppress non-inlined s-function support, you need to use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% NoFixptDivByZeroProtection = false
    %%
    %if (NoFixptDivByZeroProtection == 1)
      %assign errMsg = "To remove code that protects division against "...
        "arithmetic exceptions, you need to use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

    %%
    %% CustomSymbolStr = $R$N$M
    %%
    %if (CustomSymbolStr != "$R$N$M")
      %assign errMsg = "To customize RTW symbol mangling rule, "...
        "you need to use an ERT or ERT-based target."
      %<LibReportFatalError(errMsg)>
    %endif

  %endif
%endfunction %% SLibERTFeatureCheck


%% Function: SLibSetupDiagnosticOptions ========================================
%% Abstract:
%%   Set up options that report diagnostics during the code generation process.
%%   These options do not directly affect the actual code that is generated.
%%
%function SLibSetupDiagnosticDefaults() void
  %%
  %% Set verbosity (postpone adding to CompiledModel until after the function
  %% library is loaded)
  %%
  %if !EXISTS("RTWVerbose")
    %assign ::RTWVerbose = 1
  %endif

  %%
  %% HTML report
  %%
  %if !EXISTS("GenerateReport")
    %assign ::GenerateReport = 0
  %endif

  %%
  %% Boolean to display warnings due to use of obsolete functions
  %%
  %if !EXISTS("ShowObsoleteWarnings")
    %assign ::ShowObsoleteWarnings = 0
  %endif

  %%
  %% Flag to control display of overflow warnings for blocks that have
  %% saturation capability, but have it turned off(unchecked) in their dialog.
  %%       0 no warning is displayed
  %%       1 displays one warning for the model during code generation
  %%       2 displays one warning which contains a list of all offending blocks
  %%
  %if !EXISTS("WarnNonSaturatedBlocks")
    %assign ::WarnNonSaturatedBlocks = 2
  %endif

  %%
  %% TLC global variable cleanup
  %%       Setting this variable to 1 causes cleanup of global TLC variables
  %%       after they are used such as after their LibDump* function is called.
  %%
  %%
  %if !EXISTS("ResetTLCGlobalsAfterUse")
    %assign ::ResetTLCGlobalsAfterUse = 1
  %endif

%endfunction %% SLibSetupDiagnosticDefaults


%% Function: SLibSetupPrintStatusMsgs ==========================================
%% Abstract:
%%   Utility function for printing a status message to STDOUT.
%%
%function SLibSetupPrintStatusMsgs(statusID) void
  %if !RTWVerbose
    %return
  %endif

  %selectfile STDOUT

  %switch statusID
    %case "libload"
### Loading TLC function libraries
      %break
    %default
      %break
  %endswitch

  %selectfile NULL_FILE
%endfunction %% SLibSetupPrintStatusMsgs


%% Function: SLibSetupLayoutOptions ============================================
%% Abstract:
%%   Setup fields that are responsible for determining the layout of the
%%   generated code.
%%
%function SLibSetupLayoutOptions() void

  %assert (!IsModelReferenceTarget() || GenerateSampleERTMain == 0)

  %% Pass arguments into entry point functions
  %assert (!IsModelReferenceTarget() || MultiInstanceERTCode == 0)

  %% Pass arguments into entry point functions
  %if !EXISTS("MultiInstanceErrorCode")
    %assign ::MultiInstanceErrorCode = "None"
  %endif
  %<LibAddToCompiledModel("MultiInstanceErrorCode",MultiInstanceErrorCode)>

  %% Pass top level I/O using structures
  %if !EXISTS("RootIOStructures")
    %assign ::RootIOStructures = 0
  %endif
  %<LibAddToCompiledModel("RootIOStructures",RootIOStructures)>

  %% Suppress ErrorStatus in real-time model
  %if EXISTS("ExtMode") && ...
    ExtMode == 1 && ...
    SuppressErrorStatus == 1
    %assign errMsg = "Can not select ERT option 'Suppress error status in " + ...
      "real-time model data structure' when selecting ERT option 'External mode'"
    %<LibReportFatalError(errMsg)>
  %endif

  %%
  %% ERT: suppress the model_SetEventsForThisBaseRate function
  %%
  %if !EXISTS("SuppressSetEventsForThisBaseRateFcn")
    %assign ::SuppressSetEventsForThisBaseRateFcn = 0
  %endif
  %if IsModelReferenceTarget()
    %assign ::SuppressSetEventsForThisBaseRateFcn = 1
  %endif

  %<LibAddToCompiledModel("SuppressSetEventsForThisBaseRateFcn",...
    SuppressSetEventsForThisBaseRateFcn)>

  %%
  %% Setup GenerateComments to be true if not setup already
  %%
  %if !EXISTS("GenerateComments")
    %assign ::GenerateComments = 1
  %endif
  %<LibAddToCompiledModel("GenerateComments",GenerateComments)>

  %%
  %% Output comments for parameters in model.prm file
  %%
  %if !EXISTS("ForceParamTrailComments")
    %assign ::ForceParamTrailComments = 0
  %endif
  %<LibAddToCompiledModel("ForceParamTrailComments", ForceParamTrailComments)>

  %%
  %% Boolean to display eliminted C-code with /* */
  %%
  %if !EXISTS("ShowEliminatedStatements")
    %assign ::ShowEliminatedStatements = 1
  %endif
  %<LibAddToCompiledModel("ShowEliminatedStatements", ShowEliminatedStatements)>

  %%
  %% Declare externs for all globals and function-calls.
  %%
  %if !EXISTS("HaveSeparateSourceFiles")
    %assign ::HaveSeparateSourceFiles = 0
  %endif
  %<LibAddToCompiledModel("HaveSeparateSourceFiles", HaveSeparateSourceFiles)>

  %%
  %% Boolean to switch on/off the protection against calling initialize function
  %% twice at startup.
  %%
  %if !EXISTS("ProtectCallInitFcnTwice")
    %assign ::ProtectCallInitFcnTwice = 1
  %endif
  %<LibAddToCompiledModel("ProtectCallInitFcnTwice", ProtectCallInitFcnTwice)>`

  %%
  %% TLC interface API
  %%
  %if !EXISTS("GenerateInterfaceAPI")
    %assign ::GenerateInterfaceAPI = 0
  %endif
  %<LibAddToCompiledModel("GenerateInterfaceAPI", GenerateInterfaceAPI)>

  %%
  %% ASAP2 file (assumes GenerateInterfaceAPI already defined)
  %%
  %if !EXISTS("GenerateASAP2")
    %assign ::GenerateASAP2 = 0
  %endif
  %<LibAddToCompiledModel("GenerateASAP2", GenerateASAP2)>
  %if GenerateASAP2 == 1
    %assign ::CompiledModel.GenerateInterfaceAPI = 1
  %endif

  %%
  %% Setup InlineParameters to be false if not setup already
  %%
  %if !EXISTS("InlineParameters")
    %assign ::InlineParameters = 0
  %endif
  %<LibAddToCompiledModel("InlineParameters", InlineParameters)>

  %%
  %% Inline outputs of blocks with Constant TID in C-code
  %%
  %if !EXISTS("InlineInvariantSignals")
    %assign ::InlineInvariantSignals = InlineParameters
  %endif
  %<LibAddToCompiledModel("InlineInvariantSignals", InlineInvariantSignals)>

  %%
  %% MaxStackSize
  %%
  %if !EXISTS("MaxStackSize")
    %assign ::MaxStackSize = rtInf
  %else
    %if EXISTS("DivideStackByRate") && DivideStackByRate == TLC_TRUE
      %assign ::MaxStackSize = MaxStackSize / CompiledModel.NumSynchronousSampleTimes
    %endif
  %endif
  %<LibAddToCompiledModel("MaxStackSize", MaxStackSize)>

  %%
  %% MaxStackVariableSize
  %%
  %if !EXISTS("MaxStackVariableSize")
    %assign ::MaxStackVariableSize = rtInf
  %endif
  %<LibAddToCompiledModel("MaxStackVariableSize", MaxStackVariableSize)>

  %%
  %% FullRootOutportVector
  %%
  %if !EXISTS("FullRootOutportVector")
    %assign ::FullRootOutportVector = 0
  %endif
  %<LibAddToCompiledModel("FullRootOutportVector", FullRootOutportVector)>


  %%
  %% Setup EnforceIntegerDowncast to be true if not setup already
  %%
  %if !EXISTS("EnforceIntegerDowncast")
    %assign ::EnforceIntegerDowncast = 1
  %endif
  %<LibAddToCompiledModel("EnforceIntegerDowncast",EnforceIntegerDowncast)>

  %%
  %% Boolean to generate assertion free code, default is no asserts
  %%
  %if !EXISTS("DoAsserts")
    %assign ::DoAsserts = 0
  %endif
  %<LibAddToCompiledModel("DoAsserts", DoAsserts)>

  %%
  %% Set RateBasedStepFcn if not set yet
  %% this flag is used by targets that support
  %% RateBasedStep Fcn.
  %%
  %if !EXISTS("RateBasedStepFcn")
    %assign ::RateBasedStepFcn = 0
  %endif
  %<LibAddToCompiledModel("RateBasedStepFcn", RateBasedStepFcn)>

%endfunction %% SLibSetupLayoutOptions


%% Function: SLibSetupRollingInfo ==============================================
%% Abstract:
%%   Setup variables needed for rolling
%%   - Using the RTW page on the Simulation Parameters dialog, you can specify
%%     the RollThreshold
%%   - Other variables set up here are for tracking code generation during the
%%     execution of %roll constructs in TLC
%%
%function SLibSetupRollingInfo() void
  %%
  %% Automatic roll threshold
  %%
  %if !EXISTS("RollThreshold")
    %assign ::RollThreshold = 5
  %endif
  %<LibAddToCompiledModel("RollThreshold", RollThreshold)>

  %%
  %% Tracking field:
  %% For counter for roll loop control variable
  %%
  %if !EXISTS("LoopControlIdx")
    %assign ::LoopControlIdx = 0
  %endif
  %<LibAddToCompiledModel("LoopControlIdx", LoopControlIdx)>

  %%
  %% Tracking field:
  %% This is the current loop offset if we are inside a %roll and lcv != ""
  %%
  %if !EXISTS("CurrentLoopOffset")
    %assign ::CurrentLoopOffset = 0
  %endif
  %<LibAddToCompiledModel("CurrentLoopOffset", CurrentLoopOffset)>

  %%
  %% Tracking field:
  %% Current loop offset when inside a %roll
  %%
  %if !EXISTS("CurrentRollRegionOffset")
    %assign ::CurrentRollRegionOffset = -1
  %endif
  %<LibAddToCompiledModel("CurrentRollRegionOffset", CurrentRollRegionOffset)>

  %%
  %% Override Roll Variable Declaration 'const %<dt>' => '%<dt>'
  %%
  %if !EXISTS("RollInputIsWritable")
    %assign ::RollInputIsWritable = 0
  %endif
  %<LibAddToCompiledModel("RollInputIsWritable", RollInputIsWritable)>

%endfunction %% SLibSetupRollingInfo


%% Function: SLibSetupLoggingInfo ==============================================
%% Abstract:
%%   Setup all globals related to logging data and states
%%
%function SLibSetupLoggingInfo() void
  %%
  %% Use standard ".mat" file logging
  %%
  %if MatFileLogging == 1 && IsModelReferenceTarget()
    %assign errTxt = "Model reference does not support 'MAT-file " ...
      "logging'. Please turn off MatFileLogging flag."
    %<LibReportError(errTxt)>
  %endif

  %% make sure both non-finite support and floating point support are enabled
  %% if MAT-file logging is enabled.
  %if (MatFileLogging==1) && ((SupportNonFinite==0) || (PurelyIntegerCode==1))
    %assign errTxt = "To use MAT-file logging, both floating point number "...
      "and non-finite number support must be enabled."
    %<LibReportError(errTxt)>
  %endif
  
  %if MatFileLogging == 1 && SuppressErrorStatus == 1
    %assign errMsg = "Can not select ERT option 'Suppress error status in " + ...
      "real-time model data structure' when selecting ERT option 'MAT-file logging'"
    %<LibReportFatalError(errMsg)>
  %endif
  %<LibAddToCompiledModel("MatFileLogging", MatFileLogging)>
  %assert EXISTS(MultiInstanceERTCode) && EXISTS(MultiInstanceErrorCode)
  %if MatFileLogging && MultiInstanceERTCode
    %if MultiInstanceErrorCode == "Warning"
      %assign warnMsg = "The ERT option 'MAT-file logging' is not " ...
                        "compatible with the ERT option 'Generate " ...
                        "reusable code'; consider deselecting one of the " ...
                        "two options"
      %warning %<warnMsg>
    %elseif MultiInstanceErrorCode == "Error"
      %<LibReportFatalError("The ERT option 'MAT-file logging' is not " ...
               "compatible with the ERT option 'Generate reusable code'; " ...
               "consider deselecting one of the two options, or " ...
               "setting the ERT option 'Reusable code error diagnostic' " ...
               "to 'None' or 'Warning'")>
    %endif
  %endif

  %if MatFileLogging && !IncludeMdlTerminateFcn
     %<LibReportFatalError("The ERT option 'MAT-file logging' requies that " ...
       "the ERT option 'Terminate functions required' is checked. Considering " ...
       "deselecting 'MAT-file logging' or selecting "...
       "'Terminate functions required'")>
  %endif
  %%
  %% Append this prefix to all the variable names when saving to the
  %% .mat file
  %%
  %if !EXISTS("LogVarNameModifier")
    %assign ::LogVarNameModifier = "rt_"
  %endif
  %<LibAddToCompiledModel("LogVarNameModifier", LogVarNameModifier)>

%endfunction %% SLibSetupLoggingInfo

%% Function: SLibSetTriggerConstantTID==============================================
%% Abstract:
%%      Set all TriggerTID for all blocks whos TID is "triggered",
%%   If a subsystem contains constant subsystem(s),  the SubsystemTID
%%   of this subsystem need include [0].
%function SLibSetTriggerConstantTID() void
  %with CompiledModel
    %foreach sysIdx = NumSystems - 1
      %assign system     = System[sysIdx]
      %assign currentTID = FcnGetSubsystemTID(system)
      %with system
	%foreach blkIdx = NumBlocks
	  %assign block = Block[blkIdx]
	  %with block
	    %if SkipBlockFcn 
	      %continue
	    %endif
	    %if LibTriggeredTID(TID)
	      %if !ISFIELD(block, "TriggerTID")
		%addtorecord block TriggerTID currentTID
	      %endif
	    %elseif ISEQUAL(TID,"Subsystem")
	      %if LibTriggeredTID(SubsystemTID)
		%if !ISFIELD(block, "TriggerTID")
		  %addtorecord block TriggerTID currentTID
		%endif
	      %elseif ISEQUAL(SubsystemTID,"constant") && SLibIsRateGrouping()
		%assign block.SubsystemTID =  0
	      %endif
	    %endif
	  %endwith
	%endforeach
      %endwith
    %endforeach
  %endwith
%endfunction

%% Function: SLibSetupAbsoluteTime =============================================
%% Abstract:
%%   Setup special cases requiring absolute time
%%   1) MatFileLogging selected
%%   2) ExtMode active
%%   3) ERT target sets ForceAbsoluteTime in system target file
%%   4) ERT with a continuous task.
%%   Setup TriggerTID for all blocks inside trigger subsystem. 
%%   Block need this informatio to get absolute time.
%%
%function SLibSetupAbsoluteTime() void
  %if !EXISTS("ForceAbsoluteTime")
    %if (CodeFormat == "Embedded-C") && LibIsContinuous(0)
      %assign ::ForceAbsoluteTime = 1
    %else
      %assign ::ForceAbsoluteTime = 0
    %endif
  %endif
  %if MatFileLogging || ExtMode || ForceAbsoluteTime
    %with CompiledModel
      %assign altNumST = ISFIELD(CompiledModel,"FixedStepOpts") ? ...
          FixedStepOpts.TID01EQ+1 : 1
      %foreach idx = ExtMode ? NumSampleTimes : altNumST
	%assign SampleTime[idx].NeedAbsoluteTime = "yes"
	%if idx == 0 && ...
	  ( ExtMode || MatFileLogging || ForceAbsoluteTime || ...
	    (IsModelReferenceForASimstructBasedTarget() && LibIsContinuous(idx)) )
	    %if !ISFIELD(SampleTime[idx], "needFloatTime")
	      %addtorecord SampleTime[idx] needFloatTime TLC_TRUE
	    %endif
	%endif
	%if !SLibClockTickIsUnit32Pair(idx) && ...
	  !(IsModelReferenceForASimstructBasedTarget() && LibIsContinuous(idx))
	  %assign SampleTime[idx].ClockTickDataTypeId = tSS_TIMER_UINT32_PAIR
	%endif
      %endforeach
    %endwith
  %endif
  %<SLibSetTriggerConstantTID()>
%endfunction %% SLibSetupAbsoluteTime


%% Function: FcnSetupHdrsAndSources ===========================================
%% Abstract:
%%   Setup variables to store all sources & headers needed for model
%%
%function FcnSetupHdrsAndSources() void
  %assign numSrcs = 0
  %<LibAddToCompiledModel("Sources", [])>
  %% For model reference we do not generate model.c file
  %if !IsModelReferenceTarget()
    %assign ::CompiledModel.Sources = CompiledModel.Sources+"%<CompiledModel.Name>"
    %assign numSrcs = 1
  %endif
  %<LibAddToCompiledModel("NumSources", numSrcs)>
  %<LibAddToCompiledModel("Headers", [])>
  %<LibAddToCompiledModel("NumHeaders", 0)>

  %<LibAddToCompiledModel("SysPathHeaders", [])>
  %<LibAddToCompiledModel("NumSysPathHeaders", 0)>
  %<LibAddToCompiledModel("SysLocalHeaders", [])>
  %<LibAddToCompiledModel("NumSysLocalHeaders", 0)>
  %<LibAddToCompiledModel("BlockPathHeaders", [])>
  %<LibAddToCompiledModel("NumBlockPathHeaders", 0)>
  %<LibAddToCompiledModel("BlockLocalHeaders", [])>
  %<LibAddToCompiledModel("NumBlockLocalHeaders", 0)>
%endfunction %% FcnSetupHdrsAndSources


%% Function: SLibSetupCodeGenTrackingFields ====================================
%% Abstract:
%%   Setup fields that track the current state of code generation. These are
%%   fields that are setup for internal use by the TLC code-base.
%%
%function SLibSetupCodeGenTrackingFields() void
  %%
  %% Unmangle function names via RTWData
  %%
  %assign tmpVar = FunctionNamesRepository { dummy 1 }
  %<LibAddToCompiledModel("FunctionNamesRepository", FunctionNamesRepository)>

  %%
  %% Cache whether IntegerSizes exists (created when %including
  %% funclib.tlc, which %includes fixptlib.tlc, which can create
  %% IntegerSizes
  %%
  %<LibAddToCompiledModel("IntegerSizesExists", EXISTS("IntegerSizes"))>

  %%
  %% Setup HaveVirtualOutports to be false
  %%
  %assign ::HaveVirtualOutports = 0
  %<LibAddToCompiledModel("HaveVirtualOutports", HaveVirtualOutports)>

  %%
  %% Setup GeneratingDeadCode (in MdlStart) to be false
  %%
  %<LibAddToCompiledModel("GeneratingDeadCode", 0)>

  %%
  %% Setup GeneratingOutputsCode to keep track of when outputs code is
  %% being generated (for expression folding)
  %%
  %<LibAddToCompiledModel("GeneratingOutputsCode", 0)>

  %%
  %% Default value for child S-Functions
  %%
  %<LibAddToCompiledModel("NumChildSFunctions", 0)>
  %<LibAddToCompiledModel("ChildSFunctionList", [])>

  %%
  %% Flags for tracking Non-finites
  %%
  %<LibAddToCompiledModel("NeedRealInf", 0)>
  %<LibAddToCompiledModel("NeedRealMinusInf", 0)>
  %<LibAddToCompiledModel("NeedRealNaN", 0)>

  %%
  %% Global Variable to cache the existence of TLC files
  %%   FILE_EXISTS can be very slow.  Once it is known that a file exists,
  %%   it is much quicker to look in the cache.
  %%
  %if !EXISTS("GblInlinedTLCFileAccessed")
    %createrecord ::GblInlinedTLCFileAccessed {}
  %endif

  %%
  %% Include rtlibsrc.h
  %%
  %if !EXISTS("IncludeLibsrc")
    %assign ::IncludeLibsrc = 0
  %endif
  %<LibAddToCompiledModel("IncludeLibsrc", IncludeLibsrc)>

  %%
  %% Setup fields for tracking the header and source files.
  %%
  %<FcnSetupHdrsAndSources()>

  %%
  %% Setup field to track if we need TID or not
  %%
  %<LibAddToCompiledModel("NeedTID", 0)>

%endfunction %% SLibSetupCodeGenTrackingFields

%%Function SLibNeedGenerateGRTWrapper ==============================
%%  For GRT code formate, this function will determinate if we will
%%  generate GRT classic code or New GRT which is ERT with GRT Wrapper.
%%
%%   For ert code format, if Generate GRT Interface option is checked,
%%  returns true. and do diagnostic check.
%%

%function SLibNeedGenerateGRTWrapper() void
  %assign retVal = TLC_FALSE

  %if CodeFormat == "RealTime"
    %if GenRTModel && !IsModelReferenceTarget()
      %assign ::CodeFormat = "Embedded-C"
      %assign retVal = TLC_TRUE
      %assign ::TargetOS = "BareBoardExample"
      %assign ::CombineOutputUpdateFcns = 0
    %endif
  %elseif CodeFormat == "Embedded-C"
    %assign retVal = CompiledModel.ConfigSet.GRTInterface
    %if retVal
      %assert !IsModelReferenceTarget()
      %assign ::RateGroupingCode = 0
      %if CombineOutputUpdateFcns
	%assign  errTxt = "When RTW option 'GRT compatible call Interface' "...
	"is checked, 'Single output/update function' must be unchecked"
	%<LibReportError(errTxt)>
      %endif
      %if PurelyIntegerCode
	%assign  errTxt = "When RTW option 'GRT compatible call Interface' "...
	"is checked, 'floating-point number' must be checked"
	%<LibReportError(errTxt)>
      %endif
    %endif
  %endif

  %if retVal
    %if EXISTS(MultiInstanceERTCode) && MultiInstanceERTCode
       %assign errTxt = "When RTW option 'GRT compatible call Interface' is checked, " ...
      "'Generate reusable code' must be unchecked"
      %<LibReportError(errTxt)>
    %endif

    %foreach tid = CompiledModel.NumSynchronousSampleTimes
      %<SLibSetNeedAbsoluteTime(tid)>
      %if !ISFIELD(CompiledModel.SampleTime[tid], "needFloatTime")
	%addtorecord CompiledModel.SampleTime[tid] needFloatTime TLC_TRUE
      %endif
    %endforeach
   %endif
  %return retVal

%endfunction

%% Function: SLibSetupCodeFormat ===============================================
%% Abstract:
%%   Sets up:
%%   (a) Default code format if not already setup to be "RealTime"
%%
%%   (b) Accelerator and ExtMode to be 0 if not already setup/
%%
%%   (c) UsingMalloc and IOQualifier based on the CodeFormat:
%%
%%   .-----------------------+-------.
%%   | Code                  | Using |
%%   | Format                | Malloc|
%%   +-----------------------+-------+
%%   | RealTime              |   0   |
%%   | RealTimeMalloc        |   1   |
%%   | Embedded-C            |   0   |
%%   | Ada                   |   0   |
%%   | S-Function            |   1   |
%%   `-----------------------+-------'
%%
%%   Note on UsingMalloc:
%%   RTW uses static or dynamic memory allocation for specified values of 0
%%   and 1, respectively.  Note these dependencies on UsingMalloc.
%%
%%   o Global parameter data is not allowed when dynamic memory allocation is
%%     used.  That is, TLC function LibCacheGlobalPrmData is disabled.
%%
%%   o Model_prm is included at the top of model.c and the bottom of model.c
%%     for UsingMalloc equal to 0 and 1, respectively.
%%
%%   (d) PreStructTypedefPragma & PostStructTypedefPragma
%%       PreStructDeclarePragma & PostStructDeclarePragma
%%
%%   xxx byu
%%   If code format is "RealTime", change to "Embedded-C" and
%%   "GenerateGRTWrapper=1"
%%
%function SLibSetupCodeFormat() void

  %%
  %% Setup the code format if not already setup
  %%
  %if !EXISTS("CodeFormat")
    %assign ::CodeFormat = "RealTime"
  %endif

  %%
  %% Setup fields for generating the rtModel
  %%
  %if CodeFormat == "Embedded-C"
    %% Always generate the rtModel for ERT
    %assign ::GenRTModel = 1
  %endif

  %if !EXISTS(GenRTModel)
    %assign ::GenRTModel = 0
  %endif

  %%
  %% Extmode flag
  %%
  %if !EXISTS("ExtMode")
    %assign ::ExtMode = 0
  %endif

  %if ExtMode == 1 || EXISTS("_RSIM_")
    %assign ::CompiledModel.HaveSeparateSourceFiles = 1
  %endif

  %assign ::GenerateGRTWrapper = SLibNeedGenerateGRTWrapper()

  %assign ::UseGlobalTimingForModelReference = ...
    FEVAL("feature", "ModelReferenceGlobalTiming")

  %assign ::ModelReferenceTargetWithGlobalTiming = TLC_FALSE
  %if IsModelReferenceTarget()
    %assign ::ModelReferenceTargetWithGlobalTiming = ...
      ::UseGlobalTimingForModelReference
  %endif

  %if EXISTS("SimstructBasedTarget") && ...
    (SimstructBasedTarget == TLC_FALSE && GenRTModel == 0)
    %assign errTxt = "Invalid setting is specified for SimstructBasedTarget (false) "
    "GenRTModel (0). Please check you system target file."
    %<LibReportError(errTxt)>
  %endif

  %if !EXISTS("SimstructBasedTarget")
    %if ::GenRTModel == 0
      %assign ::SimstructBasedTarget = TLC_TRUE
    %else
      %assign ::SimstructBasedTarget = TLC_FALSE
    %endif
  %endif

  %if (IsModelReferenceTarget() && IsSimstructBasedTarget())
    %assign ::ModelReferenceForASimstructBasedTarget = TLC_TRUE
    %assert (EXISTS("tMdlRefSfcnS"))
    %% tMdlRefSfcn is not defined in the TLC files. Model reference
    %% targets that use SimStruct must declare tMdlRefSfcnS
    %% in their target TLC files
  %else
    %assign ::ModelReferenceForASimstructBasedTarget = TLC_FALSE
  %endif

  %% Global timing engine for model reference only works with
  %% Embedded-C and simstruct based targets
  %if ::UseGlobalTimingForModelReference && HasModelReferenceBlocks()
    %if CodeFormat != "Embedded-C" && !::SimstructBasedTarget
      %assign errTxt = "Invalid system target file.  This model "...
        "contains Model blocks that were built using a global timing "...
        "engine.  This is only supported for targets that have CodeFormat "...
        "set to Embedded-C or SimStruct based targets."
      %<LibReportError(errTxt)>
    %endif
  %endif

  %if IsModelReferenceRTWTarget()
    %if !( CodeFormat == "Embedded-C" || ...
      CodeFormat == "RealTime" || ...
      EXISTS("_RSIM_") )
      %assign errTxt = "Model reference does not support the '%<CodeFormat>' code format."
      %<LibReportError(errTxt)>
    %endif
    %assign ::CodeFormat = "Embedded-C"

    %if ::GenRTModel == 0
      %assign ::GenRTModel = 1
      %% Model reference RTW target requires rtModel
      %% data structure to store information about the model

      %assign msgTxt = "### Turning on GenRTModel setting to use " ...
	"rtModel data structure"
      %<LibWriteToStandardOutput(msgTxt)>
    %endif
  %endif

  %<LibAddToCompiledModel("CodeFormat", CodeFormat)>

  %if !EXISTS("RateGroupingCode")
    %assign ::RateGroupingCode = 0
  %endif

  %if IsModelReferenceTarget()
    %assign ::RateGroupingCode = 1
  %endif
  %<LibAddToCompiledModel("RateGroupingCode", RateGroupingCode)>

  %<SLibCreateSystemInterfaceRecordsForRateGrouping()>

  %%
  %assign ::ModelInitializeFcnUsesFirstTime = 0

  %%
  %% Accelerator flag.  Used in conjuction with the S-Function code format.
  %%
  %if !EXISTS("Accelerator")
    %assign ::Accelerator = 0
  %endif
  %<LibAddToCompiledModel("Accelerator", Accelerator)>

  %%
  %% Setup the UsingMalloc & IOQualifier fields
  %%
  %assign UsingMalloc = 0
  %if ISFIELD(CompiledModel,"RTWGenSettings")
    %if ISFIELD(CompiledModel.RTWGenSettings,"UsingMalloc")
      %if CompiledModel.RTWGenSettings.UsingMalloc == "yes"
	%assign UsingMalloc = 1
      %endif
    %endif
  %endif

  %switch CodeFormat
    %case "RealTime"
      %assign IOQualifier   = "."
      %if UsingMalloc != 0
	%assign errTxt = "UsingMalloc setting passed in from gensettings " ...
	  "is not consistent with selected CodeFormat"
	%<LibReportFatalError(errTxt)>
      %endif
      %break
    %case "RealTimeMalloc"
      %assign IOQualifier   = "->"
      %if UsingMalloc != 1
	%assign errTxt = "UsingMalloc setting passed in from gensettings " ...
	  "is not consistent with selected CodeFormat"
	%<LibReportFatalError(errTxt)>
      %endif
      %break
    %case "Embedded-C"
      %assign IOQualifier   = "."
      %if UsingMalloc != 0
	%assign errTxt = "UsingMalloc setting passed in from gensettings " ...
	  "is not consistent with selected CodeFormat"
	%<LibReportFatalError(errTxt)>
      %endif
      %break
    %case "S-Function"
      %assign IOQualifier   = "->"
      %if UsingMalloc != 1
	%assign errTxt = "UsingMalloc setting passed in from gensettings " ...
	  "is not consistent with selected CodeFormat"
	%<LibReportFatalError(errTxt)>
      %endif
      %assign ::OrigName    = CompiledModel.Name
      %assign CompiledModel = CompiledModel + OrigName
      %if !Accelerator
	%assign warnTxt = "Changing output file name to " ...
	  "%<CompiledModel.Name>_sf"
	%<LibReportWarning(warnTxt)>
	%assign ::newName          = "%<CompiledModel.Name>_sf"
	%assign CompiledModel.Name = "%<CompiledModel.Name>_sf"
      %else
	%assign ::newName          = "%<CompiledModel.Name>_acc"
	%assign CompiledModel.Name = "%<CompiledModel.Name>_acc"
      %endif
      %break
    %default
      %openfile errTxt


Unknown code format:  %<CodeFormat>

Specify CodeFormat as one of these values:

Embedded-C
RealTime
RealTimeMalloc
S-Function
      %closefile errTxt
      %<LibReportError(errTxt)>
  %endswitch

  %%
  %% Error check for UsingMalloc and IOQualifier
  %%
  %assign errTxt = "Must specify UsingMalloc as 0 or 1."
  %if !EXISTS("UsingMalloc")
    %% variable doesn't exist
  %elseif !ISEQUAL(UsingMalloc, 0) && !ISEQUAL(UsingMalloc, 1)
    %% variable exists, but has invalid setting
  %else
    %% valid setting so clear error text
    %assign errTxt = ""
  %endif

  %if !EXISTS("IOQualifier")
    %assign errTxt = "Must specify IOQualifier corresponding to " ...
      "UsingMalloc.  Value should be . or -> for UsingMalloc equal " ...
      "to 0 and 1, respectively."
  %endif

  %if errTxt != ""
    %<LibReportFatalError(errTxt)>
  %endif

  %%
  %% Add fields to CompiledModel
  %%
  %assign ::UsingMalloc = UsingMalloc
  %assign ::IOQualifier = IOQualifier
  %<LibAddToCompiledModel("UsingMalloc", UsingMalloc)>
  %<LibAddToCompiledModel("IOQualifier", IOQualifier)>

  %%
  %% Initialize target specific compiler hooks
  %%
  %if !EXISTS("PreStructTypedefPragma")
    %assign ::PreStructTypedefPragma = ""
  %endif
  %<LibAddToCompiledModel("PreStructTypedefPragma", PreStructTypedefPragma)>

  %if !EXISTS("PostStructTypedefPragma")
    %assign ::PostStructTypedefPragma = ""
  %endif
  %<LibAddToCompiledModel("PostStructTypedefPragma", PostStructTypedefPragma)>

  %if !EXISTS("PreStructDeclarePragma")
    %assign ::PreStructDeclarePragma = ""
  %endif
  %<LibAddToCompiledModel("PreStructDeclarePragma", PreStructDeclarePragma)>

  %if !EXISTS("PostStructDeclarePragma")
    %assign ::PostStructDeclarePragma = ""
  %endif
  %<LibAddToCompiledModel("PostStructDeclarePragma", PostStructDeclarePragma)>

  %if GenRTModel
    %<SLibInitRTMdlRecs()>
  %endif

  %assign cs = CompiledModel.ConfigSet

  %if cs.IsERTTarget
    %assign srcCTemplate  = FEVAL("rtw_cgt_name_conv",cs.ERTSrcFileBannerTemplate,"cgt2tlc")
    %assign srcHTemplate  = FEVAL("rtw_cgt_name_conv",cs.ERTHdrFileBannerTemplate,"cgt2tlc")
    %assign dataCTemplate = FEVAL("rtw_cgt_name_conv",cs.ERTDataSrcFileTemplate,"cgt2tlc")
    %assign dataHTemplate = FEVAL("rtw_cgt_name_conv",cs.ERTDataHdrFileTemplate,"cgt2tlc")

    %if !EXISTS("ERTSrcFileBannerTemplate")
      %assign ::ERTSrcFileBannerTemplate = srcCTemplate
    %endif

    %if !EXISTS("ERTHdrFileBannerTemplate")
      %assign ::ERTHdrFileBannerTemplate = srcHTemplate
    %endif

    %if !EXISTS("ERTCustomFileTemplate")
      %assign ::ERTCustomFileTemplate = cs.ERTCustomFileTemplate
    %endif

    %<LibAddToCompiledModel("ERTSrcFileBannerTemplate",ERTSrcFileBannerTemplate)>
    %<LibAddToCompiledModel("ERTHdrFileBannerTemplate",ERTHdrFileBannerTemplate)>
    %<LibAddToCompiledModel("ERTDataSrcFileTemplate",dataCTemplate)>
    %<LibAddToCompiledModel("ERTDataHdrFileTemplate",dataHTemplate)>
    %<LibAddToCompiledModel("ERTCustomFileTemplate",ERTCustomFileTemplate)>
  %else
    %<LibAddToCompiledModel("ERTSrcFileBannerTemplate","n/a")>
    %<LibAddToCompiledModel("ERTHdrFileBannerTemplate","n/a")>
    %<LibAddToCompiledModel("ERTDataSrcFileTemplate","n/a")>
    %<LibAddToCompiledModel("ERTDataHdrFileTemplate","n/a")>
    %<LibAddToCompiledModel("ERTCustomFileTemplate","n/a")>
  %endif

  %% Initialize ActualMultiRateSampleHits field for embedded-c
  %%
  %if CodeFormat == "Embedded-C"
    %assign numSyncTs = CompiledModel.NumSynchronousSampleTimes
    %if numSyncTs > 1
      %assign tmp = FEVAL("zeros", numSyncTs, numSyncTs)
    %else
      %assign tmp = Matrix(1,1)[[0]]
    %endif
    %addtorecord CompiledModel RequireMultiRateSampleHits 0
    %addtorecord CompiledModel ActualMultiRateSampleHits tmp
  %endif

%endfunction %% SLibSetupCodeFormat


%% Function: FcnSetupCommonCodeIdents ==========================================
%% Abstract:
%%   Setup identifiers that are common to all Code Formats.
%%
%function FcnSetupCommonCodeIdents() void
  %if !EXISTS("tRealPart")
    %assign ::tRealPart = "re"
  %endif
  %<LibAddToCompiledModel("tRealPart", tRealPart)>

  %if !EXISTS("tImagPart")
    %assign ::tImagPart = "im"
  %endif
  %<LibAddToCompiledModel("tImagPart", tImagPart)>

  %<LibAddToCompiledModel("tLocalBlockIO", "rtb")>

  %assign ::tMdlRefTimingBridge = "mdlref_%<CompiledModel.Name>TimingBridge"

%%  %if !EXISTS("PrefixModelToStructs")
%%    %assign ::PrefixModelToStructs = 1
%%  %endif
%%  %if !EXISTS("PrefixModelToSubsysFcnNames")
%%    %assign ::PrefixModelToStructs = 1
%%  %else
%%    %assign ::PrefixModelToStructs = %<PrefixModelToSubsysFcnNames>
%%  %endif
%%
%% dboissy says:
%% This is no longer a boolean setting.  The decision to prefix
%% model names is made by searching for "$R" (root model name) in
%% the symbol format string.
  %if (ConfigSet.IsERTTarget == 0)
    %assign ::PrefixModelToStructs = 1
  %else
    %assign ::PrefixModelToStructs = !ISEMPTY(FEVAL("strfind",CustomSymbolStr,"$R"))
  %endif
  %<LibAddToCompiledModel("PrefixModelToStructs", PrefixModelToStructs)>

  %if !EXISTS("GenerateFullHeader")
    %assign ::GenerateFullHeader = 1
  %else
    %assign ::GenerateFullHeader = %<GenerateFullHeader>
  %endif
  %<LibAddToCompiledModel("GenerateFullHeader", GenerateFullHeader)>

  %if !EXISTS("IncludeFileBanners")
    %assign IncludeFileBanners = 1
  %endif
  %<LibAddToCompiledModel("IncludeFileBanners", IncludeFileBanners)>

%endfunction %% FcnSetupCommonCodeIdents

%% Function: FcnSetupRTModelNames ==============================================
%% Abstract:
%%   Used by RealTime and RealTimeMalloc targets to setup the names of the
%%   rtModel
%%
%function FcnSetupRTModelNames() void
  %if !EXISTS("tSimStruct")
    %assign ::tSimStruct = GenRTModel ? "rtM_%<CompiledModel.Name>" : "rtS"
  %endif
  %if !EXISTS("tSimStructType")
    %assign ::tSimStructType = GenRTModel ? "rtModel_%<CompiledModel.Name>" : ...
      "SimStruct"
  %endif
  %<LibAddToCompiledModel("tSimStruct", tSimStruct)>
%endfunction %% FcnSetupRTModelNames

%% Function: SLibSetupCodeIdentifiers===========================================
%% Abstract:
%%   Sets up fields for various Identifiers used in the generated code.
%%   Some of these fields are set up on the basis of the specific code format
%%
%function SLibSetupCodeIdentifiers() void

  %%
  %% Setup identifiers that do not depend on code format
  %%
  %<FcnSetupCommonCodeIdents()>

  %if !EXISTS("NeedUNUSED_PARAMETERDeclaration")
	%assign ::NeedUNUSED_PARAMETERDeclaration = 0
  %endif

  %% Only generate into _sharedutils if a sub-model or top model with references.
  %% This provides for backwards compatibility of the user makefiles and other
  %% custom post-codegen processing. Note: Any change to this logic should be
  %% duplicated in rtwinfomatman.m so that checking _sharedutil dir checksum is
  %% done only when GenUtilsSrcInSharedLocation is set.
  %if HasModelReferenceBlocks() || IsModelReferenceTarget() || ...
       (CompiledModel.ConfigSet.UtilityFuncGeneration == "Shared location")
    %if !ISFIELD(CompiledModel, "RTWInfoMatFile")
      %<LoadRTWInfoMatFileforTLC()>
    %endif
    %assign gShared = 1
    %assign gPath = CompiledModel.RTWInfoMatFile.sharedSourcesDir
  %else
    %assign gShared = 0
    %assign gPath = FEVAL("rtwprivate", "rtwattic","getBuildDir")
  %endif
  %% Ensure m-code and TLC code are in sync
  %if EXISTS(::OrigName)
    %assign rtwgenshared = FEVAL("rtw_gen_shared_utils","%<CompiledModel.OrigName>")
  %else
    %assign rtwgenshared = FEVAL("rtw_gen_shared_utils","%<CompiledModel.Name>")
  %endif
  %assert rtwgenshared == gShared
  %<LibAddToCompiledModel("GenUtilsSrcInSharedLocation", gShared)>
  %<LibAddToCompiledModel("GenUtilsPath", gPath)>
  %% Store GenUtilsLocation in rtwattic for reference after TLC phase
  %matlab rtwprivate("rtwattic","AtticData","genDirForTFL","%<CompiledModel.GenUtilsPath>")

  %assign ::Tid01Eq = ISEQUAL(CompiledModel.SolverType, "FixedStep") && ...
                      CompiledModel.FixedStepOpts.TID01EQ
  %<LibAddToCompiledModel("Tid01Eq", Tid01Eq)>

  %switch CompiledModel.CodeFormat
    %case "Embedded-C"

      %if !EXISTS("AutoBuildProcedure")
	%assign ::AutoBuildProcedure = 0
      %endif

      %if IsModelReferenceTarget()
	%assign ::AutoBuildProcedure = 0
        %assign ::tMdlRefGlobalTID    = "mdlref_%<CompiledModel.Name>GlobalTID"
      %endif

      %<LibAddToCompiledModel("AutoBuildProcedure", AutoBuildProcedure)>

      %assign varPrefix = PrefixModelToStructs ? "%<CompiledModel.Name>_" : "rt"
      %assign tdPostfix = PrefixModelToStructs ? "_%<CompiledModel.Name>" : ""

      %if !EXISTS("tSimStruct")
	%assign ::tSimStruct = "%<varPrefix>M"
      %endif
      %if !EXISTS("tSimStructType")
	%if GenerateGRTWrapper
	  %% rtModel for real-time code format
	  %<FcnSetupRTModelNames()>
	%else
	  %assign ::tSimStructType = "RT_MODEL" + tdPostfix
	  %<LibAddToCompiledModel("tSimStruct", tSimStruct)>
	%endif
      %endif
      %<LibAddToCompiledModel("tSimStructType", tSimStructType)>

      %<LibAddToCompiledModel("tLogObject", "rtL")>
      %<LibAddToCompiledModel("tLogObjectType", "LogObject")>

      %<LibAddToCompiledModel("tExtModeObject", "rtE")>
      %<LibAddToCompiledModel("tExtModeObjectType", "ExtModeObject")>

      %assign ::logObject     = "logObject"
      %assign ::logObjectAddr = "&%<logObject>"

      %if !IsModelReferenceTarget()
	%assign name = "%<varPrefix>B"
	%<LibAddToCompiledModel("tBlockIO", name)>
	%<LibAddToCompiledModel("tBlockIOType", "BlockIO"+tdPostfix)>
      %else
	%<LibAddToCompiledModel("tBlockIO", "ASSERT_MDLREF_NO_TBLOCKIO")>
	%<LibAddToCompiledModel("tBlockIOType", "ASSERT_MDLREF_NO_TBLOCKIOTYPE")>
      %endif

      %assign name = "%<varPrefix>U"
      %<LibAddToCompiledModel("tInput", name)>
      %<LibAddToCompiledModel("tInputType", "ExternalInputs"+tdPostfix)>

      %assign upperSolver = FEVAL("upper", CompiledModel.Solver)
      %<LibAddToCompiledModel("upperSolver", upperSolver)>
      %assign solverOrder = IDNUM(CompiledModel.Solver)[1]
      %<LibAddToCompiledModel("solverOrder", solverOrder)>

      %if !EXISTS("tContState")
        %assign ::tContState = "%<varPrefix>X"
      %endif
      %<LibAddToCompiledModel("tContState", tContState)>
      %<LibAddToCompiledModel("tContStateType", "ContinuousStates"+tdPostfix)>

      %if !EXISTS("tXdot")
        %assign ::tXdot = "%<varPrefix>Xdot"
      %endif
      %<LibAddToCompiledModel("tXdot", tXdot)>
      %<LibAddToCompiledModel("tXdotType", "StateDerivatives"+tdPostfix)>

      %if !EXISTS("tXdis")
        %assign ::tXdis = "%<varPrefix>Xdis"
      %endif
      %<LibAddToCompiledModel("tXdis", tXdis)>
      %<LibAddToCompiledModel("tXdisType", "StateDisabled"+tdPostfix)>

      %assign name = "%<varPrefix>Y"
      %<LibAddToCompiledModel("tOutput", name)>
      %<LibAddToCompiledModel("tOutputType", "ExternalOutputs"+tdPostfix)>

      %if SLibAreSimulinkGlobalParamsUnstructured()
	%assign name = "rtP"
	%<LibAddToCompiledModel("tParameters", name)>
      %else
	%assign name = "%<varPrefix>P"
	%<LibAddToCompiledModel("tParameters", name)>
	%<LibAddToCompiledModel("tParametersType", "Parameters"+tdPostfix)>
      %endif

      %assign name = "%<varPrefix>ConstP"
      %<LibAddToCompiledModel("tConstParamType", "ConstParam"+tdPostfix)>
      %<LibAddToCompiledModel("tConstParamStruct", name)>

      %assign name = "%<varPrefix>ConstWithInitP"
      %<LibAddToCompiledModel("tConstParamWithInitType", "ConstParamWithInit"+tdPostfix)>
      %<LibAddToCompiledModel("tConstParamWithInitStruct", name)>

      %if !EXISTS("tChildSimStruct")
        %assign ::tChildSimStruct = "rts"
      %endif
      %<LibAddToCompiledModel("tChildSimStruct", tChildSimStruct)>

      %if !IsModelReferenceTarget()
	%assign name = "%<varPrefix>DWork"
	%<LibAddToCompiledModel("tDWork", name)>
	%<LibAddToCompiledModel("tDWorkType", "D_Work"+tdPostfix)>
      %else
	%<LibAddToCompiledModel("tDWork", "ASSERT_MDLREF_NO_TDWORK")>
	%<LibAddToCompiledModel("tDWorkType", "ASSERT_MDLREF_NO_TDWORKTYPE")>
      %endif

      %assign name = "%<varPrefix>ConstB"
      %<LibAddToCompiledModel("tConstBlockIODefine", "rtC")>
      %<LibAddToCompiledModel("tConstBlockIOStruct", name)>
      %<LibAddToCompiledModel("tConstBlockIOType", "ConstBlockIO"+tdPostfix)>

      %assign name = "%<varPrefix>PrevZC"
      %<LibAddToCompiledModel("tPrevZCState", name)>
      %<LibAddToCompiledModel("tPrevZCStateType", "PrevZCSigStates"+tdPostfix)>

      %assign name = "%<varPrefix>NonsampledZC"
      %<LibAddToCompiledModel("tNonsampledZC", name)>
      %<LibAddToCompiledModel("tNonsampledZCType", "NonsampledZCs"+tdPostfix)>

      %<LibAddToCompiledModel("tTID", "tid")>
      %<LibAddToCompiledModel("tTIDType", "int_T")>

      %<LibAddToCompiledModel("tControlPortIdx", "controlPortIdx")>
      %<LibAddToCompiledModel("tControlPortIdxType", "int_T")>

      %if !EXISTS("tInf")
	%assign ::tInf = "rtInf"
      %endif
      %<LibAddToCompiledModel("tInf", tInf)>
      %<LibAddToCompiledModel("tInfType", "real_T")>

      %if !EXISTS("tMinusInf")
	%assign ::tMinusInf = "rtMinusInf"
      %endif
      %<LibAddToCompiledModel("tMinusInf", tMinusInf)>
      %<LibAddToCompiledModel("tMinusInfType", "real_T")>

      %if !EXISTS("tNaN")
	%assign ::tNaN = "rtNaN"
      %endif
      %<LibAddToCompiledModel("tNaN", tNaN)>
      %<LibAddToCompiledModel("tNaNType", "real_T")>

      %break

    %case "RealTime"
      %if !EXISTS("AutoBuildProcedure")
	%assign ::AutoBuildProcedure = 0
      %endif
      %<LibAddToCompiledModel("AutoBuildProcedure", AutoBuildProcedure)>

      %if !EXISTS("tBlockIO")
	%assign ::tBlockIO = "rtB"
      %endif
      %<LibAddToCompiledModel("tBlockIO", tBlockIO)>
      %<LibAddToCompiledModel("tBlockIOType", "BlockIO")>

      %if !EXISTS("tInput")
	%assign ::tInput = "rtU"
      %endif
      %<LibAddToCompiledModel("tInput", tInput)>
      %<LibAddToCompiledModel("tInputType", "ExternalInputs")>

      %assign upperSolver = FEVAL("upper", CompiledModel.Solver)
      %<LibAddToCompiledModel("upperSolver", upperSolver)>
      %assign solverOrder = IDNUM(CompiledModel.Solver)[1]
      %<LibAddToCompiledModel("solverOrder", solverOrder)>

      %if !EXISTS("tContState")
	%assign ::tContState = "rtX"
      %endif
      %<LibAddToCompiledModel("tContState", tContState)>
      %<LibAddToCompiledModel("tContStateType", "ContinuousStates")>

      %if !EXISTS("tXdot")
	%assign ::tXdot = "rtXdot"
      %endif
      %<LibAddToCompiledModel("tXdot", tXdot)>
      %<LibAddToCompiledModel("tXdotType", "StateDerivatives")>

      %if !EXISTS("tXdis")
	%assign ::tXdis = "rtXdis"
      %endif
      %<LibAddToCompiledModel("tXdis", tXdis)>
      %<LibAddToCompiledModel("tXdisType", "StateDisabled")>

      %if !EXISTS("tOutput")
	%assign ::tOutput = "rtY"
      %endif
      %<LibAddToCompiledModel("tOutput", tOutput)>
      %<LibAddToCompiledModel("tOutputType", "ExternalOutputs")>

      %if !EXISTS("tParameters")
	%assign ::tParameters = "rtP"
      %endif
      %<LibAddToCompiledModel("tParameters", tParameters)>
      %<LibAddToCompiledModel("tParametersType", "Parameters")>

      %% rtModel for real-time code format
      %<FcnSetupRTModelNames()>

      %if !EXISTS("tChildSimStruct")
	%assign ::tChildSimStruct = "rts"
      %endif
      %<LibAddToCompiledModel("tChildSimStruct", tChildSimStruct)>

      %if !EXISTS("tDWork")
	%assign ::tDWork = "rtDWork"
      %endif
      %<LibAddToCompiledModel("tDWork", tDWork)>
      %<LibAddToCompiledModel("tDWorkType", "D_Work")>

      %if !EXISTS("tConstBlockIOType")
	%assign ::tConstBlockIOType = "ConstBlockIO"
      %endif
      %<LibAddToCompiledModel("tConstBlockIOType", tConstBlockIOType)>

      %if !EXISTS("tConstBlockIODefine")
	%assign ::tConstBlockIODefine = "rtC"
      %endif
      %<LibAddToCompiledModel("tConstBlockIODefine", tConstBlockIODefine)>

      %if !EXISTS("tConstBlockIOStruct")
	%assign ::tConstBlockIOStruct = "rtC"
      %endif
      %<LibAddToCompiledModel("tConstBlockIOStruct", tConstBlockIOStruct)>

      %if !EXISTS("tConstParamType")
	%assign ::tConstParamType = "ConstParam"
      %endif
      %<LibAddToCompiledModel("tConstParamType", tConstParamType)>

      %if !EXISTS("tConstParamStruct")
	%assign ::tConstParamStruct = "rtcP"
      %endif
      %<LibAddToCompiledModel("tConstParamStruct", tConstParamStruct)>

      %if !EXISTS("tConstParamWithInitType")
	%assign ::tConstParamWithInitType = "ConstParamWithInit"
      %endif
      %<LibAddToCompiledModel("tConstParamWithInitType", tConstParamWithInitType)>

      %if !EXISTS("tConstParamWithInitStruct")
	%assign ::tConstParamWithInitStruct = "rtcWithInitP"
      %endif
      %<LibAddToCompiledModel("tConstParamWithInitStruct", tConstParamWithInitStruct)>

      %if !EXISTS("tPrevZCState")
	%assign ::tPrevZCState = "rtPrevZCSigState"
      %endif
      %<LibAddToCompiledModel("tPrevZCState", tPrevZCState)>
      %<LibAddToCompiledModel("tPrevZCStateType", "PrevZCSigStates")>

      %if !EXISTS("tNonsampledZC")
	%assign ::tNonsampledZC = "rtNonsampledZC"
      %endif
      %<LibAddToCompiledModel("tNonsampledZC", tNonsampledZC)>
      %<LibAddToCompiledModel("tNonsampledZCType", "NonsampledZCs")>

      %if !EXISTS("tTID")
	%assign ::tTID = "tid"
      %endif
      %<LibAddToCompiledModel("tTID", tTID)>
      %<LibAddToCompiledModel("tTIDType", "int_T")>

      %if !EXISTS("tControlPortIdx")
	%assign ::tControlPortIdx = "controlPortIdx"
      %endif
      %<LibAddToCompiledModel("tControlPortIdx", tControlPortIdx)>
      %<LibAddToCompiledModel("tControlPortIdxType", "int_T")>

      %if !EXISTS("tInf")
	%assign ::tInf = "rtInf"
      %endif
      %<LibAddToCompiledModel("tInf", tInf)>
      %<LibAddToCompiledModel("tInfType", "real_T")>

      %if !EXISTS("tMinusInf")
	%assign ::tMinusInf = "rtMinusInf"
      %endif
      %<LibAddToCompiledModel("tMinusInf", tMinusInf)>
      %<LibAddToCompiledModel("tMinusInfType", "real_T")>

      %if !EXISTS("tNaN")
	%assign ::tNaN = "rtNaN"
      %endif
      %<LibAddToCompiledModel("tNaN", tNaN)>
      %<LibAddToCompiledModel("tNaNType", "real_T")>

      %break

    %case "S-Function"
      %assign varPrefix = PrefixModelToStructs ? "%<CompiledModel.Name>_" : ""
      %assign tdPostfix = PrefixModelToStructs ? "_%<CompiledModel.Name>" : ""

      %if !EXISTS("AutoBuildProcedure")
	%assign ::AutoBuildProcedure = 0
      %endif
      %<LibAddToCompiledModel("AutoBuildProcedure", AutoBuildProcedure)>

      %<LibAddToCompiledModel("tBlockIO",          OrigName+"_B")>
      %<LibAddToCompiledModel("tBlockIOType",      OrigName+"_BlockIO")>
      %<LibAddToCompiledModel("tInput",            OrigName+"_UPtrs")>
      %<LibAddToCompiledModel("tInputType",        OrigName+"_ExternalUPtrs")>
      %<LibAddToCompiledModel("tContState",        OrigName+"_X")>
      %<LibAddToCompiledModel("tContStateType",    OrigName+"_ContinuousStates")>
      %<LibAddToCompiledModel("tXdot",             OrigName+"_Xdot")>
      %<LibAddToCompiledModel("tXdotType",         OrigName+"_StateDerivatives")>
      %<LibAddToCompiledModel("tXdis",             OrigName+"_Xdis")>
      %<LibAddToCompiledModel("tXdisType",         OrigName+"_StateDisabled")>
      %<LibAddToCompiledModel("tOutput",           OrigName+"_Y")>
      %<LibAddToCompiledModel("tOutputType",       OrigName+"_ExternalOutputs")>
      %<LibAddToCompiledModel("tParameters",       OrigName+"_P")>
      %<LibAddToCompiledModel("tDefaultParameters",OrigName+"_DefaultParameters")>
      %<LibAddToCompiledModel("tParametersType",   OrigName+"_Parameters")>
      %if Accelerator
	%<LibAddToCompiledModel("tDWork",            OrigName+"_DWork")>
	%<LibAddToCompiledModel("tDWorkType",        OrigName+"_D_Work")>
      %endif
      %<LibAddToCompiledModel("tPrevZCState",      OrigName+"_PrevZCSigState")>
      %<LibAddToCompiledModel("tPrevZCStateType",  OrigName+"_PrevZCSigStates")>
      %<LibAddToCompiledModel("tNonsampledZC",     OrigName+"_NonsampledZC")>
      %<LibAddToCompiledModel("tNonsampledZCType", OrigName+"_NonsampledZCs")>

      %assign ::tSimStruct = "S"
      %if !EXISTS("tSimStructType")
	%assign ::tSimStructType = "SimStruct"
      %endif
      %<LibAddToCompiledModel("tSimStruct",        "S")>
      %<LibAddToCompiledModel("tChildSimStruct",   "rts")>

      %assign str = "rtC(%<CompiledModel.tSimStruct>)"
      %<LibAddToCompiledModel("tConstBlockIOStruct", str)>
      %undef str
      %<LibAddToCompiledModel("tInvariantSignals", "InvariantSignals")>
      %<LibAddToCompiledModel("tConstBlockIOType", "ConstBlockIO")>
      %<LibAddToCompiledModel("tConstBlockIODefine", "rtC")>

      %<LibAddToCompiledModel("tConstParamType",           "ConstParam"+tdPostfix)>
      %<LibAddToCompiledModel("tConstParamStruct",         varPrefix+"rtcP")>
      %<LibAddToCompiledModel("tConstParamWithInitType",   "ConstParamWithInit"+tdPostfix)>
      %<LibAddToCompiledModel("tConstParamWithInitStruct", varPrefix+"rtcWithInitP")>

      %<LibAddToCompiledModel("tTID",              "tid")>
      %<LibAddToCompiledModel("tTIDType",          "int_T")>
      %<LibAddToCompiledModel("tControlPortIdx",   "controlPortIdx")>
      %<LibAddToCompiledModel("tControlPortIdxTpye", "int_T")>
      %<LibAddToCompiledModel("tInf",              "rtInf")>
      %<LibAddToCompiledModel("tInfType",          "real_T")>
      %<LibAddToCompiledModel("tMinusInf",         "rtMinusInf")>
      %<LibAddToCompiledModel("tMinusInfType",     "real_T")>
      %<LibAddToCompiledModel("tNaN",              "rtNaN")>
      %<LibAddToCompiledModel("tNaNType",          "real_T")>

      %break

    %case "RealTimeMalloc"
      %if !EXISTS("AutoBuildProcedure")
	%assign ::AutoBuildProcedure = 0
      %endif

      %assign varPrefix = PrefixModelToStructs ? "%<CompiledModel.Name>_" : ""
      %assign tdPostfix = PrefixModelToStructs ? "_%<CompiledModel.Name>" : ""

      %<LibAddToCompiledModel("AutoBuildProcedure", AutoBuildProcedure)>

      %<LibAddToCompiledModel("tBlockIO",            varPrefix+"B")>
      %<LibAddToCompiledModel("tBlockIOType",        "BlockIO"+tdPostfix)>
      %<LibAddToCompiledModel("tInput",              varPrefix+"U")>
      %<LibAddToCompiledModel("tInputType",          "ExternalInputs"+tdPostfix)>
      %assign upperSolver = FEVAL("upper", CompiledModel.Solver)
      %<LibAddToCompiledModel("upperSolver", upperSolver)>
      %assign solverOrder = IDNUM(CompiledModel.Solver)[1]
      %<LibAddToCompiledModel("solverOrder", solverOrder)>
      %<LibAddToCompiledModel("tContState",          varPrefix+"X")>
      %<LibAddToCompiledModel("tContStateType",      "ContinuousStates"+tdPostfix)>
      %<LibAddToCompiledModel("tXdot",               varPrefix+"Xdot")>
      %<LibAddToCompiledModel("tXdotType",           "StateDerivatives"+tdPostfix)>
      %<LibAddToCompiledModel("tXdis",               varPrefix+"Xdis")>
      %<LibAddToCompiledModel("tXdisType",           "StateDisabled"+tdPostfix)>
      %<LibAddToCompiledModel("tOutput",             varPrefix+"Y")>
      %<LibAddToCompiledModel("tOutputType",         "ExternalOutputs"+tdPostfix)>
      %<LibAddToCompiledModel("tParameters",         varPrefix+"P")>
      %<LibAddToCompiledModel("tDefaultParameters",  varPrefix+"DefaultParameters")>
      %<LibAddToCompiledModel("tParametersType",     "Parameters"+tdPostfix)>

      %<FcnSetupRTModelNames()>

      %<LibAddToCompiledModel("tChildSimStruct",     "s")>
      %<LibAddToCompiledModel("tDWork",              varPrefix+"DWork")>
      %<LibAddToCompiledModel("tDWorkType",          "D_Work"+tdPostfix)>

      %assign str = "rtC(%<CompiledModel.tSimStruct>)"
      %<LibAddToCompiledModel("tConstBlockIOStruct", varPrefix+str)>
      %undef str
      %<LibAddToCompiledModel("tInvariantSignals",   varPrefix+"InvariantSignals")>
      %<LibAddToCompiledModel("tConstBlockIOType",   "ConstBlockIO"+tdPostfix)>
      %<LibAddToCompiledModel("tConstBlockIODefine", varPrefix+"rtC")>
      %<LibAddToCompiledModel("tConstParamType",     "ConstParam"+tdPostfix)>
      %<LibAddToCompiledModel("tConstParamStruct",   varPrefix+"rtcP")>
      %<LibAddToCompiledModel("tConstParamWithInitType",   "ConstParamWithInit"+tdPostfix)>
      %<LibAddToCompiledModel("tConstParamWithInitStruct", varPrefix+"rtcWithInitP")>
      %<LibAddToCompiledModel("tPrevZCState",        varPrefix+"PrevZCSigState")>
      %<LibAddToCompiledModel("tPrevZCStateType",    "PrevZCSigStates"+tdPostfix)>
      %<LibAddToCompiledModel("tNonsampledZC",       varPrefix+"NonsampledZC")>
      %<LibAddToCompiledModel("tNonsampledZCType",   "NonsampledZCs"+tdPostfix)>
      %<LibAddToCompiledModel("tTID",                "tid")>
      %<LibAddToCompiledModel("tTIDType",            "int_T")>
      %<LibAddToCompiledModel("tControlPortIdx",     "controlPortIdx")>
      %<LibAddToCompiledModel("tControlPortIdxTpye", "int_T")>
      %<LibAddToCompiledModel("tInf",                "rtInf")>
      %<LibAddToCompiledModel("tInfType",            "real_T")>
      %<LibAddToCompiledModel("tMinusInf",           "rtMinusInf")>
      %<LibAddToCompiledModel("tMinusInfType",       "real_T")>
      %<LibAddToCompiledModel("tNaN",                "rtNaN")>
      %<LibAddToCompiledModel("tNaNType",            "real_T")>

      %break
  %endswitch

  %%
  %% Constant run-time parameters
  %%
  %if !EXISTS("tConstPrms")
    %assign ::tConstPrms = "rtcP"
  %endif

  %%
  %% Default logObject is the SimStruct. Is overridden in some
  %% code formats
  %%
  %if !EXISTS("logObject")
    %assign ::logObject   = tSimStruct
    %assign ::logObjectAddr = tSimStruct
  %endif

%endfunction %% SLibSetupCodeFmtRTWIdents


%% Function: SLibSetupLibSrcFcnNames ===========================================
%% Abstract:
%%   Setup LibSrc function names.
%%
%function SLibSetupLibSrcFcnNames() void
  %if !EXISTS("tRZCFcn")
    %assign ::tRZCFcn = "rt_ZCFcn"
  %endif

  %if !EXISTS("tR32ZCFcn")
    %assign ::tR32ZCFcn = "rt_ZCFcn"
  %endif

  %if !EXISTS("tI32ZCFcn")
    %assign ::tI32ZCFcn = "rt_I32ZCFcn"
  %endif

  %if !EXISTS("tI16ZCFcn")
    %assign ::tI16ZCFcn = "rt_I32ZCFcn"
  %endif

  %if !EXISTS("tI8ZCFcn")
    %assign ::tI8ZCFcn = "rt_I32ZCFcn"
  %endif

  %if !EXISTS("tU32ZCFcn")
    %assign ::tU32ZCFcn = "rt_U32ZCFcn"
  %endif

  %if !EXISTS("tU16ZCFcn")
    %assign ::tU16ZCFcn = "rt_U16ZCFcn"
  %endif

  %if !EXISTS("tU8ZCFcn")
    %assign ::tU8ZCFcn = "rt_U8ZCFcn"
  %endif

  %if !EXISTS("tBZCFcn")
    %assign ::tBZCFcn = "rt_BZCFcn"
  %endif

  %if !EXISTS("tCreateLogVar")
    %assign ::tCreateLogVar = "rt_CreateLogVar"
  %endif

  %if !EXISTS("tUpdateLogVar")
    %assign ::tUpdateLogVar = "rt_UpdateLogVar"
  %endif

  %if !EXISTS("tCreateStructLogVar")
    %assign ::tCreateStructLogVar = \
      "rt_CreateStructLogVar"
  %endif

  %if !EXISTS("tUpdateStructLogVar")
    %assign ::tUpdateStructLogVar = \
      "rt_UpdateStructLogVar"
  %endif

  %<LibAddToCompiledModel("tRZCFcn", tRZCFcn)>
  %<LibAddToCompiledModel("tR32ZCFcn", tR32ZCFcn)>
  %<LibAddToCompiledModel("tI32ZCFcn", tI32ZCFcn)>
  %<LibAddToCompiledModel("tI16ZCFcn", tI16ZCFcn)>
  %<LibAddToCompiledModel("tI8ZCFcn", tI8ZCFcn)>
  %<LibAddToCompiledModel("tU32ZCFcn", tU32ZCFcn)>
  %<LibAddToCompiledModel("tU16ZCFcn", tU16ZCFcn)>
  %<LibAddToCompiledModel("tU8ZCFcn", tU8ZCFcn)>
  %<LibAddToCompiledModel("tBZCFcn", tBZCFcn)>
  %<LibAddToCompiledModel("tCreateLogVar", tCreateLogVar)>
  %<LibAddToCompiledModel("tUpdateLogVar", tUpdateLogVar)>
  %<LibAddToCompiledModel("tCreateStructLogVar", tCreateStructLogVar)>
  %<LibAddToCompiledModel("tUpdateStructLogVar", tUpdateStructLogVar)>

%endfunction %% SLibSetupLibSrcFcnNames


%% Function: SLibCheckCompiledModel ============================================
%% Abstract:
%%   Check if the CompiledModel satisfies some important preliminary criteria:
%%    - There are no algebraic loops
%%
%function SLibCheckCompiledMdl() void
  %%
  %% Exit if there are any algebraic loops
  %%
  %if CompiledModel.NumAlgebraicLoops > 0
    %if !Accelerator
      %assign errTxt = "Real-Time Workshop does not support models with " ...
	"algebraic loops."
      %<LibReportError(errTxt)>
    %else
      %assign errTxt = "Simulink Accelerator does not currently support " ...
	"models with algebraic loops."
      %exit %<errTxt>
    %endif
  %endif
%endfunction %% SLibCheckCompiledMdl


%% Function: SLibSetupDoCodeFmtChecks ==========================================
%% Abstract:
%%   Do checks that pertain to specific code formats
%%
%function SLibSetupDoCodeFmtChecks() void
  %%
  %% S-Function wrapper for ERT-C-Code
  %%
  %if !EXISTS("GenerateErtSFunction")
    %assign ::GenerateErtSFunction = 0
  %endif
  %if GenerateErtSFunction == 1
    %if CodeFormat != "Embedded-C"
      %assign errTxt = "The Embedded-C S-Function wrapper is only supported " ...
	"for the Embedded-C code format. Change the system target file to " ...
	"ert.tlc."
      %<LibReportError(errTxt)>
    %elseif LibIsContinuous(0)
      %assign errTxt = "The Embedded-C S-Function wrapper is not supported " ...
	"for models with a continuous sample time."
      %<LibReportError(errTxt)>
    %endif
  %endif
  %<LibAddToCompiledModel("GenerateErtSFunction", GenerateErtSFunction)>

  %<LibAddToCompiledModel("EmptyRealTimeObject", 0)>

  %%
  %% Flag to determine if purely integer code is to be generated.
  %% This flag will be set to 1 if INTEGER_CODE=1 is specified on the make_rtw
  %% command line.
  %% NOTE: This flag is only supported for the Embedded-C code format.
  %%
  %if PurelyIntegerCode == 1 && CodeFormat != "Embedded-C"
    %assign errTxt = "Purely integer code is only supported for the " ...
      "Embedded-C code format.  Change the system target file to ert.tlc."
    %<LibReportError(errTxt)>
  %endif

  %if (CodeFormat == "Embedded-C") && SLibNeedAbsoluteTime() && PurelyIntegerCode && !MatFileLogging
      %assign warnTxt = "Absolute time is being set up as an integer that " ...
	"increments once per model step."
      %<LibReportWarning(warnTxt)>
  %endif

  %%
  %% Flag to indicate the model.rtw has been created with root Inports
  %% non-contiguous.  This is required for the S-Function code format.
  %%
  %if CodeFormat == "S-Function" && !Accelerator
    %assign InvalidSTF = 1
    %if EXISTS("CompiledModel.RTWGenSettings.IsRTWSfcn")
      %if CompiledModel.RTWGenSettings.IsRTWSfcn == "yes"
	%assign InvalidSTF = 0
      %endif
    %endif
    %if InvalidSTF == 1
      %assign errTxt = "The S-Function code format requires that the system" ...
	" target file specify the IsRTWSfcn option in the rtwGenSettings " ...
	"structure.  See the file ""rtwsfcn.tlc"" as an example of how to " ...
	"specify this option."
      %<LibReportError(errTxt)>
    %endif
  %endif
%endfunction %% SLibSetupDoCodeFmtChecks


%% Function: SLibSetupAdaCGTrackingFields ======================================
%% Abstract:
%%   Setup variables that track Ada code generation.
%%
%function SLibSetupAdaCGTrackingFields() void
  %%
  %% With RT_Lookup
  %%
  %if !EXISTS("WithRTlook")
    %assign ::WithRTlook = 0
  %endif
  %<LibAddToCompiledModel("WithRTlook", WithRTlook)>

  %%
  %% With RT_Lookup2D
  %%
  %if !EXISTS("WithRTlook2D")
    %assign ::WithRTlook2D = 0
  %endif
  %<LibAddToCompiledModel("WithRTlook2D", WithRTlook2D)>

  %%
  %% With RT_LookupND
  %%
  %if !EXISTS("WithRTLookupND")
    %assign ::WithRTLookupND = 0
  %endif
  %<LibAddToCompiledModel("WithRTLookupND", WithRTLookupND)>

  %%
  %% With RT_LookupND32
  %%
  %if !EXISTS("WithRTLookupND32")
    %assign ::WithRTLookupND32 = 0
  %endif
  %<LibAddToCompiledModel("WithRTLookupND32", WithRTLookupND32)>

  %%
  %% With RT_SplineND
  %%
  %if !EXISTS("WithRTSplineND")
    %assign ::WithRTSplineND = 0
  %endif
  %<LibAddToCompiledModel("WithRTSplineND", WithRTSplineND)>

  %%
  %% With RT_SplineND32
  %%
  %if !EXISTS("WithRTSplineND32")
    %assign ::WithRTSplineND32 = 0
  %endif
  %<LibAddToCompiledModel("WithRTSplineND32", WithRTSplineND32)>

  %%
  %% With RT_Rand
  %%
  %if !EXISTS("WithRTrand")
    %assign ::WithRTrand = 0
  %endif
  %<LibAddToCompiledModel("WithRTrand", WithRTrand)>

  %%
  %% Flag to include integer multiply and divide saturation routines.
  %%
  %if !EXISTS("WithRTsat")
    %assign ::WithRTsat = 0
  %endif
  %<LibAddToCompiledModel("WithRTsat", WithRTsat)>

  %%
  %% With RT_Matrix
  %%
  %if !EXISTS("WithRTmat")
    %assign ::WithRTmat = 0
  %endif
  %<LibAddToCompiledModel("WithRTmat", WithRTmat)>

  %%
  %% With Cstreams
  %%
  %if !EXISTS("WithCstreams")
    %assign ::WithCstreams = 0
  %endif
  %<LibAddToCompiledModel("WithCstreams", WithCstreams)>

  %%
  %% Flag to include declaration of constants for pi, e, ln(10), log10(e)
  %%
  %if !EXISTS("MathConstantDefines")
    %assign Pi = PiRec { Required 0 }
    %assign E = ERec { Required 0 }
    %assign LN10   = LN10Rec { Required 0 }
    %assign LOG10E = LOG10E { Required 0 }
    %assign MathConstantDefines = MathConstantDefinesRec { Stub 0 }
    %assign MathConstantDefines = MathConstantDefines + Pi
    %assign MathConstantDefines = MathConstantDefines + E
    %assign MathConstantDefines = MathConstantDefines + LN10
    %assign MathConstantDefines = MathConstantDefines + LOG10E
  %endif
  %assign ::MathConstantDefines = MathConstantDefines
  %<LibAddToCompiledModel("MathConstantDefines", MathConstantDefines)>

%endfunction %% SLibSetupAdaCGTrackingFields


%% Function: SLibSetupBIOAPI ===================================================
%% Abstract:
%%   Setup Block IO Signals C API for monitoring signals in a running model
%%
%function SLibSetupBIOAPI() void
  %if !EXISTS("BlockIOSignals")
    %assign ::BlockIOSignals = 0
  %endif
  %if BlockIOSignals == 1 && IsModelReferenceTarget()
    %assign errTxt = "Model reference does not support the old version " ...
    "of C API for signal monitoring.  Please see RTW user's guide " ...
    "for generating C API. "
    %<LibReportError(errTxt)>
  %endif
  %if (RTWCAPI) && BlockIOSignals == 1
    %assign errTxt = "Real-Time Workshop does not support generating both " ...
    "versions of C API for Signal monitoring. Please see RTW user's guide " ...
      "for generating C API. "
    %<LibReportError(errTxt)>
  %endif
  %if BlockIOSignals == 1
    %assign ::CompiledModel.HaveSeparateSourceFiles = 1
  %endif
  %if UsingMalloc == 1 && BlockIOSignals == 1
    %assign errTxt = "Real-Time Workshop does not support both the C API " ...
      "for BlockIOSignals monitoring and a dynamic memory allocation code " ...
      "format being used at the same time."
    %<LibReportError(errTxt)>
  %endif
  %if !EXISTS("xPC")
    %assign ::xPC = 0
  %endif
  %if !xPC==1
    %if ExtMode == 1 && BlockIOSignals == 1
      %assign errTxt = "Real-Time Workshop does not support both External " ...
	"Mode and the C API for BlockIOSignals being used at the same time."
      %<LibReportError(errTxt)>
    %endif
  %endif
  %assign ::tBlockIOSignals     = "rtBIOSignals"
  %assign ::tBlockIOSignalsType = "BlockIOSignals"
  %<LibAddToCompiledModel("BlockIOSignals", BlockIOSignals)>
  %if BlockIOSignals == 1
    %assign ::CompiledModel.GenerateInterfaceAPI = 1
    %assign ::CompiledModel.MapBlockOutputs = 1
  %endif
%endfunction %% SLibSetupBIOAPI


%% Function: SLibSetupPrmAPI ==================================================
%% Abstract:
%%   Parameter Tuning C API for changing parameter values in a running model
%%
%function SLibSetupPrmAPI() void
  %if !EXISTS("ParameterTuning")
    %assign ::ParameterTuning = 0
  %endif
  %if ParameterTuning == 1 && IsModelReferenceTarget()
    %assign errTxt =  "Model reference does not support the old version " ...
      "of C API for parameter tuning.  Please see RTW user's guide " ...
      "for generating C API. "
    %<LibReportError(errTxt)>
  %endif
  %if(RTWCAPI) && ParameterTuning == 1
    %assign errTxt = "Real-Time Workshop does not support generating both " ...
   "model_capi.c and model_pt.c (old API). The old API will be obsoleted. " ...
      "Please see RTW user's guide for generating C API. "
    %<LibReportError(errTxt)>
  %endif
  %if ParameterTuning == 1
    %assign ::CompiledModel.HaveSeparateSourceFiles = 1
  %endif
  %if (ParameterTuning == 1) && (CodeFormat == "S-Function")
    %assign errTxt = "The S-function code format and Accelerator do not " ...
      "support the C API for Parameter Tuning (-aParameterTuning=1)."
    %<LibReportError(errTxt)>
  %endif
  %if !xPC==1
    %if ExtMode == 1 && ParameterTuning == 1
      %assign errTxt = "Real-Time Workshop does not support both External " ...
	"Mode and the C API for Parameter Tuning being used at the same time."
      %<LibReportError(errTxt)>
    %endif
  %endif
  %assign ::tBlockTuning        = "rtBlockTuning"
  %assign ::tBlockTuningType    = "BlockTuning"
  %assign ::tVariableTuning     = "rtVariableTuning"
  %assign ::tVariableTuningType = "VariableTuning"
  %assign ::tParametersMapType  = "void *"
  %assign ::tParametersMap      = "rtParametersMap"
  %assign ::tDimensionsMapType  = "uint_T"
  %assign ::tDimensionsMap      = "rtDimensionsMap"
  %<LibAddToCompiledModel("ParameterTuning", ParameterTuning)>
  %if ParameterTuning == 1
    %assign ::CompiledModel.GenerateInterfaceAPI = 1
    %assign ::CompiledModel.MapParameters        = 1
    %assign ::CompiledModel.MapStateflow         = 1
  %endif
%endfunction %% SLibSetupPrmAPI

%% Function: SLibSetupCAPI ====================================================
%% Abstract:
%%   Setup C API for monitoring signals and tuning parameter in a running model
%%
%%
%function SLibSetupCAPI() void
  %if !EXISTS("RTWCAPITestPtSignals")
    %assign ::RTWCAPITestPtSignals = 0
  %endif
  %if !EXISTS("RTWCAPISignals")
    %assign ::RTWCAPISignals     = 0
  %endif
  %if IsModelReferenceSimTarget()
    %assert (::RTWCAPISignals)
    %% We do not need all global signals. We only need
    %% test pointed signals
    %assign ::RTWCAPITestPtSignals = 1
  %endif
  %if !EXISTS("RTWCAPIParams")
      %assign ::RTWCAPIParams    = 0
  %endif
  %if !EXISTS("RTWCAPIStates")
    %if ISFIELD(::CompiledModel.ConfigSet, "RTWCAPIStates")
      %assign ::RTWCAPIStates    = ::CompiledModel.ConfigSet.RTWCAPIStates
    %else
      %assign ::RTWCAPIStates    = 0
    %endif
  %endif
  %% Add logic for turning on RTWCAPI States here
  %if !EXISTS("MatFileLogging")
    %assign ::MatFileLogging = 0 
    %% Above line needs to replaced with below line with Matt's change
    %% %assign ::MatFileLogging = ::CompiledModel.ConfigSet.MatFileLogging
  %endif
  %% Turn on RTWCAPIStates if we need to, i.e. if
  %%  (1) there are model blocks
  %%  (2) state logging is on
  %%  (3) MatFileLogging is on
  %%  (4) the old api is not specified
  %if !IsModelReferenceTarget() && HasModelReferenceBlocks()
    %assign dlo = CompiledModel.DataLoggingOpts
    %if ((dlo.StateSaveName != "" || dlo.FinalStateName != "") && ...
      (MatFileLogging == 1))
      %if EXISTS("BlockIOSignals") || EXISTS("ParameterTuning")
	%assign warnTxt = "States cannot be logged for this model because of "...
	  "the specification of either -aBlockIOSignals or -aParameterTuning in "...
	  "the TLC options. Please remove this specification in order to log states"
	%<LibReportWarning(warnTxt)>
      %else
	%assign ::RTWCAPIStates = 1
      %endif
    %endif
  %endif
  
  %assign ::RTWCAPI = ::RTWCAPISignals || ::RTWCAPIParams || ::RTWCAPIStates
  %if RTWCAPI
    %assign ::CompiledModel.HaveSeparateSourceFiles = 1
  %endif
  %if (RTWCAPIParams) && (CodeFormat == "S-Function")
    %assign errTxt = "The S-function code format and Accelerator do not " ...
      "support the C API"
    %<LibReportError(errTxt)>
  %endif
  %if PurelyIntegerCode && RTWCAPI
    %assign errTxt = "The C-API relies on floating point support to " ...
      "represent fixed-point scaling information.  Therefore, pure " ...
      "integer code cannot be generated when the C-API option is selected." ...
      " Consider selecting floating-point support when using the C-API."
    %<LibReportError(errTxt)>
  %endif
  %if !EXISTS("xPC")
    %assign ::xPC = 0
  %endif
  %if !xPC==1
    %if ExtMode == 1 && RTWCAPI
      %assign errTxt = "Real-Time Workshop does not support both External " ...
	"Mode and the RTW C API at the same time."
      %<LibReportError(errTxt)>
    %endif
  %endif
  %assign ::tBlockSignals       = "rtBlockSignals"
  %assign ::tBlockSignalsType   = "rtwCAPI_Signals"
  %assign ::tBlockStates        = "rtBlockStates"
  %assign ::tBlockStatesType    = "rtwCAPI_States"
  %assign ::tBlockParams        = "rtBlockParameters"
  %assign ::tBlockParamsType    = "rtwCAPI_BlockParameters"
  %assign ::tModelParams        = "rtModelParameters"
  %assign ::tModelParamsType    = "rtwCAPI_ModelParameters"
  %assign ::tDataAddrType       = "void* "
  %assign ::tDataAddrMap        = "rtDataAddrMap"
  %assign ::tDataTypeMapType    = "rtwCAPI_DataTypeMap"
  %assign ::tDataTypeMap        = "rtDataTypeMap"
  %assign ::tDimensionMapType   = "rtwCAPI_DimensionMap"
  %assign ::tDimensionMap       = "rtDimensionMap"
  %assign ::tDimensionArrayType = "uint_T"
  %assign ::tDimensionArray     = "rtDimensionArray"
  %assign ::tFixPtMapType       = "rtwCAPI_FixPtMap"
  %assign ::tFixPtMap           = "rtFixPtMap"
  %assign ::tElementMapType     = "rtwCAPI_ElementMap"
  %assign ::tElementMap         = "rtElementMap"
  %assign ::tSampleTimeMapType  = "rtwCAPI_SampleTimeMap"
  %assign ::tSampleTimeMap      = "rtSampleTimeMap"
  %<LibAddToCompiledModel("RTWCAPI", RTWCAPI)>
  %<LibAddToCompiledModel("RTWCAPISignals", RTWCAPISignals)>
  %<LibAddToCompiledModel("RTWCAPIParams", RTWCAPIParams)>
  %<LibAddToCompiledModel("RTWCAPITestPtSignals", RTWCAPITestPtSignals)>
  %<LibAddToCompiledModel("RTWCAPIStates", RTWCAPIStates)>
  %if RTWCAPI
    %assign ::CompiledModel.GenerateInterfaceAPI = 1
  %endif
  %if RTWCAPISignals
    %assign ::CompiledModel.MapBlockOutputs = 1
  %endif
  %if RTWCAPIParams
    %assign ::CompiledModel.MapParameters        = 1
    %assign ::CompiledModel.MapStateflow         = 1
  %endif
  %if RTWCAPIStates
    %assign ::CompiledModel.MapDWork = 1
    %assign ::CompiledModel.MapContStates = 1
  %endif
%endfunction %% SLibSetupCAPI

%% Function: SLibSetupAndCheckCustomSC =========================================
%% Abstract:
%%   Setup custom storage classes.
%%
%function SLibSetupAndCheckCustomSC() void
  %with CompiledModel
    %if CustomStorageClasses.NumCustomStorageClasses > 0
      %% Setup custom storage classes if we have any
      %<SLibSetupCustomStorageClasses()>
    %endif
  %endwith
%endfunction %% SLibSetupAndCheckCustomSC


%% Function: FcnCacheRootBodyMthNames ==========================================
%% Abstract:
%%   Cache method names for the root system based on code format
%%
%function FcnCacheRootBodyMthNames(rootSys,useCaps,useMdlName,reqMethods) void
  %assign mPrefix = useCaps ? "M" : "m"

  %if !EXISTS(rootSys.OutputFcn) && reqMethods.OutputFcn
    %if useMdlName
      %addtorecord rootSys OutputFcn "%<Name>_output"
    %else
      %addtorecord rootSys OutputFcn "%<mPrefix>dlOutputs"
    %endif
  %endif

  %if !EXISTS(rootSys.UpdateFcn) && reqMethods.UpdateFcn
    %if useMdlName
      %addtorecord rootSys UpdateFcn "%<Name>_update"
    %else
      %addtorecord rootSys UpdateFcn "%<mPrefix>dlUpdate"
    %endif
  %endif

  %if !EXISTS(rootSys.DerivativeFcn) && reqMethods.DerivativeFcn
    %if useMdlName
      %addtorecord rootSys DerivativeFcn "%<Name>_derivatives"
    %else
      %addtorecord rootSys DerivativeFcn "%<mPrefix>dlDerivatives"
    %endif
  %endif

  %if !EXISTS(rootSys.ProjectionFcn) && reqMethods.ProjectionFcn
    %if useMdlName
      %addtorecord rootSys ProjectionFcn "%<Name>_projection"
    %else
      %addtorecord rootSys ProjectionFcn "%<mPrefix>dlProjection"
    %endif
  %endif

  %if !EXISTS(rootSys.InitializeFcn) && reqMethods.InitializeFcn
    %if useMdlName
      %addtorecord rootSys InitializeFcn "%<Name>_initialize"
    %else
      %if CodeFormat == "S-Function"
	%addtorecord rootSys InitializeFcn "%<mPrefix>dlInitializeConditions"
      %else
	%addtorecord rootSys InitializeFcn "%<mPrefix>dlInitialize"
      %endif
    %endif
  %endif

  %if !EXISTS(rootSys.EnableFcn) && reqMethods.EnableFcn
    %if useMdlName
      %addtorecord rootSys EnableFcn "%<Name>_enable"
    %else
      %addtorecord rootSys EnableFcn "%<mPrefix>dlEnable"
    %endif
  %endif

  %if !EXISTS(rootSys.DisableFcn) && reqMethods.DisableFcn
    %if useMdlName
      %addtorecord rootSys DisableFcn "%<Name>_disable"
    %else
      %addtorecord rootSys DisableFcn "%<mPrefix>dlDisable"
    %endif
  %endif

  %if !EXISTS(rootSys.ZeroCrossingFcn) && reqMethods.ZeroCrossingFcn
    %if useMdlName
      %addtorecord rootSys ZeroCrossingFcn "%<Name>_zeroCrossings"
    %else
      %addtorecord rootSys ZeroCrossingFcn "%<mPrefix>dlZeroCrossings"
    %endif
  %endif

  %if !EXISTS(rootSys.StartFcn) && reqMethods.StartFcn
    %if useMdlName
      %addtorecord rootSys StartFcn "%<Name>_start"
    %else
      %addtorecord rootSys StartFcn "%<mPrefix>dlStart"
    %endif
  %endif

  %if !EXISTS(rootSys.TerminateFcn) && reqMethods.TerminateFcn
    %if useMdlName
      %addtorecord rootSys TerminateFcn "%<Name>_terminate"
    %else
      %addtorecord rootSys TerminateFcn "%<mPrefix>dlTerminate"
    %endif
  %endif
%endfunction %% FcnCacheRootBodyMthNames


%% Function: FcnSetupRootBodyReqMths ==========================================
%% Abstract:
%%   Cache the root methods that are required by each code format
%%
%function FcnSetupRootBodyReqMths() void
  %%
  %% Initialize the record to have no methods
  %%
  %createrecord reqBodyMethods \
     {\
        EnableFcn       TLC_FALSE;\
        DisableFcn      TLC_FALSE;\
	InitializeFcn   TLC_FALSE;\
	StartFcn        TLC_FALSE;\
	OutputFcn       TLC_FALSE;\
	UpdateFcn       TLC_FALSE;\
	OutputUpdateFcn TLC_FALSE;\
	DerivativeFcn   TLC_FALSE;\
	ProjectionFcn   TLC_FALSE;\
	TerminateFcn    TLC_FALSE;\
	ZeroCrossingFcn TLC_FALSE\
      }

  %switch CodeFormat
    %case "RealTime"
    %case "RealTimeMalloc"
      %assign reqBodyMethods.StartFcn        = TLC_TRUE
      %assign reqBodyMethods.InitializeFcn   = TLC_TRUE
      %assign reqBodyMethods.EnableFcn       = TLC_TRUE
      %assign reqBodyMethods.OutputFcn       = TLC_TRUE
      %assign reqBodyMethods.UpdateFcn       = TLC_TRUE
      %assign reqBodyMethods.DerivativeFcn   = TLC_TRUE
      %assign reqBodyMethods.ProjectionFcn   = TLC_TRUE
      %assign reqBodyMethods.TerminateFcn    = TLC_TRUE
      %if EXISTS("_RSIM_FULL_") %% ModelReference is ok. Embedded-C supports all
	%assign reqBodyMethods.ZeroCrossingFcn = TLC_TRUE
      %endif
      %break
    %case "S-Function"
      %if Accelerator
	%assign reqBodyMethods.OutputFcn       = TLC_TRUE
	%assign reqBodyMethods.UpdateFcn       = TLC_TRUE
	%assign reqBodyMethods.DerivativeFcn   = TLC_TRUE
	%assign reqBodyMethods.ProjectionFcn   = TLC_TRUE
	%assign reqBodyMethods.ZeroCrossingFcn = TLC_TRUE
	%assign reqBodyMethods.TerminateFcn    = TLC_TRUE
      %else
	%assign reqBodyMethods.StartFcn        = TLC_TRUE
	%assign reqBodyMethods.InitializeFcn   = TLC_TRUE
	%assign reqBodyMethods.EnableFcn       = TLC_TRUE
	%assign reqBodyMethods.DisableFcn      = TLC_TRUE
	%assign reqBodyMethods.OutputFcn       = TLC_TRUE
	%assign reqBodyMethods.UpdateFcn       = TLC_TRUE
	%assign reqBodyMethods.DerivativeFcn   = TLC_TRUE
	%assign reqBodyMethods.ProjectionFcn   = TLC_TRUE
	%assign reqBodyMethods.ZeroCrossingFcn = TLC_TRUE
	%assign reqBodyMethods.TerminateFcn    = TLC_TRUE
      %endif
      %break
    %case "Embedded-C"
    %case "Ada"
      %assign reqBodyMethods.StartFcn        = TLC_TRUE
      %assign reqBodyMethods.InitializeFcn   = TLC_TRUE
      %assign reqBodyMethods.EnableFcn       = TLC_TRUE
      %assign reqBodyMethods.OutputFcn       = TLC_TRUE
      %assign reqBodyMethods.UpdateFcn       = TLC_TRUE
      %assign reqBodyMethods.DerivativeFcn   = TLC_TRUE
      %assign reqBodyMethods.ProjectionFcn   = TLC_TRUE
      %assign reqBodyMethods.ZeroCrossingFcn = TLC_TRUE
      %assign reqBodyMethods.TerminateFcn    = TLC_TRUE
      %break
    %default
      %break
  %endswitch

  %return reqBodyMethods

%endfunction %% FcnSetupRootBodyReqMths


%% Function: FcnSetupRootPrmHdrReqInstances ====================================
%% Abstract:
%%   Setup the required root parameter data instance vectors for the various
%%   code formats
%%
%function FcnSetupRootPrmHdrReqInstances(rootSys) void

  %<LibAddToCompiledModel("XQualifier",     IOQualifier)>
  %<LibAddToCompiledModel("UQualifier",     IOQualifier)>
  %<LibAddToCompiledModel("YQualifier",     IOQualifier)>
  %<LibAddToCompiledModel("PQualifier",     IOQualifier)>
  %<LibAddToCompiledModel("BQualifier",     IOQualifier)>
  %<LibAddToCompiledModel("DWorkQualifier", IOQualifier)>
  %<LibAddToCompiledModel("PrevZCQualifier",IOQualifier)>
  %<LibAddToCompiledModel("ConstBQualifier",IOQualifier)>
  %<LibAddToCompiledModel("ConstPQualifier",".")>

  %%
  %% Initialize the record to have no instances
  %%

  %createrecord reqPrmHdrInsts \
     {\
        GroupedCustomDataInst  TLC_FALSE;\
	ParamsInst             TLC_FALSE;\
	ConstBlockIOInst       TLC_FALSE;\
	ConstParamInst         TLC_FALSE;\
	ExpGlobalSigsInst      TLC_FALSE;\
	ExpGlobalPrmsInst      TLC_FALSE;\
	BlockIOInst            TLC_FALSE;\
	ExpGlobalDworkInst     TLC_FALSE;\
	ContStatesInst         TLC_FALSE;\
	DworkInst              TLC_FALSE;\
	PrevZCStatesInst       TLC_FALSE;\
	ExtInpsInst            TLC_FALSE;\
	ExtOutputsInst         TLC_FALSE;\
	SimStructInst          TLC_FALSE;\
	GlobalPrmDataCacheInst TLC_FALSE\
      }

  %switch CodeFormat
    %case "RealTime"
      %assign reqPrmHdrInsts.GroupedCustomDataInst  = TLC_TRUE
      %assign reqPrmHdrInsts.ParamsInst             = TLC_TRUE
      %assign reqPrmHdrInsts.ConstBlockIOInst       = TLC_TRUE
      %assign reqPrmHdrInsts.ConstParamInst         = TLC_TRUE
      %assign reqPrmHdrInsts.ExpGlobalSigsInst      = TLC_TRUE
      %assign reqPrmHdrInsts.ExpGlobalPrmsInst      = TLC_TRUE
      %assign reqPrmHdrInsts.BlockIOInst            = TLC_TRUE
      %assign reqPrmHdrInsts.ExpGlobalDworkInst     = TLC_TRUE
      %assign reqPrmHdrInsts.ContStatesInst         = TLC_TRUE
      %assign reqPrmHdrInsts.DworkInst              = TLC_TRUE
      %assign reqPrmHdrInsts.PrevZCStatesInst       = TLC_TRUE
      %assign reqPrmHdrInsts.ExtInpsInst            = TLC_TRUE
      %assign reqPrmHdrInsts.ExtOutputsInst         = TLC_TRUE
      %assign reqPrmHdrInsts.SimStructInst          = TLC_TRUE
      %assign reqPrmHdrInsts.GlobalPrmDataCacheInst = TLC_TRUE

      %break
    %case "RealTimeMalloc"
      %assign reqPrmHdrInsts.GroupedCustomDataInst = TLC_TRUE
      %assign reqPrmHdrInsts.ParamsInst            = TLC_TRUE
      %assign reqPrmHdrInsts.ConstBlockIOInst      = TLC_TRUE
      %assign reqPrmHdrInsts.ConstParamInst        = TLC_TRUE
      %assign reqPrmHdrInsts.ExpGlobalSigsInst     = TLC_TRUE
      %assign reqPrmHdrInsts.ExpGlobalPrmsInst     = TLC_TRUE
      %assign reqPrmHdrInsts.ExpGlobalDworkInst    = TLC_TRUE
      %break
    %case "S-Function"
      %if Accelerator
	%assign reqPrmHdrInsts.ParamsInst             = TLC_TRUE
	%assign reqPrmHdrInsts.ConstBlockIOInst       = TLC_TRUE
	%assign reqPrmHdrInsts.ConstParamInst         = TLC_TRUE
	%assign reqPrmHdrInsts.GlobalPrmDataCacheInst = TLC_TRUE
      %else
	%assign reqPrmHdrInsts.ParamsInst         = TLC_TRUE
	%assign reqPrmHdrInsts.ConstBlockIOInst   = TLC_TRUE
	%assign reqPrmHdrInsts.ConstParamInst     = TLC_TRUE
	%assign reqPrmHdrInsts.ExpGlobalSigsInst  = TLC_TRUE
	%assign reqPrmHdrInsts.ExpGlobalPrmsInst  = TLC_TRUE
      %endif
      %break
    %case "Embedded-C"
      %assign mdlRef = IsModelReferenceTarget()
      %assign multiOrMdlref = MultiInstanceERTCode || mdlRef

      %% In what cases do we generate instantiation code for unstructured
      %% global data as part of the body of the generated code?
      %%
      %% ---------------------------------------------------------------
      %%                  MdlRef               |       Not MdlRef
      %% ---------------------------------------------------------------
      %%   SIM  | RTW (SimStructBased) |  RTW  | SimStructBased | Other
      %% ---------------------------------------------------------------
      %%  No(1) |         No(2)        | No(2) |        Y       |   Y
      %%
      %% NOTE:
      %% (1) Global data instances generated in model reference S-Fcn
      %% (2) Global data instances generated by top model.
      %assign genUnstrParamInsts = !mdlRef

      %assign reqPrmHdrInsts.GroupedCustomDataInst  = TLC_TRUE
      %assign reqPrmHdrInsts.ExpGlobalSigsInst      = TLC_TRUE
      %assign reqPrmHdrInsts.ExpGlobalPrmsInst      = genUnstrParamInsts
      %assign reqPrmHdrInsts.ExpGlobalDworkInst     = TLC_TRUE

      %assign reqPrmHdrInsts.DworkInst              = !multiOrMdlref
      %assign reqPrmHdrInsts.PrevZCStatesInst       = !multiOrMdlref
      %assign reqPrmHdrInsts.ContStatesInst         = !multiOrMdlref
      %assign reqPrmHdrInsts.BlockIOInst            = !multiOrMdlref
      %assign reqPrmHdrInsts.ExtInpsInst            = !multiOrMdlref
      %assign reqPrmHdrInsts.ExtOutputsInst         = !multiOrMdlref
      %assign reqPrmHdrInsts.SimStructInst          = !multiOrMdlref

      %assign reqPrmHdrInsts.ConstBlockIOInst       = TLC_TRUE
      %assign reqPrmHdrInsts.ConstParamInst         = TLC_TRUE

      %% In what cases do we generate instantiation code for
      %% SimulinkGlobal parameters?
      %%
      %%     =====================================
      %%      MultiInstance? ||    Y    |    N
      %%     =====================================
      %%        Structured   ||   No    |   Yes
      %%     -------------------------------------
      %%       Unstructured  || (above) | (above)
      %%     =====================================
      %%
      %% NOTE: SimulinkGlobal parameters are generated as unstructured variables
      %%       (treated like ExportedGlobal) when generating code for a model
      %%       that is or contains a model reference.
      %%
      %if SLibAreSimulinkGlobalParamsUnstructured()
	%assign reqPrmHdrInsts.ParamsInst = genUnstrParamInsts
      %else
	%assign reqPrmHdrInsts.ParamsInst = !MultiInstanceERTCode
      %endif

      %assign reqPrmHdrInsts.GlobalPrmDataCacheInst = TLC_TRUE

      %if MultiInstanceERTCode
	%assign ::CompiledModel.BQualifier      = "->"
	%assign ::CompiledModel.PQualifier      = "->"
	%assign ::CompiledModel.DWorkQualifier  = "->"
	%assign ::CompiledModel.XQualifier      = "->"
	%assign ::CompiledModel.PrevZCQualifier = "->"
	%if RootIOStructures
	  %assign ::CompiledModel.UQualifier      = "->"
	  %assign ::CompiledModel.YQualifier      = "->"
	%else
	  %assign ::CompiledModel.UQualifier      = "_"
	  %assign ::CompiledModel.YQualifier      = "_"
	%endif
      %endif
      %break
    %default
      %break
  %endswitch

  %<LibAddToSystem(rootSys, "ReqRootPrmHdrDataInsts", reqPrmHdrInsts)>

%endfunction %% FcnSetupRootPrmHdrReqInstances


%% Function: SLibRootSystemMethodProps =========================================
%% Abstract:
%%   Setup properties of the methods corresponding to the Root system
%%
%function SLibRootSystemMethodProps() void
  %with CompiledModel
    %assign rootIdx    = NumSystems-1
    %assign rootSystem = System[rootIdx]

    %%
    %% Setup root body and header method property defaults
    %%

    %% Do we need "static" prefix for root body methods?
    %assign rootBodyMthsStatic         = TLC_FALSE %% assume
    %% Do we capitalize the start of root body methods names?
    %assign rootBodyMthsCaps           = TLC_FALSE %% assume
    %% Do we use the name of the model in the root methods names (ERT)?
    %assign rootBodyMthUseMdlName      = TLC_FALSE %% assume
    %% Do we call mdlInitialize and mdlEnable in mdlStart?
    %assign rootBodyStartCallsInitEnab = TLC_FALSE %% assume
    %% Do we need tid for the root body output, update methods?
    %assign rootBodyTIDneeded          = TLC_FALSE %% assume
    %% Do we need verbose comments in model header?
    %assign rootHdrVerboseCmnts        = TLC_TRUE  %% assume
    %% Do we need generic defines to be made in the header?
    %assign rootHdrGenericDefines      = TLC_FALSE %% assume
    %% Do we need to declare prm instances to be static?
    %assign rootPrmHdrInstsStatic      = TLC_FALSE %% assume

    %%
    %% Setup root body and header method properties based on code format
    %%
    %switch CodeFormat
      %case "RealTime"
	%assign rootBodyMthsCaps           = TLC_TRUE
	%assign rootBodyStartCallsInitEnab = TLC_TRUE
	%assign rootBodyTIDneeded          = TLC_TRUE
	%assign rootHdrGenericDefines      = TLC_TRUE
	%break
      %case "RealTimeMalloc"
	%assign rootBodyMthsStatic         = TLC_TRUE
	%assign rootBodyMthsCaps           = TLC_TRUE
	%assign rootBodyStartCallsInitEnab = TLC_TRUE
	%assign rootBodyTIDneeded          = TLC_TRUE
	%assign rootHdrGenericDefines      = TLC_TRUE
	%assign rootPrmHdrInstsStatic      = TLC_TRUE
	%break
      %case "Embedded-C"
	%assign rootBodyMthUseMdlName = TLC_TRUE
	%break
      %case "S-Function"
	%assign rootBodyMthsStatic      = TLC_TRUE
	%assign rootBodyTIDneeded       = TLC_TRUE
	%if Accelerator
	  %assign rootHdrVerboseCmnts = TLC_FALSE
	%endif
	%break
      %case "Ada"
      %default
	%break
    %endswitch

    %%
    %% Cache into global variables
    %%
    %assign ::RootBodyMthsStatic         = rootBodyMthsStatic
    %assign ::RootBodyStartCallsInitEnab = rootBodyStartCallsInitEnab
    %assign ::RootBodyTIDneeded          = rootBodyTIDneeded
    %assign ::RootHdrVerboseCmnts        = rootHdrVerboseCmnts
    %assign ::RootHdrGenericDefines      = rootHdrGenericDefines
    %assign ::RootPrmHdrInstsStatic      = rootPrmHdrInstsStatic

    %with CompiledModel
      %assign rootIdx    = NumSystems-1
      %assign rootSystem = System[rootIdx]

      %%
      %% Setup which methods are to be generated in the body file
      %% for each code format
      %%
      %assign reqMethods = FcnSetupRootBodyReqMths()

      %%
      %% Setup the names of the root methods
      %%
      %<FcnCacheRootBodyMthNames(rootSystem, rootBodyMthsCaps, ...
	rootBodyMthUseMdlName, reqMethods)>

      %%
      %% Setup which data vector instances are setup in
      %% the parameters section of model.c for the various code formats
      %%
      %<FcnSetupRootPrmHdrReqInstances(rootSystem)>

    %endwith

  %endwith
%endfunction %% SLibRootSystemMethodProps

%% Function: SLibSetupTLCvtable ============================================
%% Abstract:
%%   Setup TLC replacement v-table with defaults
%%
%function SLibSetupTLCvtable() void
  %with CompiledModel
  %%fixed-point Outputs function of Product block:
  %if !EXISTS(productOutputsFixptType)
    %assign productOutputsFixptType = "Product"
    %<LibAddToCompiledModel("productOutputsFixptType",productOutputsFixptType)>
  %endif

  %if !EXISTS(productOutputsFixptFunc)
    %assign productOutputsFixptFunc = "OutputsFixpt"
    %<LibAddToCompiledModel("productOutputsFixptFunc",productOutputsFixptFunc)>
  %endif

  %%fixed-point Outputs function of Sum block:
  %if !EXISTS(sumOutputsFixptType)
    %assign sumOutputsFixptType = "Sum"
    %<LibAddToCompiledModel("sumOutputsFixptType",sumOutputsFixptType)>
  %endif

  %if !EXISTS(sumOutputsFixptFunc)
    %assign sumOutputsFixptFunc = "OutputsFixpt"
    %<LibAddToCompiledModel("sumOutputsFixptFunc",sumOutputsFixptFunc)>
  %endif

  %%fixed-point Outputs function of Gain block:
  %if !EXISTS(gainOutputsFixptType)
    %assign gainOutputsFixptType = "Gain"
    %<LibAddToCompiledModel("gainOutputsFixptType",gainOutputsFixptType)>
  %endif

  %if !EXISTS(gainOutputsFixptFunc)
    %assign gainOutputsFixptFunc = "FixptOutputs"
    %<LibAddToCompiledModel("gainOutputsFixptFunc",gainOutputsFixptFunc)>
  %endif
  %endwith
%endfunction %% SLibSetupTLCvtable

%function SLibSetupCustomCode() void
  %with ConfigSet
    %if EXISTS("CustomSourceCode")
      %<LibSourceFileCustomCode(CustomSourceCode, "header")>
    %endif

    %if EXISTS("CustomHeaderCode")
      %<LibHeaderFileCustomCode(CustomHeaderCode, "header")>
    %endif

    %if EXISTS("CustomInitializer")
      %assign rootSys = CompiledModel.System[CompiledModel.NumSystems-1]
      %<LibSystemInitializeCustomCode(rootSys, CustomInitializer, "execution")>
    %endif

    %if EXISTS("CustomTerminator")
      %with CompiledModel
        %<LibMdlTerminateCustomCode(CustomTerminator, "execution")>
      %endwith
    %endif
  %endwith
%endfunction

%endif %% _SETUPLIB_

%% [EOF] setuplib.tlc
