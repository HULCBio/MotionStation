%% 
%% $Revision: 1.1.6.11 $
%% 
%%
%% Copyright 1994-2004 The MathWorks, Inc.
%%
%% Abstract:
%%   This TLC library file contains all the block I/O functions.
%%

%if EXISTS("_BLKIOLIB_") == 0
%assign _BLKIOLIB_ = 1


%% DocFunction{Input Signal Functions}: LibBlockInputSignal ====================
%% Abstract:
%%   Based on the input port number (portIdx), the user control variable
%%   (ucv), the loop control variable (lcv), the signal index (sigIdx), and
%%   where this input signal is coming from, LibBlockInputSignal returns
%%   the appropriate reference to a block input signal.
%%
%%   The returned string value is a valid rvalue (right hand side assignment
%%   value) for an expression. The block input signal may be coming from
%%   another block, a state vector, an external input, a ground variable,
%%   a parameter, special memory location, or it can be a literal constant
%%   (e.g. 5.0).
%%
%%   Since the returned value can be a literal constant, you should not use this
%%   function to access the address of an input signal. To access the address of
%%   an input signal, use LibBlockInputSignalAddr. Accessing the address of the
%%   signal via LibBlockInputSignal may result in a reference to a literal
%%   constant (e.g., 5.0).
%%
%%   For example,
%%     - In C, the following would not work :
%%         %assign u = LibBlockInputSignal(0, "", lcv, sigIdx)
%%         x = &%<u>;
%%
%%         If %<u> refers to a invariant signal with a value of 4.95, the
%%         statement (after being processed by the pre-processor) would be
%%         generated as
%%
%%           x = &4.95;
%%
%%         or, if the input signal sources to ground, the statement could
%%         come out as
%%
%%           x = &0.0;
%%
%%         neither of these would compile.
%%
%%     - You avoid any such situations by using LibBlockInputSignalAddr():
%%
%%         %assign uAddr = LibBlockInputSignalAddr(0, "", lcv, sigIdx)
%%         x = %<uAddr>;
%%
%%       Real-Time Workshop tracks signals and parameters accessed by their
%%       address and declares them in addressable memory.
%%
%%   Input arguments:
%%     portIdx - An integer specifying the input port index starting at 0.
%%               Note, for certain build-in blocks this can be a string
%%               identifying the port (e.g., "enable", "trigger", etc.).
%%     ucv     - must be a string, either "" or an indexing expression.
%%     lcv     - must be a string, either "" or an indexing expression
%%               generated by the %roll construct. See the %roll construct.
%%     sigIdx  - either an integer literal or a string of the form
%%                  %<tRealPart>Integer
%%                  %<tImagPart>Integer
%%               For example:
%%                 "%<tRealPart>5" the real part of the signal starting at
%%                 index 5.
%%                 "%<tImagPart>5" the imaginary part of the signal starting
%%                 at index 5.
%%
%%   General usage:
%%     1) Direct indexing. If ucv == "" and lcv == "", then return an
%%        indexing expression for the element specified by sigIdx. 
%%
%%     2) Loop rolling/unrolling using the %roll directive and the MathWorks 
%%        provided "Roller" TLC file.
%%
%%        In this case, lcv and sigIdx are generated by the %roll directive,
%%        and ucv must be "".  A non-empty value for lcv is only
%%        allowed when generated by the %roll directive and when using
%%        the Roller TLC file (or a user supplied Roller TLC file that conforms
%%        to the same variable/signal offset handling). In addition, calls to 
%%        LibBlockInputSignal with lcv should only occur when "U" or a specific
%%        input port (e.g. "u0") is passed to the %roll directive via the roll
%%        variables argument. An example that is appropriate for a single 
%%        input/single output port S-function:
%%
%%           %assign rollVars  = ["U", "Y", "P"]
%%           %roll sigIdx=RollRegions, lcv=RollThreshold, block, ...
%%             "Roller", rollVars
%%             %assign u = LibBlockInputSignal( 0, "", lcv, sigIdx)
%%             %assign y = LibBlockOutputSignal(0, "", lcv, sigIdx)
%%             %assign p = LibBlockParameter(   0, "", lcv, sigIdx)
%%             %<y> = %<p> * %<u>;
%%           %endroll
%%
%%        With the %roll directive, sigIdx is always the starting index
%%        of the current roll region and lcv will be "" or a indexing
%%        variable, thus the following are valid values examples:
%%
%%
%%          LibBlockInputSignal(0, "", lcv, sigIdx)    rtB.blockname[0]
%%          LibBlockInputSignal(0, "", lcv, sigIdx)    u[i]
%%
%%
%%        The first LibBlockInputSignal call returns rtB.blockname[2] when
%%        input port is connected to the output of another block and
%%          a) the loop control variable (lcv) generated by the %roll
%%             directive is empty, indicating that the current roll region
%%             is below the roll threshold and sigIdx is 0. If sigIdx
%%             was non-zero (say 3), then rtB.blockname[3].
%%          b) the width of the input port is 1 indicating that this
%%             port is being scalar expanded.
%%
%%        The second LibBlockInputSignal call returns u[i] when the
%%        current roll region is above the roll threshold and the input
%%        port width is non-scalar (wide). In this case, the Roller
%%        TLC file sets up a local variable, u, to point to the input
%%        signal and the code in the current %roll directive is placed
%%        within a for loop.
%%
%%
%%        For another example, suppose we have a block with multiple input 
%%        ports where each port has width >= 1 and at least one port has width 
%%        equal to 1. Lets set the output signal to the sum of the squares of 
%%        all the input signals.
%%
%%          %assign y = LibBlockOutputSignal(0, "", "", 0)
%%          y = 0;
%%          
%%          %assign rollVars = ["U"]
%%          %foreach port = block.NumDataInputPorts - 1
%%            %roll sigIdx=RollRegions, lcv = RollThreshold, block, ...
%%              "Roller", rollVars
%%               %assign u = LibBlockInputSignal(port, "", lcv, sigIdx)
%%               y += %<u> * %<u>;
%%            %endroll
%%          %endforeach
%%
%%          Since the first parameter of LibBlockInputSignal is 0-indexed, you
%%          must index the foreach loop to start from 0 and end at
%%          NumDataInputPorts-1.
%%
%%     3) ucv handling. This is an advanced mode and generally not needed by
%%        S-function authors.
%%        
%%        If ucv != "", then return a rvalue for the input signal using the
%%        user control variable indexing expression of the form:
%%        
%%            rvalue_id[%<ucv>]%<optional_real_or_imag_part>
%%        
%%        o) rvalue_id is obtained by looking at the integer part of sigIdx.
%%           Specifying sigIdx is required because the input to this block can
%%           be discontiguous meaning that the input comes from several
%%           different memory areas (signal sources) and sigIdx is used to
%%           identify the area of interest for the ucv. Also sigIdx is used
%%           to determine if we are accessing the real or imaginary part of
%%           a signal.
%%        
%%        o) optional_real_or_imag_part is obtained by the string part of
%%           sigIdx (i.e. "re", or "im", or "").
%%        
%%        Note, the value for lcv is ignored and sigIdx must point to the same
%%        element in the input signal that the ucv initially points to.
%%        
%%        The handling of ucv with LibBlockInputSignal requires a lot of care.
%%        Consider a discontiguous input signal feeding an input port as in:
%%        
%%            .------.        .-----.
%%            | sin1 |------->|     |
%%            `------'        |     |          .-------.
%%                            | mux |--------->| block |
%%            .------.        |     |          `-------'
%%            | sin2 |------->|     |
%%            `------'        `-----'
%%        
%%        To use ucv in a robust manner, you must use the %roll directive with
%%        a roll threshold of 1 and a roller tlc file that has no loop
%%        header/trailer setup for this input signal. In addition, you need to
%%        use ROLL_ITERATIONS to determine the width of the current roll
%%        region. Some example C TLC code:
%%        
%%          {
%%              int i;
%%        
%%              %assign rollVars  = [""]
%%              %assign threshold = 1
%%              %roll sigIdx=RollRegions, lcv=threshold, block, ...
%%                "FlatRoller", rollVars
%%                %assign u = LibBlockInputSignal( 0, "i",           "", sigIdx)
%%                %assign y = LibBlockOutputSignal(0, "i+%<sigIdx>", "", sigIdx)
%%                %assign p = LibBlockParameter(   0, "i+%<sigIdx>", "", sigIdx)
%%                for (i = 0; i < %<ROLL_ITERATIONS()>; i++) {
%%                  %<y> = %<p> * %<u>;
%%                }
%%              %endroll
%%          }
%%        
%%        Note, the FlatRoller has no loop header/trailer setup (rollVars
%%        is ignored). It's purpose is to walk the RollRegions of the
%%        block.
%%        
%%        Alternatively, you can force a contiguous input signal to your block
%%        by specifying
%%           ssSetInputPortRequiredContiguous(S, port, TRUE)
%%        in your S-function and then your TLC code simplifies to:
%%        
%%          {
%%              %assign u = LibBlockInputSignal( 0, "i", "", 0)
%%              %assign y = LibBlockOutputSignal(0, "i", "", 0)
%%              %assign p = LibBlockParameter(   0, "i", "", 0)
%%        
%%                for (i = 0; i < %<DataInputPort[0].Width>; i++) {
%%                  %<y> = %<p> * %<u>;
%%                }
%%          }
%%        
%%        If you create your own roller and the indexing doesn't conform
%%        to the way the MathWorks provided Roller TLC file works, then
%%        you will need to use ucv instead of lcv.
%%
%%
%% Review of input arguments (ucv, lcv, and sigIdx) handling:
%%
%%     Function calls (case 1,2,3,4):             Example return value
%%     ---------------------------------------    --------------------
%%     LibBlockInputSignal(0, "i", "", sigIdx)    rtB.blockname[i]
%%     LibBlockInputSignal(0, "i", "", sigIdx)    rtU.signame[i]
%%     LibBlockInputSignal(0, "", lcv, sigIdx)    u0[i1]
%%     LibBlockInputSignal(0, "", lcv, sigIdx)    rtB.blockname[0]
%%
%%     The value returned depends on what the input signal is
%%     connected to in the block diagram and how the function is being
%%     invoked (e.g. in a %roll or directly). In the above example,
%%       - Case 1 & 2 occurs when an explicit call is made with the ucv set to
%%         "i".
%%       - Case 1 occurs when sigIdx pointing to the block I/O vector, i.e.,
%%         the first element that "i" starts with. For example, if you
%%         initialize "i" to be starting at offset 5, then you should specify
%%         sigIdx == 5.
%%       - Case 2 occurs when sigIdx pointing to the external input vector,
%%         i.e., the first element that "i" starts with. For example, if you
%%         initialize "i" to be starting at offset 20, then you should specify
%%         sigIdx == 20.
%%       - Cases 3 and 4 receive the same arguments, lcv and sigIdx however
%%         they produce different return values.
%%       - Case 3 occurs when LibBlockInputSignal is called within a
%%         %roll directive and the current roll region is being rolled
%%         (lcv != "").
%%       - Case 4 occurs when LibBlockInputSignal is called within a
%%         %roll directive and the current roll region is not being rolled
%%         (lcv == "").
%%
%%     When called within a %roll directive, this function looks at ucv,
%%     lcv, and sigIdx, the current roll region, and the current roll
%%     threshold to determine the return value. The variable ucv has highest
%%     precedence, lcv has the next highest precedence, and sigIdx has the
%%     lowest precedence. That is, if ucv is specified, it will be used
%%     (thus, when called in a %roll directive it is usually ""). If ucv is
%%     not specified and lcv and sigIdx are specified, the returned value
%%     depends on whether or not the current roll region is being placed in
%%     a for loop or being expanded. If the roll region is being placed in a
%%     loop then, lcv is used, otherwise sigIdx is used.
%%
%%     A direct call to this function (inside or outside of a %roll
%%     directive) will use sigIdx when ucv and lcv are specified as "".
%%
%%     For an example use of this function, see
%%     matlabroot/toolbox/simulink/blocks/tlc_c/sfun_multiport.tlc.
%%
%function LibBlockInputSignal(portIdx, ucv, lcv, sigIdx) void

  %% Optionally recurse on input
  %if LibBlockInputSignalIsExpr(portIdx)
    %assign ip     = FcnGetInputPortRecord(portIdx)
    %assign srcSys = System[ip.SrcIdx[0]]
    %assign srcBlk = srcSys.Block[ip.SrcIdx[1]]
    %assign srcPort = ip.SrcIdx[2]

    %% Move lcv to ucv to prevent usage of rolling tmp vars
    %if lcv != ""
      %if ucv != ""
	%<LibReportFatalError("invalid indexing into output expression")>
      %endif
      %assign ucv = lcv
      %assign lcv = ""
    %endif
      
    %with srcSys %% switch system context if needed
      %% Update expression comment
      %<FcnAddToExprCommentList(srcBlk, srcPort)>
      
      %assign cast = LibOutputExprCast(srcBlk, srcPort)
      %assign retSignal = SLibBlockOutputSignal(srcBlk,srcSys,srcPort,ucv,lcv,sigIdx,"Signal")
      %if cast != ""
	%assign retSignal = "(%<cast>%<retSignal>)"
      %endif
      
    %endwith %% srcSys
    
    %% We don't clear (set to -1) these until after SLibBlockOutputSignal
    %% because we want their info during the possible recursion in 
    %% SLibBlockOutputSignal.
    
    %assign srcBlk.ExprCommentSrcIdx.SysIdx = -1
    %assign srcBlk.ExprCommentSrcIdx.BlkIdx = -1
    
    %return  SLibProcessSafeExpression(srcBlk.Name, retSignal, 1)
      
  %endif

  %% Handle scalar expansion of ucv
  %if (ucv != "" && LibBlockInputSignalWidth(portIdx) == 1)
    %assign tmpVect = SLibGetReimAndIdx(sigIdx)
    %assign reim    = tmpVect[0]
    %assign sigIdx = "%<reim>0"
    %assign ucv = ""
  %endif
    
  %% See Also:
  %%      LibBlockInputSignalAddr, 
  %%      LibBlockOutputSignal,
  %%      LibBlockOutputSignalAddr,
  %%      LibBlockParameter,
  %%      LibBlockParameterAddr
  %%
  %assign retSignal = FcnGetInputOrOutputSignal("input",portIdx, ucv, ...
    lcv, sigIdx)

  %return retSignal

%endfunction %% LibBlockInputSignal


%function FcnAddToExprCommentList (srcBlk, srcPort) void

  %if ExprCommentSrcIdx.SysIdx != -1
    %% transfer comment info from port
    %assign srcBlk.ExprCommentSrcIdx.SysIdx  = ExprCommentSrcIdx.SysIdx
    %assign srcBlk.ExprCommentSrcIdx.BlkIdx  = ExprCommentSrcIdx.BlkIdx
  %else
    %% transfer comment info from block
    %assign srcBlk.ExprCommentSrcIdx.SysIdx = BlockIdx[0]
    %assign srcBlk.ExprCommentSrcIdx.BlkIdx = BlockIdx[2]
  %endif

  %assign commSysIdx = srcBlk.ExprCommentSrcIdx.SysIdx
  %assign commBlkIdx = srcBlk.ExprCommentSrcIdx.BlkIdx
  %assign commInfo = System[commSysIdx].Block[commBlkIdx].ExprCommentInfo
  
  %<SLibAddToExprCommentList(commInfo,srcBlk,srcPort)>

%endfunction %% FcnAddToExprCommentList

%% DocFunction{Input Signal Functions}: LibBlockInputSignalAddr ================
%% Abstract:
%%   Returns appropriate C string providing the the memory address of
%%   the specified block input port signal.
%%
%%   When an input signal address is needed, you must use this function
%%   instead of appending an "&" to the string returned by LibBlockInputSignal.
%%   For example, LibBlockInputSignal can return a literal constant,
%%   such as 5 (i.e. an invariant input signal). Real-Time Workshop tracks
%%   when LibBlockInputSignalAddr is called on an invariant signal and declares
%%   the signal as "const" data (which is addressable), instead of being placed
%%   as a literal constant in the generated code (which is not addressable).
%%
%%   Note, unlike LibBlockInputSignal() the last input argument, sigIdx,
%%   is not overloaded. Hence, if the input signal is complex, the
%%   address of the complex container is returned.
%%
%%   Example:
%%      To get the address of a wide input signal and pass it to a
%%      user-function for processing one could use:
%%
%%        %assign uAddr = LibBlockInputSignalAddr(0, "", "", 0)
%%        %assign y = LibBlockOutputSignal(0, "", "", 0)
%%        y = myfcn(%<uAddr>);
%%
%function LibBlockInputSignalAddr(portIdx, ucv, lcv, sigIdx) void

  %% See Also:
  %%      LibBlockInputSignal, 
  %%      LibBlockOutputSignal,
  %%      LibBlockOutputSignalAddr,
  %%      LibBlockParameter
  %%      LibBlockParameterAddr

  %if LibBlockInputSignalIsExpr(portIdx)
    %%START_ASSERT
    %assign errTxt = "%<Type> block %<Name> has specified that input " ...
      "port %<portIdx> can be an expression in RTW, however the block is " ...
      "attempting to obtain the address of this input in TLC using " ...
      "LibBlockInputSignalAddr.  The conflict must be resolved."
    %<LibReportFatalError(errTxt)>
    %%END_ASSERT
  %endif

  %assign retSignal = FcnGetInputOrOutputSignal("inputAddr",portIdx, ucv, ...
    lcv, sigIdx)

  %return retSignal

%endfunction %% LibBlockInputSignalAddr


%% Function LibBlockInputSignalIsExpr =========================================
%% Abstract:
%%   Returns 1 (true) if the input signal is an expression (versus a variable),
%%   and 0 (false) otherwise.
%%
%function LibBlockInputSignalIsExpr(portIdx) void
  %if GeneratingOutputsCode
    %return LibBlockInputSignalIsExprInOutputs(portIdx)
  %else
    %return TLC_FALSE
  %endif
%endfunction


%% Function LibBlockInputSignalIsExpr =========================================
%% Abstract:
%%   Returns 1 (true) if the input signal is an expression (versus a variable),
%%   and 0 (false) otherwise.
%%
%function LibBlockInputSignalIsExprInOutputs(portIdx) void
  %return FcnGetBlockInputSignalExprType(portIdx, FcnIsOutputExpression)
%endfunction


%% Function LibBlockInputSignalIsTrivialExpr ===================================
%% Abstract:
%%   Returns 1 (true) if the input signal is a trivial expression (versus a 
%%   variable), and 0 (false) otherwise.
%%
%function LibBlockInputSignalIsTrivialExpr(portIdx) void
  %if GeneratingOutputsCode
    %return LibBlockInputSignalIsTrivialExprInOutputs(portIdx)
  %else
    %return TLC_FALSE
  %endif
%endfunction


%% Function LibBlockInputSignalIsTrivialExpr ====================================
%% Abstract:
%%   Returns 1 (true) if the input signal is an expression (versus a variable),
%%   and 0 (false) otherwise.
%%
%function LibBlockInputSignalIsTrivialExprInOutputs(portIdx) void
  %return FcnGetBlockInputSignalExprType(portIdx, FcnIsTrivialOutputExpression)
%endfunction

%function FcnIsOutputExpression (iDataOutputPort)
  %return iDataOutputPort.OutputExpression
%endfunction


%function FcnIsTrivialOutputExpression (iDataOutputPort)
  %return iDataOutputPort.TrivialOutputExpression
%endfunction


%% Function FcnGetBlockInputSignalExprType =======================================
%% Abstract:
%%   Call TypeGetterFunc on the DataOutputPort connected to the input with port
%%   index portIdx, if we're supposed to recurse on this input.  If we're not 
%%   supposed to recurse, just return TLC_FALSE.
%%
%function FcnGetBlockInputSignalExprType(portIdx, TypeGetterFunc) void
  %assign ip = FcnGetInputPortRecord(portIdx)
  %if ip.RecurseOnInput
    %assign sIdx = ip.SrcIdx[0]
    %assign bIdx = ip.SrcIdx[1]
    %assign pIdx = ip.SrcIdx[2]
    %return TypeGetterFunc (System[sIdx].Block[bIdx].DataOutputPort[pIdx])
  %else
    %return TLC_FALSE
  %endif
%endfunction


%% Function: LibBlockOutputSignalIsTrivialExpr ==================================
%% Abstract:
%%   Returns 1 (true) if the output signal is a trivial expression, and 0 
%%   (false) otherwise.
%%
%function LibBlockOutputSignalIsTrivialExpr(portIdx) void
  %if GeneratingOutputsCode
    %return LibBlockOutputSignalIsTrivialExprInOutputs(portIdx)
  %else
    %return 0
  %endif
%endfunction

%% Function: LibBlockOutputSignalIsTrivialExprInOutputs ========================
%% Abstract:
%%   Returns 1 (true) if the output signal is a trivial expression in the 
%%   outputs function, and 0 (false) otherwise.  This function is used as 
%%   a low level utility to get access to what the value will be when 
%%   generating the block's outputs code.  Should be used in 
%%   BlockInstanceSetup function.
%%
%function LibBlockOutputSignalIsTrivialExprInOutputs(portIdx) void
  %if NumDataOutputPorts == 1
    %return DataOutputPort.TrivialOutputExpression
  %else
    %return 0
  %endif
%endfunction


%% Function: LibBlockOutputSignalIsConstExpr ==================================
%% Abstract:
%%   Returns 1 (true) if the output signal is a const expression, and 0 
%%   (false) otherwise.  Note that const expressions are always const,
%%   whether called in a block Outputs function or not.
%%
%function LibBlockOutputSignalIsConstExpr(portIdx) void
  %assign op  = FcnGetOutputPortRecord(portIdx)
  %return (IDNUM(op.SignalSrc[0])[0] == "C")
%endfunction

%% Function: SLibSetBlockInputSignalIsNotExpr ==============================
%% Abstract:
%%   Force this block input signal into a variable, and update its source
%%   block accordingly; the source can no longer be a nonconst output
%%   expression (const is of course always allowed)
%%
%function SLibSetBlockInputSignalIsNotExpr(iPort) void
  %if iPort.RecurseOnInput == 1
    %assign sIdx = iPort.SrcIdx[0]
    %assign bIdx = iPort.SrcIdx[1]
    %assign srcBlk = System[sIdx].Block[bIdx]
    %assign srcPort = iPort.SrcIdx[2]
    %<SLibSetBlockNonConstOutputSignalIsNotExpr(srcBlk, srcPort)>
  %endif
%endfunction


%% DocFunction{Input Signal Functions}: LibBlockInputSignalWidth ===============
%% Abstract:
%%   Returns the width of the specified block input port index.
%%
%function LibBlockInputSignalWidth(portIdx) void
  %% See Also:
  %%   LibBlockOutputSignalWidth
  %%
  %assign ip = FcnGetInputPortRecord(portIdx)
  %return ip.Width
%endfunction %% LibBlockInputSignalWidth

%% SLibBlockSystemToCallForInput ==============================================
%% Abstract:
%%   Returns the conditionally executed system to call for the input port.
%%
%function SLibBlockSystemToCallForInput(portIdx) void
  %% See Also:
  %%
  %assign ip = FcnGetInputPortRecord(portIdx)
  %return ip.SystemToCall
%endfunction %% LibBlockSystemToCallForInput

%% DocFunction{Input Signal Functions}: LibBlockInputSignalDimensions ==========
%% Abstract:
%%   Returns the dimensions vector of specified block input port, e.g. [2,3]
%%
%function LibBlockInputSignalDimensions(portIdx) void
  %% See Also:
  %%   LibBlockInputSignalNumDimensions
  %%
  %assign ip = FcnGetInputPortRecord(portIdx)
  %if ISFIELD(ip,"Dimensions")
    %return ip.Dimensions
  %else
    %return %<LibBlockInputSignalWidth(portIdx)>
  %endif
%endfunction %% LibBlockInputSignalDimensions


%% DocFunction{Input Signal Functions}: LibBlockInputSignalNumDimensions =======
%% Abstract:
%%   Returns the number of dimensions of the specified block input port.
%%
%function LibBlockInputSignalNumDimensions(portIdx) void
  %% See Also:
  %%   LibBlockInputSignalDimensions
  %%
  %assign ip = FcnGetInputPortRecord(portIdx)
  %if ISFIELD(ip,"Dimensions")
    %return SIZE(ip.Dimensions,1)
  %else
    %return 1
  %endif
%endfunction %% LibBlockInputSignalNumDimensions


%% DocFunction{Input Signal Functions}: LibBlockInputSignalIsComplex ===========
%% Abstract:
%%   Returns 1 if the specified block input port is complex, 0 otherwise.
%%
%function LibBlockInputSignalIsComplex(portIdx) void
  %% See Also:
  %%   LibBlockOutputSignalIsComplex, LibBlockParameterIsComplex
  %%
  %assign ip = FcnGetInputPortRecord(portIdx)
  %return SLibGetRecordIsComplex(ip)
%endfunction %% LibBlockInputSignalIsComplex


%% DocFunction{Input Signal Functions}: LibBlockInputSignalIsFrameData =========
%% Abstract:
%%   Returns 1 if the specified block input port is frame based, 0 otherwise.
%%
%function LibBlockInputSignalIsFrameData(portIdx) void

  %% See Also:
  %%   LibBlockOutputSignalIsFrameData
  %%
  %assign ip = FcnGetInputPortRecord(portIdx)
  %return ip.FrameData == "yes"
%endfunction %% LibBlockInputSignalIsFrameData


%% DocFunction{Input Signal Functions}: LibBlockInputSignalDataTypeId ==========
%% Abstract:
%%   Returns the numeric identifier (id) corresponding to the data type of the
%%   specified block input port.
%%
%%   If the input port signal is complex, this function returns the data type
%%   of the real part (or the imaginary part) of the signal.
%%
%function LibBlockInputSignalDataTypeId(portIdx) void

  %% See Also:
  %%   LibBlockInputSignalDataTypeName
  %%   LibBlockOutputSignalDataTypeId
  %%   LibBlockParameterDataTypeId
  %%
  %assign ip = FcnGetInputPortRecord(portIdx)
  %if Type == "S-Function" && !ParamSettings.AliasDataTypeCompliant
    %return LibGetDataTypeIdAliasedThruToFromId(SLibGetRecordDataTypeId(ip))
  %else
    %return SLibGetRecordDataTypeId(ip)
  %endif
%endfunction %% LibBlockInputSignalDataTypeId


%% DocFunction{Input Signal Functions}: LibBlockInputSignalDataTypeName ========
%% Abstract:
%%   Returns the name of the data type (e.g., int_T, ... creal_T) corresponding
%%   to the specified block input port.
%%
%%   Specify the reim argument as "" if you want the complete signal type name.
%%   For example, if reim=="" and the first output port is real and complex,
%%   the data type name placed in dtname will be creal_T.
%%
%%       %assign dtname = LibBlockInputSignalDataTypeName(0,"")
%%
%%   Specify the reim argument as tRealPart if you want the raw element type
%%   name. For example, if reim==tRealPart and the first output port is real
%%   and complex, the data type name returned will be real_T.
%%
%%       %assign dtname = LibBlockOutputSignalDataTypeName(0,tRealPart)
%%
%function LibBlockInputSignalDataTypeName(portIdx, reim) void
  %% See Also:
  %%      LibBlockOutputSignalDataTypeName, LibBlockParameterDataTypeName
  %%

  %if Type == "S-Function" && !ParamSettings.AliasDataTypeCompliant
    %return LibBlockInputSignalAliasedThruDataTypeName(portIdx, reim)
  %else
    %assign ip = FcnGetInputPortRecord(portIdx)
    %return SLibGetRecordDataTypeName(ip, reim)
  %endif
%endfunction %% LibBlockInputSignalDataTypeName


%% DocFunction{Input Signal Functions}: LibBlockInputSignalAliasedThruDataTypeName ====
%% Abstract:
%%   Returns the name of the aliased thru data type (e.g., int_T, ... creal_T)
%%   corresponding to the specified block input port.
%%
%%   Specify the reim argument as "" if you want the complete signal type name.
%%   For example, if reim=="" and the first output port is real and complex,
%%   the data type name placed in dtname will be creal_T.
%%
%%       %assign dtname = LibBlockInputSignalDataTypeName(0,"")
%%
%%   Specify the reim argument as tRealPart if you want the raw element type
%%   name. For example, if reim==tRealPart and the first output port is real
%%   and complex, the data type name returned will be real_T.
%%
%%       %assign dtname = LibBlockOutputSignalDataTypeName(0,tRealPart)
%%
%function LibBlockInputSignalAliasedThruDataTypeName(portIdx, reim) void
  %% See Also:
  %%      LibBlockOutputSignalAliasedThruDataTypeName
  %%

  %assign ip = FcnGetInputPortRecord(portIdx)
  %return LibGetRecordAliasedThruDataTypeName(ip, reim)
%endfunction %% LibBlockInputSignalAliasedThruDataTypeName


%% DocFunction{Input Signal Functions}: LibBlockInputSignalSampleTime ==========
%% Abstract:
%%   Returns the sample time corresponding to the specified block input
%%   port.
%%
%function LibBlockInputSignalSampleTime(portIdx) void
  %% See Also:
  %%      LibBlockOutputSignalSampleTime, LibBlockInputSignalSampleTimeIndex,
  %%      LibBlockInputSignalOffsetTime
  %%
  %if EXISTS("InputPortSampleTimes")
    %assign idx = InputPortSampleTimes[portIdx]
  %else
    %%START_ASSERT
    %assign errTxt = "SampleTime is not contained within the specified record"
    %<LibBlockReportError([],errTxt)>
    %%END_ASSERT
  %endif
  %return idx
%endfunction %% LibBlockInputSignalSampleTime


%% DocFunction{Input Signal Functions}: LibBlockInputSignalOffsetTime ==========
%% Abstract:
%%   Returns the offset time corresponding to the specified block input
%%   port.
%%
%function LibBlockInputSignalOffsetTime(portIdx) void
  %% See Also:
  %%      LibBlockOutputSignalOffsetTime, LibBlockInputSignalSampleTimeIndex,
  %%      LibBlockInputSignalSampleTime
  %%
  %if EXISTS("InputPortOffsetTimes")
    %assign idx = InputPortOffsetTimes[portIdx]
  %else
    %%START_ASSERT
    %assign errTxt = "OffsetTime is not contained within the specified record"
    %<LibBlockReportError([],errTxt)>
    %%END_ASSERT
  %endif
  %return idx
%endfunction %% LibBlockInputSignalOffsetTime


%% DocFunction{Input Signal Functions}: LibBlockInputSignalSampleTimeIndex =====
%% Abstract:
%%   Returns the sample time index corresponding to the specified block input
%%   port.
%%
%function LibBlockInputSignalSampleTimeIndex(portIdx) void
  %% See Also:
  %%      LibBlockOutputSignalSampleTimeIndex, LibBlockInputSignalSampleTime,
  %%      LibBlockInputSignalOffsetTime
  %%
  %if EXISTS("InputPortTIDs")
    %assign idx = InputPortTIDs[portIdx]
  %else
    %%START_ASSERT
    %assign errTxt = "SampleTimeIndex is not contained within the specified record"
    %<LibBlockReportError([],errTxt)>
    %%END_ASSERT
  %endif
  %return idx
%endfunction %% LibBlockInputSignalSampleTimeIndex


%% DocFunction{Input Signal Functions}: LibBlockInputSignalLocalSampleTimeIndex
%% Abstract:
%%   Returns the local sample time index corresponding to the specified block
%%   input port.
%%
%function LibBlockInputSignalLocalSampleTimeIndex(portIdx) void
  %% See Also:
  %%      LibBlockOutputSignalSampleTimeIndex, LibBlockInputSignalSampleTime,
  %%      LibBlockInputSignalOffsetTime,
  %%      LibBlockOutputSignalLocalSampleTimeIndex
  %%
  %if EXISTS("InputPortLocalTIDs")
    %assign idx = InputPortLocalTIDs[portIdx]
  %else
    %%START_ASSERT
    %assign errTxt = "LocalSampleTimeIndex is not contained within the specified record"
    %<LibBlockReportError([],errTxt)>
    %%END_ASSERT
  %endif
  %return idx
%endfunction %% LibBlockInputSignalLocalSampleTimeIndex


%% DocFunction{Input Signal Functions}: LibBlockInputSignalConnected ===========
%% Abstract:
%%   Returns 1 if the specified input port is connected to a block other than 
%%   the Ground block and 0 otherwise.
%%
%%
%function LibBlockInputSignalConnected(portIdx) void
  %% See Also:
  %%      LibBlockOutputSignalConnected
  %%
  %if EXISTS("Connections.InputPortConnected")
    %assign connected = (Connections.InputPortConnected[portIdx] == "yes")
  %else
    %%START_ASSERT
    %assign errTxt = "InputPortConnected is not contained within the specified record"
    %<LibBlockReportError([],errTxt)>
    %%END_ASSERT
  %endif
  %return connected
%endfunction %% LibBlockInputSignalConnected


%% DocFunction{Advanced Functions}: LibBlockInputSignalBufferDstPort ===========
%% Abstract:
%%   Returns the output port corresponding to input port (portIdx) which share
%%   the same memory, otherwise (-1) is returned. You will need to use this
%%   function when you specify ssSetInputPortOverWritable(S,portIdx,TRUE) in
%%   your S-function.
%%
%%   If an input port and some output port of a block are
%%
%%     1) not test points and
%%     2) the input port is overwritable,
%%
%%   then the output port might reuse the same buffer as the input port.
%%   In this case, LibBlockInputSignalBufferDstPort returns the index of the
%%   output port that reuses the specified input port's buffer.  If none of
%%   the block's output ports reuse the specified input port buffer, then
%%   this function returns -1.
%%
%%   This function is the TLC implementation of the Simulink macro
%%   ssGetInputPortBufferDstPort.
%%
%%   Example:
%%     Assume you have a block that has two input ports, both of which receive
%%     a complex number in 2-wide vectors.  The block outputs the product
%%     of the two complex numbers.
%%
%%     %assign u1r = LibBlockInputSignal (0, "", "", 0)
%%     %assign u1i = LibBlockInputSignal (0, "", "", 1)
%%     %assign u2r = LibBlockInputSignal (1, "", "", 0)
%%     %assign u2i = LibBlockInputSignal (1, "", "", 1)
%%     %assign yr  = LibBlockOutputSignal (0, "", "", 0)
%%     %assign yi  = LibBlockOutputSignal (0, "", "", 1)
%%
%%     %if (LibBlockInputSignalBufferDstPort(0) != -1)
%%       %% The first input is going to get overwritten by yr so
%%       %% we need to save the real part in a temporary variable.
%%       {
%%         real_T tmpRe = %<u1r>;
%%         %assign u1r = "tmpRe";
%%     %endif
%%
%%     %<yr> = %<u1r> * %<u2r> - %<u1i> * %<u2i>;
%%     %<yi> = %<u1r> * %<u2i> + %<u1i> * %<u2r>;
%%
%%     %if (LibBlockInputSignalBufferDstPort(0) != -1)
%%       }
%%     %endif
%%
%%     Note that in this case, we could have equivalently used
%%     (LibBlockInputSignalBufferDstPort(0) == 0) as the boolean condition
%%     for the %if statements since there is only one output port.
%%
%function LibBlockInputSignalBufferDstPort(portIdx)
  %assign ip = FcnGetInputPortRecord(portIdx)
  %if ip.BufferDstPort < 0
    %foreach opIdx = NumDataOutputPorts
      %if ip.SignalSrc[0] == DataOutputPort[opIdx].SignalSrc[0]
        %return opIdx
      %endif
    %endforeach
    %return -1
  %else
    %return ip.BufferDstPort
  %endif
%endfunction %% LibBlockInputSignalBufferDstPort


%% DocFunction{Advanced Functions}: LibBlockInputSignalStorageClass ============
%% Abstract:
%%   Returns the storage class of the specified block input port signal.
%%   The storage class can be "Auto", "ExportedSignal", "ImportedExtern",
%%   "ImportedExternPointer", "Custom".
%%
%function LibBlockInputSignalStorageClass(portIdx, sigIdx) void
  %assign ip = FcnGetInputPortRecord(portIdx)
  %assign mapSource = IDNUM(ip.SignalSrc[sigIdx])[0]
  
  %if (mapSource == "L" || mapSource == "b" || mapSource == "B" || ...
       mapSource == "I" || mapSource == "C" || mapSource == "G" || ...
       mapSource == "x" || mapSource == "X" || mapSource == "F")

    %return "Auto"
  %else
    %assign sigRec = SLibGetSourceRecord(ip, sigIdx)
    %return sigRec.StorageClass
  %endif 
%endfunction %% LibBlockInputSignalStorageClass


%% DocFunction{Advanced Functions}: LibBlockInputSignalStorageTypeQualifier ====
%% Abstract:
%%   Returns the storage type qualifier of the specified block input port
%%   signal. The type qualifier can be anything entered by the user such
%%   as "const". The default type qualifier is "Auto" - meaning do the
%%   default action.
%%
%function LibBlockInputSignalStorageTypeQualifier(portIdx, sigIdx) void
  %% See Also:
  %%      LibBlockOutputSignalStorageTypeQualifier
  %%
  %assign        ip = FcnGetInputPortRecord(portIdx)
  %assign mapSource = IDNUM(ip.SignalSrc[sigIdx])[0]
  
  %if (mapSource == "L" || mapSource == "b" || mapSource == "B" || ...
       mapSource == "I" || mapSource == "G" || mapSource == "x" || ...
       mapSource == "X" || mapSource == "F")
    %return ""
  %elseif mapSource == "C"
    %assign tmpVec = LibBlockSrcSignalBlock(portIdx, sigIdx)
    %assign sysIdx = tmpVec[0]
    %assign blkIdx = tmpVec[1]
    %assign srcBlock = CompiledModel.System[sysIdx].Block[blkIdx] 
    %% If a block with a constant output expression has more than 1
    %% runtime parameter, we don't really know which parameter it is
    %% that is output as an expression, and we'll just return the
    %% default "" in that case
    %if srcBlock.Parameters[0] == 1
      %assign mdlParamIdx = ...
	FcnGetModelParamIdxFromBlockParam(srcBlock.Parameter[0])
      %% If we can't identify a unique model parameter from the block
      %% parameter, mdlParamIdx will be < 0, and we'll just return the
      %% default "" in that case
      %if mdlParamIdx >= 0
	%assign mdlParam = ModelParameters.Parameter[mdlParamIdx]
	%return SLibGetModelParameterTypeQualifier(mdlParam)
      %else
	%return ""
      %endif
    %else
      %return ""
    %endif
  %else
    %assign sigRec = SLibGetSourceRecord(ip, sigIdx)
    %return sigRec.StorageTypeQualifier
  %endif
%endfunction %% LibBlockInputSignalTypeQualifier


%% DocFunction{Output Signal Functions}: LibBlockOutputSignal ==================
%% Abstract:
%%   Based on the output port number (portIdx), the user control variable (ucv),
%%   the loop control variable (lcv), the signal index (sigIdx), and where the
%%   output signal destination, LibBlockOutputSignal returns the
%%   appropriate reference to a block output signal.
%%
%%   The returned value is a valid lvalue (left value) for an expression.
%%   The block output destination can be a location in the block I/O vector
%%   (another block's input), the state vector, or an external output.
%%
%%   Note, never use this function to access the address of an output signal.
%%   The Real-Time Workshop tracks when a variable (e.g. signals and
%%   parameters) is accessed by its address. To access the address of an
%%   output signal use LibBlockOutputSignalAddr as in the following example:
%%     %assign yAddr = LibBlockOutputSignalAddr(0, "", lcv, sigIdx)
%%     x = %<yAddr>;
%%
%function LibBlockOutputSignal(portIdx, ucv, lcv, sigIdx) void

  %if LibBlockOutputSignalIsExpr(portIdx)
    %return ""
  %endif
  
  %% See Also:
  %%      LibBlockInputSignal,
  %%      LibBlockInputSignalAddr,
  %%      LibBlockOutputSignalAddr, 
  %%      LibBlockParameter
  %%      LibBlockParameterAddr
  %%
  %assign retSignal = FcnGetInputOrOutputSignal("output",portIdx, ucv, ...
    lcv, sigIdx)

  %return retSignal


%endfunction %% LibBlockOutputSignal


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalAddr ==============
%% Abstract:
%%   Returns appropriate string providing the the memory address of
%%   the specified block output port signal.
%%
%%   When an output signal address is needed, you must use this function
%%   instead of taking the address of is returned by LibBlockOutputSignal.
%%   For example, LibBlockOutputSignal can return a literal constant,
%%   such as 5 (i.e. an invariant output signal). When
%%   LibBlockOutputSignalAddr is called on an invariant signal, the signal
%%   is declared as a "const" instead of  being placed as a literal
%%   constant in the generated code.
%%
%%   Note, unlike LibBlockOutputSignal() the last argument, sigIdx,
%%   is not overloaded. Hence, if the output signal is complex, the
%%   address of the complex container is returned.
%%
%%   Example:
%%      To get the address of a wide output signal and pass it to a
%%      user-function for processing one could use:
%%
%%      %assign u = LibBlockOutputSignalAddr(0, "", "", 0)
%%      %assign y = LibBlockOutputSignal(0, "", "", 0)
%%      y = myfcn(%<u>);
%%
%function LibBlockOutputSignalAddr(portIdx, ucv, lcv, sigIdx) void

  %if LibBlockOutputSignalIsExpr(portIdx)
    %return ""
  %endif
  
  %% See Also:
  %%      LibBlockInputSignal,
  %%      LibBlockInputSignalAddr,
  %%      LibBlockOutputSignal, 
  %%      LibBlockParameter
  %%      LibBlockParameterAddr
  %%
  %assign retSignal = FcnGetInputOrOutputSignal("outputAddr",portIdx, ucv, ...
    lcv, sigIdx)

  %return retSignal

%endfunction %% LibBlockOutputSignalAddr


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalWidth =============
%% Abstract:
%%   Returns the width of specified block output port.
%%
%function LibBlockOutputSignalWidth(portIdx) void
  %% See Also:
  %%   LibBlockInputSignalWidth,
  %%   LibBlockOutputSignalNumDimensions, LibBlockOutputSignalDimensions
  %%
  %assign op = FcnGetOutputPortRecord(portIdx)
  %if op.Width != -1
    %return op.Width
  %else
    %assign sigRec = SLibGetSourceRecord(op, 0)
    %if ISEMPTY(sigRec) %% FcnCall
      %return NumSFcnSysOutputCalls
    %else
      %return sigRec.Width
    %endif
  %endif
%endfunction %% LibBlockOutputSignalWidth


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalDimensions ========
%% Abstract:
%%   Returns the dimensions of specified block output port.
%%
%function LibBlockOutputSignalDimensions(portIdx) void
  %% See Also:
  %%   LibBlockInputSignalDimensions
  %%
  %assign op = FcnGetOutputPortRecord(portIdx)
  %if op.Dimensions[0] != -1
    %return op.Dimensions
  %else
    %return %<LibBlockOutputSignalWidth(portIdx)>
  %endif
%endfunction %% LibBlockOutputSignalDimensions


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalNumDimensions =====
%% Abstract:
%%   Returns the number of dimensions of the specified block output port.
%%
%function LibBlockOutputSignalNumDimensions(portIdx) void
  %% See Also:
  %%   LibBlockInputSignalNumDimensions
  %%
  %assign op = FcnGetOutputPortRecord(portIdx)
  %if op.Dimensions[0] != -1
    %return SIZE(op.Dimensions,1)
  %else
    %return 1
  %endif
%endfunction %% LibBlockOutputSignalNumDimensions


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalIsComplex =========
%% Abstract:
%%   Returns 1 if the specified block output port is complex, 0 otherwise.
%%
%function LibBlockOutputSignalIsComplex(portIdx) void
  %% See Also:
  %%   LibBlockInputSignalIsComplex, LibBlockParameterIsComplex
  %%
  %assign op = FcnGetOutputPortRecord(portIdx)
  %return SLibGetRecordIsComplex(op)  
%endfunction %% LibBlockOutputSignalIsComplex


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalIsFrameData =======
%% Abstract:
%%   Returns 1 if the specified block output port is frame based, 0 otherwise.
%%
%function LibBlockOutputSignalIsFrameData(portIdx) void
  %% See Also:
  %%   LibBlockInputSignalIsFrameData
  %%
  %assign op = FcnGetOutputPortRecord(portIdx)
  %return op.FrameData == "yes"
%endfunction %% LibBlockOutputSignalIsFrameData


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalDataTypeId ========
%% Abstract:
%%   Returns the numeric ID corresponding to the data type of the specified
%%   block output port.
%%
%%   If the output port signal is complex, this function returns the data type
%%   of the real (or the imaginary) part of the signal.
%%
%function LibBlockOutputSignalDataTypeId(portIdx) void
  %% See Also:
  %%   LibBlockOutputSignalDataTypeName, LibBlockInputSignalDataTypeId,
  %%   LibBlockParameterDataTypeId
  %%
  %assign op = FcnGetOutputPortRecord(portIdx)
  %if (IDNUM(op.SignalSrc[0])[0] == "F") %% FcnCall
    %return tSS_INVALID_DATA_TYPE_ID
  %elseif Type == "S-Function" && !ParamSettings.AliasDataTypeCompliant
    %return LibGetDataTypeIdAliasedThruToFromId(SLibGetRecordDataTypeId(op))
  %else
    %return SLibGetRecordDataTypeId(op)
  %endif
%endfunction %% LibBlockOutputSignalDataTypeId


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalDataTypeName ======
%% Abstract:
%%   Returns the type name string (e.g. int_T, ... creal_T) of the data type
%%   corresponding to the specified block output port.
%%
%%   Specify the reim argument as "" if you want the complete signal type name.
%%   For example if reim=="" and the first output port is real and complex,
%%   the data type  name placed in dtname will be creal_T:
%%      %assign dtname = LibBlockOutputSignalDataTypeName(0x,"")
%%
%%   Specify the reim argument as tRealPart if you want the raw element type
%%   name. For example if reim==tRealPart and the first output port is real
%%   and complex, the data type name returned will be real_T.
%%      %assign dtname = LibBlockOutputSignalDataTypeName(0,tRealPart)
%%
%function LibBlockOutputSignalDataTypeName(portIdx, reim) void
  %% See Also:
  %%   LibBlockOutputSignalDataTypeId, LibBlockInputSignalDataTypeName,
  %%   LibBlockParameterDataTypeName
  %%
  %if Type == "S-Function" && !ParamSettings.AliasDataTypeCompliant
    %return LibBlockOutputSignalAliasedThruDataTypeName(portIdx, reim)
  %else
    %assign op = FcnGetOutputPortRecord(portIdx)
    %if (IDNUM(op.SignalSrc[0])[0] == "F") %% FcnCall
      %return ""
    %else
      %return SLibGetRecordDataTypeName(op, reim)
    %endif
  %endif
%endfunction %% LibBlockOutputSignalDataTypeName

%% DocFunction{Output Signal Functions}: LibBlockOutputSignalAliasedThruDataTypeName ======
%% Abstract:
%%   Returns the type name string (e.g. int_T, ... creal_T) of the aliased
%%   data type corresponding to the specified block output port.
%%
%%   Specify the reim argument as "" if you want the complete signal type name.
%%   For example if reim=="" and the first output port is real and complex,
%%   the data type  name placed in dtname will be creal_T:
%%      %assign dtname = LibBlockOutputSignalDataTypeName(0x,"")
%%
%%   Specify the reim argument as tRealPart if you want the raw element type
%%   name. For example if reim==tRealPart and the first output port is real
%%   and complex, the data type name returned will be real_T.
%%      %assign dtname = LibBlockOutputSignalDataTypeName(0,tRealPart)
%%
%function LibBlockOutputSignalAliasedThruDataTypeName(portIdx, reim) void
  %% See Also:
  %%   LibBlockOutputSignalDataTypeId, LibBlockInputSignalDataTypeName,
  %%   LibBlockParameterDataTypeName
  %%
  %assign op = FcnGetOutputPortRecord(portIdx)
  %if (IDNUM(op.SignalSrc[0])[0] == "F") %% FcnCall
    %return ""
  %else
    %return LibGetRecordAliasedThruDataTypeName(op, reim)
  %endif
%endfunction %% LibBlockOutputSignalAliasedThruDataTypeName

%% Function: LibBlockOutputSignalIsNonConstExpr ================================
%% Abstract:
%%   Returns 1 (true) if the output signal is an expression, and 0 (false)
%%   otherwise.
%%
%function LibBlockOutputSignalIsNonConstExpr(portIdx) void
  %if GeneratingOutputsCode
    %return LibBlockOutputSignalIsExprInOutputs(portIdx) && ...
      ! LibBlockOutputSignalIsConstExpr(portIdx)
  %else
    %return 0
  %endif
%endfunction


%% Function: LibBlockOutputSignalIsExpr ========================================
%% Abstract:
%%   Returns 1 (true) if the output signal is an expression, and 0 (false)
%%   otherwise.
%%
%function LibBlockOutputSignalIsExpr(portIdx) void
  %if GeneratingOutputsCode
    %return LibBlockOutputSignalIsExprInOutputs(portIdx)
  %else
    %return 0
  %endif
%endfunction

%% Function: LibBlockAllOutputSignalsAreExpr =================================
%% Abstract:
%%   Returns 1 (true) if all output signals are expressions, and 0 (false)
%%   otherwise.
%%
%function LibBlockAllOutputSignalsAreExpr() void
  %if Type == "Opaque"
    %return 0
  %elseif NumDataOutputPorts >= 1
    %foreach opIdx = NumDataOutputPorts
      %if !LibBlockOutputSignalIsExpr(opIdx)
	%return 0
      %endif
    %endforeach
    %return 1
  %else
    %return 0
  %endif
%endfunction

%% Function: LibBlockSomeOutputSignalIsExpr =================================
%% Abstract:
%%   Returns 1 (true) if some output signal is an expressions, and 0 (false)
%%   otherwise.
%%
%function LibBlockSomeOutputSignalIsExpr() void
  %foreach opIdx = NumDataOutputPorts
    %if LibBlockOutputSignalIsExpr(opIdx)
      %return 1
    %endif
  %endforeach
  %return 0
%endfunction

%% Function: LibBlockOutputSignalIsExprInOutputs ===============================
%% Abstract:
%%   Returns 1 (true) if the output signal is an expression in the outputs
%%   function, and 0 (false) otherwise.  This function is used as a low level
%%   utility to get access to what the value will be when generating the
%%   block's outputs code.  Should be used in BlockInstanceSetup function.
%%
%function LibBlockOutputSignalIsExprInOutputs(portIdx) void
  %if NumDataOutputPorts >= 1
    %return DataOutputPort[portIdx].OutputExpression
  %else
    %return 0
  %endif
%endfunction


%% Function: SLibSetBlockNonConstOutputSignalIsNotExpr ======================
%% Abstract:
%%   For each block output that is not a constant expression, force the
%%   output into a variable.
%%   This routine is used to turn off nonconst expressions in TLC
%%   when the TLC implementation of this block doesn't support nonconst output
%%   expressions, or ultimately when the TLC implementation of a 
%%   destination block does not accept (nonconst) output expressions
%%   This cannot be used to turn off a constant output expression
%%
%function SLibSetBlockNonConstOutputSignalIsNotExpr(block, opIdx) void
  %with block
      %if DataOutputPort[opIdx].OutputExpression == 1 && ...
	!LibBlockOutputSignalIsConstExpr(opIdx)
	%assign DataOutputPort[opIdx].OutputExpression = 0
	%assign DataOutputPort[opIdx].TrivialOutputExpression = 0
      %endif
  %endwith
%endfunction

%% Function: SLibSetBlockOutputSignalsAreNotExpr ===============================
%% Abstract:
%%   Force each block output into a variable.
%%   This routine is used to turn off output expressions in TLC
%%   when the TLC implementation of this block doesn't support output
%%   expressions, or ultimately when the TLC implementation of a 
%%   destination block does not accept output expressions
%%
%function SLibSetBlockOutputSignalsAreNotExpr(block) void
  %with block
    %foreach opIdx = NumDataOutputPorts
      %if DataOutputPort[opIdx].OutputExpression == 1
	%%
	%%
	%% NOTICE: Constant expressions are predetermined in the Simulink 
	%%         engine and can not be switched off using TLC. This is due to 
	%%         significant code generation speed penalty if the constant
	%%         expressions would be configurable in TLC.
	%%
	%assign op = DataOutputPort[opIdx]
	%if (IDNUM(op.SignalSrc[0])[0] != "C")
	  %assign DataOutputPort[opIdx].OutputExpression = 0
	  %assign DataOutputPort[opIdx].TrivialOutputExpression = 0
	%endif
      %endif
    %endforeach
  %endwith
%endfunction

%% DocFunction{Output Signal Functions}: LibBlockOutputSignalSampleTime ========
%% Abstract:
%%   Returns the sample time corresponding to the specified block output
%%   port.
%%
%function LibBlockOutputSignalSampleTime(portIdx) void
  %% See Also:
  %%      LibBlockOutputSignalSampleTime, LibBlockOutputSignalSampleTimeIndex,
  %%      LibBlockInputSignalOffsetTime
  %%

  %if EXISTS("OutputPortSampleTimes")
    %assign idx = OutputPortSampleTimes[portIdx]
  %else
    %%START_ASSERT
    %assign errTxt = "SampleTime is not contained within the specified record"
    %<LibBlockReportError([],errTxt)>
    %%END_ASSERT
  %endif
  %return idx
%endfunction %% LibBlockOutputSignalSampleTime


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalOffsetTime ========
%% Abstract:
%%   Returns the offset time corresponding to the specified block output
%%   port.
%%
%function LibBlockOutputSignalOffsetTime(portIdx) void
  %% See Also:
  %%      LibBlockOutputSignalOffsetTime, LibBlockOutputSignalSampleTimeIndex,
  %%      LibBlockInputSignalSampleTime
  %%

  %if EXISTS("OutputPortOffsetTimes")
    %assign idx = OutputPortOffsetTimes[portIdx]
  %else
    %%START_ASSERT
    %assign errTxt = "OffsetTime is not contained within the specified record"
    %<LibBlockReportError([],errTxt)>
    %%END_ASSERT
  %endif
  %return idx
%endfunction %% LibBlockOutputSignalOffsetTime


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalSampleTimeIndex ===
%% Abstract:
%%   Returns the sample time index corresponding to the specified block output
%%   port.
%%
%function LibBlockOutputSignalSampleTimeIndex(portIdx) void
  %% See Also:
  %%      LibBlockOutputSignalSampleTimeIndex, LibBlockOutputSignalSampleTime,
  %%      LibBlockInputSignalOffsetTime
  %%

  %if EXISTS("OutputPortTIDs")
    %assign idx = OutputPortTIDs[portIdx]
  %else
    %%START_ASSERT
    %assign errTxt = "SampleTimeIndex is not contained within the specified record"
    %<LibBlockReportError([],errTxt)>
    %%END_ASSERT
  %endif
  %return idx
%endfunction %% LibBlockOutputSignalSampleTimeIndex


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalLocalSampleTimeIndex
%% Abstract:
%%   Returns the local sample time index corresponding to the specified block
%%   output port.
%%
%function LibBlockOutputSignalLocalSampleTimeIndex(portIdx) void
  %% See Also:
  %%      LibBlockOutputSignalSampleTimeIndex, LibBlockOutputSignalSampleTime,
  %%      LibBlockOutputSignalOffsetTime,
  %%      LibBlockOutputSignalLocalSampleTimeIndex
  %%
  %if EXISTS("OutputPortLocalTIDs")
    %assign idx = OutputPortLocalTIDs[portIdx]
  %else
    %%START_ASSERT
    %assign errTxt = "LocalSampleTimeIndex is not contained within the specified record"
    %<LibBlockReportError([],errTxt)>
    %%END_ASSERT
  %endif
  %return idx
%endfunction %% LibBlockOutputSignalLocalSampleTimeIndex


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalConnected =========
%% Abstract:
%%   Returns 1 if the specified output port is connected to a block other than 
%%   the Terminator block and 0 otherwise.
%%
%function LibBlockOutputSignalConnected(portIdx) void
  %% See Also:
  %%      LibBlockInputSignalConnected
  %%
  %if EXISTS("Connections.OutputPortConnected")
    %assign connected = (Connections.OutputPortConnected[portIdx] == "yes")
  %else
    %%START_ASSERT
    %assign errTxt = "OutputPortConnected is not contained within the specified record"
    %<LibBlockReportError([],errTxt)>
    %%END_ASSERT
  %endif
  %return connected
%endfunction %% LibBlockOutputSignalConnected


%% DocFunction{Output Signal Functions}: LibBlockOutputSignalBeingMerged========
%% Abstract:
%%   Returns whether the specified output port is connected to a merge
%%   block
%%
%function LibBlockOutputSignalBeingMerged(portIdx) void
  %% See Also:
  %%      LibBlockInputSignalConnected
  %%
  %if EXISTS("Connections.OutputPortBeingMerged")
    %assign connected = (Connections.OutputPortBeingMerged[portIdx] == "yes")
  %else
    %%START_ASSERT
    %assign errTxt = "OutputPortBeingMerged is not contained within the specified record"
    %<LibBlockReportError([],errTxt)>
    %%END_ASSERT
  %endif
  %return connected
%endfunction %% LibBlockOutputSignalBeingMerged


%% DocFunction{Advanced Functions}: LibBlockOutputSignalStorageClass ===========
%% Abstract:
%%   Returns the storage class of the block's specified output signal.
%%   The storage class can be "Auto", "ExportedSignal", "ImportedExtern",
%%   "ImportedExternPointer", "Custom".
%%
%function LibBlockOutputSignalStorageClass(portIdx) void
  %% See Also:
  %%      LibBlockInputSignalStorageClass
  %%
  %assign        op = FcnGetOutputPortRecord(portIdx)
  %assign mapSource = IDNUM(op.SignalSrc[0])[0]
  %if (mapSource == "F") %% FcnCall
    %return "FcnCall"
  %elseif (mapSource != "E")
    %return "Auto"
  %else
    %assign sigRec = SLibGetSourceRecord(op, 0)
    %return sigRec.StorageClass
  %endif
%endfunction %% LibBlockOutputSignalDataTypeName


%% DocFunction{Advanced Functions}: LibBlockOutputSignalStorageTypeQualifier ===
%% Abstract:
%%   Returns the storage type qualifier of the block's specified output
%%   signal. The type qualifier can be anything entered by the user such
%%   as "const". The default type qualifier is "Auto" - meaning do the
%%   default action.
%%
%function LibBlockOutputSignalStorageTypeQualifier(portIdx) void
  %% See Also:
  %%      LibBlockInputSignalStorageTypeQualifier
  %%
  %assign op = FcnGetOutputPortRecord(portIdx)
  %assign mapSource = IDNUM(op.SignalSrc[0])[0]
  %if (mapSource == "F") %% FcnCall
    %return "FcnCall"
  %elseif (mapSource != "E")
    %return ""
  %else
    %assign sigRec = SLibGetSourceRecord(op, 0)
    %return sigRec.StorageTypeQualifier
  %endif
%endfunction %% LibBlockOutputSignalStorageTypeQualifier


%% DocFunction{Advanced Functions}: LibBlockOutputSignalIsInBlockIO ============
%% Abstract:
%%   Returns 1 if the specified block output port exists in the global Block
%%   I/O data structure. You may need to use this if you specify
%%   ssSetOutputPortReusable(S,portIdx,TRUE) in your S-function.
%%   See matlabroot/toolbox/simulink/blocks/tlc_c/sfun_multiport.tlc.
%%
%function LibBlockOutputSignalIsInBlockIO(portIdx) void
  %assign        op = FcnGetOutputPortRecord(portIdx)
  %assign mapSource = IDNUM(op.SignalSrc[0])[0]
  
  %if mapSource != "b" && mapSource != "B" && mapSource != "y"
    %return 0
  %else
    %assign sigRec = SLibGetSourceRecord(op, 0)
    %return sigRec.RequiredInBlockIO[0]
  %endif
%endfunction %% LibBlockOutputSignalIsInBlockIO


%% DocFunction{Advanced Functions}: LibBlockOutputSignalIsValidLValue ==========
%% Abstract:
%%   Returns 1 if the specified block output port signal can be used a valid
%%   left hand side argument (lvalue) in an assignment expression, otherwise
%%   returns 0.  For example, this function returns 1 if the block output
%%   port signal is in read/write memory.
%%
%function LibBlockOutputSignalIsValidLValue(portIdx) void
  %assign        op = FcnGetOutputPortRecord(portIdx)
  %assign mapSource = IDNUM(op.SignalSrc[0])[0]
  
  %if (mapSource == "F") %% FcnCall
    %return 0
  %elseif (mapSource == "I")
    %assign sigRec = SLibGetSourceRecord(op, 0)
    %return (sigRec.DoNotConstify == 1)
  %else
    %return 1
  %endif
  
%endfunction %% LibBlockOutputSignalIsValidLValue


%% DocFunction{Advanced Functions}: LibBlockOutputSignalIsGlobal ===============
%% Abstract:
%%   Returns 1 if the specified block output port signal is declared in the
%%   global scope, otherwise returns 0.
%%
%%   If this function returns 1, then the variable holding this signal is
%%   accessible from any where in generated code. For example, this function
%%   returns 1 for signals that are test points, external or invariant.
%%
%function LibBlockOutputSignalIsGlobal(portIdx) void
  %assign        op = FcnGetOutputPortRecord(portIdx)
  %assign mapSource = IDNUM(op.SignalSrc[0])[0]
  
  %if (mapSource == "L" || mapSource == "C" || mapSource == "F")
    %return 0
  %else
    %return 1
  %endif
%endfunction %% LibBlockOutputSignalIsGlobal

%% SLibBlockSystemToCallForOutput ==============================================
%% Abstract:
%%   Returns the conditionally executed system to call for the input port.
%%
%function SLibBlockSystemToCallForOutput(portIdx) void
  %% See Also:
  %%
  %assign ip = FcnGetOutputPortRecord(portIdx)
  %return ip.SystemToCall
%endfunction %% LibBlockSystemToCallForOutput

%function FcnCheckHasSrcSignalThing(thing, validThings, funcSuffix, typeOfThing) void
  %if ...
    thing != validThings[0] && ...
    thing != validThings[1] && ...
    thing != validThings[2]
    
    %<LibBlockReportError([],"Cannot use " ...
      "LibBlockSrcSignalLocation%<funcSuffix> with %<typeOfThing> "...
      "\"%<thing>\", only with %<typeOfThing>s %<validThings>")>
  %endif
%endfunction

%function FcnCheckHasSrcSignal(loc, funcSuffix) void
  %assign validTypes =  ["EnablePort", "TriggerPort", "Inport"]
  %assign validLocs  =  ["enableblk",  "triggerblk",  "inportblk"]
  
  %<FcnCheckHasSrcSignalThing(loc,  validLocs,  funcSuffix, "location"  )>
  %<FcnCheckHasSrcSignalThing(Type, validTypes, funcSuffix, "block type")>
%endfunction

%% Function: LibBlockSrcSignalLocation =========================================
%% Abstract:
%%   Return reference to a source signal in a higher level subsystem. Only
%%   supported for enabport, inport and trigport blocks.
%%
%%   Allows the enable, trigger, and inport blocks to determine their input
%%   signal attributes even though they themselves have no input port.
%%   Because there is an input port at the parent subsystem level associated
%%   with the enable, trigger or inport block, this function goes to the
%%   parent subsystem to determine the input signal.
%%
%%   Specify loc as one of "inportblk", "enableblk", "triggerblk".
%%
%%   See enable block (enabport.ttlc) or inport block (inport.ttlc)
%%   implementations for usage examples.
%%
%function LibBlockSrcSignalLocation(loc, ucv, lcv, sigIdx)
  %<FcnCheckHasSrcSignal(loc, "")>
  %return LibBlockInputSignal(loc, ucv, lcv, sigIdx)
%endfunction %% LibBlockSrcSignalLocation


%% Function: LibBlockSrcSignalLocationAddr =====================================
%% Abstract:
%%   Determine address of a source signal. Only supported for enabport,
%%   inport and trigport blocks. Returns a reference to a source signal
%%   address via the higher level subsystem.
%%
%%   Specify loc as one of {"inportblk", "enableblk", "triggerblk"}
%%
%%   Allows the enable, trigger, and inport blocks to determine their input
%%   signal attributes even though they themselves have no input port.
%%   Because there is an input port at the parent subsystem level associated
%%   with the enable, trigger or inport block, this function goes to the
%%   parent subsystem to determine the input signal address.
%%
%%   See rolllib.tlc for usage examples.
%%
%function LibBlockSrcSignalLocationAddr(loc, ucv, lcv, sigIdx)
  %<FcnCheckHasSrcSignal(loc, "Addr")>
  %return LibBlockInputSignalAddr(loc, ucv, lcv, sigIdx)
%endfunction %% LibBlockSrcSignalLocationAddr


%% Function: LibBlockSrcSignalLocationStorageClass =============================
%% Abstract:
%%   Determine storage class of a source signal. Only supported for enabport,
%%   inport and trigport blocks. Returns the storage class of source signal
%%   via the higher level subsystem.
%%
%%   Specify loc as one of {"inportblk", "enableblk", "triggerblk"}
%%
%%   Allows the enable, trigger, and inport blocks to determine their input
%%   signal attributes even though they themselves have no input port.
%%   Because there is an input port at the parent subsystem level associated
%%   with the enable, trigger or inport block, this function goes to the
%%   parent subsystem to determine the input signal storage class.
%%
%%   See rolllib.tlc for usage examples.
%%
%function LibBlockSrcSignalLocationStorageClass(loc, sigIdx)
  %<FcnCheckHasSrcSignal(loc, "StorageClass")>
  %return LibBlockInputSignalStorageClass(loc, sigIdx)
%endfunction %% LibBlockSrcSignalLocationStorageClass


%% Function: LibBlockSrcSignalLocationStorageTypeQualifier =====================
%% Abstract:
%%   Determine storage type qualifier of a source signal. Only supported for
%%   enabport, inport and trigport blocks. Returns the storage class of
%%   source signal via the higher level subsystem.
%%
%%   Specify loc as one of {"inportblk", "enableblk", "triggerblk"}
%%
%%   Allows the enable, trigger, and inport blocks to determine their input
%%   signal attributes even though they themselves have no input port.
%%   Because there is an input port at the parent subsystem level associated
%%   with the enable, trigger or inport block, this function goes to the
%%   parent subsystem to determine the input signal storage type qualifier.
%%
%%   See rolllib.tlc for usage examples.
%%
%function LibBlockSrcSignalLocationStorageTypeQualifier(loc, sigIdx)
  %<FcnCheckHasSrcSignal(loc, "StorageTypeQualifier")>
  %return LibBlockInputSignalStorageTypeQualifier(loc, sigIdx)
%endfunction %% LibBlockSrcSignalLocationStorageTypeQualifier


%% DocFunction{Advanced Functions}: LibBlockSrcSignalBlock =====================
%% Abstract:
%%   Returns a reference to the block that is source of the specified block
%%   input port element. The return argument one of the following:
%%
%%      [systemIdx, blockIdx] if unique block output or block state
%%      "ExternalInput"       if external input (root inport)
%%      "Ground"              if unconnected or connected to ground
%%      "FcnCall"             if function-call output
%%      0                     if not unique (i.e. sources to a Merge block
%%                            or is a reused signal due to block I/O
%%                            optimization)
%%   Example:
%%     If you want to find the block that drives the second input on
%%     the first port of the current block.  Then, assign
%%     the input signal of this source block to the variable y.  The
%%     following code fragment does exactly this:
%%
%%     %assign srcBlock = LibBlockSrcSignalBlock(0, 1)
%%     %% Make sure that the source is a block
%%     %if TYPE(srcBlock) == "Vector"
%%       %assign sys = srcBlock[0]
%%       %assign blk = srcBlock[1]
%%       %assign block = CompiledModel.System[sys].Block[blk]
%%       %with block
%%         %assign u = LibBlockInputSignal(0, "", "", 0)
%%         y = %<u>;
%%       %endwith
%%     %endif
%%
%function LibBlockSrcSignalBlock(portIdx, sigIdx) void
  %assign ip = FcnGetInputPortRecord(portIdx)
  %assign sigRec = SLibGetSourceRecord(ip, sigIdx)
  
  %if ISEMPTY(sigRec) %% ground
    %return "Ground"
  %else
    %if !ISFIELD(sigRec,"SigSrc") || ISEMPTY(sigRec.SigSrc)
      %return 0
    %else
      %return Vector(2) [%<sigRec.SigSrc[0]>, %<sigRec.SigSrc[2]>]
    %endif
  %endif
  %% Notice that the a input signal can't have "FcnCall" as a source
  
%endfunction %% LibBlockSrcSignalBlock


%% Function: SLibExternalOutputIsVirtual =======================================
%% Abstract:
%%   Return true if root outport corresponding to a root outport block can
%%   be virtualized
%function SLibExternalOutputIsVirtual(opBlock)
  %return !MatFileLogging && ...
          !FullRootOutportVector == 1 && ...
          opBlock.ParamSettings.VirtualizableRoot == "yes" ...
	  && CodeFormat != "S-Function"
%endfunction %% SLibExternalOutputIsVirtualized  

%% Function: SLibBlockSrcSignalIsGnd ===========================================
%% Abstract:
%%   Return true if specified input signal source is ground.  Otherwise, return
%%   false.
%%
%function SLibBlockSrcSignalIsGnd(portIdx, sigIdx) void
  %assign ip    = FcnGetInputPortRecord(portIdx)
  %assign idNum = IDNUM(ip.SignalSrc[sigIdx])
  %return (idNum[0] == "G")
%endfunction


%% DocFunction{Advanced Functions}: LibBlockSrcSignalIsDiscrete ================
%% Abstract:
%%   Returns 1 if the source signal corresponding to the specified block input
%%   port element is discrete, otherwise returns 0.
%%   Note that this function also returns 0 if the driving block cannot be
%%   uniquely determined if it is a merged or reused signal (i.e. the source
%%   is a Merge block or the signal has been reused due to optimization).
%%
%function LibBlockSrcSignalIsDiscrete(portIdx, sigIdx) void

  %% See Also:
  %%      LibBlockSrcSignalBlock
  %%
  %assign tmpVect = LibBlockSrcSignalBlock(portIdx, sigIdx)
  %if TYPE(tmpVect) == "Vector"
    %assign sysIdx = tmpVect[0]
    %assign blkIdx = tmpVect[1]
    %assign srcBlk = CompiledModel.System[sysIdx].Block[blkIdx]
    %return LibIsDiscrete(srcBlk.TID)
  %else
    %return 0
  %endif

%endfunction %% LibBlockSrcSignalIsDiscrete


%% DocFunction{Advanced Functions}: LibBlockSrcSignalIsGlobalAndModifiable =====
%% Abstract:
%%   This function returns 1 of the source signal corresponding to the specified
%%   block input port element satisfies the following three conditions:
%%
%%        a) It is readable everywhere in the generated code
%%        b) It can be referenced by its address
%%        c) Its value can change (i.e. it is not declared as a "const")
%%
%%   otherwise, this function returns 0
%%
%function LibBlockSrcSignalIsGlobalAndModifiable(portIdx, sigIdx) void
  
  %assign ip = FcnGetInputPortRecord(portIdx)
  %assign mapSource = IDNUM(ip.SignalSrc[sigIdx])[0]
  
  %return (mapSource == "b" || mapSource == "B" || mapSource == "E" ||  mapSource == "y")
  
%endfunction %% LibBlockSrcSignalIsGlobalAndModifiable


%% DocFunction{Advanced Functions}: LibBlockSrcSignalIsInvariant ===============
%% Abstract:
%%   Returns 1 if the source signal corresponding to the specified block input
%%   port element is invariant (i.e. the signal does not change).
%%   For example, a source block with a constant TID (or equivalently, an
%%   infinite sample-time) would output an invariant signal.
%%
%function LibBlockSrcSignalIsInvariant(portIdx, sigIdx) void
  
  %assign ip = FcnGetInputPortRecord(portIdx)
  %assign mapSource = IDNUM(ip.SignalSrc[sigIdx])[0]
  
  %return (mapSource == "I" || mapSource == "C")
  
%endfunction %% LibBlockSrcSignalIsInvariant


%% Function: LibBlockDstSignalLocation =========================================
%% Abstract:
%%   Used by outport block to determine the destination signal location
%%   for the corresponding subsystem block output port. Input argument,
%%   loc must be "outportblk".
%%
%%   This function returns:
%%     ((%<dtype> *) ssGetOutputPortSignal(%<tSimStruct>,%<outPortNum>)) for
%%           S-Function code formats (writes directly to S-function outputs)
%%     rtY<ioq><id><idx> for all other code formats
%%     rtY.<id><idx>     - External outputs vector (driving an outport block)
%%
%function LibBlockDstSignalLocation(loc, ucv, lcv, sigIdx) void

  %% First split sigIdx into idx and reim
  %assign tmpVect = SLibGetReimAndIdx(sigIdx)
  %assign reim    = tmpVect[0]
  %assign idx     = tmpVect[1]

  %switch loc
    %case "outportblk"

      %% If the signal is not complex then the imaginary part is ""
      %if reim == tImagPart && !LibBlockInputSignalIsComplex(0)
        %return ""
      %endif
      
      %assign inputWidth = LibBlockInputSignalWidth(0)
      %assign sigIndexer = SLibGet1DArrayIndexer(inputWidth, ucv, lcv, idx)

      %if (ucv != "") || (lcv == "") || (lcv != "" && inputWidth == 1)
        %assign outPortNum = ParamSettings.PortNumber-1
        %if CodeFormat == "S-Function"
          %assign dtype = LibBlockInputSignalDataTypeName(0, "")
          %assign ans = "((%<dtype> *)"...
	    "%<RTMGetIdxed("OutputPortSignal",outPortNum)>)"
          %assign ans = ans + "[%<idx>]"
        %else
	  %assign ::BlockFcnAccessed.Y = 1
	  %assign ans = "%<tOutput>%<YQualifier>%<Identifier>%<sigIndexer>"
	  %if MultiInstanceERTCode && ...
	    !RootIOStructures && ...
	    LibBlockInputSignalWidth(0) == 1
            %assign ans = "(*%<ans>)"
          %endif
	  %assign extOut = ExternalOutputs.ExternalOutput[outPortNum]
	  %<LibAccessArg(extOut)>
        %endif
      %else
        %% rolling
        %assign ans = "y0%<sigIndexer>"
      %endif

      %if LibBlockInputSignalIsComplex(0) && reim != ""
        %assign ans = ans + ".%<reim>"
      %endif

      %return ans
    %default
      %%START_ASSERT
      %assign errTxt = "Invalid location '%<loc>' specified."
      %%END_ASSERT
      %<LibBlockReportError([],errTxt)>
  %endswitch %% loc

%endfunction %% LibBlockDstSignalLocation


%%-----------------------------------------%
%% Local Functions used only in this file. %
%%-----------------------------------------%


%% Function: FcnGetInputPortRecord =============================================
%% Abstract:
%%   For the given input port index, return a reference to the corresponding
%%   data input port record (DataInputPort[i]). The inport blocks are
%%   handled by mapping back to the corresponding subsystem data input port
%%   record.
%%
%function FcnGetInputPortRecord(portIdx) void

  %if TYPE(portIdx) == "String"
    %switch(portIdx)
      %case "inportblk"
        %if Type != "Inport"
	  %%START_ASSERT
          %assign errTxt = "Request made for an inport port block " ...
            "port, but this is not the inport port block."
          %<LibBlockReportError([],errTxt)>
	  %%END_ASSERT
        %endif	        
	%assign ip = HiddenDataInputPort[0]
	%break

      %case "enableblk"
        %if Type != "EnablePort"
	  %%START_ASSERT
          %assign errTxt = "Request made for an enable port block " ...
            "port, but this is not the enable port block."
          %<LibBlockReportError([],errTxt)>
	  %%END_ASSERT
        %endif
	%assign ip = HiddenControlInputPort[0]
        %break

      %case "enable"
        %assign ip = ControlInputPort[0]
        %if ip.Type != "enable"
	  %%START_ASSERT
          %assign errTxt = "Request made for a subsystem %<portIdx> port " ...
            "where one does not exist."
          %<LibBlockReportError([],errTxt)>
	  %%END_ASSERT
        %endif
        %break

      %case "trigger"
        %assign ip = ControlInputPort[NumControlInputPorts-1]
        %if ip.Type != "trigger"
	  %%START_ASSERT
          %assign errTxt = "Request made for a subsystem %<portIdx> port " ...
            "where one does not exist."
          %<LibBlockReportError([],errTxt)>
	  %%END_ASSERT
        %endif
        %break

      %default
	%%START_ASSERT
        %assign errTxt = "Unhandled port type '%<TYPE(portIdx)>'."
        %<LibBlockReportError([],errTxt)>
	%%END_ASSERT
    %endswitch
  %else
    %if portIdx >= 0 && portIdx < NumDataInputPorts
      %assign ip = DataInputPort[portIdx]
    %else
        %assign errTxt = "The specified port index '%<TYPE(portIdx)>' " ...
          "should be a number between 0 and %<NumDataInputPorts-1>."
        %<LibBlockReportError([],errTxt)>
    %endif
  %endif

  %return ip

%endfunction %% FcnGetInputPortRecord


%% Function: FcnGetOutputPortRecord ============================================
%% Abstract:
%%   For the given output port index, return a reference to the corresponding
%%   data output port record (DataOutputPort[i]).
%%
%function FcnGetOutputPortRecord(portIdx) void
  %if portIdx >= 0 && portIdx < NumDataOutputPorts
    %assign op = DataOutputPort[portIdx]
  %else
    %assign errTxt = "The specified port index '%<TYPE(portIdx)>' " ...
      "should be a number between 0 and %<NumDataOutputPorts-1>."
      %<LibBlockReportError([],errTxt)>
  %endif

  %return op

%endfunction %% FcnGetOutputPortRecord


%% Function: SLibGetMapSrcAndMapIdx ============================================
%% Abstract:
%%   Return [%<src>, %<srcidx>] for the specified port and 
%%   signalOffset
%%
%function SLibGetMapSrcAndMapIdx(port, sigIdx)
    %if port.Width > 1
      %assign idNum = IDNUM(port.SignalSrc[sigIdx])
    %else
      %assign idNum = IDNUM(port.SignalSrc[0])
    %endif
    %return idNum
%endfunction %% SLibGetMapSrcAndMapIdx()


%% Function: FcnGetMapSrcAndMapIdx =============================================
%% Abstract:
%%   Return [%<src>, %<srcidx>] for the specified input port signal index
%%   (sigIdx).
%%
%function FcnGetMapSrcAndMapIdx(portIdx, sigIdx) void
  %assign ip = FcnGetInputPortRecord(portIdx)
  
  %% find map ID, and scalar expanded if necessary
  %return SLibGetMapSrcAndMapIdx(ip, sigIdx)

%endfunction %% FcnGetMapSrcAndMapIdx


%% Function: FcnGetBasicSignalReference ========================================
%% Abstract:
%%
%%   This is the 'guts' of FcnGetInputOrOutputSignal when we are not
%%   truly rolling in C and is always the body for Ada. Its purpose
%%   is to provide a valid signal reference for the specified mapSource
%%   (e.g. block I/O: "B") and mapIndex (e.g. 25th logical element in the 
%%   block I/O vector).
%%
%function FcnGetBasicSignalReference(sigRecAndMapInfo, portWidth, reim, ...
                                     bInput, bAddr, isComplex, ucv, lcv) void
				     
  %assign sigRec      = sigRecAndMapInfo.sigRec
  %assign mapSource   = sigRecAndMapInfo.mapSrc
  %assign mapIdx      = sigRecAndMapInfo.mapIdx
  %assign sigSrcWidth = sigRec.Width
  %assign sigOffset   = sigRecAndMapInfo.signalOffset
  
  %%
  %assign returnBaseAddr = (sigOffset == 0 && ucv == "" && lcv == "" && bAddr && portWidth > 1 && sigSrcWidth == portWidth)
  %%
  %%-------------------------------------------------------------%
  %% Returning a reference to a block I/O, input or state signal %
  %%-------------------------------------------------------------%

  %%
  %% Locate the the block record that is driving (input
  %% signal source) or generates (output signal) this signal.
  %%
  %% Notes:
  %%   1) For input signal sources, the blkOut connection may
  %%      be have a non-zero offset (sigOffset). This occurs in
  %%      cases like:
  %%
  %%        .-----------.         .---------.      .-------.
  %%        | sin(1:10) |-------->| Sel 3:6 |----->| block |
  %%        `-----------'         `---------'      `-------'
  %%
  %%      In this example, the blkIOSlotWidth is 10 and the input port
  %%      width to the block is 4 with an offset of 3.
  %%
  %%   2) For output signals, we can have a non-zero offset
  %%      due to merge blocks.
  %%
  %%
  %% Generate the signal indexer (sigIndexer)
  %%
  
  %if bInput && sigSrcWidth > 1 && portWidth == 1
    %%
    %% This occurs in cases like:
    %%
    %%                     .-------.
    %%  .----------.       |       |
    %%  | sin(1:2) |------>| demux |           .-------.
    %%  `----------'       |       |---------->| block |
    %%                     `-------'           `-------'
    %%
    %%  The input width to block is 1, yet the sigSrcWidth it is
    %%  connected to is > 1. In this case we need to return a
    %%  index of the form rtB.sigout[1].
    %%
    %assign sigIndexer = SLibGet1DArrayIndexer(sigSrcWidth, ...
      "", "",  sigOffset)
    %assign lcv      = ""
  %else
    %%if returnBaseAddr
    %%assign sigIndexer = ""
    %%else
    %assign sigIndexer = SLibGet1DArrayIndexer(sigSrcWidth, ...
      ucv, lcv, sigOffset)
    %%endif
  %endif
  
  %%--------------------------------------------------%
  %% Special handling for the different record types  %
  %%--------------------------------------------------%
  
  %if !ISEMPTY(sigRecAndMapInfo.identi)
    %if reim != "" && isComplex
      %assign rm = ".%<reim>"
    %else
      %assign rm = ""
    %endif
    %if bAddr
      %%
      %if returnBaseAddr
	%return sigRecAndMapInfo.identi
      %else
	%return "&%<sigRecAndMapInfo.identi>%<sigIndexer>"
      %endif
      %%
    %else
      %return "%<sigRecAndMapInfo.identi>%<sigIndexer>%<rm>"
    %endif
  %endif
  
  %assign storageClass = sigRec.StorageClass
  
  %switch (mapSource)
    %case "C"
      %% 
      %% An example of this is:
      %%
      %%    .--------------.       .-------.
      %%    | constant 1:5 |------>| block |
      %%    `--------------'       `-------'
      %%
      %assign sysRef = System[sigRec.SigSrc[0]]
      %assign blkRef = sysRef.Block[sigRec.SigSrc[2]]
      %assign oPort  = sigRec.SigSrc[3]
      
      %if !bInput
	%% constExpr is turned off when connected to a merge
	%% block.  Therefore, there is no concept of an offset for
	%% a constExpr output signal
	%assign sigOffset = 0
      %endif
      
      %assign sigIdx = "%<reim>%<sigOffset>"
      
      %if sigOffset != 0
	%if ucv != ""
	  %assign ucv    = "%<ucv>+%<sigOffset>"
	  %assign sigIdx = "%<reim>0"
	%elseif lcv != ""
	  %assign lcv    = "%<lcv>+%<sigOffset>"
	  %assign sigIdx = "%<reim>0"
	%endif
      %endif

      %% Update expression comment
      %if GeneratingOutputsCode
	%<FcnAddToExprCommentList(blkRef, oPort)>

	%assign blkRef.ExprCommentSrcIdx.SysIdx = -1
	%assign blkRef.ExprCommentSrcIdx.BlkIdx = -1
      %endif
      
      %assign retSignal = SLibBlockOutputSignal(blkRef,sysRef,oPort,...
	ucv,lcv,sigIdx, bAddr ? "SignalAddr" : "Signal")
      
      %%--------------%%
      %% early return %%
      %%--------------%%
      %return retSignal
      
    %case "E"
      %% external signal

      %if storageClass == "Custom"
	%return LibCustomData(sigRec, bAddr ? "address" : "contents", ...
	  sigIndexer,reim)
      %else
	%assign retSignalWithOutIndexer = sigRec.Identifier
      %endif

      %if reim != "" && isComplex
	%% The real or imaginary part of a complex signal is
	%% requested.  For now, disallow imported complex block
	%% signals since we don't know how to dereference them.
	%if storageClass == "ImportedExtern" || ...
	  storageClass == "ImportedExternPointer"
	  %assign errTxt = ...
	    "Imported complex signals not supported: " + ...
	    retSignalWithOutIndexer
	  %<LibBlockReportError([],errTxt)>
	%endif
      %endif
      
      %assign retSignal = retSignalWithOutIndexer + sigIndexer
      
      %%
      %% Finally, if we got here, decorate the return signal as needed
      %%
      %if reim != "" && isComplex
        %assign retSignal = retSignal + ".%<reim>"
      %endif
      
      %break
      
    %case "I" %% This is an invariant signal, get its identifier.
      
      %if !sigRec.RequiredInConstBlockIO && !GeneratingDeadCode
	%assign sigRec.RequiredInConstBlockIO = 1
	%assign blkOutsRec = CompiledModel.BlockOutputs
	%assign blkOutsRec.NumSignalsInConstBlockIO = ...
	  blkOutsRec.NumSignalsInConstBlockIO + 1
      %endif
      %%
      %% Constant block IO structure handling
      %%
      %%
      %% see the comment in SLibGetSourceRecordAndMapInfo
      %% for more information on this.  Basically, a block inside
      %% a nonreusable function is reading from the const blockIO
      %% of it's reusable parent.
      %assign accessSysIdx = System[SystemIdx].HStructDeclSystemIdx
      %assign identiPath = FcnGetConstBlockIOPathHelper(sigRec.SigSrc[0], ...
	sigRec.SigSrc[1], accessSysIdx, CrossNoArgFcnBound)
      %assign retSignalWithOutIndexer = identiPath + sigRec.Identifier
      
      %assign retSignal = retSignalWithOutIndexer + sigIndexer
      
      %%
      %% Finally, if we got here, decorate the return signal as needed
      %%
      %if reim != "" && isComplex
        %assign retSignal = retSignal + ".%<reim>"
      %endif
      
      %break
      
    %case "D" %% Discrete State
      %assign signalName = tDWork + DWorkQualifier + sigRec.Identifier
      %assign  retSignal = signalName + sigIndexer
      %break
      
    %case "X" %% Continuous State
      %assign signalName = tContState + XQualifier + sigRec.Identifier
      %assign  retSignal = signalName + sigIndexer
      %break
      
    %case "U"
      %%--------------------------------------------%
      %% Returning a reference to an external input %
      %%--------------------------------------------%      
  
      %% Update expression comment
      %if GeneratingOutputsCode
	%if Type != "Opaque"
	  %assign commSysIdx = ExprCommentSrcIdx.SysIdx
	  %assign commBlkIdx = ExprCommentSrcIdx.BlkIdx
	  %if commSysIdx != -1 && commBlkIdx != -1
	    %assign commInfo = System[commSysIdx].Block[commBlkIdx].ExprCommentInfo
	  %else
	    %assign commInfo = ExprCommentInfo
	  %endif
	%else
	  %assign commInfo = ExprCommentInfo
	%endif
	%<SLibAddToExprCommentList(commInfo,sigRec,0)>
      %endif

      %if storageClass != "Auto"
        %% external signal
        %%
        %% S-functions do not support external i/o
        %%
        %if CodeFormat == "S-Function"
          %assign errTxt = "The S-Function code format only supports " ...
            "'Auto' storage class for root inport signals.  Signal " ...
            "%<sigRec.Identifier> specifies: %<storageClass>."
          %<LibReportError(errTxt)>
        %endif
        %if storageClass == "Custom"
          %return LibCustomData(sigRec, bAddr ? "address" : "contents", ...
	    sigIndexer, reim)
        %endif
        %assign retSignal = "%<sigRec.Identifier>%<sigIndexer>"
        %if reim != ""
          %% The real or imaginary part of a complex signal is
          %% requested.  For now, disallow imported complex block
          %% signals since we don't know how to dereference them.
          %if storageClass == "ImportedExtern" || ...
            storageClass == "ImportedExternPointer"
            %assign errTxt = ...
              "Imported complex signals not supported: %<retSignal>."
            %<LibReportError(errTxt)>
          %else
            %assign retSignal = retSignal + ".%<reim>"
          %endif
        %endif
      %else
        %% Normal RTW signal or the Accelerator version of the S-function
	%% target. The Accelerator doesn't need the 'ssGetInputPortSignalPtrs
	%% because the inputs only exist at the root model window.
        %if CodeFormat != "S-Function" || Accelerator
	  %assign ::BlockFcnAccessed.U = 1
	  %assign dataTypeId = SLibGetRecordDataTypeId(sigRec)
	  %assign structType = LibIsStructDataType(dataTypeId)
	  %if MultiInstanceERTCode && ...
	    structType && ...
	    !RootIOStructures
	    %assign retSignal = ...
	      "(*%<tInput>%<UQualifier>%<sigRec.Identifier>)%<sigIndexer>"
	  %else
	    %assign retSignal = ...
	      "%<tInput>%<UQualifier>%<sigRec.Identifier>%<sigIndexer>"
	  %endif
	  %if reim != ""
            %assign retSignal = retSignal + ".%<reim>"
          %endif
        %else %% s-function target
          %assign dataType = SLibGetRecordDataTypeName(sigRec, "")
	  %assign sigIndexer = (sigIndexer == "") ? "[0]" : sigIndexer

	  %assign retSignalPtr = "((const %<dataType>**)"...
	    "ssGetInputPortSignalPtrs(%<tSimStruct>, %<mapIdx>))%<sigIndexer>"

          %if reim != ""
            %assign retSignal = "(%<retSignalPtr>->%<reim>)"
          %else
            %assign retSignal = "(*(%<retSignalPtr>))"
          %endif
        %endif
      %endif
      
      %break
      
    %case "G"
    %default  
      %<LibReportError("Unexpected map source  %<mapSource>")>
  %endswitch %% mapSource
  
  %if bAddr && ...
    ((storageClass != "ImportedExternPointer") || (sigSrcWidth > 1)) 
    %assign retSignal = "&" + retSignal
  %endif
  
  %return retSignal

%endfunction %% end FcnGetBasicSignalReference

%% Function: FcnGetGroundSignalReference =======================================
%% Abstract:
%%     Returning a reference to a grounded signal
%%
%%
%function FcnGetGroundSignalReference(sigKind, iPortRec, isComplex, reim) void
  
  %switch sigKind
    %case "input"
      %if isComplex && reim == ""
	%% the complex container is required (by name)
	%assign retSignal = SLibGetGroundName(iPortRec, reim)
	%assign id        = SLibGetRecordDataTypeId(iPortRec)
	%<SLibSetDataTypeComplexGroundReqInMemory(id)>
      %else
	%% it's a non-complex ground or the real or imaginary part
	%% of a complex ground, so return the actual value
	%assign retSignal = SLibGetGroundValue(iPortRec, reim)
	%if TYPE(retSignal) != "String"
	  %% format value according to data type
	  %assign retSignal = SLibGetFormattedValue(iPortRec, retSignal)
	%endif
      %endif
      %break
      
    %case "inputAddr"
      %assign retSignal = "&" + SLibGetGroundName(iPortRec, "")
      %assign id        = SLibGetRecordDataTypeId(iPortRec)
      %if isComplex
	%<SLibSetDataTypeComplexGroundReqInMemory(id)>
      %else
	%<SLibSetDataTypeGroundReqInMemory(id)>
      %endif
      %break
      
    %default
      %% output signals can't source to ground!
      %<LibReportError("Unexpected sigKind %<sigKind>")>
  %endswitch
  
  %return retSignal
  
%endfunction %% end FcnGetGroundSignalReference

%% Function: FcnGetLocalBlockIOPath ============================================
%% Abstract:
%%   This function return the identifier path for a block IO signal.
%%   (e.g. "rtB.sub1.sub2., localB->sub1.sub2.")
%%
%% Arguments:
%%     
%%   sysIdx       - Where does the signal live ?
%%   csIdx        - Which instance do you want see ?
%%   accessSysIdx - Where do want to see the signal ?
%%
%function FcnGetLocalBlockIOPath(sysIdx, csIdx, accessSysIdx) void
  %assign cross =  System[sysIdx].CrossNoArgFcnBound
  %return FcnGetLocalBlockIOPathHelper(sysIdx, csIdx, accessSysIdx, cross)
%endfunction

%function FcnGetLocalBlockIOPathHelper(sysIdx, csIdx, accessSysIdx, cross) void
  %if sysIdx < accessSysIdx
    %assign cs = System[sysIdx].CallSites[csIdx]
    %assign ssBlk = System[cs[2]].Block[cs[3]]
    %if !SLibSystemHasOwnDataScope(System[sysIdx])
      %return  FcnGetLocalBlockIOPathHelper(cs[0], cs[1], accessSysIdx,cross)
    %else
      %return  FcnGetLocalBlockIOPathHelper(cs[0], cs[1], accessSysIdx,cross) + ...
	ssBlk.CallSiteInfo.StructId + "."
    %endif
  %else
    %<LibAccessArg(System[sysIdx].Interface.BlockIOArgDef)>
    %if (sysIdx == (NumSystems-1))
      %assign ::BlockFcnAccessed.B = 1
      %return tBlockIO + BQualifier
    %else
      %assign isMdlRefSysReg = IsModelReferenceBaseSys(System[sysIdx]) && ...
	::BlockFcn == "Registration"

      %if !isMdlRefSysReg && cross
	%<LibAccessGlobalArg(System[sysIdx].Interface.BlockIOArgDef)>
        %return "%<GetGlobalPrefix()>B_%<System[sysIdx].SystemIdx>->"
      %else
        %return "localB->"
      %endif
    %endif
  %endif
%endfunction

%% Function: FcnGetConstBlockIOPath ============================================
%% Abstract:
%%   This function return the identifier path for a invariant block IO signal.
%%   (e.g. "rtC.sub1.sub2., localC->sub1.sub2.")
%%
%% Arguments:
%%     
%%   sysIdx       - Where does the signal live ?
%%   csIdx        - Which instance do you want see ?
%%   accessSysIdx - Where do want to see the signal ?
%%
%function FcnGetConstBlockIOPath(sysIdx, csIdx, accessSysIdx) void
  %assign cross =  System[sysIdx].CrossNoArgFcnBound
  %return FcnGetConstBlockIOPathHelper(sysIdx, csIdx, accessSysIdx, cross)
%endfunction

%function FcnGetConstBlockIOPathHelper(sysIdx, csIdx, accessSysIdx, cross) void
  %if sysIdx < accessSysIdx
    %assign cs = System[sysIdx].CallSites[csIdx]
    %assign ssBlk = System[cs[2]].Block[cs[3]]
    %if !SLibSystemHasOwnDataScope(System[sysIdx])
      %return  FcnGetConstBlockIOPathHelper(cs[0], cs[1], accessSysIdx, cross)
    %else
      %return  FcnGetConstBlockIOPathHelper(cs[0], cs[1], accessSysIdx, cross) + ...
	ssBlk.CallSiteInfo.StructId + "."
    %endif
  %else
    %assign isMdlRefSys = IsModelReferenceBaseSys(System[sysIdx])
    %% Do not mark ConstBlockIOArgDef. When generating code for 
    %% model reference, ConstBlockIOArg does not appear in the fcn arg
    %if !isMdlRefSys
      %<LibAccessArg(System[sysIdx].Interface.ConstBlockIOArgDef)>
    %endif
    
    %if (sysIdx == (NumSystems-1)) || isMdlRefSys
      %return tConstBlockIOStruct + ConstBQualifier
    %else
      %if cross
	%<LibAccessGlobalArg(System[sysIdx].Interface.ConstBlockIOArgDef)>
	%return "%<GetGlobalPrefix()>C_%<System[sysIdx].SystemIdx>->"
      %else
	%return "localC->"
      %endif
    %endif
  %endif
%endfunction

%% Function: FcnGetLocalBlockIOIdentifier  =====================================
%% Abstract:
%%   This function return an relative identifier for a block IO signal declared
%%   in global memory, e.g.,
%%     suppose localB = rtB.sub1
%%   and we'd like references to signals within sub1 of the form:
%%     localB->sub2.signal
%%
%% Arguments:
%%     
%%  blkSysIdx    - Where does the signal live ? (not used yet)
%%  accessSysIdx - Where do want to see the signal?
%%  sigIdx       - Absolute BlockOutputs record index that contains 
%%                 SignalSrc from which we get the callsite index.
%%
%function FcnGetLocalBlockIOIdentifier(blkSysIdx, accessSysIdx, sigIdx) void
  %% To make sigIdx relative we would need to use:
  %% %assign idx = sigIdx + System[sysIdx].Interface.BlockIOArgDef.FirstLocation
  %assign globalBO = BlockOutputs.GlobalBlockOutput[sigIdx]
  %assign identiPath = ...
    FcnGetLocalBlockIOPath(globalBO.SigSrc[0], globalBO.SigSrc[1], accessSysIdx)
  %return identiPath + globalBO.Identifier
%endfunction

%% Function: FcnGetLocalDWorkIdentifier  =======================================
%% Abstract:
%%   This function return the identifier for a **global** DWork signal.
%%   (e.g. "rtDW.sub1.sub2.signal, localDW->sub1.sub2.signal")
%%
%% Arguments:
%%     
%%  blkSysIdx    - Where does the signal live ? (Not used yet)
%%  accessSysIdx - Where do want to see the signal ?
%%  sigIdx       - SignalSrc index (contains callsite index)
%%
%function FcnGetLocalDWorkIdentifier(blkSysIdx, accessSysIdx, sigIdx) void
  %assign dwRec = DWorks.DWork[sigIdx]
  %if dwRec.StorageClass == "Auto"
    %if CodeFormat == "S-Function" && !Accelerator
      %assign idxStr = dwRec.Width == 1 ? "[0]" : ""
      %return SLibGetGlobalDWorkIdentifier(dwRec, sigIdx) + idxStr
    %else
      %assign identiPath = ...
        FcnGetLocalDWorkPath(dwRec.SigSrc[0], dwRec.SigSrc[1], accessSysIdx)
      %return identiPath + dwRec.Identifier
    %endif
  %else
    %return ""
  %endif
%endfunction

%% Function: FcnGetLocalCStateIdentifier  =======================================
%% Abstract:
%%   This function return the identifier for a **global** CState signal.
%%   (e.g. "rtX.sub1.sub2.signal, localX->sub1.sub2.signal")
%%
%% Arguments:
%%     
%%  blkSysIdx    - Where does the signal live ? (Not used yet)
%%  accessSysIdx - Where do want to see the signal ?
%%  sigIdx       - SignalSrc index (contains callsite index)
%%
%function FcnGetLocalCStateIdentifier(blkSysIdx, accessSysIdx, sigIdx) void
  %assign csRec = CompiledModel.ContStates.ContState[sigIdx]
  %assign identiPath = ...
    FcnGetLocalCStatePath(csRec.SigSrc[0], csRec.SigSrc[1], accessSysIdx)
  %return "%<identiPath>%<csRec.Identifier>"
%endfunction

%% Function: FcnGetCanonicalInputIdentifier ====================================
%% Abstract:
%%   This function return the identifier for a canonical input or a **global** 
%%   block IO signal.
%%   (e.g. "fu0, fu1, rtB.sub1.sub2.signal, localB->sub1.sub2.signal")
%%
%% Arguments:
%%     
%% blkSysIdx    - Where does the signal live ?
%% accessSysIdx - Where do want to see the signal ?
%% canIdx       - canonical input SignalSrc index
%%
%function FcnGetCanonicalInputIdentifier(blkSysIdx, accessSysIdx, canIdx) void
  %assert accessSysIdx <= blkSysIdx
  %assign canInputArg = System[blkSysIdx].Interface.CanonicalInputArgDef[canIdx]
  %<LibAccessArg(canInputArg)>    
  %return canInputArg.Identifier
%endfunction

%% Function: FcnGetCanonicalArg ================================================
%% Abstract:
%%   Returns a identifier for a canonical input or output argument.
%%
%function FcnGetCanonicalArg(portObj, sigIdx) void
  %assign sigRecAndMapInfo = ...
    SLibGetSourceRecordAndMapInfo(portObj, sigIdx, TLC_TRUE)
  
  %assign     bAddr = TLC_FALSE
  %assign   sigType = "input" %% only needed by canonical inputs that are
                              %% connected to ground blocks or unconnected
  
  %assign portWidth = portObj.Width
  %assign    identi = sigRecAndMapInfo.identi
  
  %if portWidth > 1
    %assign sigOffset = sigRecAndMapInfo.signalOffset    
    %if !ISEMPTY(identi) && sigOffset == 0
      %return identi
    %endif
    %assign   bAddr = TLC_TRUE
    %assign sigType = "inputAddr"
  %endif
  
  %assign signalRec = sigRecAndMapInfo.sigRec
  %assign mapSource = sigRecAndMapInfo.mapSrc
  
  %if mapSource=="G" || ISEMPTY(signalRec) %% needs to be removed
    %return FcnGetGroundSignalReference(sigType, portObj, TLC_FALSE, "")
  %else
    %assign retSignal =  FcnGetBasicSignalReference(sigRecAndMapInfo, ...
      portWidth, "", TLC_TRUE, bAddr, TLC_FALSE, "", "")
  
    %if signalRec.StorageClass == "ImportedExternPointer"
      %assert !bAddr
      %if signalRec.Width == 1
	%assign retSignal = "(*%<retSignal>)"
      %endif
    %endif
  
    %return retSignal
  %endif
  
%endfunction


%% Function: ReAssignLocalBlockOutputTID =======================================
%% Abstract:
%%   This function sets al TID's of a local block output.
%%   The TID in the local block output is a superset of the TID needed to
%%   declare the local variables in each rate where the variable appears.
%%   This function prunes not needed TID elements of the local block outputs
%%   TID vector and assigns a TID for every triggerd block output.
%%
%function ReAssignLocalBlockOutputTID(localBO) void
  %if SLibIsRateGrouping()
    %if TYPE(CurrentTID) == "Number" && CurrentTID == -1
      %% don't change localBO.TID if CurrenTID is -1 
    %elseif !ISEQUAL(localBO.TID, CurrentTID)
      %assign temp = []
      %foreach i = NumSampleTimes
	%assign temp = temp + 0
      %endforeach

      %if TYPE(localBO.TID) == "Vector"
	%foreach i = SIZE(localBO.TID,1)
	  %assign idx = (localBO.TID[i] > 0) ? localBO.TID[i] : 0
	  %assign temp[idx] = 1
	%endforeach
      %endif
      %if TYPE(CurrentTID) == "Number"
	%assign temp[CurrentTID] =1 
      %elseif TYPE(CurrentTID) == "Vector"
	%foreach i = SIZE(CurrentTID,1)
	  %assign idx = (CurrentTID[i] > 0) ? CurrentTID[i] : 0
	  %assign temp[idx] = 1
	%endforeach
      %endif
      %assign localBO.TID = []
      %foreach i = NumSampleTimes
	%if temp[i] == 1
	  %assign localBO.TID = localBO.TID + i
	%endif
      %endforeach
    %endif
  %endif
%endfunction


%% Function: SLibGetSourceRecordAndMapInfo =====================================
%% Abstract:
%%     This function takes a port object and port signal index as a argument
%%     and returns a signal record and .
%%
%%     bReturnIdentfier - does the function caller needs to know the
%%                        signal identifier string ??
%%
%function SLibGetSourceRecordAndMapInfo(portObj, sigIdx, bReturnIdentfier) void
  
  %createrecord rec {mapSrc "";mapIdx -1;sigRec [];signalOffset -1;identi ""}
    
  %if portObj.Width > 1
    %assign lSigIdx = sigIdx
  %else
    %assign lSigIdx = 0
  %endif
  
  %assign sigRecEmpty = TLC_TRUE
  %assign       idNum = IDNUM(portObj.SignalSrc[lSigIdx])
  %assign      offset = portObj.SignalOffset[lSigIdx]
    
  %% translate relative into absolute positions
  %switch (idNum[0])
    %case "L"
      %assign     localBO = BlockOutputs.LocalBlockOutput[idNum[1]]
      %assign  rec.sigRec = localBO
      %assign  rec.mapSrc = "b"
      %assign sigRecEmpty = TLC_FALSE
      %%
      %if bReturnIdentfier
	%assign localBO.DeclareInFcnScope = 1
	%<ReAssignLocalBlockOutputTID(localBO)>
	%assign rec.identi = tLocalBlockIO + "_" + localBO.Identifier
      %endif
      %break
    %%
    %% Global block IO structure handling
    %%
    %case "b" %% global block IO index
      %assign    globalBO = BlockOutputs.GlobalBlockOutput[idNum[1]]
      %assign  rec.sigRec = globalBO
      %assign  rec.mapSrc = "b"
      %assign sigRecEmpty = TLC_FALSE
      %%
      %if bReturnIdentfier
	%% where the signal is accessed
        %% For example,
        %%
        %%    gainA -> [ O->gainB->O]
        %%                ^
        %%                |
        %%          nonreusable function
        %% then LibBlockInputSignal for gainB needs to know that
        %% is crossed the nonreused boundary to generate the correct
        %% path.
	%if globalBO.OwnerSysIdx[0] != -1 %% default
	  %assign thisSysIdx  = globalBO.OwnerSysIdx[0]
	  %assign thisInstance = globalBO.OwnerSysIdx[1]
	%else
	  %assign thisSysIdx  = globalBO.SigSrc[0]
	  %assign thisInstance = globalBO.SigSrc[1]
	%endif
        %assign accessSysIdx = System[SystemIdx].HStructDeclSystemIdx
        %assign identiPath = FcnGetLocalBlockIOPathHelper(thisSysIdx, ...
          thisInstance, accessSysIdx, CrossNoArgFcnBound)
        %assign   rec.identi = identiPath + globalBO.Identifier
      %endif
      %break
    %%  
    %% Canonical inputs handling (system level inputs)
    %%
    %case "u" 
      %assign   blkSysIdx = System[BlockIdx[1]].HStructDeclSystemIdx
      %assign   interface = System[blkSysIdx].Interface
      %assign canInputArg = interface.CanonicalInputArgDef[idNum[1]]
      
      %if ISFIELD(portObj,"RecordType") &&  ...
	portObj.RecordType == "ControlInputPort"
	%% See engine_blksNS/tsubsys (msubsys5). Connect Enable port to
	%% a root inport block
	%assign cross =  System[BlockIdx[1]].CrossNoArgFcnBound
      %else
	%% See example in modelref/basic/tblockio lvlTwo25
	%assign cross =  System[BlockIdx[0]].CrossNoArgFcnBound
      %endif
      
      %%
      %if bReturnIdentfier
	%% where the signal is accessed
	%assert System[SystemIdx].HStructDeclSystemIdx <= blkSysIdx
	%if !cross
          %assign rec.identi = canInputArg.Identifier
        %else
          %<LibAccessGlobalArg(canInputArg)>
          %assign rec.identi = GetGlobalPrefix() + "_" + canInputArg.Identifier + "_%<blkSysIdx>"
        %endif
	%if canInputArg.ScalarPassByRef == "yes"
	  %assign rec.identi = "(*%<rec.identi>)"
	%endif
	%<LibAccessArg(canInputArg)>
	%assign  rec.sigRec = canInputArg
	%assign  rec.mapSrc = "u"
	%assign sigRecEmpty = TLC_FALSE
      %else
	%assign        idNum = IDNUM(canInputArg.SignalSrc[0])    
	%assign    mapSource = idNum[0]
	%assign     mapIndex = idNum[1]
      %endif
      %%
      %break
    %case "y" %% system level output
      %assign   blkSysIdx = System[BlockIdx[1]].HStructDeclSystemIdx
      %assign   interface = System[blkSysIdx].Interface
      %assign canOutputArg = interface.CanonicalOutputArgDef[idNum[1]]
      %if ISFIELD(portObj,"RecordType") &&  ...
	portObj.RecordType == "ControlInputPort"
	%% See engine_blksNS/tsubsys (msubsys5)
	%% Since each enable subsystems accesses its enable port inside
	%% the system function, the cross flag must be basded on the 
	%% sysIdx of the subsystem itself.
	%assign cross =  System[BlockIdx[1]].CrossNoArgFcnBound
      %else
	%% See example in modelref/basic/tblockio lvlTwo25
	%assign cross =  System[BlockIdx[0]].CrossNoArgFcnBound
      %endif
      %% 
      %if bReturnIdentfier
	%% where the signal is accessed
	%assert System[SystemIdx].HStructDeclSystemIdx <= blkSysIdx
        %if !cross
          %if canOutputArg.Width == 1 
            %assign rec.identi = "(*" + canOutputArg.Identifier + ")"
          %else
            %assign rec.identi = canOutputArg.Identifier
          %endif
        %else
          %<LibAccessGlobalArg(canOutputArg)>
          %if canOutputArg.Width == 1 
            %assign rec.identi = "(*%<GetGlobalPrefix()>_" + canOutputArg.Identifier + "_%<blkSysIdx>)"
          %else 
            %assign rec.identi = "%<GetGlobalPrefix()>_" + canOutputArg.Identifier + "_%<blkSysIdx>"
          %endif
        %endif
	%<LibAccessArg(canOutputArg)>
	%assign  rec.sigRec = canOutputArg
	%assign  rec.mapSrc = "y"
	%assign sigRecEmpty = TLC_FALSE
      %else
	%assign        idNum = IDNUM(canOutputArg.SignalSrc[0])    
	%assign    mapSource = idNum[0]
	%assign     mapIndex = idNum[1]
      %endif
      %%
      %break
    %case "d" %% local DWork index
      %if bReturnIdentfier
	%assign blkSysIdx    = BlockIdx[0]   %% where the signal is created
	%assign accessSysIdx = System[SystemIdx].HStructDeclSystemIdx
	%% where the signal is accessed
	%assign rec.identi = ...
	  FcnGetLocalDWorkIdentifier(blkSysIdx, accessSysIdx, idNum[1])
      %endif
      %assign mapSource = "D"
      %assign mapIndex  =  idNum[1]
      %break
    %case "x" %% local continuous state index
      %if bReturnIdentfier
	%assign blkSysIdx    = BlockIdx[0]   %% where the signal is created
	%assign accessSysIdx = System[SystemIdx].HStructDeclSystemIdx
	%% where the signal is accessed
	%assign rec.identi = ...
	  FcnGetLocalCStateIdentifier(blkSysIdx, accessSysIdx, idNum[1])
      %endif
      %assign mapSource = "X"
      %assign mapIndex  =  idNum[1]
      %break
    %default
      %assign mapSource = idNum[0]
      %assign mapIndex  = idNum[1]
  %endswitch
  
  %assign rec.signalOffset = offset
  
  %if sigRecEmpty
    %if bReturnIdentfier
      %assign rec.mapSrc = mapSource
      %assign rec.mapIdx = mapIndex
    %endif
    %switch (mapSource)
      %%
      %% Constant expression handling
      %%
      %case "C"
	%assign rec.sigRec = BlockOutputs.ConstOutputExpr[mapIndex]
	%break
      %case "L" %% local variable
	%assign rec.sigRec = ...
	  CompiledModel.BlockOutputs.LocalBlockOutput[mapIndex]
	%break
      %case "B" %% global block IO index 
	%assign rec.sigRec = ...
	  CompiledModel.BlockOutputs.GlobalBlockOutput[mapIndex]
	%break
      %case "I" %% invariant signal
	%assign rec.sigRec = ...
	  CompiledModel.BlockOutputs.ConstBlockOutput[mapIndex]
	%break
      %case "E" %% external signal
	%assign rec.sigRec = ...
	  CompiledModel.BlockOutputs.ExternalBlockOutput[mapIndex]
	%break
      %case "D" %% global DWork index
	%assign rec.sigRec = CompiledModel.DWorks.DWork[mapIndex]
	%break
      %case "X" %% global state vector index     
	%assign rec.sigRec = CompiledModel.ContStates.ContState[mapIndex]
	%assign ::BlockFcnAccessed.XC = 1
	%break
      %case "U" %% root level input
	%assign rec.sigRec = ...
	  CompiledModel.ExternalInputs.ExternalInput[mapIndex]
	  %<LibAccessArg(rec.sigRec)>
	%break
      %case "Y" %% root level output
	%assign rec.sigRec = ...
	  CompiledModel.ExternalOutputs.ExternalOutput[mapIndex]
	%break
      %case "G" %% grounded signal
	%assign rec.sigRec = []
	%break
      %case "F" %% function call
	%assign rec.sigRec = []
	%break
      %default
	%error ...
	  "Wrong map source '%<mapSource>' in SLibGetSourceRecordAndMapInfo."
    %endswitch %% mapSource
  %endif
  %return rec
  
%endfunction %% end SLibGetSourceRecordAndMapInfo

%% Function: SLibGetSourceRecord ===============================================
%% Abstract:
%%     This function takes a port object and port signal index as a argument
%%     and returns a signal record.
%%
%function SLibGetSourceRecord(portObj, sigIdx) void
  %assign rec = SLibGetSourceRecordAndMapInfo(portObj, sigIdx, TLC_FALSE)
  %return rec.sigRec
%endfunction %% end SLibGetSourceRecord

%% Function: FcnGetInputOrOutputSignal =========================================
%% Abstract:
%%   This implements the 'body' of
%%      LibBlockInputSignal
%%      LibBlockInputSignalAddr
%%      LibBlockOutputSignal
%%      LibBlockOutputSignalAddr
%%
%%
%%   In general, there are essentially four parts to the signal reference
%%   returned by this routine:
%%       <vect><ioq><id><index>.
%%
%%   The first part, <vect>, depends on where this signal is declared, which
%%   in turn is essentially determined by the attributes of the driving block
%%   and the output port from where this signal originates. Here are the
%%   various possibilities:
%%
%%       "rtU":  External inputs vector (driven by a inport block not in a
%%               subsystem)
%%       "rtX":  States vector (output from the state port of driving block)
%%       "rtB":  Block I/O vector, declared globally
%%       "rtb_": Block I/O vector, declared locally
%%       "rtC":  Const Block I/O vector (driven by an invariant block)
%%       "rtC_": #define'd Const Block I/O (driven by an invariant block)
%%       {FALSE, "0", "0.0", "rt<dType>GROUND", "rt<dType>GROUND_Complex"}:
%%               Grounded or unconnected input where dType is the input port
%%               data type.
%%       "u":    Inside a rolled loop
%%       data banks: (user defined memory location).
%%       rtP:    Defined in TLC
%%
%%   The second part, <ioq>, is the I/O qualifier (or the selection operator)
%%   which is largely determined by the code format.  The possibilities:
%%
%%         "":   Inside a rolled loop
%%         ".":  RealTime and Embedded-C code formats
%%         "->": RealTimeMalloc and S-function code formats
%%
%%   The third part, <id>, is the uniquified identifier assigned to this
%%   signal.  This identifier is obtained from either the signal label
%%   specified in the Simulink diagram or, if a signal label is not
%%   present, the name of the block from which this signal originates.
%%
%%   For #define'd invariant block I/O signals, an additional "_" is
%%   appended between the <id> and <index> positions.
%%
%%   The final part, <index>, is the index into the appropriate element
%%   and/or the real/imaginary part of the input signal, if it is either
%%   wide and/or complex.
%%
%%   Combining all of them, one gets strings such as "rtB.s7_Gain1[2]". "rtB"
%%   is the <vect> part, "." is the I/O qualifier, "s7_Gain1" is the <id>
%%   part (s7 represents Subsystem 7 while Gain1 is the name of the block),
%%   and "[2]" is the <index> part.
%%
%function FcnGetInputOrOutputSignal(sigKind, portIdx, ucv, lcv, sigIdx) void
  
  %%------------------------------------------%%
  %% Process sigIdx & configure reim, retType %%
  %%------------------------------------------%%
  %assign reim = "" %% assume we are accessing the whole signal

  %if sigKind == "input" || sigKind == "inputAddr"
    %assign bInput  = TLC_TRUE
  %elseif sigKind == "output" || sigKind == "outputAddr"
    %assign bInput  = TLC_FALSE
  %else
    %<LibBlockReportError([],"Invalid sigKind")>
  %endif
  
  %if sigKind == "input" || sigKind == "output"
    %assign bAddr = TLC_FALSE
  %else
    %assign bAddr = TLC_TRUE
  %endif
  
  %if ISEMPTY(sigIdx)
    %if ISEMPTY(ucv) && ISEMPTY(lcv)
      %setcommandswitch "-v1"
      %<LibBlockReportError([],"Invalid sigIdx: '%<sigIdx>' " + ...
	"(must be an integer or an integer prefixed with the TLC " + ...
	"variable tRealPart or tImagPart)")>
    %endif
    %assign sigIdx = 0  %% ucv != "" || lcv != "" => sigIdx ignored.
  %endif
  
  %if bInput
    %assign portObj  = FcnGetInputPortRecord(portIdx)
    %assign portType = "BlockInput" %% needed for purely integer error message
    %assign varName  = "u"          %% needed in case of rolling 
  %else %%output
    %assign portObj  = FcnGetOutputPortRecord(portIdx)
    %assign portType = "BlockOutput" %% needed for purely integer error message
    %assign varName  = "y"           %% needed in case of rolling
  %endif

  %assign isComplex  = (portObj.ComplexSignal == "yes")
  
  %% the complex signal handling is the same for input and output signals
  %% because discontiguous signal with mixed complex and non-complex signals
  %% are not allowed in Simulink
  %%
  %if !bAddr
    %if TYPE(sigIdx) == "String"
      %assign tmpVect = SLibGetReimAndIdx(sigIdx)
      %assign reim    = tmpVect[0]
      %assign sigIdx  = tmpVect[1]

      %% Return "" when attempting to access the imaginary part of a
      %% non-complex signal.
      %if reim != "" && !isComplex
	%% If the signal is not complex then the imaginary part is ""
	%if reim == tImagPart
	  %return ""
	%elseif reim == tRealPart
	  %% The input signal is not complex so we don't need the .re part
	  %assign reim = ""
	%else
	  %<LibBlockReportError([], ...
	    "Invalid value of Real/Imag sigIdx part: %<reim>")>
	%endif
      %endif
    %endif
  %else %% sigKind == "inputAddr" || sigKind == "outputAddr"
    %if TYPE(sigIdx) != "Number"
      %<LibBlockReportError([], "sigIdx must be an integer index " + ...
	"when accessing an input signal address")>
    %endif
  %endif
  
  %if !bInput && ucv != "" %% ucv handling for output signals
    %% the signal type is output and ucv is specified inside a roller
    %% the user has to manage the signal indexing by passing the
    %% the loop variable plus signal index
    %%
    %% Notice: this library function will add an offset if the outport
    %%         is connected to a merge block (e.g. SignalOffset[0] != 0).
    %%
    %assign sigIdx = 0
  %endif
  
  %% 
  %%
  %assign sigRecAndMapInfo = ...
    SLibGetSourceRecordAndMapInfo(portObj, sigIdx, TLC_TRUE)
  
  %assign portWidth = portObj.Width
  %assign signalRec = sigRecAndMapInfo.sigRec
  %assign mapSource = sigRecAndMapInfo.mapSrc
  %assign sigOffset = sigRecAndMapInfo.signalOffset
  
  %%---------------------------------------------------------------------%%
  %% Based on mapSource, generate signal identifier to return (retSignal) %%
  %%---------------------------------------------------------------------%%
  %if ucv != "" || lcv == "" || (lcv != "" && portWidth==1) || ...
    mapSource=="G" || ISEMPTY(signalRec)
    %% ucv specified, not rolling, or rolling a scalar or ground
          
    %if mapSource == "F"
      %error "This function is called from a function that did not" + ...
	"check for function call or action data output port"
    %endif
    
    %if mapSource=="G" || ISEMPTY(signalRec) %% needs to be removed
      %return FcnGetGroundSignalReference(sigKind, portObj, isComplex, reim)
    %else
      %% Check for floating-point types if integer only code
      %if PurelyIntegerCode
	%assign dTypeId =  LibGetDataTypeIdAliasedThruToFromId(SLibGetRecordDataTypeId(signalRec))
	%if dTypeId == tSS_DOUBLE || dTypeId ==tSS_SINGLE
	  %<SLibCacheIntegerOnlyWarning(Name, portType)>
	%endif
      %endif
      
      %assign retSignal = FcnGetBasicSignalReference(sigRecAndMapInfo, ...
	 portWidth, reim, bInput, bAddr, isComplex, ucv, lcv)
    %endif
    
  %else %% 'true' rolling
    %%
    %% We are rolling a signal that is non-scalar and non-grounded signal.
    %%
    %%

    %assign hasCustomStorage = LibHasCustomStorage(signalRec)
    
    %assign sigIndexer = SLibGet1DArrayIndexer(portWidth, ucv, lcv, sigOffset)
    
    %assign returnBaseAddr = (bAddr && ucv == "" && lcv == "" && sigIdx == 0 && portWidth > 1)
    %%
    %% Return reference to the signal
    %%
    %if returnBaseAddr
      %assign retSignal  = "%<varName>%<portIdx>"
    %else
      %assign retSignal  = "%<varName>%<portIdx>%<sigIndexer>"
      %%
      %if reim != ""
	%assign retSignal = retSignal + ".%<reim>"
      %endif
      %%
      %if bAddr
	%assign retSignal = "&" + retSignal
      %endif
      %%
    %endif
    %%
  %endif
  %%
  %% Add indirection access if needed
  %%
  %%
  %if !bAddr && ...
    signalRec.StorageClass == "ImportedExternPointer" && ...
    signalRec.Width == 1
    %assign retSignal = "(*%<retSignal>)"
  %endif
  
  %return retSignal

%endfunction %% FcnGetInputOrOutputSignal

%function FcnGetIOSignalBaseAddr(sigKind, portIdx) void
  
  %%------------------------------------------%%
  %% Process sigIdx & configure reim, retType %%
  %%------------------------------------------%%
  %assign reim = "" %% assume we are accessing the whole signal

  %if sigKind == "input"
    %assign bInput  = TLC_TRUE
  %elseif sigKind == "output"
    %assign bInput  = TLC_FALSE
  %else
    %<LibBlockReportError([],"Invalid sigKind")>
  %endif
  
  %if bInput
    %assign portObj  = FcnGetInputPortRecord(portIdx)
    %assign varName  = "u"          %% needed in case of rolling 
  %else %%output
    %assign portObj  = FcnGetOutputPortRecord(portIdx)
    %assign varName  = "y"           %% needed in case of rolling
  %endif

  %%
  %% Return reference to the signal
  %%
  %assign retSignal  = "%<varName>%<portIdx>"
  %if portObj.Width == 1
    %assign retSignal = "&" + retSignal
  %endif
  
  %return retSignal

%endfunction %% FcnGetIOSignalBaseAddr

%% Function: SLibBlockOutputSignal =============================================
%% Abstract:
%%   Call back into a block's BlockOutputSignal.
%%
%%
%function SLibBlockOutputSignal(block,system,portIdx,ucv,lcv,sigIdx,retType) void
  
  %assign fcn = "BlockOutputSignal"
  %if LibBlockFunctionExists(block,fcn)
    %with block
      %return GENERATE(block,fcn,system,portIdx,ucv,lcv,sigIdx,retType)
    %endwith
  %else
    %assign errTxt = "Block specifies that its output signal " ...
      "is an expression, however, the block does not provide the " ...
      "necessary TLC function: %<fcn>"
    %<LibBlockReportError(block, errTxt)>
  %endif
%endfunction

%% Function: SLibGetBlockOutputIdentifierFromRecord
%%    From the RTW file BlockOutputs Record get its base identifier in the
%%    block I/O structure to be accessed from within the accessSysIdx
%function SLibGetBlockOutputIdentifierFromRecord(bo, accessSysIdx) void

  %if bo.OwnerSysIdx[0] != -1 %% default
    %assign thisSysIdx  = bo.OwnerSysIdx[0]
    %assign thisInstance = bo.OwnerSysIdx[1]
  %else
    %assign thisSysIdx  = bo.SigSrc[0]
    %assign thisInstance = bo.SigSrc[1]
  %endif
	
  %assign identiPath = FcnGetLocalBlockIOPath(thisSysIdx,thisInstance,accessSysIdx)  
  %return "%<identiPath>%<bo.Identifier>"
%endfunction

%% Function: SLibGetBlockOutputFromRecord
%%    From the RTW file BlockOutputs Record get the path
%%    to that elemnt in the block I/O structure to be 
%%    accessed from within the accessSysIdx
%function SLibGetBlockOutputFromRecord(bo,accessSysIdx) void

  %assign id = SLibGetBlockOutputIdentifierFromRecord(bo, accessSysIdx)

  %if bo.Width > 1
    %assign indexer = "[0]"
  %else
    %assign indexer = ""
  %endif
  %if bo.ComplexSignal == "yes"
    %assign re = ".%<tRealPart>"
  %else
    %assign re = ""
  %endif
  %return "&%<id>%<indexer>%<re>"
%endfunction

%endif %% _BLKIOLIB_

%% [EOF] blkiolib.tlc
