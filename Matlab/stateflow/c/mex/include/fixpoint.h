/*
 * @(#)fixpoint.h    generated by: makeheader 4.21  Sun May  2 22:42:03 2004
 *
 *		built from:	../../src/include/pragma_interface.h
 *				include/header_dependencies.h
 *				fxp_util/a100_fixpt_version.cpp
 *				fxp_util/a200_fixpt_types.cpp
 *				fxp_util/a300_fixpt_types.cpp
 *				fxp_util/fix_add.cpp
 *				fxp_util/fix_bitop.cpp
 *				fxp_util/fix_convert.cpp
 *				fxp_util/fix_div.cpp
 *				fxp_util/fix_dtrules.cpp
 *				fxp_util/fix_extr.cpp
 *				fxp_util/fix_lookup.cpp
 *				fxp_util/fix_mul.cpp
 *				fxp_util/fix_nonlinear.cpp
 *				fxp_util/fix_published.cpp
 *				fxp_util/fix_sfun.cpp
 *				fxp_util/fix_util.cpp
 *				fxp_util/fix_vlogic.cpp
 *				fxp_util/fprtw_util.cpp
 *				modver/modver.cpp
 */

#ifndef fixpoint_h
#define fixpoint_h


/*
 * Prevent g++ from making copies of vtable and typeinfo data
 * in every compilation unit.  By allowing for only one, we can
 * save space and prevent some situations where the linker fails
 * to coalesce them properly into a single entry.
 *
 * References:
 *    http://gcc.gnu.org/onlinedocs/gcc/Vague-Linkage.html#Vague%20Linkage
 *    http://gcc.gnu.org/onlinedocs/gcc/C---Interface.html
 */

#ifdef __cplusplus
#  ifdef GLNX86
#    pragma interface
#  endif
#endif



/* $Revision: 1.1 $ */
#include <math.h> 
#include <limits.h>
#include <float.h>
#include <stdio.h>
#include "tmwtypes.h"


/*
 * Copyright 1994-2001 The MathWorks, Inc.
 */
#define FIXPT_COMPILE_FOR_RELEASE 12



/* Abstract:
 *
 * The primary motivation of this header file is to allow customers to
 * write C language S-functions that support fixed-point data types.  However,
 * the API in this header extends beyond fixed-point and includes support for
 * standard floating point and integer data types.  
 *
 * This header contains definitions and prototypes for use in creating 
 * Simulink S-functions that can process a wide variety of data types.
 * These data types include the Simulink builtin data types,
 *     double        single
 *     uint8         int8
 *     uint16        int16
 *     uint32        int32
 * all the MathWorks defined fixed-point data types such as
 *     sfix16_En15
 *     ufix32_En16
 *     ufix128
 *     sfix37_S3_B5
 * and the versions of data types obtained when Data Type Override is set
 * to Scaled Doubles such as
 *     flts16
 *     flts16_En15
 *     fltu32_S3_B5
 *
 * This header file contains functions and definitions that allow S-functions
 * to determine which of these data types an input port or output port is
 * using.  The S-function can also specify which of these data types should
 * be used for an input, output, DWork state, or Runtime Parameter.  The
 * information required to properly read to and write from different variables
 * of each data type is given.
 */

/* Note on License Design:
 *
 * The following comments are simply an attempt to clarify the License Design 
 * so that authors can write better S-functions.
 * As of 
 *      Release 13
 *      Simulink 5.0
 *      Fixed-Point Blockset 4.0
 * all the blocks from Fixed-Point Blockset were merged into Simulink.  All
 * the blocks are installed even if a user does not have a Fixed-Point License.
 * Simulink customers can use all the blocks with any builtin data types that a
 * block supports.  If all the blocks in a model are only using builtin data
 * types and the Min-Max-Overflow Logging Mode is set to Force Off, then a 
 * Fixed-Point License is NOT required.  If any block in a model is "actively" 
 * using a non-builtin fixed-point data type or is actively logging Min-Max and/or
 * Overflow information, then a Fixed-Point License will be required for the 
 * remainder of that Matlab session.  
 *   Even if blocks in a model are configured to have fixed-point signals and/or
 * configured to log Min-Max-Overflow information, then simply loading, viewing, 
 * editing, or saving a model should not trigger active use.  Actions such as 
 * Update Diagram, Simulation, and Code Generation from such a model are active 
 * use and would cause a Fixed-Point License to be checked out.
 *   S-functions written using the API in this header file should be able to
 * follow this license design.  For example, suppose an S-function is written
 * so that it can handle any builtin or fixed-point data type.  Suppose in a
 * particular model, this S-function is processing just builtin data types such 
 * as double, single, uint8, or int32.  That use case would not trigger a 
 * Fixed-Point License to be checked out.  Suppose in a different model,
 * the S-function was processing non-builtin fixed-point data types.  That use,
 * like any other use of fixed-point data types, would cause a Fixed-Point 
 * License to be checked out.
 *   The key pitfall S-function authors must guard against is registering
 * a fixed-point data type when a model is simply being loaded or viewed.  In
 * Simulink jargon, loading or opening a model or sub-system is a 
 * "Sizes Call Only."  The Simulink S-function API provides a way to detect a
 * "Sizes Call Only", so by careful programming, an S-function author can avoid 
 * Fixed-Point License problems when a user is simply loading or viewing a model.
 */



/*
 * A key concept in the use of these utilities is that one function will
 * handle all of the data types.  For example, it is NOT necessary to use one 
 * function for floating point and another function for fixed point.  In
 * almost all cases, one function will handle all floating point cases, will
 * handle all integer sizes, will handle both signed and unsigned integers, and
 * will handle all cases of fixed point scaling.  
 *   Moreover, there is no requirement that all data types involved be the 
 * same.  Take a multiply function as an example.  All the data types could be
 * mixed.  One input could be floating point.  The other input could be an 
 * unsigned 16 bit integer.  The output could be a signed 57 bit fixed point
 * integer with 41 bits to the right of the binary point.  
 *   Supporting such wild combinations is not the real purpose of these
 * utility functions.  The real value of these utilities is that they allow
 * users to write a fairly small amount of code, yet produce an sfunction
 * that can handle almost all data types of interest.  Including floating
 * point, fixed point, and integer.
 */
 
 /* Include standard C libraries
  *
  * Note, users working on designs that will eventually be implemented on
  * fixed-point embedded processors may be concerned about the inclusion
  * of floating point libraries such as math.h.  These routines are used
  * only in off-line calculations and in simulations that involve floating
  * point signals.  Real Time Workshop is designed to produce efficient 
  * streamlined code from a Simulink model.  For example, if only integer 
  * signals are used in a model, then MathWorks supplied blocks will not use 
  * floating point signals or floating point commands or functions.
  *    Users written blocks can also generate efficient streamlined code.
  * To achieve this, users must write TLC files corresponding to each of
  * their sfunctions.  In fact, the utility functions prototyped here
  * only work in simulation.  Code generation will not succeed if users do
  * not supply TLC files for each of their SFunctions.  A library of 
  * corresponding TLC functions is supplied.  This are very similar in
  * design, including the fact that one function can produce efficient
  * streamlined code for all cases of data types and all cases of scaling
  * with very few limitation.
  */

/* The following conditional include is only for MathWorks internal use
 */
#ifndef S_FUNCTION_NAME
# ifndef MATLAB_MEX_FILE
#   ifndef SL_INTERNAL
#    ifndef   FIPXT_SHARED_MODULE
#     define FIPXT_SHARED_MODULE (1)
#    endif
#   include "package.h"
#  endif
# endif
#endif

/* Include MathWorks headers
 * Most uses of this fixed-point header will also include the Simulink 
 * simstruct header.   The key exception to this is plain C mex functions
 * intended to be run from the matlab command line and not as Simulink
 * S-Functions.  These plain C mex functions do require a few items
 * from simstruc.h; these are redefined here only as absolutely necessary.
 */
#ifndef __SIMSTRUC__
#if defined(S_FUNCTION_NAME) || defined(FIPXT_SHARED_MODULE) || defined(MathWorks_h)
#include "simstruc.h"
#else
/* plain C mex support here */
#include "mex.h"
#include "simstruc_types.h"
typedef struct SimStruct_tag SimStruct;
typedef struct _slDataTypeAccess_tag slDataTypeAccess;
typedef enum {
    FIXPT_PRODHWDEVICE_MICRO,
    FIXPT_PRODHWDEVICE_ASIC,
    FIXPT_PRODHWDEVICE_UNKNOWN
} ProdHWDeviceType;
#endif
#endif



/* Simulink supports fixed-point data types with any number of bits from
 *    1 to FXP_MAX_BITS for unsigned numbers and 
 *    2 to FXP_MAX_BITS for signed numbers.
 * The API in this header file treats pure integers just like
 * any other fixed-point numbers.  Pure integers just happen 
 * to have trivial scaling.  The 6 standard Simulink integer
 * types uint8, int8, uint16, int16, uint32, and int32 are not 
 * exceptions.  They are treated like fixed-point numbers 
 * that happend to have trivial scaling and happend to have
 * 8, 16, or 32 bits.  The same API applies.
 *   Simulink builtin integers are special only in that they do
 * not trigger the need for a Fixed-Point License. 
 *
 * The number of bits used to represent a signal in simulation
 * may be more than the number specified.  In this case, the
 * signals will be emulated inside various sized containers 
 * according to the following table.
 *
 *   Specified Bits       Container Bits   Container typedef
 *    1 to  8              8               int8_T  or uint8_T
 *    9 to 16             16               int16_T or uint16_T
 *   17 to 32             32               int32_T or uint32_T
 *   33 to FXP_MAX_BITS   FXP_MAX_BITS     fxpChunkArray
 *
 * In the bottom case, a structure called a fxpChunkArray is used. The 
 * ChunkArray spreads the bits over a multi-word array of integer CHUNKS. 
 * Properties of the CHUNKS are given below.
 *
 * For signed numbers, the bit encoding format is always 
 * two's complement.
 *
 * When the specified number of bits is less than the size of
 * the container, the desired bits are always stored in the
 * least significant part of the container.  Any "unused" bits
 * are in the most significant part of the container.  
 *     The "unused" bits must be set to specific values.  The
 * required values depend on whether of not the number is stored in 
 * a ChunkArray.  If the number is stored in an fxpChunkArray, then
 * all unused bits must always be cleared to zero.
 *   If the number is not stored in a fxpChunkArray, then any unused
 * bits must be set to a sign extension.  If the data type is
 * an unsigned number, then obviously, the number is always
 * nonnegative so the (implicit) sign bit is zero.  For unsigned
 * data types, all unused bits must always be cleared to zero.
 *    If the data type is a signed number, then the sign bit is
 * one for strictly negative numbers and zero otherwise.  If
 * the stored integer is negative, then all unused bits must be
 * set to one.  If the stored integer is positive, then all
 * unused bits must be cleared to zero.
 *
 * Simulink also supports two builtin floating point data types.  
 * These are the standard floating point singles and doubles.
 *
 * Simulink also supports a data type category that is a hybrid 
 * between floating-point and fixed-point.  This category is
 * called ScaledDouble.  ScaledDouble cases occur when
 * an individual block is configured to have a fixed-point
 * output, but the system it lives in has its Data Type Override 
 * setting for a system is set to Scaled Doubles.  The
 * resulting data type has the scaling the fixed-point
 * specification, but stores its output using floating 
 * point doubles.  Storing in a double means that overflow
 * and precision issues are almost always eliminated. Removing the 
 * range and precision issues is very useful for benchmarking, testing, 
 * and debugging. 
 *   ScaledDouble data types contain information
 * signedness and number of bits of what their non-overrided data 
 * types would have been.  This is useful for information for other
 * portions of the model that are not being debugged with Data Type 
 * Override.
 */
typedef enum fxpStorageContainerCategory_tag {
    FXP_STORAGE_UNKNOWN = 0,
    FXP_STORAGE_DOUBLE,
    FXP_STORAGE_SINGLE,
    FXP_STORAGE_UINT8,
    FXP_STORAGE_INT8,
    FXP_STORAGE_UINT16,
    FXP_STORAGE_INT16,
    FXP_STORAGE_UINT32,
    FXP_STORAGE_INT32,
    FXP_STORAGE_CHUNKARRAY,
    FXP_STORAGE_SCALEDDOUBLE

} fxpStorageContainerCategory;

#define FXP_MAX_BITS 128

typedef uint32_T FXP_CHUNK_T;

#define FXP_BITS_PER_CHUNK 32

#define FXP_NUM_CHUNKS ( FXP_MAX_BITS / FXP_BITS_PER_CHUNK )

#define FXP_INDEX_LEAST_SIGNIFICANT_CHUNK 0

#define FXP_INDEX_MOST_SIGNIFICANT_CHUNK  ( FXP_NUM_CHUNKS - 1 )

#define FXP_ALL_ONES_CHUNK 0xFFFFFFFFul
 
typedef struct fxpChunkArray_tag
{
    FXP_CHUNK_T chunk[ FXP_NUM_CHUNKS ];
    
} fxpChunkArray;

/* Simulink Scaling
 *
 * Simulink data types support scaling.  The Fixed-Point User's Guide
 * presents the following general formula.
 * 
 *    V = S * Q + B
 *
 * where
 *
 *    V is the Real World Value in the engineering units of choice
 *    Q is the called the Stored Integer Value.  It is the raw value 
 *      stored in the digital hardware.  Despite the name Q can use
 *      an integer or a floating point format.
 *    S is the Slope.  For clarity, this is also called the Total-Slope
 *    B is the Bias
 *
 * The Total-Slope is often decomposed into two parts.
 *
 *    S = F * 2^E
 *
 * where
 *
 *   1. <= F < 2.0
 *
 *    F is the Fractional Slope
 *    E is the Fixed Exponent, E is always an integer.
 *
 * If
 *    B == 0.0
 * and
 *    F == 1.0
 * then
 * there is a clean binary point interpretation.
 *
 *    Fraction Length = -1 * Fixed Exponent 
 *
 * For example, if 
 *    S == 0.125
 *    B == 0.0
 * then
 *    F == 1.0
 *    E == -3
 * so
 *    Fraction Length = 3
 * therefore, this data type has 3 bits to the right of the
 * binary point.
 *
 * The concept of scaling is most useful for fixed-point cases, but
 * it does generalize to all the scalar numeric data types.  For
 * floating point doubles and singles and for pure integers, 
 * the scaling is trivial
 *    B == 0
 *    S == 1
 *    F == 1
 *    E == 0
 *    Fraction Length == 0
 * The access methods to get scaling information can be used
 * for all the data types, they just return trivial values
 * when the scaling is trivial.
 */ 



/* The following structure gives is a data type that is large enough to
 * hold the values of all fixed point data types without any loss of range
 * or precision.
 * 
 * When a fixed point data types has more than 32 bits is always stored
 * in this structure.
 */
typedef union 
{
    double       FltPt;
    FXP_CHUNK_T  FixPt[ FXP_NUM_CHUNKS ];
    
} fxpScalarOversized;

typedef struct fxpScalarOversizedComplex_tag
{
    fxpScalarOversized re;
    fxpScalarOversized im;

} fxpScalarOversizedComplex;


/* This structure is essentially the union of all the containers used to hold
 * floating point, fixed point, and integer data types.
 * It's use can make writing flexible code easier.
 * For example, if a local variable is declared to be of this type, then
 * it will always be big enough to handle any scalar signal or parameter.
 * No need to allocate memory.
 * Also, switch statements can often be avoided in handling a variety of
 * data types.
 * For example, the following code
 *    fxpScalarUnionAll fxpUnionTemp;
 *    void *pVoidInput = ssGetInputPortSignal(pS,0);
 *    int  bytesPerInput = ssGetDataTypeSize(pS,ssGetInputPortDataType(pS,0));
 *
 *    memcpy( &fxpUnionTemp, pVoidInput, bytesPerInput );
 *    
 * copies any input into temporary variable fxpUnionTemp without use of
 * if statements or switch statements or memory allocations.
 */
typedef union
{
    uint8_T    ufix8;
    int8_T     sfix8;
    uint16_T   ufix16;
    int16_T    sfix16;
    uint32_T   ufix32;
    int32_T    sfix32;
    float      flt32;
    double     FltPt;
    FXP_CHUNK_T    FixPt[ FXP_NUM_CHUNKS ];
    
} fxpScalarUnionAll;

/* The following #define should be set to true as soon as
 * changes to matlab/src/cg_ir/dom_core/cg_fixpt.c 
 * that remove all use of the field totalSlope from fxpDataTypeProp
 * reach the Aslrtw cluster
 */ 
#define FIXPT_REMOVE_TOTALSLOPE 1

/* Bridge for removing the distinction between
 * fxpDataTypePropPrimary and fxpDataTypeProp
 */
/* The following structure is used to describe the attributes of any
 * floating point, fixed point, or integer data type.
 */

#ifndef _fxpDataTypeProp_has_been_defined
#define _fxpDataTypeProp_has_been_defined
typedef struct fxpDataTypeProp_tag 
{
    unsigned int    FixClass: 15;
    unsigned int    IsSigned:  1;
    unsigned int    MantBits: 16;

    int        FixExp;

    double    Slope;
    double    Bias;

} fxpDataTypeProp;
#endif /* _fxpDataTypeProp_has_been_defined */

typedef fxpDataTypeProp fxpDataTypePropPrimary;


/* The following structure is used to describe the attributes of any Simulink
 * Signal, Parameter, State, or other internal variable.
 * Currently it is limited to scalars, and arrays of dimension 1 or 2.
 */
typedef enum {
  FXP_ARRAY_PTR_CONTIGUOUS,
  FXP_ARRAY_PTR_PTR,
  FXP_ARRAY_UNION_ALL,
  FXP_ARRAY_OVERSIZED
  
} fxpArrayStorageOrg;



typedef struct fxpArrayProp_tag 
{
    fxpArrayStorageOrg fxpArrayOrg;
    
    int isComplex;
  
    int numElem;
    int numDims;
    int numRows;
    int numCols;
    
    int numProp;
    
    int signalSize;
    
    const fxpDataTypeProp *pFxpDtpTrue;

    const fxpDataTypeProp *pFxpDtpForOp;

} fxpArrayProp;

/* The following structure is used to describe the attributes of an operation.
 * For example, if a summation operation overflows should the result
 * saturate or wrap modulo N bits.
 */
typedef struct fxpOperationChoices 
{
    int rndMeth;
    int doSatur;
    int doLog;
        
} fxpOperationChoices;



/* Properties of a block, required by many fixed point utility functions
 *
 */ 
typedef enum {
  FXP_SFUNCTION_BLOCK,
  FXP_BUILTIN_BLOCK,
  FXP_EITHER_SFUNCTION_OR_BUILTIN,
  FXP_NOT_A_BLOCK
  
} fxpCallerCategory;

typedef enum {
    FXP_PARAMETER,
    FXP_SIGNAL

} fxpVariableCategory;



/* Overflow logging structure
 *
 * Some fixed-point math functions accept a pointer to this structure.
 * These functions will intialize each of the event counts to zero.  Then
 * the functions will carryout the requested math operations.  Each
 * time an event is detect during the math operation the appropriate 
 * count will be incremented.  The increment operations makes sure
 * the count does not overflow to zero; it will saturate to the upper limit.
 *   
 * For example, suppose a fixed-point conversion function is called. Suppose,
 * one oveflow occurred during the conversion.  After the function return,
 * the memory pointed to be oveflow logging structure pointer would indicate
 * one overflow, zero saturations, and zero divide-by-zeros.
 */
typedef struct fxpOverflowLogs_tag
{
      int OverflowOccurred;
      int SaturationOccurred;
      int DivisionByZeroOccurred;

} fxpOverflowLogs;



/*
 *  MinMax object
 */
typedef struct fxpMinMaxLog_tag
{
    double    MinValue;
    double    MaxValue;

} fxpMinMaxLog;

typedef enum {
    FXP_SIM_MODE_UNKNOWN,
    FXP_SIM_MODE_SIZES_ONLY

} fxpSimMode;

typedef struct fxpLogStruct_tag
{
    fxpVariableCategory fxpVarCat;
      
    fxpOverflowLogs fxpOverLogs;
    
    int doMinMaxLog;

    fxpMinMaxLog fxpMinMaxLogs;

    int hasValidLogDataType;

    DTypeId logDataType;

} fxpLogStruct;

typedef struct fxpProdHardware_tag
{
    ProdHWDeviceType devType;

    /* bits per char  is element [0]
     * bits per short is element [1]
     * bits per int   is element [3]
     * bits per long  is element [3]
     */
    int bitsPerCIntegers[4];

} fxpProdHardware;

typedef struct fxpBlockProperties_tag 
{
    fxpCallerCategory callerCategory;

    /* Set dta to NULL if not available, such as FXP_NOT_A_BLOCK
     */
    slDataTypeAccess *pDataTypeAccess; 

    /* Pointer to a string that identifies the block
     * For blocks, this is usually the full path of the block.
     * Example, in an sfunction, ssGetPath(pS)
     */
    const char *pStrIndentifier;

    /* Pointer to sfunction simstruc
     * set to NULL if not known to be an sfunction
     */
    SimStruct *pSimStruct;

    /* Structure for logging overflows, etc
     */
    fxpLogStruct fxpLogs;

    fxpProdHardware hardwareInfo;

    /* Used for logging simulation time */
    double time;

    /* Need output port data type info for unified blocks */
    DTypeId oPortDataType;            

    /* Definition of pointer to function which lives in slerror.cpp */
    void* (*slErrorUseStringFormat)(const char*, const char*);

    /* Definition of pointer to function which lives in slerror.cpp */
    void* (*slWarningUseStringFormat)(const char*, const char*);

    /* Definition of pointer to function which lives in dtypetbl.cpp
     * This function pointer sets up access to the License manager checkout
     * feature function.
     */
    void* (*CheckOutFixedPointLicense)(int*, const char*, const char*);

    /* need to know if being called in a Sizes Only situation
     * in this case do not register fixed point data types that
     * would case license issues
     */
    fxpSimMode simMode;

} fxpBlockProperties;


typedef enum {
    FXP_PORT_INPUT,
    FXP_PORT_OUTPUT

} fxpPortCategory;




#ifndef UINT32_T
#error Fixed Point Blockset needs UINT32_T to be defined.
#endif

#define FXP_BITS_PER_HALF_CHUNK 16
#define FXP_ALL_ONES_HALF_CHUNK 0x0000FFFFul
#define FXP_MS_BIT_ONE_CHUNK    0x80000000ul

/*==============*
 * Typedefs     *
 *==============*/

enum {
    FXP_LOG_MINMAX_NO,     /* if local, can be overridden by global setting */
    FXP_LOG_MINMAX_YES,    /* if local, can be overridden by global setting */
    FXP_LOG_MINMAX_NEVER_WANTED  /* can NOT be overridden by global setting */
};

/*==============*
 * Misc defines *
 *==============*/

#ifndef TRUE
# define TRUE  (1)
#endif

#ifndef FALSE
# define FALSE (0)
#endif

#ifndef NULL
# define NULL (0)
#endif

#define NULL_S ((SimStruct *)NULL)
#define NULL_FxpBlockProps ((fxpBlockProperties *)NULL)

/*
 *  Codes used to represent the use of C Doubles or C Floats
 */
typedef enum {
    FXP_DT_FIXPT,
    FXP_DT_SCALED_DOUBLE,
    FXP_DT_DOUBLE,
    FXP_DT_SINGLE,
    FXP_DT_BOOLEAN,
    FXP_DT_CUSTOM_FLOAT /* custom float must come last */

} fxpModeDataType;


/* for backwards compatibility, boolean will be classified as being in the fixed point
 * category.  When reading a boolean value, there is no loss of accuracy from this
 * classification.  However, optimizations may be missed based on the fact that
 * the input can (well should) only be zero or one.  When writing a boolean value,
 * special treatment should be done to make sure only values of zero or one are written.
 * For these cases, the more selective APIs should be used.
 */
#define fxpIsDataTypeFixPt(pFxpDataTypeProp)          ( (pFxpDataTypeProp)->FixClass == FXP_DT_FIXPT   || \
                                                        (pFxpDataTypeProp)->FixClass == FXP_DT_BOOLEAN )

#define fxpIsDataTypeFixPtNonBool(pFxpDataTypeProp)   ( (pFxpDataTypeProp)->FixClass == FXP_DT_FIXPT )

#define fxpIsDataTypeBoolean(pFxpDataTypeProp)        ( (pFxpDataTypeProp)->FixClass == FXP_DT_BOOLEAN )

#define fxpIsDataTypeScaledDouble(pFxpDataTypeProp)   ( (pFxpDataTypeProp)->FixClass == FXP_DT_SCALED_DOUBLE )

#define fxpIsDataTypeDouble(pFxpDataTypeProp)         ( (pFxpDataTypeProp)->FixClass == FXP_DT_DOUBLE )

#define fxpIsDataTypeSingle(pFxpDataTypeProp)         ( (pFxpDataTypeProp)->FixClass == FXP_DT_SINGLE )

#define fxpIsDataTypeCustomFloat(pFxpDataTypeProp)    ( (pFxpDataTypeProp)->FixClass >= FXP_DT_CUSTOM_FLOAT )

#define fxpIsDataTypeFloatOrSclDbl(pFxpDataTypeProp)  ( (pFxpDataTypeProp)->FixClass != FXP_DT_FIXPT   && \
                                                        (pFxpDataTypeProp)->FixClass != FXP_DT_BOOLEAN )

#define fxpIsDataTypeTrueFloat(pFxpDataTypeProp)      ( (pFxpDataTypeProp)->FixClass == FXP_DT_DOUBLE ||    \
                                                        (pFxpDataTypeProp)->FixClass == FXP_DT_SINGLE ||    \
                                                        (pFxpDataTypeProp)->FixClass >= FXP_DT_CUSTOM_FLOAT )

#define fxpIsDataTypeNotTrueFloat(pFxpDataTypeProp)   ( (pFxpDataTypeProp)->FixClass == FXP_DT_FIXPT   ||     \
                                                        (pFxpDataTypeProp)->FixClass == FXP_DT_BOOLEAN ||     \
                                                        (pFxpDataTypeProp)->FixClass == FXP_DT_SCALED_DOUBLE )



#define NotYet_DataTypeGetExpBitsPrim(fixClass)           ( fixClass - ( FXP_DT_CUSTOM_FLOAT - 1 ) )
#define NotYet_DataTypeGetExpBits(pFxpDataTypeProp)       ( (pFxpDataTypeProp)->FixClass - ( FXP_DT_CUSTOM_FLOAT - 1 ) )


/* Determine is fixpt signal is stored using a husky boy
 */
#define FixPt_DataTypeUsesFixValueStruct(pFxpDataTypeProp)          \
        ( ( (pFxpDataTypeProp)->FixClass == FXP_DT_FIXPT       ) && \
          ( (pFxpDataTypeProp)->MantBits >  FXP_BITS_PER_CHUNK ) )



/* The enums specify the rounding modes supported by most fixed-point 
 * math functions.
 */
typedef enum fxpModeRounding_tag {
  FXP_ROUND_ZERO,
  FXP_ROUND_NEAR,
  FXP_ROUND_CEIL,
  FXP_ROUND_FLOOR
  
} fxpModeRounding;

/* The enums specify the overflow handling modes supported by most fixed-point 
 * math functions.
 */
typedef enum fxpModeOverflow_tag {
  FXP_OVERFLOW_WRAP,
  FXP_OVERFLOW_SATURATE

} fxpModeOverflow;



/*
 *  Codes used to represent the best precision scaling modes for
 *  time invariant parameters and constants
 */
typedef enum fxpModeBestPrecision_tag {
  FXP_BEST_PREC_OFF,
  FXP_BEST_PREC_MAT,
  FXP_BEST_PREC_COL,
  FXP_BEST_PREC_ROW,
  FXP_BEST_PREC_ELE

} fxpModeBestPrecision;

#define   FXP_BEST_PREC_VEC  FXP_BEST_PREC_COL


typedef enum {
  FXP_EQUAL,
  FXP_NOT_EQUAL,
  FXP_LESS_THAN,
  FXP_LESS_THAN_OR_EQUAL,
  FXP_GREATER_THAN_OR_EQUAL,
  FXP_GREATER_THAN,
  FXP_GT_POS_LT_NEG_EQ_ZERO
} fxpComparisonType;

typedef enum {
    FXP_DTRULE_FLOATPT_YES,
    FXP_DTRULE_FLOATPT_NO,
    FXP_DTRULE_FLOATPT_UNKNOWN
} fxpDtRuleFloatPtStatus;

typedef enum {
    FXP_DTRULE_EXCESS_BITS_ERROR,
    FXP_DTRULE_EXCESS_BITS_KEEP_LSB,
    FXP_DTRULE_EXCESS_BITS_KEEP_MSB
} fxpDtRuleExcessBitsMode;

/*=============================*
 * Utilities defined as macros *
 *=============================*/

/*==============*
 * Typedefs     *
 *==============*/



/* Fixed Point Assert
 */
#ifdef DEBUG
    void* NotYet_Assertion
    (
      fxpBlockProperties *pFxpBlockProps,
      const char *strFile,
      unsigned uLine,
      const char *msg
    );

#   define NotYet_Assert(pFxpBlockProps,f,msg)                           \
        if (f)                                              \
        {                                                   \
        }                                                   \
        else                                                \
        {                                                   \
            NotYet_Assertion( pFxpBlockProps, __FILE__, __LINE__, msg );  \
        }
#else
#   define NotYet_Assert(pFxpBlockProps,f,msg)
#endif


#define fxpDataTypePropDefault    (*fxpGetDataTypePropertiesDefault())
#define fxpBlockPropertiesDefault (*fxpGetBlockPropertiesDefault())

/* Function: fxpDataTypeSame ===============================================
 * Abstract:
 *      Determine if two fixed point scalar objects have the same data type
 */
#define fxpDataTypeSame(pFxpDataTypeProp1,pFxpDataTypeProp2) \
( \
( (pFxpDataTypeProp1)->FixClass == (pFxpDataTypeProp2)->FixClass ) && \
( (pFxpDataTypeProp1)->MantBits == (pFxpDataTypeProp2)->MantBits ) && \
( (pFxpDataTypeProp1)->IsSigned == (pFxpDataTypeProp2)->IsSigned ) && \
( (pFxpDataTypeProp1)->FixExp   == (pFxpDataTypeProp2)->FixExp   ) && \
( (pFxpDataTypeProp1)->Slope    == (pFxpDataTypeProp2)->Slope    ) && \
( (pFxpDataTypeProp1)->Bias     == (pFxpDataTypeProp2)->Bias     ) \
)
/* end fxpDataTypeSame */


/* Function: fxpDataTypeStorageContainerSame ===============================================
 * Abstract:
 *      Determine if two fixed point scalar objects have the same data type
 */
#define fxpDataTypeStorageContainerSame(pFxpDataTypeProp1,pFxpDataTypeProp2) \
( \
( (pFxpDataTypeProp1)->FixClass == (pFxpDataTypeProp2)->FixClass ) && \
( (pFxpDataTypeProp1)->MantBits == (pFxpDataTypeProp2)->MantBits ) && \
( (pFxpDataTypeProp1)->IsSigned == (pFxpDataTypeProp2)->IsSigned ) \
)
/* end fxpDataTypeStorageContainerSame */


#define FixPt_DTConvertBetweenOptMaxStr 32
#define FixPt_DTConvertBetweenOptIdStrV0 "fixptv0"

typedef struct FixPt_DTConvertBetweenOptions
{
  char idStr[FixPt_DTConvertBetweenOptMaxStr];
  int RndMeth;
  int DoSatur;
     
} FixPt_DTConvertBetweenOptions;


/*
 * Name of Matlab Variable for storing the maximums and minimums
 * that occur during simulation
 */
#define FixPt_Name_MINMAX_Log_Var "FixPtSimRanges"


  
/* Deprecated items provided only for backwards compatibility */

/* The term Doubles-Override is outdated and misleading.
 * Instead, the terms Data-Type-Override and Scaled-Doubles should be used 
 * as appropriate.
 * The follow definition is provided for backwards compatibility
 */
#define FXP_STORAGE_DOUBLESOVERRIDE FXP_STORAGE_SCALEDDOUBLE
#define FXP_DT_FIXPT_DBL_OVER FXP_DT_SCALED_DOUBLE
#define fxpIsDataTypeFixPtDblOver(pFxpDataTypeProp)   fxpIsDataTypeScaledDouble(pFxpDataTypeProp)
#define fxpIsDataTypeFloatOrDblOver(pFxpDataTypeProp) fxpIsDataTypeFloatOrSclDbl(pFxpDataTypeProp)

/* This is a temporary bridge for automatically coordinating
 * a solution across Adsp and Aslrtw.  The goal, under the current design, 
 * is for DSP blocks to ignore Data Type Override when registering data types.
 */ 
#define DSP_FIXPT_BRIDGE_DTOVER_IGNORE FIXPT_DATATYPE_OVERRIDE_IGNORE


#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxp_CRUDE_AccumPos
(
 fxpBlockProperties *pFxpBlockProps,
 fxpScalarOversized       *pFatValOut,
 const fxpDataTypeProp  *pFxpDTPOut,
 fxpScalarOversized         fixValIn,
 const fxpDataTypeProp  *pFxpDTPIn,
 int RndMeth,
 int DoSatur
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxp_CRUDE_AccumNeg
(
 fxpBlockProperties *pFxpBlockProps,
 fxpScalarOversized       *pFatValOut,
 const fxpDataTypeProp  *pFxpDTPOut,
 fxpScalarOversized         fixValIn,
 const fxpDataTypeProp  *pFxpDTPIn,
 int RndMeth,
 int DoSatur
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpAccumPos(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpScAccumPos(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpAccumNeg(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpScAccumNeg(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpSumPosCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpSumNegCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpAccumPosCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpAccumNegCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpBitwiseAndEqual(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpBitwiseOrEqual(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpBitwiseXorEqual(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpBitwiseComplement(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpBitwiseAndCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpBitwiseOrCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpBitwiseXorCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpBitwiseNandCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpBitwiseNorCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fhpConvertThin2Fat
(
 fxpScalarOversized *pFatVal,
 const fxpDataTypeProp *pFxpDtp,
 const void *pThin
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fhpConvertFat2Thin
(
 void *pThin,
 const fxpScalarOversized *pFatVal,
 const fxpDataTypeProp *pFxpDtp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT double fxpScGetStoredIntegerValue(
  fxpBlockProperties        *pFxpBlockProps,
  const void                *pVoidU0,
  const fxpDataTypeProp     *pFxpDtpU0
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT double fxpScGetRealWorldValue(
  fxpBlockProperties        *pFxpBlockProps,
  const void                *pVoidU0,
  const fxpDataTypeProp     *pFxpDtpU0
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void FatPt_ConvertFat2FatRad_Prime
(
 fxpBlockProperties    *pFxpBlockProps,
 fxpScalarOversized    *pFatValOut,
 const fxpDataTypeProp *pFxpDtpOut,
 fxpScalarOversized    fixValIn,
 const fxpDataTypeProp *pFxpDtpIn,
 int RndMeth,
 int DoSatur
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void FatPt_ConvertFat2FatRad
(
 fxpBlockProperties    *pFxpBlockProps,
 fxpScalarOversized    *pFatValOut,
 const fxpDataTypeProp *pFxpDTPOut,
 fxpScalarOversized    fixValIn,
 const fxpDataTypeProp *pFxpDTPIn,
 int RndMeth,
 int DoSatur
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpConvert_Thin2Bool(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpConvert(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpFrameConvert(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpScConvert(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpDataTypeProp     *pFxpDtpY0,
  const void                *pVoidU0,
  const fxpDataTypeProp     *pFxpDtpU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT double fxpScQuantize(
  fxpBlockProperties        *pFxpBlockProps,
  double                    dblU0,
  const fxpDataTypeProp     *pFxpDtpU0,
  const fxpOperationChoices *pFxpOpChoices
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxp_CRUDE_Divide
(
 fxpBlockProperties *pFxpBlockProps,
 fxpScalarOversized       *pFixQuotVal,
 const fxpDataTypeProp  *pFxpDTPQuot,
 fxpScalarOversized         fixValNum,
 const fxpDataTypeProp  *pFxpDTPNum,
 fxpScalarOversized         fixValDen,
 const fxpDataTypeProp  *pFxpDTPDen,
 int RndMeth,
 int DoSatur
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpDivide
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpReciprocal
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpDivideCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpSelectRadixDataTypeAllow(
 fxpBlockProperties    *pFxpBlockProps,
 fxpDataTypeProp       *pFxpDtpY,
 const fxpDataTypeProp *pFxpDtpU,
 int                   lenWordLengthAllow,
 double                *pWordLengthAllow
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpSelectRadixDataType(
 fxpBlockProperties    *pFxpBlockProps,
 fxpDataTypeProp       *pFxpDtpY,
 const fxpDataTypeProp *pFxpDtpU,
 fxpProdHardware       *pFxpProdHardware
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void CreateFixedPointLicenseName(char* feature_name);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void displayFxpDTP(const fxpDataTypeProp *pFxpDTP);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpDataTypeIdIsFixPt
(
 fxpBlockProperties *pFxpBlockProps,
 DTypeId dataTypeId
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int dtaDataTypeIdIsFixPt
(
 slDataTypeAccess *dta,
 const char       *pStrPath,
 DTypeId          dataTypeId
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void getPartOfDataTypeStr(char *pOutStr, double *pInVal, int availableChars, char symbol );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpDataTypeNameCreate
(
 fxpBlockProperties     *pFxpBlockProps,
 char                   *DataTypeStr,
 fxpDataTypeProp        *pFxpDTP
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpDataTypeRegisterWithCheck
(
 fxpBlockProperties *pFxpBlockProps,
 DTypeId *pDataTypeId,
 const fxpDataTypeProp  *pFxpDtp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpDataTypeRegister
(
 fxpBlockProperties *pFxpBlockProps,
 DTypeId *pDataTypeId,
 const fxpDataTypeProp  *pFxpDtp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT DTypeId fxpDataTypeRegisterNominalScaling
(
  fxpBlockProperties *pFxpBlockProps,
  unsigned int    FixClass,
  unsigned int    MantBits,
  unsigned int    IsSigned,
  int valLocalDTOver
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpDataTypeRegisterNominalScalingWithCheck
(
  fxpBlockProperties *pFxpBlockProps,
  unsigned int    FixClass,
  unsigned int    MantBits,
  unsigned int    IsSigned,
  int valLocalDTOver,
  DTypeId *pDataTypeId
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT DTypeId fxpDataTypeRegisterFull
(
  fxpBlockProperties *pFxpBlockProps,
  unsigned int    FixClass,
  unsigned int    MantBits,
  unsigned int    IsSigned,
  int             FixExp,
  double          Slope,
  double          Bias,
  int valLocalDTOver
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpDataTypeRegisterFullWithCheck
(
  fxpBlockProperties *pFxpBlockProps,
  unsigned int    FixClass,
  unsigned int    MantBits,
  unsigned int    IsSigned,
  int             FixExp,
  double          Slope,
  double          Bias,
  int valLocalDTOver,
  DTypeId* pDataTypeId
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpDataTypeIdSupported
(
 fxpBlockProperties *pFxpBlockProps,
 DTypeId   dataTypeId
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpDataTypeComplexCheck(
fxpBlockProperties *pFxpBlockProps 
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpScNamedParameterCast
(
 fxpBlockProperties *pFxpBlockProps,
 char *pCharLumpVal,
 const fxpDataTypeProp *pFxpDTP,
 double originalValue,
 const char* paramName
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpScParameterCast
(
 fxpBlockProperties *pFxpBlockProps,
 char *pCharLumpVal,
 const fxpDataTypeProp *pFxpDTP,
 double originalValue
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int NotYet_ParameterGetFixExp
(
 const mxArray *pOrigParam,
 const fxpDataTypeProp *pFxpDTP,
 int radixGroup
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int NotYet_ParameterNeedsSingleProp
(
 const mxArray *pOrigParam,
 const fxpDataTypeProp *pFxpDTP,
 int radixGroup
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void NotYet_ParameterPropBestPrecision
(
 fxpBlockProperties *pFxpBlockProps,
 const mxArray *pOrigParam,
 fxpDataTypeProp *pFxpDtpMatrix,
 const fxpDataTypeProp *pFxpDtpNominal,
 int radixGroup
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpNamedParameterCastMxArray
(
 fxpBlockProperties *pFxpBlockProps,
 char *pCharLumpVal,
 fxpArrayProp *pFxpArrayProp,
 const mxArray *pOrigParam,
 const char *paramName
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpParameterCastMxArray
(
 fxpBlockProperties *pFxpBlockProps,
 char *pCharLumpVal,
 fxpArrayProp *pFxpArrayProp,
 const mxArray *pOrigParam
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpCheckAllPortsUnconnected
( 
 fxpBlockProperties *pFxpBlockProps
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpMdlInitSizesCommonPrep(
 fxpBlockProperties *pFxpBlockProps
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpDataTypeAdjustForDTOver(
 fxpBlockProperties *pFxpBlockProps,
 fxpDataTypeProp *pFxpDTP,
 int valLocalDTOver
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpDataTypeAdjustForDblOver(
 fxpBlockProperties *pFxpBlockProps,
 fxpDataTypeProp *pFxpDTP,
 int valLocalDblOver
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpLogStateflow(UINT32_T        archiveMode,
							char           *signalName,
							char           *sfBlockPath,
							char           *sfDataName,
							int             sfDataID,
							fxpModeDataType sfDataFixClass,
							bool            sfDataIsSigned,
							UINT32_T        sfDataMantBits,
							UINT32_T        sfDataFixExp,
							double          sfDataSlope,
							double          sfDataBias,
							double          sfDataMinValue,
							double          sfDataMaxValue);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpInstrumentLogSaveNamed(
 fxpBlockProperties *pFxpBlockProps,
 const char *pCharSignalName
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpInstrumentLogSaveOut(
 fxpBlockProperties *pFxpBlockProps,
 fxpLogStruct *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpLookUpBreakPointsCheckMono(
 fxpBlockProperties *pFxpBlockProps,
 DTypeId dType,
 const mxArray *pOrigParam
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpLook1DInterp
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidXData,
 const fxpArrayProp        *pFxpArrayPropXData,
 const void                *pVoidYData,
 const fxpArrayProp        *pFxpArrayPropYData,
 const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpLook1DInterpExtrap
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidXData,
 const fxpArrayProp        *pFxpArrayPropXData,
 const void                *pVoidYData,
 const fxpArrayProp        *pFxpArrayPropYData,
 const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpLook1DBelow
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidXData,
 const fxpArrayProp        *pFxpArrayPropXData,
 const void                *pVoidYData,
 const fxpArrayProp        *pFxpArrayPropYData,
 const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpLook1DAbove
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidXData,
 const fxpArrayProp        *pFxpArrayPropXData,
 const void                *pVoidYData,
 const fxpArrayProp        *pFxpArrayPropYData,
 const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpLook1DNearest
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidXData,
 const fxpArrayProp        *pFxpArrayPropXData,
 const void                *pVoidYData,
 const fxpArrayProp        *pFxpArrayPropYData,
 const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpLook2DInterp
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const void                *pVoidU0Data,
 const fxpArrayProp        *pFxpArrayPropU0Data,
 const void                *pVoidU1Data,
 const fxpArrayProp        *pFxpArrayPropU1Data,
 const void                *pVoidYData,
 const fxpArrayProp        *pFxpArrayPropYData,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpLook2DInterpExtrap
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const void                *pVoidU0Data,
 const fxpArrayProp        *pFxpArrayPropU0Data,
 const void                *pVoidU1Data,
 const fxpArrayProp        *pFxpArrayPropU1Data,
 const void                *pVoidYData,
 const fxpArrayProp        *pFxpArrayPropYData,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpLook2DBelow
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const void                *pVoidU0Data,
 const fxpArrayProp        *pFxpArrayPropU0Data,
 const void                *pVoidU1Data,
 const fxpArrayProp        *pFxpArrayPropU1Data,
 const void                *pVoidYData,
 const fxpArrayProp        *pFxpArrayPropYData,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpLook2DAbove
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const void                *pVoidU0Data,
 const fxpArrayProp        *pFxpArrayPropU0Data,
 const void                *pVoidU1Data,
 const fxpArrayProp        *pFxpArrayPropU1Data,
 const void                *pVoidYData,
 const fxpArrayProp        *pFxpArrayPropYData,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpLook2DNearest
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const void                *pVoidU0Data,
 const fxpArrayProp        *pFxpArrayPropU0Data,
 const void                *pVoidU1Data,
 const fxpArrayProp        *pFxpArrayPropU1Data,
 const void                *pVoidYData,
 const fxpArrayProp        *pFxpArrayPropYData,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpMultiplyIsExpressionFriendly(
 fxpBlockProperties     *pFxpBlockProps,
 const fxpDataTypeProp  *pFxpDTPOut,
 const fxpDataTypeProp  *pFxpDTPIn1,
 const fxpDataTypeProp  *pFxpDTPIn2,
 int RndMeth,
 int DoSatur
 );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxp_CRUDE_Multiply
(
 fxpBlockProperties     *pFxpBlockProps,
 fxpScalarOversized     *pFatValOut,
 const fxpDataTypeProp  *pFxpDTPOut,
 fxpScalarOversized     fixValIn1,
 const fxpDataTypeProp  *pFxpDTPIn1,
 fxpScalarOversized     fixValIn2,
 const fxpDataTypeProp  *pFxpDTPIn2,
 int RndMeth,
 int DoSatur
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpMultiply
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpMagSquared
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpMultiplyMatrix
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const fxpOperationChoices *pFxpOpChoices
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpMultiplyCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxp_CRUDE_MultiplyComplex_LogMinMax
(
 fxpBlockProperties *pFxpBlockProps,
 fxpScalarOversizedComplex       *pFatValCompOut,
 const fxpDataTypeProp   *pFxpDTPOut,
 fxpScalarOversizedComplex         fixValCompIn1,
 const fxpDataTypeProp   *pFxpDTPIn1,
 fxpScalarOversizedComplex         fixValCompIn2,
 const fxpDataTypeProp   *pFxpDTPIn2,
 int RndMeth,
 int DoSatur
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpWeightedSum
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpDotProduct
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpMultiplyAccum
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpMultiplyMatrixAccum
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const fxpOperationChoices *pFxpOpChoices
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpDeadZone
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidLoLim,
 const fxpArrayProp        *pFxpArrayPropLoLim,
 const void                *pVoidHiLim,
 const fxpArrayProp        *pFxpArrayPropHiLim,
 const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct             *pFxpLogs
);
#ifdef __cplusplus
}
#endif


/* Function: ssRegisterDataTypeFxpBinaryPoint ===============================
 * 
 * This function fully registers a fixed-point data type with Simulink and 
 * returns a Data Type Id.  Unlike the standard Simulink function, 
 * ssRegisterDataType, additional registration steps do not need to be taken 
 * and should not be taken.  The returned Data Type Id can be used to specify
 * the data types of input ports, output ports, RunTimeParameters, and DWork
 * states.  The Data Type Id can also be used with all the standard 
 * data type access methods in simstruc.h such as ssGetDataTypeSize. 
 *    
 * The input arguments are
 *    isSigned              TRUE if signed, FALSE if unsigned
 *    wordLength            total number of bits including any sign bit
 *    fractionLength        number of bit to right of binary point
 *    obeyDataTypeOverride  if FALSE ignore system's setting for Data Type Override
 *                          if TRUE obey Data Type Override setting, depending
 *                          on Data Type Override, resulting data type could be
 *                          True Double, True Single, Scaled Double, or the 
 *                          requested fixed point type.
 *
 * Cautions:
 *
 * 1) If the registered data type is not one of the builtin data types, then
 * a Fixed-Point License will be checked out.  To prevent, a Fixed-Point
 * License from being checked out when a user simply opens or views a model,
 * calls to registration should be protected with
 *    if ( ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY )
 *       ssRegisterDataType ...
 * 
 * 2) There is no fixed relationship between the Data Type Id value and
 * the input arguments.  Simulink hands out data type Ids on a first come, first
 * served basis, so small changes to a model can cause the a different data
 * type id value to be returned.  Always uses functions to get data type
 * attributes from the data type id; never directly rely on the data type
 * id value.  
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT DTypeId ssRegisterDataTypeFxpBinaryPoint(
    SimStruct *S,
    int isSigned,
    int wordLength,
    int fractionLength,
    int obeyDataTypeOverride
    );
#ifdef __cplusplus
}
#endif


/* Function: ssRegisterDataTypeFxpSlopeBias ===============================
 * 
 * This function fully registers a fixed-point data type with Simulink and 
 * returns a Data Type Id.  Unlike the standard Simulink function, 
 * ssRegisterDataType, additional registration steps do not need to be taken 
 * and should not be taken.  The returned Data Type Id can be used to specify
 * the data types of input ports, output ports, RunTimeParameters, and DWork
 * states.  The Data Type Id can also be used with all the standard 
 * data type access methods in simstruc.h such as ssGetDataTypeSize. 
 *    
 * The input arguments are
 *    isSigned              TRUE if signed, FALSE if unsigned
 *    wordLength            total number of bits including any sign bit
 *    totalSlope            total slope
 *    bias                  bias
 *    obeyDataTypeOverride  if FALSE ignore system's setting for Data Type Override
 *                          if TRUE obey Data Type Override setting, depending
 *                          on Data Type Override, resulting data type could be
 *                          True Double, True Single, Scaled Double, or the 
 *                          requested fixed point type.
 *
 * Cautions:
 *
 * 1) If the registered data type is not one of the builtin data types, then
 * a Fixed-Point License will be checked out.  To prevent, a Fixed-Point
 * License from being checked out when a user simply opens or views a model,
 * calls to registration should be protected with
 *    if ( ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY )
 *       ssRegisterDataType ...
 * 
 * 2) There is no fixed relationship between the Data Type Id value and
 * the input arguments.  Simulink hands out data type Ids on a first come, first
 * served basis, so small changes to a model can cause the a different data
 * type id value to be returned.  Always uses functions to get data type
 * attributes from the data type id; never directly rely on the data type
 * id value.  
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT DTypeId ssRegisterDataTypeFxpSlopeBias(
    SimStruct *S,
    int isSigned,
    int wordLength,
    double totalSlope,
    double bias,
    int obeyDataTypeOverride
    );
#ifdef __cplusplus
}
#endif


/* Function: ssRegisterDataTypeFxpFSlopeFixExpBias =============================
 * 
 * This function fully registers a fixed-point data type with Simulink and 
 * returns a Data Type Id.  Unlike the standard Simulink function, 
 * ssRegisterDataType, additional registration steps do not need to be taken 
 * and should not be taken.  The returned Data Type Id can be used to specify
 * the data types of input ports, output ports, RunTimeParameters, and DWork
 * states.  The Data Type Id can also be used with all the standard 
 * data type access methods in simstruc.h such as ssGetDataTypeSize. 
 *    
 * The input arguments are
 *    isSigned              TRUE if signed, FALSE if unsigned
 *    wordLength            total number of bits including any sign bit
 *    fractionalSlope       fractional slope
 *    fixedExponent         fixed exponent
 *    bias                  bias
 *    obeyDataTypeOverride  if FALSE ignore system's setting for Data Type Override
 *                          if TRUE obey Data Type Override setting, depending
 *                          on Data Type Override, resulting data type could be
 *                          True Double, True Single, Scaled Double, or the 
 *                          requested fixed point type.
 *
 * Cautions:
 *
 * 1) If the registered data type is not one of the builtin data types, then
 * a Fixed-Point License will be checked out.  To prevent, a Fixed-Point
 * License from being checked out when a user simply opens or views a model,
 * calls to registration should be protected with
 *    if ( ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY )
 *       ssRegisterDataType ...
 * 
 * 2) There is no fixed relationship between the Data Type Id value and
 * the input arguments.  Simulink hands out data type Ids on a first come, first
 * served basis, so small changes to a model can cause the a different data
 * type id value to be returned.  Always uses functions to get data type
 * attributes from the data type id; never directly rely on the data type
 * id value.  
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT DTypeId ssRegisterDataTypeFxpFSlopeFixExpBias(
    SimStruct *S,
    int isSigned,
    int wordLength,
    double fractionalSlope,
    int fixedExponent,
    double bias,
    int obeyDataTypeOverride
    );
#ifdef __cplusplus
}
#endif


/* Function: ssRegisterDataTypeFxpScaledDouble =============================
 * 
 * This function fully registers a fixed-point data type with Simulink and 
 * returns a Data Type Id.  Unlike the standard Simulink function, 
 * ssRegisterDataType, additional registration steps do not need to be taken 
 * and should not be taken.  The returned Data Type Id can be used to specify
 * the data types of input ports, output ports, RunTimeParameters, and DWork
 * states.  The Data Type Id can also be used with all the standard 
 * data type access methods in simstruc.h such as ssGetDataTypeSize. 
 *    
 * The input arguments are
 *    isSigned              TRUE if signed, FALSE if unsigned
 *    wordLength            total number of bits including any sign bit
 *    fractionalSlope       fractional slope
 *    fixedExponent         fixed exponent
 *    bias                  bias
 *    obeyDataTypeOverride  if FALSE ignore system's setting for Data Type Override
 *                          if TRUE obey Data Type Override setting, depending
 *                          on Data Type Override, resulting data type could be
 *                          True Double, True Single, Scaled Double, or the 
 *                          requested fixed point type.
 *
 * Cautions:
 *
 * 1) If the registered data type is not one of the builtin data types, then
 * a Fixed-Point License will be checked out.  To prevent, a Fixed-Point
 * License from being checked out when a user simply opens or views a model,
 * calls to registration should be protected with
 *    if ( ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY )
 *       ssRegisterDataType ...
 * 
 * 2) There is no fixed relationship between the Data Type Id value and
 * the input arguments.  Simulink hands out data type Ids on a first come, first
 * served basis, so small changes to a model can cause the a different data
 * type id value to be returned.  Always uses functions to get data type
 * attributes from the data type id; never directly rely on the data type
 * id value.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT DTypeId ssRegisterDataTypeFxpScaledDouble(
    SimStruct *S,
    int isSigned,
    int wordLength,
    double fractionalSlope,
    int fixedExponent,
    double bias,
    int obeyDataTypeOverride
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeIsFxpFltApiCompat ==============================
 * 
 * Giving a registered Data Type Id as input, determine if it is 
 * supported by the API for user written fixed-point and floating-point
 * s-functions.  Support covers all the standard Simulink numeric types 
 * double, single, uint8, ..., int32.  It also includes all the Fixed-Point 
 * data types, including ScaledDouble versions.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int ssGetDataTypeIsFxpFltApiCompat(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeStorageContainCat ===============================
 * 
 * Giving a registered Data Type Id as input, determine the Storage Container
 * Category used to represent Input Signals, Output Signals, Run Time 
 * Parameters, DWorks, etc. during Simulink Simulations.
 *   Descriptions of the Storage Containers and the definitions of
 * the output fxpStorageContainerCategory are given earlier in this header
 * file.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT fxpStorageContainerCategory ssGetDataTypeStorageContainCat(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeStorageContainSize ===============================
 * 
 * Giving a registered Data Type Id as input, determine the Storage Container
 * Size used to represent Input Signals, Output Signals, Run Time 
 * Parameters, DWorks, etc. during Simulink Simulations.  This is the size
 * that the sizeof() function would return.  This is the appropriate size
 * measurement to pass to functions like memcpy().
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 *
 * This functions gives the same answer as the standard function 
 * ssGetDataTypeSize.  This alternate version is only provide to reinforce
 * the distinction between specified word length and container size.  For
 * example, sfix24_En10 is specified to have 24 bits, but it actually is
 * stored in a larger container during Simulink Simulations.  The size of
 * the larger container is returned by this function.  This is the proper
 * value to use for memcpy, malloc, etc.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT size_t ssGetDataTypeStorageContainerSize(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeIsFixedPoint ===============================
 * 
 * Giving a registered Data Type Id as input, determine the if the data
 * type is a fixed-point type.  Pure integers including the standard Simulink
 * integer types uint8, int8, uint16, uint32, and int32 are classified
 * as fixed-point types by this function.  Double, Single, and 
 * ScaledDouble are NOT classified as fixed-point types.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int ssGetDataTypeIsFixedPoint(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeIsFloatingPoint ===============================
 * 
 * Giving a registered Data Type Id as input, determine the if the data
 * type is a true floating-point type.  Double and Single are true floating-
 * point types.  ScaledDouble is NOT classified as true float-point.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int ssGetDataTypeIsFloatingPoint(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeFxpWordLength ===============================
 * 
 * Giving a registered Data Type Id as input, determine the word length 
 * of the data type.  
 *     When the data type is fixed-point (including pure
 * integers), the word length is the total number of bits including 
 * any sign bits, any bits in the integer part, and any bits in the 
 * fractional bits.  
 *     When the data type is ScaledDouble, the
 * word length is the total bits the original data type would have
 * used if override had not occurred.  For example, flts32_En4 would 
 * have been sfix32_En4 if Data Type Override was off.  The word length is
 * therefore 32 bits.
 *     When the data type is true floating-point, this function errors
 * out.  Word length for a floating-point data type can mean different
 * things to different users.  For some, word length should only be the
 * physical mantissa bits excluding the hidden lead one.  For others,
 * the hidden leading one should be included.  For still others, the 
 * word length should be all the physical bits including sign bit,
 * exponent bits, and mantissa bits, but not the hidden bit.  Rather
 * than mislead some users, this function errors out.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int ssGetDataTypeFxpWordLength(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeFxpContainWordLen ===============================
 * 
 * Giving a registered Data Type Id as input, determine the word length 
 * of the storage container.
 *    When the data type is fixed-point (including pure
 * integers), the word length is the total number of bits including 
 * any sign bits, any bits in the integer part, and any bits in the 
 * fractional bits.  
 *   The information provided by this function is not meaning full
 * when the data type is ScaledDouble or true floating point.  For
 * these data types, this function will error out.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int ssGetDataTypeFxpContainWordLen(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeFxpIsSigned ===============================
 * 
 * Giving a registered Data Type Id as input, return true if the data
 * type is signed, and return false if it is unsigned.  
 *    When the data type is fixed-point (including pure
 * integers), the meaning of signed or unsigned is obvious.
 *     When the data type is ScaledDouble, the whether the data type
 * is signed or unsigned is determined by what the original data type would 
 * have used if override had not occurred.  For example, flts32_En4 would 
 * have been sfix32_En4 if Data Type Override was off.  This uses a signed
 * integer so the return value is true.  Conversely, fltu8_S3 would have
 * used ufix8_S3 which is unsigned, so false would be returned.
 *     When the data type is true floating-point, this function errors
 * out.  Asking whether a floating point number is signed or unsigned causes
 * some confusion, so this is prevented.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int ssGetDataTypeFxpIsSigned(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeIsScalingTrivial =============================
 * 
 * Giving a registered Data Type Id as input, determine if the scaling
 * is the trivial case of 
 *    Slope   S == 1.0
 *    Bias    B == 0.0
 * This is always true for pure integers like int8 and for the true floating
 * point types double and single.  It will also be true for ScaledDouble
 * of pure integers such as flts8.  For binary point scaling, trivial means
 * the binary point is just to the right of the least significant bit.
 * Equivalently, the fraction length is zero.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int ssGetDataTypeIsScalingTrivial(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeIsScalingPow2 ===========================
 * 
 * Giving a registered Data Type Id as input, determine if the scaling
 * is an exact power of two
 *    Fractional Slope   F == 1.0
 *    Bias               B == 0.0
 * If the scaling is trivial, then the answer is true.  For fixed-point
 * cases, the answer is true if there is a clean binary point interpretation
 * of the scaling.
 *    Many fixed-point algorithms are only designed to handle power of
 * two scaling.  For this algorithms, this function can be called in
 * mdlSetInputPortDataType and mdlSetOutputPortDataType to prevent
 * unsupported data types from being accepted.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int ssGetDataTypeIsScalingPow2(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeFractionLength ===============================
 * 
 * Giving a registered Data Type Id as input, determine the fraction
 * length for data types that use power of two scaling. 
 *    This function should be called only if ssGetDataTypeIsScalingPow2 
 * returns true.  It errors out otherwise.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int ssGetDataTypeFractionLength(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeTotalSlope ===============================
 * 
 * Giving a registered Data Type Id as input, determine the scalings 
 * total slope.
 *    S = F * 2^E
 * where
 *   1. <= F < 2.0
 *   S is the Total Slope
 *   F is the Fractional Slope
 *   E is the Fixed Exponent, E is always an integer
 *
 *     When the data type is ScaledDouble, the slope is determined by 
 * what the original data type would  have used if override had not occurred.  
 * For example, flts32_En4 would have been sfix32_En4 if Data Type Override was 
 * off.  The total slope is 0.0625 = 2^-4.   For fltu16_S7p98, the total 
 * slope is 7.98
 *     When the data type has trivial scaling, including floating point
 * double and single, the total slope is the trivial value 1.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT double ssGetDataTypeTotalSlope(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeBias ===============================
 * 
 * Giving a registered Data Type Id as input, determine the scalings 
 * bias.
 *     When the data type is ScaledDouble, the slope is determined by 
 * what the original data type would  have used if override had not occurred.  
 * For example, flts32_En4 would have been sfix32_En4 if Data Type Override was 
 * off.  The bias is simply 0.   For fltu16_S3_Bn55p32, the total 
 * slope is -55.32
 *     When the data type has trivial scaling, including floating point
 * double and single, the bias is the trivial value 0.  Likewise, when 
 * the data type has power of two scaling, the bias is always the trivial
 * value 0.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT double ssGetDataTypeBias(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeFracSlope ===============================
 * 
 * Giving a registered Data Type Id as input, determine the scalings 
 * fractional slope.
 *    S = F * 2^E
 * where
 *   1. <= F < 2.0
 *   S is the Total Slope
 *   F is the Fractional Slope
 *   E is the Fixed Exponent, E is always an integer
 *
 *     When the data type is ScaledDouble, the slope is determined by 
 * what the original data type would  have used if override had not occurred.  
 * For example, flts32_En4 would have been sfix32_En4 if Data Type Override was 
 * off.  This case has power of two scaling, so the fractional slope is the 
 * trivial case 1.   For fltu16_S3, the total slope is 3 which is decomposed
 * into Fixed Exponent +1 and Fractional Slope 1.5 
 *     When the data type has trivial scaling, including floating point
 * double and single, the total slope is the trivial value 1.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT double ssGetDataTypeFracSlope(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif


/* Function: ssGetDataTypeFixedExponent ===============================
 * 
 * Giving a registered Data Type Id as input, determine the scalings 
 * fixed exponent.
 *    S = F * 2^E
 * where
 *   1. <= F < 2.0
 *   S is the Total Slope
 *   F is the Fractional Slope
 *   E is the Fixed Exponent, E is always an integer
 *
 * When the data type a clean binary point interpretation, the Fixed Exponent is 
 * simply the negative of the Fraction Length.
 *     When the data type is ScaledDouble, the fixed exponent is determined by 
 * what the original data type would  have used if override had not occurred.  
 * For example, flts32_En4 would have been sfix32_En4 if Data Type Override was 
 * off.  This case has power of two scaling with fraction length +4 and
 * Fixed Exponent -4.   For fltu16_S3, the total slope is 3 which is decomposed
 * into Fixed Exponent +1 and Fractional Slope 1.5 
 *     When the data type has trivial scaling, including floating point
 * double and single, the fixed exponent is the trivial value 0.
 *   This function will error out if ssGetDataTypeIsFxpFltApiCompat
 * returns false.
 */

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int ssGetDataTypeFixedExponent(
    SimStruct *S,
    DTypeId dataTypeId
    );
#ifdef __cplusplus
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
IMPORT void ssFxpConvert(
    SimStruct *S,

    void       *pVoidDest,
    size_t      sizeofDest,
    DTypeId     dataTypeIdDest,

    const void *pVoidSrc,
    size_t      sizeofSrc,
    DTypeId     dataTypeIdSrc,

    fxpModeRounding roundMode,
    fxpModeOverflow overflowMode,

    fxpOverflowLogs *pFxpOverflowLogs
);
#ifdef __cplusplus
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
IMPORT double ssFxpConvertToRealWorldValue(
    SimStruct *S,
    const void *pVoidSrc,
    size_t      sizeofSrc,
    DTypeId     dataTypeIdSrc
);
#ifdef __cplusplus
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
IMPORT void ssFxpConvertFromRealWorldValue(
    SimStruct *S,

    void       *pVoidDest,
    size_t      sizeofDest,
    DTypeId     dataTypeIdDest,

    double      dblRealWorldValue,

    fxpModeRounding roundMode,
    fxpModeOverflow overflowMode,

    fxpOverflowLogs *pFxpOverflowLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpSfnParamCheckVector
(
 SimStruct *S,
 int minElem,
 int maxElem,
 const mxArray *pOrigParam
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpSfnParamCheckString
(
 SimStruct *S,
 const mxArray *pOrigParam
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpSfnParamCheckDataTypeSpec
(
 SimStruct *S,
 unsigned int uClass,
 const unsigned int uMantBits,
 const unsigned int uIsSigned,
 const double dSlope
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpSfnDataTypeId_IsSupported
(
  SimStruct *S,
  DTypeId   dataTypeId
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* NotYet_Assertion
(
  fxpBlockProperties *pFxpBlockProps,
  const char *strFile,
  unsigned uLine,
  const char *msg
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpSetError(
 fxpBlockProperties *pFxpBlockProps,
 const char         *pStrErrorMessage
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpSetWarning(
 fxpBlockProperties *pFxpBlockProps,
 const char         *pStrWarningMessage
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpErrorArgs(
 fxpBlockProperties *pFxpBlockProps,
 unsigned long errCode, int numArgs, ...);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpError(
 fxpBlockProperties *pFxpBlockProps,
 unsigned long errCode);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpWarning( 
    fxpBlockProperties *pFxpBlockProps,
    unsigned long warnCode, ...);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT const fxpDataTypeProp *fhpGetBuiltinDataTypeProperties( DTypeId id );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT const fxpDataTypeProp *fxpGetDataTypePropertiesDefault(void);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT const fxpBlockProperties *fxpGetBlockPropertiesDefault(void);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT const fxpDataTypeProp *fxpGetDataTypeProperties(  
 fxpBlockProperties *pFxpBlockProps,
 DTypeId id );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT const fxpDataTypeProp *fxpGetDataTypePropNoBias(  
 fxpBlockProperties *pFxpBlockProps,
 const fxpDataTypeProp *pFxpDtp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT const fxpDataTypeProp *fxpGetDataTypePropNoFrac(  
 fxpBlockProperties *pFxpBlockProps,
 const fxpDataTypeProp *pFxpDtp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT const fxpDataTypeProp *fxpGetDataTypePropNoBiasOrFrac(  
 fxpBlockProperties *pFxpBlockProps,
 const fxpDataTypeProp *pFxpDtp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT const fxpDataTypeProp *fxpGetDataTypePropNoScaling(  
 fxpBlockProperties *pFxpBlockProps,
 const fxpDataTypeProp *pFxpDtp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fhpDataTypePropExtractPrimary( 
    fxpDataTypeProp        *pFxpDtpPrime,
    const fxpDataTypeProp  *pFxpDtp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fhpDataTypePropComplete( 
  fxpDataTypeProp       *pFxpDtp,
  const fxpDataTypeProp *pFxpDtpPrime
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpDataTypePropCompleteSelf( 
  fxpDataTypeProp  *pFxpDtp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* FixPt_ReportOverflow(
 fxpBlockProperties *pFxpBlockProps
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* FixPt_ReportSaturation(
 fxpBlockProperties *pFxpBlockProps
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* FixPt_ReportDivisionByZero(
 fxpBlockProperties *pFxpBlockProps
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int NotYet_ConversionIsExpressionFriendly(
 fxpBlockProperties *pFxpBlockProps,
 const fxpDataTypeProp *pFxpDTPY,
 const fxpDataTypeProp *pFxpDTPU,
 int RndMeth,
 int DoSatur
 );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpBestPrecisionExponent
(
 double value,
 const fxpDataTypeProp *pFxpDTP
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpScValueIsZero
(
 fxpBlockProperties        *pFxpBlockProps,
 const void                *pVoidU0,
 const fxpDataTypeProp     *pFxpDtpU0
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxp_CRUDE_RemoveTrailingZeros
(
 fxpBlockProperties *pFxpBlockProps,
 char *pCharLumpU,
 fxpDataTypeProp *pFxpDTP
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxp_FAT_ValueCompareSameDT
(
 const fxpScalarOversized *pFatValLeft,
 const fxpScalarOversized *pFatValRght,
 const fxpDataTypeProp  *pFxpDTP
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpGreaterPositiveRange
(
  fxpBlockProperties  *pFxpBlockProps,
  DTypeId             dtIdLeft,
  DTypeId             dtIdRght
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxp_FATPT_SetMin
(
 fxpScalarOversized    *pFatVal,
 const fxpDataTypeProp *pFxpDTP
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxp_FATPT_SetMax
(
 fxpScalarOversized    *pFatVal,
 const fxpDataTypeProp *pFxpDTP
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxp_CRUDE_UnaryMinus
(
 fxpBlockProperties *pFxpBlockProps,
 fxpScalarOversized       *pFatValOut,
 const fxpDataTypeProp  *pFxpDTPOut,
 int DoSatur
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT uint_T fxpDataTypeProp_GetSize
(
 const fxpDataTypeProp *pFxpDTPInput
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT uint_T fxpArrayProp_GetDtSize
(
 const fxpArrayProp *pFxpArrayProp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT DTypeId fxpDataTypeForRunTimeParam
(
 fxpBlockProperties *pFxpBlockProps,
 DTypeId  trueParamDataTypeID
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpBlockProp_SetSFun
(
 fxpBlockProperties *pFxpBlockProps,
 SimStruct          *pSimStruct
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpBlockProp_SetDtaPath
(
 fxpBlockProperties *pFxpBlockProps,
 slDataTypeAccess   *pDataTypeAccess,
 const char         *pStrPath
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpBlockProp_SetMex
(
 fxpBlockProperties *pFxpBlockProps,
 const char         *pStrMexFileName
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpArrayProp_Set_Port
(
 fxpArrayProp       *pFxpArrayProp,
 fxpBlockProperties *pFxpBlockProps,
 fxpPortCategory     portCategory,
 int                 idxPort
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpArrayProp_Set_MxArray_wPortDT
(
 fxpArrayProp       *pFxpArrayProp,
 fxpBlockProperties *pFxpBlockProps,
 const mxArray      *pMxArray,
 fxpPortCategory     portCategory,
 int                 idxPort
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpArrayProp_Set_MxArray
(
 fxpArrayProp       *pFxpArrayProp,
 fxpBlockProperties *pFxpBlockProps,
 const mxArray      *pMxArray,
 const fxpDataTypeProp *pFxpDtpTrue,
 const fxpDataTypeProp *pFxpDtpForOp,
 int numProp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpArrayProp_Set_Scalar
(
  fxpArrayProp       *pFxpArrayProp,
  int isComplex,
  const fxpDataTypeProp *pFxpDtpTrue,
  const fxpDataTypeProp *pFxpDtpForOp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpLogStruct_Init( 
  fxpBlockProperties *pFxpBlockProps,
  fxpLogStruct *pFxpLogs,
  int doMinMaxLog,
  fxpVariableCategory fxpVarCat
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpLogStruct_SetLogDataType( 
    fxpLogStruct *pFxpLogs,
    DTypeId dType
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxp_CRUDE_LogUpdateMinMax(
 fxpBlockProperties    *pFxpBlockProps,
 fxpScalarOversized    *pFatVal,
 const fxpDataTypeProp *pFxpDTP
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fxpScLogUpdateMinMax(
 fxpBlockProperties    *pFxpBlockProps,
 fxpLogStruct          *pFxpLogs,
 const char            *pCharVal,
 const fxpDataTypeProp *pFxpDTP
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpSlopeNormalize(
 fxpBlockProperties *pFxpBlockProps,
 fxpDataTypeProp    *pFxpDTP
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpMinRefine(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpMaxRefine(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpMinCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpMaxCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpAbs(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpConj(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpUnaryMinus(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT double fxpDataTypeZero2Dbl(
 fxpBlockProperties *pFxpBlockProps,
 DTypeId dataTypeId
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void *fxpDataTypeRuleFloatPriority(
    fxpBlockProperties *pFxpBlockProps,
    fxpDataTypeProp        *pFxpDtpY0,
    const fxpDataTypeProp  *pFxpDtpU0,
    const fxpDataTypeProp  *pFxpDtpU1,
    fxpDtRuleFloatPtStatus *pUseFloatingPoint
    );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void *fxpDataTypeRuleApplyDeployHW(
    fxpBlockProperties      *pFxpBlockProps,
    fxpDataTypeProp         *pFxpDtpY0,
    const fxpProdHardware   *pDeployHardwareInfo,
    fxpDtRuleExcessBitsMode excessBitRule
    );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void *fxpDataTypeRuleMul(
    fxpBlockProperties *pFxpBlockProps,
    fxpDataTypeProp        *pFxpDtpY0,
    const fxpDataTypeProp  *pFxpDtpU0,
    const fxpDataTypeProp  *pFxpDtpU1,
    const fxpProdHardware   *pDeployHardwareInfo,
    fxpDtRuleExcessBitsMode excessBitRule
    );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void *fxpDataTypePropMulRule(
    fxpBlockProperties *pFxpBlockProps,
    fxpDataTypeProp        *pFxpDtpY0,
    const fxpDataTypeProp  *pFxpDtpU0,
    const fxpDataTypeProp  *pFxpDtpU1,
    const fxpProdHardware hardwareInfo
    );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void *fxpDataTypeRuleDiv(
    fxpBlockProperties *pFxpBlockProps,
    fxpDataTypeProp        *pFxpDtpY0,
    const fxpDataTypeProp  *pFxpDtpU0,
    const fxpDataTypeProp  *pFxpDtpU1,
    const fxpProdHardware   *pDeployHardwareInfo,
    fxpDtRuleExcessBitsMode excessBitRule
    );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void *fxpDataTypeRuleRecip(
    fxpBlockProperties *pFxpBlockProps,
    fxpDataTypeProp        *pFxpDtpY0,
    const fxpDataTypeProp  *pFxpDtpU0,
    const fxpProdHardware   *pDeployHardwareInfo,
    fxpDtRuleExcessBitsMode excessBitRule
    );
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fhpDtpZeroRwv2Oversized(
 const fxpDataTypeProp *pFxpDtp,
 fxpScalarOversized    *pFxpOver
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void fhpDtpZeroRwv2UnionAll(
 const fxpDataTypeProp *pFxpDtp,
 fxpScalarUnionAll     *pFxpSua
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT double fhpDtpZeroRwv2DblRwv(
 const fxpDataTypeProp *pFxpDtp
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpPower2Gain(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const char                *pPower2Exponent,
  const fxpArrayProp        *pFxpArrayPropPower2Exponent,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpAndEqual(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpOrEqual(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpXorEqual(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpComplement(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpCleanBoolean(
  fxpBlockProperties        *pFxpBlockProps,
  void                      *pVoidY0,
  const fxpArrayProp        *pFxpArrayPropY0,
  const void                *pVoidU0,
  const fxpArrayProp        *pFxpArrayPropU0,
  const fxpOperationChoices *pFxpOpChoices,
  fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpAndCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpOrCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpXorCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpNandCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpNorCollapse
(
 fxpBlockProperties        *pFxpBlockProps,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpCompare
(
 fxpBlockProperties        *pFxpBlockProps,
 fxpComparisonType         compareType,
 void                      *pVoidY0,
 const fxpArrayProp        *pFxpArrayPropY0,
 const void                *pVoidU0,
 const fxpArrayProp        *pFxpArrayPropU0,
 const void                *pVoidU1,
 const fxpArrayProp        *pFxpArrayPropU1,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpScCompare
(
 fxpBlockProperties        *pFxpBlockProps,
 fxpComparisonType         compareType,
 const void                *pVoidU0,
 const fxpDataTypeProp     *pFxpDtpU0,
 const void                *pVoidU1,
 const fxpDataTypeProp     *pFxpDtpU1,
 const fxpOperationChoices *pFxpOpChoices,
 fxpLogStruct              *pFxpLogs,
 int                       *pResults
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpScEqualsDataTypeMinimum
(
 fxpBlockProperties        *pFxpBlockProps,
 const void                *pVoidU0,
 const fxpDataTypeProp     *pFxpDtpU0
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpScEqualsDataTypeMaximum
(
 fxpBlockProperties        *pFxpBlockProps,
 const void                *pVoidU0,
 const fxpDataTypeProp     *pFxpDtpU0
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT int fxpScEqualsJustAboveDataTypeMinimum
(
 fxpBlockProperties        *pFxpBlockProps,
 const void                *pVoidU0,
 const fxpDataTypeProp     *pFxpDtpU0
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* FixPt_RtwValidate(
 fxpBlockProperties *pFxpBlockProps, 
 const fxpDataTypeProp *pFxpDTP
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpRtwWritePortDataTypes(
 fxpBlockProperties *pFxpBlockProps
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpRtwWriteObjectValue
(
 fxpBlockProperties *pFxpBlockProps, 
 const char *Name,                  
 const char *pCharLump,
 const fxpDataTypeProp *pFxpDTP,
 int mRows, 
 int nCols, 
 const int isMatrix,
 const int isComplex
);
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
IMPORT void* fxpRtwWriteOpChoices(
  fxpBlockProperties *pFxpBlockProps, 
  fxpOperationChoices *pFxpOpChoices
);
#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C" {
#endif

IMPORT_VAR char *libfixedpoint_version;

IMPORT_VAR char *libfixedpoint_build_date;


#ifdef __cplusplus
}
#endif

#endif /* fixpoint_h */
