function [msg, err, ccode] = rsdecode(code, k, tp)
%RSDECODE
%
%WARNING: This is an obsolete function and may be removed in the future.
%         Please use RSDEC instead.

%RSDECODE Reed-Solomon decoding using the exponential format.
%   MSG = RSDECODE(CODE, K) recovers the message information from code word
%   CODE, which has been coded using the Reed-Solomon encoding technique. CODE
%   is a matrix with the row length being N = 2^M - 1, where M is a positive
%   integer no less than 3. K is the message length. Usually, the message length
%   is an odd number. The error-correction capability of a Reed-Solomon code is
%   T = floor((N - K) / 2). The recovered message is stored in MSG. The row
%   number of MSG is the same as the row number of CODE. The column number of
%   MSG is K. Note the  difference from all of the other encoding/decoding
%   functions. This function takes exponential input instead of regular input
%   for processing. For example [-Inf, 0, 1, 2, ...] represents [0 1 alpha,
%   alpha^2, ...] in GF(2^m). There are 2^M elements in GF(2^M). Hence, the
%   input CODE represents 2^M * (2^M - 1) bits of information. The decoded MSG
%   represents 2^M * K bits of information.
%
%   MSG = RSDECODE(CODE, K, TP) recovers the length K message information from
%   code word CODE with specified GF(2^M) elements in TP. This format is
%   recommended even if the GF(2^M) is a default one in speeding up the process.
%   A default TP can be generated by using TP = gftuple([-1:2^M-2]',M);
%
%   [MSG, ERR] = RSDECODE(...) provides the error correction information.  A
%   non-negative positive element in ERR indicates the number of errors that
%   have been corrected. A negative element in ERR indicates there  were more
%   errors encountered in the decode than it could correct.
%
%   [MSG, ERR, CCODE] = RSDECODE(...) provides the corrected code word in CCODE.
%
%   Example:
%   M = 4;                      % M is a number larger or equal to 3.
%   N = 2^M - 1;                % The code word length.
%   K = 9;                      % K is the message length.
%   T = floor((N - K)/2);       % Error-correction capability.
%   NUM_ROW = 10;               % Number of rows in the calculation
%   MSG = randint(NUM_ROW, K, [-1, N-1])
%                               % Generate a random number. Note that
%                               % a "-1" is equivalent to "-Inf".
%   TP = gftuple([-1:N-1]', M); % A complete list of all elements in
%                               % GF(2^M).
%   PG = rspoly(N, K);          % Produce generator polynomial.
%   CODE =rsencode(MSG,PG,N,TP);% Reed-Solomon encode calculation.
%   CODE_NOI = CODE + randerr(NUM_ROW, N, [1 2 3]);
%   DEC = rsdecode(CODE_NOI, K, TP) % Reed-Solomon decode calculation.
%
%   See also RSENCODE, RSCORE.

%   Copyright 1996-2002 The MathWorks, Inc.
%   $Revision: 1.13 $   $Date: 2002/03/27 00:20:04 $ 

% build tp if it is not given
if nargin < 2
    error('Not enough input parameters.')
end;

%fprintf('Reed-Solomon decode calculation. Please wait..\n.');
[n_code, m_code] = size(code);
t2 = m_code - k;

if nargin < 3
    % find dim from m_code
    dim = 3;
    pow_dim = 2^dim -1;
    while pow_dim < m_code
        dim = dim + 1;
        pow_dim = 2^dim - 1;
    end;
    tp = gftuple([-1:pow_dim-1]', dim);
else
    if length(tp) == 1
        dim = tp;
        pow_dim = 2^dim - 1;
        tp = gftuple([-1:pow_dim-1]', dim);
    else
        [pow_dim, dim] = size(tp);
        pow_dim = pow_dim - 1;
    end;
end;

if m_code ~= pow_dim
    error('The length of the code word is not a valid one');
end;

for i = 1 : n_code
%    if rem(i, 40)
%        fprintf('.');
%    else
%        fprintf([num2str(i/n_code*100),'%%\n.']);
%    end;
    [msg(i, :), err(i), ccode(i, :)] = rscore(code(i,:), k, tp, dim, pow_dim);
end;
err = err(:);
%fprintf('. done.\n');
% -- end of rsdecode.m --

