function z = dpskdemod(y,M,varargin)
% DPSKDEMOD Differential phase shift keying demodulation.
%   Z = DPSKDEMOD(Y,M) demodulates the complex envelope Y of a DPSK
%   modulated signal. M is the alphabet size and must be an integer. For
%   two-dimensional signals, the function treats each column as 1 channel.
%
%   Z = DPSKDEMOD(Y,M,PHASEROT) specifies the phase rotation (rad). In this
%   case, the total per-symbol phase shift is the sum of PHASEROT and the
%   phase generated by the differential modulation.
%
%   See also DPSKMOD, PSKDEMOD, PSKMOD. 

%    Copyright 1996-2004 The MathWorks, Inc. 
%    $Revision: 1.1.6.4 $  $Date: 2004/04/08 20:48:08 $ 

% error checks
if(nargin>3)
    error('comm:dpskdemod:numarg','Too many input arguments.');
end

%Check y, Fs, phase
if( ~isnumeric(y))
    error('comm:dpskdemod:Ynum','Y must be numeric.');
end

if(~isreal(M) || ~isscalar(M) || M<=0 || (ceil(M)~=M) || ~isnumeric(M) )
    error('comm:dpskdemod:Mreal','M must be a positive integer.');
end

if(nargin==2 || isempty(varargin{1}) )    
   Phase_Rotation = 0;
else
    Phase_Rotation = varargin{1};
    if(~isreal(Phase_Rotation) || ~isscalar(Phase_Rotation)|| ~isnumeric(Phase_Rotation) )
        error('comm:dpskdemod:phaserotReal','PHASEROT must be a real scalar.');    
    end
end

% --- Assure that Y, if one dimensional, has the correct orientation --- %
wid = size(y,1);
if(wid ==1)
    y = y(:);
end

%create the map
modmap = 2*pi*(0:M-1)/M + Phase_Rotation;

%get the phase difference
ang = diff(unwrap(angle(y)));

%adjust the negative angles to be positive instead
ind = find(ang < -(pi/M - Phase_Rotation/2));
ang(ind) = ang(ind) + 2*pi;

% de-map
pi2 = 2*pi - pi/M;  % to ensure minimum distance decision
z = zeros(size(y));
for i = 1:size(ang,1)
    for j = 1:size(ang,2)
        minDiff = ang(i,j) - modmap;
        [tmp,ind] = min(mod(abs(minDiff), pi2));
        z(i+1,j) = ind-1;
    end
end

% --- restore the output signal to the original orientation --- %
if(wid == 1)
    z = z';
end

% [EOF]
