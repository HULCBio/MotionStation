function varargout = sim(varargin)

%SIM Closed-loop MPC simulation
%
%   SIM(MPCobj,T,r) simulates the closed-loop system formed by the plant
%   model specified in MPCobj.Model.Plant and by the MPC controller
%   specified by the MPC object MPCobj, and plots the simulation results.
%   T is the number of simulation steps. r is the reference signal array
%   with as many columns as the number of output variables.
%
%   SIM(MPCobj,T,r,v) also specified the measured disturbance signal v,
%   which has as many columns as the number of measured disturbances.
%
%   The last sample of r/v is extended constantly over the simulation horizon,
%   to obtain the correct size.
%
%   SIM(MPCobj,T,r,SimOptions) or SIM(MPCobj,T,r,v,SimOptions)
%   specifies the simulation options object SimOptions, such as
%   initial states, input/output noise and unmeasured disturbances,
%   plant mismatch, etc. Type HELP MPCSIMOPT for details.
%
%   [y,t,u,xp,xmpc,SimOptions]=SIM(MPCobj,T,r,v) instead of plotting 
%   closed-loop trajectories returns the following output arguments:
%            y: sequence of plant outputs
%            t: time sequence (equally spaced by MPCobj.Ts)
%            u: sequence of manipulated variables generated by the MPC controller
%           xp: sequence of states of Plant model (from Model / simModel)
%         xmpc: sequence of states of MPC controller (extended state observer)
%   SimOptions: MPC simulation options used (type HELP MPCSIMOPT for details)
%
%   See also MPCSIMOPT, MPCSIMSET, MPCSIMGET, MPCMOVE.

%   Author: A. Bemporad
%   Copyright 1986-2004 The MathWorks, Inc.
%   $Revision: 1.1.10.8 $  $Date: 2004/04/16 22:09:21 $

narg=nargin;
if narg>5
    warning('mpc:sim:nargin','Too many input arguments. Extra arguments will be ignored');
    varargin=varargin(1:5);
    narg=5;
end

if narg<1,
    error('mpc:sim:none','No MPC object supplied.');
else
    MPCobj=varargin{1};
end
if ~isa(MPCobj,'mpc'),
    error('mpc:sim:obj','Invalid MPC object');
end
if isempty(MPCobj),
    error('mpc:sim:empty','Empty MPC object');
end

InitFlag=MPCobj.MPCData.Init;
save_flag='mpcloop';

if ~isfield(MPCobj.MPCData,'MPCstruct'),
    InitFlag=0;
else
    if ~isfield(MPCobj.MPCData.MPCstruct,'Bup'),
        InitFlag=0;
    end
end

if ~InitFlag,
    % Initialize MPC object (QP matrices and observer)
    try
        MPCstruct=mpc_struct(MPCobj,[],save_flag); %x0,u0 are not checked by MPC_CHKX0U1
    catch
        rethrow(lasterror);
    end
    % Update MPC object in the workspace
    MPCData=MPCobj.MPCData;
    MPCData.MPCstruct=MPCstruct;
    MPCData.Init=1;
    MPCData.QP_ready=1;
    MPCData.L_ready=1;
    MPCobj.MPCData=MPCData;
    try
        assignin('caller',inputname(1),MPCobj);
    end
else
    MPCstruct=MPCobj.MPCData.MPCstruct;
end

% Retrieves parameters from MPCstruct
ny=MPCstruct.ny;
nv=MPCstruct.nv;
nym=MPCstruct.nym;
nu=MPCstruct.nu;
nd=length(MPCobj.MPCData.unindex);
% Note: nd here equals the number of UMDs to Plant, while MPCstruct.nd denotes
%       the number of unmeasured disturbances entering the extended system

Ts=MPCobj.Ts;
p=MPCobj.PredictionHorizon;

if narg<2 | isempty(varargin{2})
    Tf=[];
else
    Tf=varargin{2};
end

if narg<3 | isempty(varargin{3}),
    r=MPCstruct.yoff(:)';
    refgiven=0;
else
    refgiven=1;
    r=varargin{3};
end
% Check correctness of reference signal
if ~isa(r,'double'),
    r=zeros(0,ny+1); % to generate an error
elseif any(isinf(r)) | ~all(isreal(r)),
    r=zeros(0,ny+1); % to generate an error
end
[n_r,m]=size(r);
if m~=ny,
    error('mpc:sim:ref',sprintf('Reference signal must be a real array with %d column(s)',ny));
end

if narg<4,
    v=[];
    SimOptions=[];
elseif narg==4,
    if isa(varargin{4},'mpcsimopt'),
        SimOptions=varargin{4};
        v=[];
    else
        v=varargin{4};
        SimOptions=[];
    end
elseif narg==5,
    v=varargin{4};
    SimOptions=varargin{5};
end
if isempty(v),
    v=MPCstruct.voff(:)';
end
if isempty(SimOptions),
    SimOptions=mpcsimopt(MPCobj); % Empty mpcsimopt object
end
% Check correctness of measured disturbance signal
if ~isa(v,'double'),
    v=zeros(0,nv); % to generate an error
elseif any(isinf(v)) | ~all(isreal(v)),
    v=zeros(0,nv); % to generate an error
end
[n_v,m]=size(v);
if m~=nv-1,
    error('mpc:sim:md',sprintf('Measured disturbance signal must be a real array with %d column(s)',nv-1));
end

% remove offsets
r=r-ones(n_r,1)*MPCstruct.yoff(:)';
v=v-ones(n_v,1)*MPCstruct.voff(:)';

% Check correctness of SimOptions and assign defaults
try
    [MPCstruct,params]=mpcsimoptchk(SimOptions,MPCobj);
catch
    rethrow(lasterror);
end

n_d=params.n_d;
n_ny=params.n_ny;
n_nu=params.n_nu;
n_mv=params.n_mv;
d=params.d;
ynoise=params.ynoise;
unoise=params.unoise;
mv_signal=params.mv_signal;
plantstates=params.plantstates;
diststates=params.diststates;
noisestates=params.noisestates;
simBar=params.simBar;
u0=params.u0;

if refgiven & MPCstruct.openloop,
    warning('mpc:sim:refopenloop','Open-loop simulation, reference signals will be ignored');
end

if isempty(Tf),
    Tf=max([n_r,n_v,n_d,n_ny,n_nu,n_mv,p,10]);
else
    if isa(Tf,'double') & isfinite(Tf) & prod(size(Tf))==1,
        Tf=round(Tf);
    else
        error('mpc:sim:tot','Total number of simulation steps must be a positive scalar');
    end
end

if n_r>0, r=[r;ones(Tf-n_r,1)*r(n_r,:)]; end;
if n_v>0, v=[v;ones(Tf-n_v,1)*v(n_v,:)]; end;
if n_d>0, d=[d;ones(Tf-n_d,1)*d(n_d,:)];end;
if n_ny>0, ynoise=[ynoise;ones(Tf-n_ny,1)*ynoise(n_ny,:)];end;
if n_nu>0, unoise=[unoise;ones(Tf-n_nu,1)*unoise(n_nu,:)];end;
if n_mv>0, mv_signal=[mv_signal;ones(Tf-n_mv,1)*mv_signal(n_mv,:)];end;

MPCstruct.ref_signal=r';
MPCstruct.md_signal=v';
MPCstruct.ud_signal=d';
MPCstruct.mn_signal=ynoise';
MPCstruct.un_signal=unoise';
MPCstruct.Tf=Tf;
MPCstruct.mv_signal=mv_signal';

if simBar,
    h=waitbar(0,'MPC simulation');
    %[h,h0]=mpc_progress_bar; % h=bar handle
    %h=1;
    %fprintf('MPC Simulation in progress ');

    % Create progress bar
    %    global progress_bar
    %    import com.mathworks.toolbox.control.progresstable.*;
    %
    %    progress_bar = ProgressTable('',{''},'MPC Simulation');
    %
    %    progress_bar.setHeader('MPC Simulation');
    %
    %    %progress_bar.setDone(0,true);
    %    %progress_bar.setSelectedRow(0);
    %    progress_bar.setValue(0);
    %    progress_bar.setStatus('In progress');
    %    set(progress_bar,'visible','on')
    %    h=1;
else
    h=-1;
    % fprintf('-->MPC simulation in progress ...');
end

MPCstruct.barhandle=h;

try
    [u,y,xp,xmpc]=mpcloop_engine(MPCstruct);
catch
    rethrow(lasterror);
end

if simBar,
    close(h);

    %progress_bar.setStatus('Done!');
    %set(progress_bar,'visible','off')
    %dispose(progress_bar);

    %fprintf(' Done!\n');
end

Ts=MPCobj.Ts;

u=u';
y=y';
t=(0:Tf-1)'*Ts;
xp=xp';
xmpc=xmpc';

xmpc=struct('Plant',xmpc(:,plantstates),'Disturbance',xmpc(:,diststates),...
    'Noise',xmpc(:,noisestates),'LastMove',[u0';u(1:end-1,:)]);

if nargout==0,  
    % The number of unmeasured disturbances may be different than nominal
    ndp=MPCstruct.ndp;
    if ndp~=nd,
        % Create a dummy MPC object for plotting
        model=ss(zeros(ny,nu+ndp+nv-1));
        model=setmpcsignals(model,'MV',1:nu,'MD',nu+1:nu+nv-1,'UD',nu+nv:nu+nv-1+ndp);
        model.outputname=MPCobj.Model.Plant.OutputName;
        model.inputname(1:nu)=MPCobj.Model.Plant.InputName(MPCobj.MPCData.mvindex);
        model.inputname(nu+1:nu+nv-1)=MPCobj.Model.Plant.InputName(MPCobj.MPCData.mdindex);
        MPCobj.DisturbanceVariables=MPCobj.DisturbanceVariables(1:nv-1);
        for i=1:ndp,
            umdname=sprintf('UMD%d',i);
            model.inputname{nu+nv-1+i}=umdname;
            MPCobj.DisturbanceVariables(nv-1+i)=struct('Name',umdname,'Units','');
        end
        MPCobj.Model.Plant=model;
    end
    % Add offsets
    r=r(1:Tf,:)+ones(Tf,1)*MPCstruct.yoff(:)';
    v=v(1:Tf,:)+ones(Tf,1)*MPCstruct.voff(:)';
    
    try
        plot(MPCobj,t,y,r,u,v,d);
    catch
        h = lasterror;
        error(h.message);
    end
else
    outvec = {y,t,u,xp,xmpc,SimOptions};
    for k=1:nargout
        varargout{k} = outvec{k};
    end
end
