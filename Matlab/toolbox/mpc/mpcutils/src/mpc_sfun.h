/* mpc_sfun.h: MPC Simulink/RTW S-Function - Macros
               
      Author: A. Bemporad
      Copyright 1986-2003 The MathWorks, Inc. 
      $Revision: 1.1.10.8 $  $Date: 2004/04/04 03:37:39 $   
*/


#define MPC_SFUN

/* Debug messages */ 
/* 
   #ifndef DEBUG
   #define DEBUG
   #endif
*/


/* Activates update locking (not needed anymore) 
   If uncommented, check that MdlUpdate is not executed before MdlOutput
*/

/*
   #ifndef LOCKUPDATE
   #define LOCKUPDATE 
   #endif
*/


/* Standard prologue */

#define S_FUNCTION_NAME  mpc_sfun
#define S_FUNCTION_LEVEL 2

#include <stdlib.h>
#include <math.h>

/* #include "util.h" */
#include "simstruc.h"
#include "dantzgmp.h"
/* #include "matrix.h" */ /* needed by mxGetLogicals */
#include "mat_macros.h"

/* Required for alloca to work*/
#if defined(__hpux) && ~defined __FAST_THREADS
#include <alloca.h>
#endif

/* Required for alloca to work*/
#if (defined(sun) || defined(__sun)) && \
    (defined(__SUNPRO_C) || defined(__SUNPRO_CC))
#include <alloca.h>
#endif

/* Required for alloca to work */
#if defined(__WIN32__) || defined(WIN32) || defined(_WIN32) || \
    defined(_MSC_VER)
    #include <malloc.h>
    #ifndef RT
        #define alloca(x) _alloca(x)
    #endif
#endif

#ifdef RT
/* We are being built using RTW */
/* Merge dantzgmp source and avoid debug messages */
	#ifdef DEBUG
		#undef DEBUG
	#endif
	#include "dantzgmp_solver.c"  /* this will be trasformed to INLINE code */
#endif


/* Parameter access macros */

/* Model parameters - Generated by the mpcinit.m initialization routine
   Expected to be initialized and stored in the workspace at compile time
*/



/* ts,A,Cm,Dvm,Bu,Bv,PTYPE,nu,nv,nym,ny,nx,...
        degrees,M,MuKduINV,KduINV,Kx,Ku1,Kut,Kr,Kv,zmin,rhsc0,...
        Mlim,Mx,Mu1,Mv,rhsa0,TAB,optimalseq,utarget,... %rv,anticipate,
        lastx,lastu,p,Jm,DUFree,uoff,yoff,voff,myoff 
*/

#define p_Ts(S)               ssGetSFcnParam(S,0)
#define p_A(S)                ssGetSFcnParam(S,1)
#define p_Cm(S)               ssGetSFcnParam(S,2)
#define p_Dvm(S)              ssGetSFcnParam(S,3)
#define p_Bu(S)               ssGetSFcnParam(S,4)
#define p_Bv(S)               ssGetSFcnParam(S,5)
#define p_PTYPE(S)            ssGetSFcnParam(S,6)
#define p_nu(S)               ssGetSFcnParam(S,7)
#define p_nv(S)               ssGetSFcnParam(S,8) /* total number of MDs, including the one due to offsets */ 
#define p_nym(S)              ssGetSFcnParam(S,9)
#define p_ny(S)               ssGetSFcnParam(S,10)
#define p_nx(S)               ssGetSFcnParam(S,11)
#define p_degrees(S)          ssGetSFcnParam(S,12)
#define p_M(S)                ssGetSFcnParam(S,13)
#define p_MuKduINV(S)         ssGetSFcnParam(S,14)
#define p_KduINV(S)           ssGetSFcnParam(S,15) 
#define p_Kx(S)               ssGetSFcnParam(S,16)
#define p_Ku1(S)              ssGetSFcnParam(S,17)
#define p_Kut(S)              ssGetSFcnParam(S,18)
#define p_Kr(S)               ssGetSFcnParam(S,19)
#define p_Kv(S)               ssGetSFcnParam(S,20)
#define p_zmin(S)             ssGetSFcnParam(S,21)
#define p_rhsc0(S)            ssGetSFcnParam(S,22)
#define p_Mlim(S)             ssGetSFcnParam(S,23)
#define p_Mx(S)               ssGetSFcnParam(S,24)
#define p_Mu1(S)              ssGetSFcnParam(S,25)
#define p_Mv(S)               ssGetSFcnParam(S,26)
#define p_rhsa0(S)            ssGetSFcnParam(S,27)
#define p_TAB(S)              ssGetSFcnParam(S,28)
#define p_optimalseq(S)       ssGetSFcnParam(S,29)
#define p_utarget(S)          ssGetSFcnParam(S,30)
/* #define p_rv(S)               ssGetSFcnParam(S,31) */
/* #define p_anticipate(S)       ssGetSFcnParam(S,32) */
#define p_lastx(S)            ssGetSFcnParam(S,31)
#define p_lastu(S)            ssGetSFcnParam(S,32)
#define p_p(S)                ssGetSFcnParam(S,33)
#define p_Jm(S)               ssGetSFcnParam(S,34)
#define p_DUFree(S)           ssGetSFcnParam(S,35) 
#define p_uoff(S)             ssGetSFcnParam(S,36) 
#define p_yoff(S)             ssGetSFcnParam(S,37) 
#define p_voff(S)             ssGetSFcnParam(S,38) 
#define p_myoff(S)            ssGetSFcnParam(S,39) 

#define p_no_md(S)            ssGetSFcnParam(S,40) 
#define p_no_ref(S)           ssGetSFcnParam(S,41) 
#define p_ref_from_ws(S)      ssGetSFcnParam(S,42) 
#define p_ref_signal(S)       ssGetSFcnParam(S,43) 
#define p_ref_preview(S)      ssGetSFcnParam(S,44) 
#define p_md_from_ws(S)       ssGetSFcnParam(S,45) 
#define p_md_signal(S)        ssGetSFcnParam(S,46) 
#define p_md_preview(S)       ssGetSFcnParam(S,47) 

#define p_maxiter(S)          ssGetSFcnParam(S,48) 
#define p_nxQP(S)             ssGetSFcnParam(S,49) 
#define p_openloopflag(S)     ssGetSFcnParam(S,50) /* jgo */
#define p_md_inport(S)        ssGetSFcnParam(S,51)
#define p_no_ym(S)            ssGetSFcnParam(S,52)

#define NPARAMS 53


/* Work variables and state access macros */

#define w_lastx      (ssGetPWorkValue(S,0))  
#define w_lastu      (ssGetPWorkValue(S,1)) 
#define w_v          (ssGetPWorkValue(S,2)) 
#define w_optimalseq (ssGetPWorkValue(S,3))
#define w_lastt      (ssGetPWorkValue(S,4))  /* Time-step counter is needed for previewing signals */
                                             /* Also needed for recognizing initialization phase in MdlOutputs*/
#define NPWORK 5

#ifdef LOCKUPDATE
#define w_updateflag (ssGetIWork(S))
#define NIWORK 1
#endif

/* Misc Constants */

#define SOFTCONSTR 0   /* Optimization types */
#define HARDCONSTR 1
#define UNCONSTR   2

/* Parameter error message */
#define param_MSG "Parameter number mismatch"

