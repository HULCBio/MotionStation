<!-- $Revision: 1.1.4.1 $ -->
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<title>Lookup Tables & Functions</title>

<style>
h1 {
  color: #990000; 
  font-size: xx-large;
}
h2 {
  color: #990000;
  font-size: x-large;
  margin-bottom: 5px;
}
h3 {
  color: #990000;
  font-size: large;
  margin-bottom: 5px;
}

xA {
  text-decoration: none;
}
.small {
  font-size: small ;
}
.Xdemo {
  background-color: #EFEFEF;
}
.demo {
  border: black 1 solid;
}
</style>
</head>

<body bgcolor="#FFFFFF">
<head>

<h1>Lookup Table and Function Blocks</h1>

<p>Simulink includes several types of lookup table blocks that 
implement a variety of algorithms for approximating functions via 
table indexing, table interpolation, and subtable manipulation.  
Additional capability is obtained using the various function blocks.  
Here are some example applications for lookup table blocks to give 
you ideas for using them in your own designs.</p>


<table cellpadding="2" cellspacing="0" width="100%">
  <tr valign="top">
    <td width="50%">
      <table width="100%" height="100%" class="demo">
         <tr valign="top">
          <td width="85" height="64" align="center" valign="middle">
            <img width="85" height="0"><br clear="all">
            <img src="../../../simulink/simulinkicon.gif"
             alt="Model the behavior of a Type S thermocouple and implement input signal conversion."></td>
          <td><a href="sldemo_tc.html">Approximating Nonlinear Relationships: Type S thermocouple example</a></td>
         </tr>
      </table>
    </td>
    <td width="50%">
      <table width="100%" height="100%" class="demo">
        <tr valign="top">
          <td width="85" height="64" align="center" valign="middle">
           <img width="85" height="0"><br clear="all">
           <img src="sldemo_wavethd_script.png"
            alt="Explore several techniques for designing and generating waveforms."></td>
          <td><a href="sldemo_wavethd_script.html">Waveform Generation: Sine Waves and Distortion Measurement</a></td>
        </tr>
      </table>
    </td>
  </tr>
  <tr valign="top">
    <td width="50%">
      <table width="100%" height="100%" class="demo">
         <tr valign="top">
           <td width="85" height="64" align="center" valign="middle">
            <img width="85" height="0"><br clear="all">
            <img src="../../../simulink/simulinkicon.gif"
             alt="Shows the options available from the Lookup Table n-d block using a 2-D data set."></td>
          <td><a href="sldemo_tableplot.html">Interpolation Algorithms and Trajectory Animation</a></td>
         </tr>
      </table>
    </td>
    <td width="50%">
      <table width="100%" height="100%" class="demo">
         <tr valign="top">
           <td width="85" height="64" align="center" valign="middle">
            <img width="85" height="0"><br clear="all">
            <img src="../../../simulink/simulinkicon.gif"
             alt="Shows uses for the lookup Table Editor."></td>
          <td><a href="sldemo_tbleditor.html">Lookup Table Editor</a></td>
         </tr>
      </table>
    </td>
  </tr>
  <tr valign="top">
    <td width="50%">
      <table width="100%" height="100%" class="demo">
        <tr valign="top">
          <td width="85" height="64" align="center" valign="middle">
           <img width="85" height="0"><br clear="all">
           <img src="sldemo_prelookup_script.png"
            alt="Using pre-lookup index search and interpolation n-D blocks."></td>
          <td><a href="sldemo_prelookup_script.html">Optimize with prelookup and sub-table interpolation blocks</a></td>
        </tr>
      </table>
    </td>
    <td width="50%">
      <table width="100%" height="100%" class="demo">
        <tr valign="top">
          <td width="85" height="64" align="center" valign="middle">
           <img width="85" height="0"><br clear="all">
           <img src="sldemo_bpcheck_script.png"
            alt="Check a model that has pre-lookup index search and interpolation n-D blocks for data mismatches."></td>
          <td><a href="sldemo_bpcheck_script.html">Breakpoint Data Management</a></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<br>


<h2>Selection Guide for Using Lookup Table and Function Blocks</h2>

<p>To assist in matching blocks with applications, the following 
table summarizes the capabilities of these lookup table and 
function blocks in Simulink; a detailed selection guide follows:</p>

<center><image src="sldemo_lookuptables_types.jpg"></center>

<br>

<table Border="1" cellpadding=4 cellspacing=0>
<tr valign=top>
<td width="400"><font color=#990000>Operation</font></td>
<td align=center><font color=#990000>1-D</font></td>
<td align=center><font color=#990000>2-D</font></td>
<td align=center><font color=#990000>dyn</font></td>
<td align=center><font color=#990000>n-D</font></td>
<td align=center><font color=#990000>direct</font></td>
<td align=center><font color=#990000>pre</font></td>
<td align=center><font color=#990000>intrp</font></td>
<td align=center><font color=#990000>poly</font></td>
<td align=center><font color=#990000>fcn</font></td>
<td align=center><font color=#990000>eM</font></td>
</tr>

<tr valign=top>
<td>Linear interpolation</td>
<td align=center>1-D</td>
<td align=center>2-D</td>
<td align=center>1-D</td>
<td align=center>n-D</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>n-D</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
</tr>

<tr valign=top>
<td>Flat (or direct) lookup (+various)</td>
<td align=center>1-D+</td>
<td align=center>2-D+</td>
<td align=center>1-D+</td>
<td align=center>n-D</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>n-D</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
</tr>

<tr valign=top>
<td>Cubic spline interpolation</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>n-D</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Polynomial evaluation</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
</tr>

<tr valign=top>
<td>double, single floating point types</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
</tr>

<tr valign=top>
<td>integer, boolean data types</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Fixed-point data types</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
</tr>

<tr valign=top>
<td>Complex table data</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Wide signals, scalar expansion</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Table as an input (optional)</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>(Y)</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Range checking diagnostics</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
</tr>

<tr valign=top>
<td>Clip inputs to data range</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
</tr>

<td>Extrapolate data range</td>
<td align=center>Y'</td>
<td align=center>Y'</td>
<td align=center>Y'</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
</tr>

<tr valign=top>
<td>Mixed clipping and extrapolation</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>


<tr valign=top>
<td ><font color=#990000>Optimization, Code Generation, 
                         and Verification Options</font></td>
<td align=center><font color=#990000>1-D</font></td>
<td align=center><font color=#990000>2-D</font></td>
<td align=center><font color=#990000>dyn</font></td>
<td align=center><font color=#990000>n-D</font></td>
<td align=center><font color=#990000>direct</font></td>
<td align=center><font color=#990000>pre</font></td>
<td align=center><font color=#990000>intrp</font></td>
<td align=center><font color=#990000>poly</font></td>
<td align=center><font color=#990000>fcn</font></td>
<td align=center><font color=#990000>eM</font></td>
</tr>


<tr valign=top>
<td>Binary index search</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Linear index search</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Evenly spaced points</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Power-of-2 spaced points (speed)</td>
<td align=center>Y'</td>
<td align=center>Y'</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Mixed index search algorithms</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Start at previous index (speed)</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Share index search result (speed)</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Sub-table selection (speed)</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Suppress RTW range checks (speed)</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>MISRA C compliant code generation</td>
<td align=center>Y'</td>
<td align=center>Y'</td>
<td align=center>Y'</td>
<td align=center>Y'</td>
<td align=center>Y</td>
<td align=center>Y'</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>*</td>
</tr>

<tr valign=top>
<td>Suitable for use in embedded applications</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
</tr>

<tr valign=top>
<td>Coverage tool: table coverage</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>Y</td>
<td align=center>-</td>
<td align=center>-</td>
<td align=center>-</td>
</tr>

</table>

<p>Key: <b>Y</b> : yes/recommended, <b>*</b> : yes with extra effort, <b>-</b> : No or N/A, 
<b>'</b> : limitations</p>

<p>Details on Limitations:</p>
<ul>
<li>1-D, 2-D, and dynamic: fixed point does shifts on signed integers, 
power of 2 spacing is only effective for fixed point and integer 
breakpoint sets, cannot extrapolate tables containing fixed point data.</li>

<li>n-D, n-D interpolation: MISRA C compliant code generation up to and 
including 5-D tables for flat or linear interpolations.</li>

</ul>

<p>If you wish to develop your own algorithms, the Embedded MATLAB block offers a 
tremendous amount of flexibility with built-in support for Real-Time Workshop and 
the Real-Time Workshop Embedded Coder.  When you need to incorporate 
hand-written code into your designs, the S-function Builder block offers 
capabilities for integrating C, C++, Ada, and Fortran; it supports
efficient code generation as well.</p>


<h3>Lookup Tables and Function Approximation</h3>


<p>When available, a full numerical expression will typically give the 
highest fidelity reproduction of a function.  An example of this is the 
<code>y = sin(u)</code> function.  As this computation can take 100 or
more clock cycles on a computer, a faster way to compute sin(u) is often
needed.  If the function is periodic and is computed by a sampled 
discrete system whose sample rate evenly divides into the function's
period, then the function can be approximated most efficiently by 
accessing a sequence of stored function values precalculated for each 
sample time in the function's period.</p>

<p>The most basic table lookup operation is merely a table selection.  
The "Direct Lookup Table n-D" block can efficiently access table 
elements, columns, and planes by their index, just like these simple 
array access examples in MATLAB:</p>

<code>   y = A(u)</code> for an element in a 1-D array,<br> 
<code>   y = A(u1,u2,u3,u4)</code> in a 4-D array,<br> 
<code>   y = A(:,u)</code> for selecting an entire column, and<br>
<code>   y = A(:,:,u)</code> for selecting a 2-D plane in a 3-D array.<br>

<p>This technique is not always practical, as the required point spacing
needed to achieve an accuracy requirement may require a table that is 
too big to fit into memory. A common choice in this case is the 
interpolated table lookup.</p>


<h3>Interpolation:  choosing between the "Look-up Table n-D" block and the 
pair of blocks: "Pre-Lookup Index Search", "Interpolation n-D Using Pre-Lookup"</h3>

<p>These blocks use the same algorithms for breakpoint searches and 
interpolations and give equivalent results from a numerical point of view.  
When generating code for Real-Time Workshop, identical parameter values can 
be pooled for either approach.  The main differences are threefold.</p>  

<p>One difference is that the breakpoint search algorithm options for Look-Up 
Table n-D apply to all inputs simultaneously, while the options can be applied 
individually to inputs using the Pre-Lookup Index Search block.  As an example, 
if a 2-D table has variable spacing for one breakpoint set and even spacing
for the other, you must use either linear or binary index search to find the
breakpoint intervals when using the Look-Up Table n-D.  With the pre-lookup, 
the index search method can be different for each breakpoint set, along with 
the clipping/extrapolation option, and the "search using previous index 
result" option.  </p>

<p>The second difference is potential speed improvements:  when the pre-lookup 
index search operations consume a major portion of execution time (as they 
frequently do), multiple interpolation n-D blocks can be fed the results from 
one pre-lookup operation, reducing repetitive calculations.  </p>

<p>The third difference is an alternative algorithm choice with the 
interpolation n-D block.  For Release 14, a sub-table selection algorithm 
is available to dramatically improve speed for certain cases.  See the 
Sub-Table Selection section below. </p>


<h3>Choice of index search algorithm</h3>

<p>If the input signal can change to 
cause movement by more than 1-2 intervals per time step for variably spaced 
breakpoint sets (including software resets, etc.), the binary search algorithm may be 
the better choice.  A binary search has the fastest worst-case convergence (log2(N-1) 
iterations) compared to a linear search (N-1 iterations).  However, if the 
input signal changes so slowly that it cannot realistically traverse more 
than 1-2 intervals per time step, then using a linear index search with 
the "Begin index search using previous index result" option will cause the search to 
start on the interval found during the previous execution of the block.  
When the input value is in the same interval as the input value from the 
previous execution of the block, the search will complete in one pass.  
Conversely, the binary search algorithm can use the maximum number of 
iterations, <code>log2(N-1)</code>, just to move from one interval to the 
next <emdash> "jittery" execution latency. </p>

 
<p>Finally, if the breakpoints can be made evenly spaced, the "Evenly spaced 
points" index search method can be very deterministic. It can also be very 
fast on most modern processors.  One numerically stable method to create N 
evenly spaced points in MATLAB is:<br><br>

<code>
>> pts = M*[0:(N-1)]+B
</code><br><br>

where B is the bias and M is the spacing.  Avoid using formulations like:<br><br>

<code>
>> not_recommended = [B:M:(M*(N-1)+B)]
</code><br><br>

as the spacing is typically not as uniform as with the first method above.</p>

<p>Using pre-lookup index search blocks with a 2-D or higher table in the 
interpolation n-D block allows for pre-lookup blocks specifying different
index search algorithms.  In this way, if one input dimension of the 
table is connected to a rapidly changing signal and the other input 
dimension is connected to a slowly changing signal, the pre-lookup 
blocks can be set to use a binary search and a linear search, respectively, 
to give computational efficiency. </p>


<h3>Common input signals</h3>

<p>If two or more tables share the same input signals, 
is it practical to have one or two breakpoint sets for all the tables using 
this signal?  If so, then you should consider using the pre-lookup index 
search.  By avoiding repeated index searches, the overall application can
run faster.</p>


<h3>Clipping with the pre-lookup block</h3>

<p>If using the pre-lookup index search block to perform clipping and then 
feeding its output signals directly into one or more interpolation n-D 
blocks, it is now possible to turn off clipping and index checking for 
code generation in the interpolation n-D blocks if all the inputs are 
clipped prelookup index search blocks.  This eliminates the generation 
of what is essentially unreachable code in checking to ensure the index 
is valid for the breakpoint array.</p>

<p>It is important when using this option that the breakpoint array is 
correct and has the same number of elements as the corresponding dimension 
in the table.  If you choose "no index checking in the generated code" and 
the breakpoint index is longer than the number of points in the table, an 
<b>array bounds read</b> error can occur, resulting in wrong answers or 
even segmentation violations in code generated by Real-Time Workshop.  If 
the breakpoint array is correct, there is no possibility of this type of 
behavior.</p>

 
<h3>Sub-table selection</h3>

<p>If some dimensions of the lookup table are pure selections and are not 
to be interpolated, use the interpolation n-D block's "Number of sub-table 
selection ports" to specify the number of dimensions that are index-only. 
For example, if you have a 3-D table that is really meant to be a stack of 
2-D interpolation tables, the last dimension of the table can be marked 
as a "selection dimension", meaning that the input for that dimension 
is an integer used only to make a sub-table selection, such as picking a 
2-D plane from a 3-D table. The sub-table is then interpolated normally.</p>

<p>This way, only a 2-D interpolation is performed instead of a 3-D 
interpolation.  Since an N-dimensional interpolation takes (2^N)-1 
individual interpolation operations<br><br>

<code> (y_interp = ylow + f*(yhigh-ylow)), </code><br><br>

even just one dimension of selection can almost double the speed of 
the interpolation.  Extreme example:  a 5-D table with 3 dimensions of 
sub-table selection and 2-D interpolation:  5-D interpolation would take 
2^5-1 = 31 interpolations, but a 2-D interpolation takes only 2^2 - 1 = 3.
</p>


<br><hr width="300" align="left">


<h3>See also:</h3>

<ol>
<li>"Real-Time Workshop User's Guide", Chapter 8, "Optimizing the Model
for Code Generation", section "Look-Up Tables and Polynomials".</li>
</ol>


<br><hr width="300" align="left">

<h3>Related Products</h3>

<p>MathWorks offers several products which may come in handy during work in
designing implementations of nonlinear functional relationships.  For further
information see also:</p>

<font size="-1">
<UL>
 <LI>Simulink Parameter Estimation (adaptive tables)</LI>
 <LI><a href="http://www.mathworks.com/products/curvefitting">
     Curve Fitting Toolbox</a></LI>
 <LI><a href="http://www.mathworks.com/products/mbc">
     Model-Based Calibration Toolbox</a></LI>
 <LI><a href="http://www.mathworks.com/products/optimization">
     Optimization Toolbox</a></LI>
 <LI><a href="http://www.mathworks.com/products/splines">
     Spline Toolbox</a></LI>
</UL>
</font>

</html>
