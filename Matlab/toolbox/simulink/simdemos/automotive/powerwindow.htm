<!-- $Revision: 1.3.4.2 $ -->
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Simulink demo</title>

<LINK rel=StyleSheet href="style.css" type="text/css">

</head>

<body bgcolor="#FFFFFF">

<p style="color:#990000; font-weight:bold; font-size:x-large">Simulink Power Window Controller Specification</p>

<p>
The MATLAB and Simulink product families consists of a set of
versatile tools that support Model-Based Development for embedded control design
all the way from initial specification to code generation.
<p>
To manage the complexity of not only today's engineered systems but also of
their design teams, structured analysis methods are used to systematically
arrive at rigorous, unambiguous, and consistent specifications. 
</p>

<p>
In this context, the MATLAB and Simulink product families can be used to
provide executable specifications that support system design closer to its
actual realization than typical Computer-Aided Systems/Software Engineering
(CASE) tools can.
</p>

<p>
This example shows how you can use the MathWorks tool set and the Model-Based
Development process to go from concept through to implementation. In addition,
this demo illustrates how you can link your model to your system documentation.
</p>

<p>
The overall power window design includes:
<ul>
<li>high-level discrete event control specification</li>
<li>combined discrete event and continuous time systems, hybrid dynamic systems</li>
<li>hybrid control combined with energy based components:
<ul>
<li>power electronics to model actuator dynamics</li>
<li>multi-body system components to model the power window plant</li>
</ul></li>
<li>automatically generated controller code for the control subsystem</li>
</ul>
</p>

<p>
<font color="FF0000">Throughout this demo, links appear that have to be activated in
the presented sequence.
These links are in bold.
Please click each of the bold faced links as they appear in the text.
You can jump to a particular stage by skipping several links in bold,
but to revert, you will have to reload the demo.</font>
</p>

<p style="color:#990000; font-weight:bold; font-size:x-large">Introduction</p>

<p>
Nowadays, electronics are used in automobiles to control, e.g., the opening
and closing of windows and sun-roof, adjusting the mirrors/headlights, and
to lock and unlock the doors. These systems are subject to stringent operation
constraints as failure may result in dangerous and possibly life-threatening
situations. Therefore, a careful design and analysis is mandatory before
deployment.
</p>

<p>
In this example, let's concentrate on the power window system of an automobile,
specifically, the passenger-side window. A critical aspect of this system is
that it can never exert a force of more than 100 [N] on an object
when closing the window, see:
<blockquote>
    <blockquote>
        <p>
		<img src="pw_window1b.jpg" alt="" border="0" align="">
		</p>
    </blockquote>
</blockquote>
When such an object is detected, the window is to be lowered by about 10 [cm].
</p>

<p style="color:#990000; font-weight:bold; font-size:x-large">Requirements</p>

<p>
More formally, the quantitative requirements for the control can be stated:
<ul>
<li>The window has to be fully opened and fully closed within 4 [s].
</li>
<li>If the up or down command is issued for at least 200 [ms] and at most
1 [s], the window has to be fully opened or closed, respectively.
</li>
<li>The window has to start moving 200 [ms] after the command is issued.
</li>
<li>The force to detect when an object is present should be less than 100 [N].
</li>
<li>When an object is present, the window should be lowered by approximately 10 [cm].
</li>
</ul>
</p>

<p style="color:#990000; font-weight:bold; font-size:x-large">Discrete Event Control</p>

<p>
The discrete event control of the window can be modeled by a statechart,
i.e., a finite state machine with hierarchy and parallelism. This state
machine contains the basic states of the power window system
<font face="Courier">up</font>,
<font face="Courier">auto-up</font>,
<font face="Courier">down</font>,
<font face="Courier">auto-down</font>,
<font face="Courier">rest</font>, and
<font face="Courier">emergency</font>.
It models the state transitions between these and accounts for the 
precedence of driver commands over the passenger commands.
It also includes emergency behavior that is to be activated when
an object is detected to be present between the window and the frame
while moving up.
The <a href="matlab:powerwindowscript('initialize');"><b>initial Simulink model</b></a>
for the
<a href="matlab:powerwindowscript('highlight statechart');">power window control</a>
is a
<a href="matlab:powerwindowscript('open control');">discrete event controller</a>
that runs at a
given <a href="matlab:powerwindowscript('highlight sample rate');">sample rate</a>.
The discrete event control is a Stateflow model that extends the 
state transition diagram notion with hierarchy and parallelism.
Note that state changes because of passenger commands are encapsulated
in a <i>super state</i> that corresponds to no active driver commands.
</p>

<p>
Here, the control of the passenger window is considered. This window can be
moved up and down by either the passenger or the driver. The model includes
this control input as 
<a href="matlab:powerwindowscript('highlight passenger and driver switches');">switches</a>
that can be manually operated by double-clicking them. 
</p>


<p>
The state machine that controls a power window is tested by running the input
test vectors and verifying that the desired internal state is reached and
output is generated. The power window has four external inputs:
<ul>
<li>passenger input consists of a vector with three elements:
<ul>
<li><font face="Courier">neutral</font>: the passenger control switch is not depressed</li>
<li><font face="Courier">up</font>: the passenger control switch generates the up signal</li>
<li><font face="Courier">down</font>: the passenger control switch generates the down signal</li>
</ul></li>
<li>driver input</li>
<ul>
<li><font face="Courier">neutral</font>: the driver control switch is not depressed</li>
<li><font face="Courier">up</font>: the driver control switch generates the up signal</li>
<li><font face="Courier">down</font>: the driver control switch generates the down signal</li>
</ul></li>
<li>whether top or bottom of the window frame is reached
<ul>
<li>0: window moves freely between top or bottom</li>
<li>1: window is stuck at the top or bottom because of physical limitations</li>
</ul></li>
<li>whether an obstacle is present between the window and its frame
<ul>
<li>0: window moves freely between top or bottom</li>
<li>1: window is stuck at the top or bottom because of physical limitations</li>
</ul></li>
</ul>
The passenger and driver input signals are generated by
<a href="matlab:powerwindowscript('highlight maps');">mapping the up and
down signals</a> according to the following table

<p>
<table bordercolor="#000000" cellspacing="2" cellpadding="4" border="1" align="center">
  <tr align="center"><!-- Row 1 -->
    <td bordercolor="#FF0000" bgcolor="#FF8888"><b>up</b></td>
    <td bordercolor="#FF0000" bgcolor="#FF8888"><b>down</b></td>
    <td bordercolor="#0000FF" bgcolor="#8888FF"><b>neutral</b></td>
    <td bordercolor="#0000FF" bgcolor="#8888FF"><b>up</b></td>
    <td bordercolor="#0000FF" bgcolor="#8888FF"><b>down</b></td>
  </tr>
  <tr align="center"><!-- Row 2 -->
    <td bordercolor="#FF0000" bgcolor="FFCCCC">0</td>
    <td bordercolor="#FF0000" bgcolor="FFCCCC">0</td>
    <td bordercolor="#0000FF" bgcolor="CCCCFF">1</td>
    <td bordercolor="#0000FF" bgcolor="CCCCFF">0</td>
    <td bordercolor="#0000FF" bgcolor="CCCCFF">0</td>
  </tr>
  <tr align="center"><!-- Row 3 -->
    <td bordercolor="#FF0000" bgcolor="FFCCCC">0</td>
    <td bordercolor="#FF0000" bgcolor="FFCCCC">1</td>
    <td bordercolor="#0000FF" bgcolor="CCCCFF">0</td>
    <td bordercolor="#0000FF" bgcolor="CCCCFF">0</td>
    <td bordercolor="#0000FF" bgcolor="CCCCFF">1</td>
  </tr>
  <tr align="center"><!-- Row 4 -->
    <td bordercolor="#FF0000" bgcolor="FFCCCC">1</td>
    <td bordercolor="#FF0000" bgcolor="FFCCCC">0</td>
    <td bordercolor="#0000FF" bgcolor="CCCCFF">0</td>
    <td bordercolor="#0000FF" bgcolor="CCCCFF">1</td>
    <td bordercolor="#0000FF" bgcolor="CCCCFF">0</td>
  </tr>
  <tr align="center"><!-- Row 5 -->
    <td bordercolor="#FF0000" bgcolor="FFCCCC">1</td>
    <td bordercolor="#FF0000" bgcolor="FFCCCC">1</td>
    <td bordercolor="#0000FF" bgcolor="CCCCFF">1</td>
    <td bordercolor="#0000FF" bgcolor="CCCCFF">0</td>
    <td bordercolor="#0000FF" bgcolor="CCCCFF">0</td>
  </tr>

</table>
</p>

to explicitly generate the <font face="Courier">neutral</font> event from
the <font face="Courier">up</font> and <font face="Courier">down</font>
events as generated by pressing a power window control switch.
The blue part of the table is entered as
<a href="matlab:powerwindowscript('open truth table');">truth table</a>
in the map.
</p>

<p style="color:#990000; font-weight:bold; font-size:large">Window Up</p>

<p>
To observe the state machine behavior, first 
<a href="matlab:powerwindowscript('run');">run the simulation</a>
and then
double-click the 
<a href="matlab:powerwindowscript('highlight passenger up');">passenger window up switch</a>
or click <a href="matlab:powerwindowscript('passenger window up');">here</a>.
If the switch was pressed for more than one
second, the window moves up till the up switch is
<a href="matlab:powerwindowscript('passenger window up release');">released</a>
(or the top of the
window frame is reached and the
<a href="matlab:powerwindowscript('endstop');"><font face="Courier">endstop</font> event</font>
is generated</a>).
</p>

<p>
Please first <a href="matlab:powerwindowscript('reset switches');">reset the switches</a>
before continuing.
</p>

<p style="color:#990000; font-weight:bold; font-size:large">Window Auto-Up</p>

<p>
If the passenger up switch was pressed for a short period of time (less than a second),
<i>auto-up</i>
is activated and the window continues to move up.
To observe this state change, click the following links shortly after one another:
<a href="matlab:powerwindowscript('passenger window up');">here</a> and
<a href="matlab:powerwindowscript('passenger window up release');">here</a>.
Ultimately, the window reaches the top of the frame and the
<a href="matlab:powerwindowscript('endstop');"><font face="Courier">endstop</font> event</font>
is generated</a>
that moves the state machine back to its
neutral state.
</p>

<p>
Please first <a href="matlab:powerwindowscript('reset switches');">reset the switches</a>
before continuing.
</p>

<p style="color:#990000; font-weight:bold; font-size:large">Driver-side Precedence</p>

<p>
The driver switch for the passenger window takes precedence over the driver
commands. 
First, move the system to its <font face="Courier">passenger up</font>
state by double-clicking the passenger window up switch
or click
<a href="matlab:powerwindowscript('passenger window up');">here</a>.
Next, double-click the
<a href="matlab:powerwindowscript('highlight driver down');">driver window down switch</a>
or click <a href="matlab:powerwindowscript('driver window down');">here</a>.
Notice how the state machine moves to the driver control part to generate the
window down output instead of the window up output.
When the driver control is
<a href="matlab:powerwindowscript('driver window up');">switched to up</a>,
the driver window up state is reached that generates the window up output again, i.e.,
<font face="Courier">windowUp = 1</font>.
</p>

<p>
To observe state behavior when an object is present between the window and its
frame, double-click the
<a href="matlab:powerwindowscript('highlight obstacle');">obstacle switch</a>
or click <a href="matlab:powerwindowscript('obstacle');">here</a>. On the next
sample time, the state machine moves to its <font face="Courier">emergencyDown</font> state to
lower the window a few inches. How far exactly depends on how long the
state machine is in the <font face="Courier">emergencyDown</font> state and is part of the next 
analysis phase.
</p>

<p>
Note that if any of the driver or passenger window
switches is still active, the state machine 
moves into the up or down states upon the next sample time after the emergency
state is departed. If the obstacle switch is still active too, the emergency
state is then activated at again the next sample time.
</p>

<p>
Please
<a href="matlab:powerwindowscript('stop');">stop the simulation</a>
and
<a href="matlab:powerwindowscript('reset switches');">reset the switches</a>
before continuing.
</p>

<p style="color:#990000; font-weight:bold; font-size:x-large">Validation of the Control Subsystem</p>

<p>
We can now validate the discrete event control of the window with 
the model coverage tool. This tool will help us determine the extent 
to which a model test case exercises the conditional branches of
the controller. It helps evaluate whether all transitions in the
discrete event control are taken given the test case we run as well as
whether all clauses in a condition that enables a particular transition have become 
true. One transition may be enabled by multiple clauses, e.g.,
the transition from emergency back to neutral occurs when either
100 ticks have occurred or whether the end stop is reached.
</p>
<p>
To achieve full coverage, it is required that each of the individual
clauses evaluates to true and false for the test cases used.
The percentage of transitions that a test case exercises is 
called its model coverage. Model coverage is a measure of how thoroughly a test
exercises a model.
</p>
<p>
Let us apply the following test to our power window controller:
</p>
<p>
<table bordercolor="#000000" cellspacing="2" cellpadding="4" border="1" align="center">
  <tr align="center"><!-- Row 1 -->
    <td><b>step</b></td>
    <td><b>0</b></td>
    <td><b>1</b></td>
    <td><b>2</b></td>
    <td><b>3</b></td>
    <td><b>4</b></td>
    <td><b>5</b></td>
    <td><b>6</b></td>
  </tr>
  <tr align="center"><!-- Row 2 -->
    <td><b>passenger up</b></td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr align="center"><!-- Row 3 -->
    <td><b>passenger down</b></td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
  </tr>
  <tr align="center"><!-- Row 4 -->
    <td><b>driver up</b></td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr align="center"><!-- Row 5 -->
    <td><b>driver down</b></td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
</table>
</p>
<p>
With this test, all switches are inactive at time 0. At regular 1 [s]
steps, the state of one or more of the switches is changed. For example,
after 1 [s], the driver down switch becomes active.
To automatically run these input vectors,
<a href="matlab:powerwindowscript('powerwindow cv');"><b>replace the manual switches by prescribed sequences of input</b></a>.
The commands to generate the 
test and create the report are as follows:
<ul>
<li>Create a test object to hold the coverage results (<font face="Courier">testObj1 = cvtest('powerwindow', 'first_test', 'load firsttest')</font>).</li>
<li>Simulate the system for 7 [s] (<font face="Courier">[dataObj1,T,X,Y]=cvsim(testObj1,[0 7])</font>).</li>
<li>Create and open an HTML report with the coverage data (<font face="Courier">cvhtml('powerwindow report',dataObj1)</font>)</li>
</ul>
Let us now first <a href="matlab:powerwindowscript('open control');">open the Stateflow control</a> and then
<a href="matlab:powerwindowscript('model coverage');">create the coverage report</a>.
The results in the report reveal the following: 
</p>
<p>The test we have run handles 100% of the decision outcomes from the "driver neutral, up, down map" block while only 50% of the decision outcomes
of the "passenger neutral, up, down map" block is handled by the test. Also, the "endstop" and "obstacle" blocks are covered at 50% of their decision outcomes.</p> 
<p>Now, before continuing, recover the <a href="matlab:powerwindowscript('initial powerwindow');"><b>initial powerwindow</b></a> model.
</p>
<p style="color:#990000; font-weight:bold; font-size:x-large">Continuous Plant Behavior</p>

<p>
Once the discrete event control has been designed and verified, it can
be coupled to the continuous time plant behavior. To this end,
first 
<a href="matlab:powerwindowscript('remove output');"><b>remove initial input/output blocks</b></a>
that connect to ports that have to be connected to the
<a href="matlab:powerwindowscript('add continuous');"><b>continuous plant behavior</b></a>.
The plant is modeled as a second order differential equation with step-wise
changes in its input:
<ul>
<li>when the Stateflow chart generates <font face="Courier">windowUp</font> the input is 1,</li>
<li>when the Stateflow chart generates <font face="Courier">windowDown</font> the input is -1,</li>
<li>otherwise, the input is 0.</li>
</ul>

<p>
This phase allows analysis of the interaction between the discrete event
state behavior, its sample rate, and the continuous behavior of the window
movement. There are 
<a href="matlab:powerwindowscript('highlight thresholds');">threshold values</a>
established to generate the window frame
top and bottom, i.e., <font face="Courier">endStop</font>, events and the event when an
obstacle is present, i.e., <font face="Courier">obstacle</font>.
</p>

<p>
Before simulation, a continuous time solver has to be selected. You can
do so by selecting the <font face="Courier">Simulation</font> menu, then the
<font face="Courier">Simulation parameters</font> item
and next the <font face="Courier">Solver</font> tab.
You can change the solver parameter there or 
change to the Bogacki-Shampine solver by clicking
<a href="matlab:powerwindowscript('ode23');">here</a>.
</p>

<p>
A structured analysis of a system results in a functional decomposition
of the system, a data dictionary with the specifics of the system signals,
and the timing constraints. Another aspect is the implementation architecture,
which is not discussed here.
</p>

<p style="color:#990000; font-weight:bold; font-size:large">Activity Diagrams</p>

<p>
Activity diagrams are a means to graphically capture the specification and
gain understanding of system operation. A hierarchical structure facilitates
analysis of even large systems. At the top-level, a <i>context diagram</i>
describes the system environment its interaction with the system under study
in terms of (i) data exchange and (ii) control operations.
The system is then decomposed into an activity diagram with processes and
control specifications (called a CSPEC).
The processes guide the hierarchical decomposition:
Each process is specified by another activity diagram or a primitive
specification (called a PSPEC). A PSPEC can be given in a number of 
representations with a formal semantic, e.g., a Simulink
block diagram.
</p>

<p>
The following figure represents the context diagram of a power window system.
The square boxes capture the environment. In this case, the driver, passenger
and the window. Both the driver and passenger can send commands to the window
to move it up and down. The controller infers the correct command to be sent
to the window actuator (e.g., the driver command has priority over the passenger
command). In addition, the state of the window system is monitored to establish
when the window is fully opened and closed and to detect whether an object is
present between the window and frame.    
</p>
<p>
<b>CONTEXT DIAGRAM:</b> POWER WINDOW SYSTEM
<blockquote>
    <blockquote>
        <p>
		<img src="pw_CONTEXT.jpg" width="438" height="275" alt="" border="2" align="">
		</p>
    </blockquote>
</blockquote>
</p>

<p>
The power window controller is depicted by a circle (also referred to as 'bubble').
This is the graphical notation for a process.
Processes capture the transformation of input data into output data.
In case of a primitive process, control may also be generated. CSPECs typically
consist of combinational or sequential logic to infer output control signals
from input control.
</p>

<p>
Let's rearrange the Simulink model</a> to resemble the activity
diagram by
<ul>
<li><a href="matlab:powerwindowscript('context plant');"><b>combining the plant behavior</b></a>
into one subsystem,
</li>
<li><a href="matlab:powerwindowscript('context switches');"><b>combining the driver and passenger switches</b></a>
into two subsystems,
</li>
<li><a href="matlab:powerwindowscript('context control');"><b>putting the control in one subsystem</b></a>, and
</li>
<li><a href="matlab:powerwindowscript('context connect');"><b>connecting the new subsystems</b></a>.
</li>
<li><a href="matlab:powerwindowscript('resize for context diagram');">resize for the context diagram</a>.
</li>
</ul>
</p>

<p>
Now, the power window controller of the context diagram can be decomposed into
parts by using an activity diagram as shown below.
The input and output signals present in the context diagram are shown here again
so they can be easily traced to their origins.
</p>
<p>
<b>AD 1:</b> POWER WINDOW CONTROL
<blockquote>
    <blockquote>
        <p>
		<img src="pw_AD1.jpg" width="567" height="346" alt="" border="2" align="">
		</p>
    </blockquote>
</blockquote>
</p>

<p>
The power window control consists of three processes and a CSPEC.
Two of the processes validate the driver and passenger input to ensure their
input is meaningful given the state of the system (e.g., if the window
is completely opened, the 'window down' command is not sensible).
The remaining process detects whether the window is completely opened
or completely closed and whether an object may be present.
The CSPEC takes the control signals and infers whether the window
should be moved up or down (e.g., if an object is present, the window
should be moved down for about one second or until an endstop is reached).
</p>

<p>
In Simulink,
<a href="matlab:powerwindowscript('AD1');">open the power window control</a>
subsystem and note that the
Stateflow chart with the discrete event control forms the CSPEC, represented
by the tilted thick bar in the bottom right corner. 
The threshold detection mechnisms are encapsulated in the
<a href="matlab:powerwindowscript('position detection');">detect_obstacle_endstop</a>
subsystem.
</p>   

<p>
Now,
<a href="matlab:powerwindowscript('include data validation');"><b>add data validation functionality</b></a>
for the driver and passenger commands
to ensure correct operation (e.g., when the 
window has reached its top, the up command should be blocked). 
Each of the validation process can be decomposed in new subsystems.
Let's have a look at
the validation of the driver's commands (validation of the passenger's commands
is similar). First, it has to be checked whether the 'up' or 'down' commands
can be executed. The 'down' command is only allowed when the window is
not completely opened. The 'up' command is only allowed when the window
is not completely closed and no object is detected.
The third process ensures that only one of the three commands
('neutral', 'up', 'down') is sent to the controller. Note that in an 
actual implementation,
it may well be possible that both 'up' and 'down' are true simultaneously
(e.g., because of switch bouncing effects).  
</p> 

<p>
<b>AD 1.1:</b> VALIDATE DRIVER
<blockquote>
    <blockquote>
        <p>
		<img src="pw_AD11.jpg" width="525" height="325" alt="" border="2" align="">
		</p>
    </blockquote>
</blockquote>
</p>

<p>
Each of the processes in the VALIDATE DRIVER activity chart is
primitive and specified by a PSPEC. These PSPECs are given below
according to the previous discussion. Note that in the MAKE EXCLUSIVE
PSPEC the 'down' command takes precedence over the 'up' command,
for safety reasons.
</p>

<p>
<table border=0 cellspacing=0 cellpadding=5 bgcolor="#ffe4b0" width="100%">
<tr>
<td colspan=4>
<div class=PSPEC>
<b>PSPEC 1.1.1:</b> CHECK DOWN
</div>
</td></tr><tr><td width="5"></td><td valign="top" width="1">
CHECKED_DOWN
</td><td valign="top" width="1">
=
</td><td halign="left">
DOWN <b>and</b> <b>not</b> RESET
</td></tr>
</table>
</p>

<p>
<table border=0 cellspacing=0 cellpadding=5 bgcolor="#ffe4b0" width="100%">
<tr>
<td colspan=4>
<div class=PSPEC>
<b>PSPEC 1.1.2:</b> CHECK UP
</div>
</td></tr><tr><td width="5"></td><td valign="top" width="1">
CHECKED_UP
</td><td valign="top" width="1">
=
</td><td halign="left">
UP <b>and</b> <b>not</b> RESET
</td></tr>
</table>
</p>

<p>
<table border=0 cellspacing=0 cellpadding=5 bgcolor="#ffe4b0" width="100%">
<tr>
<td colspan=4>
<div class=PSPEC>
<b>PSPEC 1.1.3:</b> MAKE EXCLUSIVE
</div>
</td></tr><tr><td width="5"></td><td valign="top" width="1">
VALIDATED_DOWN
</td><td valign="top" width="1">
=
</td><td halign="left">
CHECKED_DOWN
</td></tr><tr><td width="5"></td><td valign="top" width="1">
VALIDATED_UP
</td><td valign="top" width="1">
=
</td><td halign="left">
CHECKED_UP <b>and</b> <b>not</b> CHECKED_DOWN
</td></tr><tr><td width="5"></td><td valign="top" width="1">
VALIDATED_NEUTRAL
</td><td valign="top" width="1">
=
</td><td halign="left">
(NEUTRAL <b>and</b> <b>not</b> (CHECKED_UP <b>and</b> <b>not</b> CHECKED_DOWN))
<b>or</b> <b>not</b> (CHECKED_UP <b>or</b> CHECKED_DOWN)
</td></tr>
</table>
</p>

<p>
The PSPECS are given by
</p>

<p>
The internals of the VALIDATE PASSENGER process are exactly the same as the
VALIDATE DRIVER process. The only difference between the two are the 
different input and output. The VALIDATE PASSENGER is given below.
</p>

<p>
<b>AD 1.2:</b> VALIDATE PASSENGER
<blockquote>
    <blockquote>
        <p>
		<img src="pw_AD12.jpg" width="525" height="325" alt="" border="2" align="">
		</p>
    </blockquote>
</blockquote>
</p>

<p>
<table border=0 cellspacing=0 cellpadding=5 bgcolor="#ffe4b0" width="100%">
<tr>
<td colspan=4>
<div class=PSPEC>
<b>PSPEC 1.2.1:</b> CHECK DOWN
</div>
</td></tr><tr><td width="5"></td><td valign="top" width="1">
CHECKED_DOWN
</td><td valign="top" width="1">
=
</td><td halign="left">
DOWN <b>and</b> <b>not</b> RESET
</td></tr>
</table>
</p>

<p>
<table border=0 cellspacing=0 cellpadding=5 bgcolor="#ffe4b0" width="100%">
<tr>
<td colspan=4>
<div class=PSPEC>
<b>PSPEC 1.2.2:</b> CHECK UP
</div>
</td></tr><tr><td width="5"></td><td valign="top" width="1">
CHECKED_UP
</td><td valign="top" width="1">
=
</td><td halign="left">
UP <b>and</b> <b>not</b> RESET
</td></tr>
</table>
</p>

<p>
<table border=0 cellspacing=0 cellpadding=5 bgcolor="#ffe4b0" width="100%">
<tr>
<td colspan=4>
<div class=PSPEC>
<b>PSPEC 1.2.3:</b> MAKE EXCLUSIVE
</div>
</td></tr><tr><td width="5"></td><td valign="top" width="1">
VALIDATED_DOWN
</td><td valign="top" width="1">
=
</td><td halign="left">
CHECKED_DOWN
</td></tr><tr><td width="5"></td><td valign="top" width="1">
VALIDATED_UP
</td><td valign="top" width="1">
=
</td><td halign="left">
CHECKED_UP <b>and</b> <b>not</b> CHECKED_DOWN
</td></tr><tr><td width="5"></td><td valign="top" width="1">
VALIDATED_NEUTRAL
</td><td valign="top" width="1">
=
</td><td halign="left">
(NEUTRAL <b>and</b> <b>not</b> (CHECKED_UP <b>and</b> <b>not</b> CHECKED_DOWN))
<b>or</b> <b>not</b> (CHECKED_UP <b>or</b> CHECKED_DOWN)
</td></tr>
</table>
</p>

<p>
The third process in the POWER WINDOW CONTROL activity diagram is the one
to detect the presence of an obstacle or when the window reaches its
top or bottom ('endstop'). The detection mechanism is based on the armature
current of the window actuator. During normal operation, this current is 
within certain bounds. When the window reaches its top or bottom, the
electro-motor draws a large current (more than 15 [A] or less than -15 [A])
to try and sustain its angular velocity. Similarly, during normal operation
the current is about 2 [A] or -2 [A] (depending on whether the window is
opening or closing). When an object is present, there is a slight deviation
from this value. To ensure the window force on the object is less than 
100 [N], the control switches to its emergency operation when a current
is detected that is less than -2.5 [A] (this is only necessary in case
the window is rolling up, which corresponds to a negative current in the
particular wiring of this model). This functionality is embodied by the
DETECT OBSTACLE ENDSTOP activity diagram and the process specifications
given below.
</p>

<p>
<b>AD 1.3:</b> DETECT OBSTACLE ENDSTOP
<blockquote>
    <blockquote>
        <p>
		<img src="pw_AD13.jpg" width="521" height="304" alt="" border="2" align="">
		</p>
    </blockquote>
</blockquote>
</p>

<p>
<table border=0 cellspacing=0 cellpadding=5 bgcolor="#ffefbf" width="100%">
<tr>
<td colspan=4>
<div class=PSPEC>
<b>CSPEC 1.3:</b> DETECT OBSTACLE ENDSTOP
</div>
</td></tr><tr><td width="5"></td><td valign="top" width="1">
RESET
</td><td valign="top" width="1">
=
</td><td halign="left" width="100%">
OBSTACLE <b>or</b> ENDSTOP
</td></tr>
</table>
</p>

<p>
<table border=0 cellspacing=0 cellpadding=5 bgcolor="#ffe4b0" width="100%">
<tr>
<td colspan=4>
<div class=PSPEC>
<b>PSPEC 1.3.1:</b> DETECT ENDSTOP
</div>
</td></tr><tr><td width="5"></td><td valign="top" width="1">
ENDSTOP
</td><td valign="top" width="1">
=
</td><td halign="left">
ARMATURE_CURRENT &gt; ENDSTOP_MAX
</td></tr>
</table>
</p>

<p>
<table border=0 cellspacing=0 cellpadding=5 bgcolor="#ffe4b0" width="100%">
<tr>
<td colspan=4>
<div class=PSPEC>
<b>PSPEC 1.3.2:</b> DETECT OBSTACLE
</div>
</td></tr><tr><td width="5"></td><td valign="top" width="1">
OBSTACLE
</td><td valign="top" width="1">
=
</td><td halign="left">
(ARMATURE_CURRENT &gt; OBSTACLE_MAX) <b>and</b> MOVE_UP <b>for</b> 500 [ms] 
</td></tr>
</table>
</p>

<p>
<table border=0 cellspacing=0 cellpadding=5 bgcolor="#ffe4b0" width="100%">
<tr>
<td colspan=4>
<div class=PSPEC>
<b>PSPEC 1.3.3:</b> ABSOLUTE VALUE
</div>
</td></tr><tr><td width="5"></td><td valign="top" width="1">
ABSOLUTE_ARMATURE_CURRENT
</td><td valign="top" width="1">
=
</td><td halign="left">
<b>abs</b>(ARMATURE_CURRENT)
</td></tr>
</table>
</p>

<p style="color:#990000; font-weight:bold; font-size:large">Data Dictionary</p>

<p>
The functional decomposition specifies each of the processes unambiguously
by their decomposition or primitive specification (PSPEC).
In addition, the signals in the activity diagrams
have to be formally specified as well. This is the goal of the
<i>data dictionary</i>.
</p>

<p>
The data dictionary contains a table with entries for each of the signals
used in any of the activity diagrams.
</p>

<table width="100%" cellspacing="2" cellpadding="2" border="2">
<DIV CLASS=table>
  <tr BGCOLOR="#DDDDDD"><!-- Row 1 -->
    <td><b>AD0</b></td>
    <td COLSPAN=5>POWER WINDOW SYSTEM</td>
  </tr>
  <tr><!-- Row 2 -->
    <td>DRIVER_COMMAND</td>
    <td>DATA</td>
    <td>DISCRETE</td>
    <td>AGGREGATE</td>
    <td>NEUTRAL,UP,DOWN</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 3 -->
    <td>PASSENGER_COMMAND</td>
    <td>DATA</td>
    <td>DISCRETE</td>
    <td>AGGREGATE</td>
    <td>NEUTRAL,UP,DOWN</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 4 -->
    <td>WINDOW_POSITION</td>
    <td>DATA</td>
    <td>CONTINUOUS</td>
    <td>REAL</td>
    <td>MIN: 0 [m]</td>
    <td>MAX: 0.4 [m}</td>
  </tr>
  <tr><!-- Row 5 -->
    <td>MOVE_UP</td>
    <td>CONTROL</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 6 -->
    <td>MOVE_DOWN</td>
    <td>CONTROL</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr BGCOLOR="#DDDDDD"><!-- Row 7 -->
    <td><b>AD1</b></td>
    <td COLSPAN=5>POWER WINDOW CONTROLLER</td>
  </tr>
  <tr><!-- Row 8 -->
    <td>RESET</td>
    <td>CONTROL</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 9 -->
    <td>VALIDATED_DRIVER_COMMAND</td>
    <td>CONTROL</td>
    <td>DISCRETE</td>
    <td>AGGREGATE</td>
    <td>NEUTRAL,UP,DOWN</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 10 -->
    <td>VALIDATED_PASSENGER_COMMAND</td>
    <td>CONTROL</td>
    <td>DISCRETE</td>
    <td>AGGREGATE</td>
    <td>NEUTRAL,UP,DOWN</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 11 -->
    <td>OBSTACLE</td>
    <td>CONTROL</td>
     <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 12 -->
    <td>ENDSTOP</td>
    <td>CONTROL</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr BGCOLOR="#DDDDDD"><!-- Row 13 -->
    <td><b>AD1.1</b></td>
    <td COLSPAN=5>VALIDATE_DRIVER</td>
  </tr>
  <tr><!-- Row 14 -->
    <td>NEUTRAL</td>
    <td>DATA</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 15 -->
    <td>UP</td>
    <td>DATA</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 16 -->
    <td>DOWN</td>
    <td>DATA</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 17 -->
    <td>CHECKED UP</td>
    <td>DATA</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 18 -->
    <td>CHECKED DOWN</td>
    <td>DATA</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr BGCOLOR="#DDDDDD"><!-- Row 19 -->
    <td><b>AD1.2</b></td>
    <td COLSPAN=5>VALIDATE_PASSENGER</td>
  </tr>
  <tr><!-- Row 20 -->
    <td>NEUTRAL</td>
    <td>DATA</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 21 -->
    <td>UP</td>
    <td>DATA</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 22 -->
    <td>DOWN</td>
    <td>DATA</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 23 -->
    <td>CHECKED UP</td>
    <td>DATA</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 24 -->
    <td>CHECKED DOWN</td>
    <td>DATA</td>
    <td>DISCRETE</td>
    <td>BOOLEAN</td>
    <td>'TRUE','FALSE'</td>
    <td>&nbsp;</td>
  </tr>
  <tr BGCOLOR="#DDDDDD"><!-- Row 25 -->
    <td><b>AD1.3</b></td>
    <td COLSPAN=5>DETECT_OBSTACLE_ENDSTOP</td>
  </tr>
  <tr><!-- Row 26 -->
    <td>ENDSTOP_MIN</td>
    <td>DATA</td>
    <td>CONSTANT</td>
    <td>REAL</td>
    <td>VALUE: 0.0 [m]</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 27 -->
    <td>ENDSTOP_MAX</td>
    <td>DATA</td>
    <td>CONSTANT</td>
    <td>REAL</td>
    <td>VALUE: 0.4 [m]</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 28 -->
    <td>OBSTACLE_MAX</td>
    <td>DATA</td>
    <td>CONSTANT</td>
    <td>REAL</td>
    <td>VALUE: 0.3 [m]</td>
    <td>&nbsp;</td>
  </tr>
</DIV>
  
</table>

<p style="color:#990000; font-weight:bold; font-size:large">Timing Requirements</p>

<p>
Now, open the
<a href="matlab:powerwindowscript('open position scope');"><font face="Courier">position</font> measurement</a> (in [m])
to view the window movement and
<a href="matlab:powerwindowscript('run');">run the simulation</a>.
Double-click the 
<a href="matlab:powerwindowscript('highlight subsystem passenger up');">passenger window up switch</a>
or click <a href="matlab:powerwindowscript('subsystem passenger window up');">here</a> to start moving the window
up. 
After 30 [cm], the <font face="Courier">obstacle</font> event is generated and the Stateflow
chart moves into its <font face="Courier">emergencyDown</font> state. In this state,
<font face="Courier">windowDown</font> is output for some time to lower the window by about
10 [cm]. Because the passenger window up switch is still on, the window starts moving up again
and this process repeats.
<a href="matlab:powerwindowscript('stop');">Stop the simulation</a>
and press the <font face="Courier">Autoscale</font> button on the position scope to
observe the oscillating process. Note that in case of an emergency
the discrete event control rolls down the window
approximately 10 [cm].
</p>

<p>
Please make sure you have
<a href="matlab:powerwindowscript('stop');">stopped the simulation</a>
and
<a href="matlab:powerwindowscript('reset subsystem switches');">reset the switches</a>
before continuing.
</p>

<p style="color:#990000; font-weight:bold; font-size:x-large">Power Effects</p>

<p>
After an initial analysis of the discrete event control and continuous dynamics,
a detailed plant model can be used to evaluate performance in a more realistic
situation. Models at such a level of detail are best designed in the
<i>power</i> domain, i.e., as energy flows. This is facilitated by several
domain specific blocksets.
</p>

<p>
Before including this behavior, first
<a href="matlab:powerwindowscript('remove continuous subsystem');"><b>remove the continuous behavior</b></a>
included before and
<a href="matlab:powerwindowscript('add power');"><b>add a more detailed subsystem</b></a>
consisting of
<a href="matlab:powerwindowscript('highlight electronics');">power electronics</a>
and a
<a href="matlab:powerwindowscript('highlight multi-body');">multi-body system</a>.
Let's have a look at these in detail next.
</p>

<p style="color:#990000; font-weight:bold; font-size:large">Power Electronics</p>

<p>
The control signals generated by the
discrete event controller
have to be 'amped up' to be sufficiently powerful to drive the
<a href="matlab:powerwindowscript('open motor');">DC motor</a>
that moves the window. This is modeled by the
<a href="matlab:powerwindowscript('open amplification up');">amplification modules</a>.
It shows that a switch either connects the DC motor
to the battery voltage or ground. By connecting the battery reversely, a
negative voltage is obtained and the window can be moved up, down, or remain
at its position. Note that the window is always driven at maximum power, i.e.,
no DC motor controller is present to apply a prescribed velocity.
</p>


<p style="color:#990000; font-weight:bold; font-size:large">Multi-Body System</p>

<p>
The window is modeled by using the multi-body system blockset. This consists
of a library of noncausal multi-body elements such as bodies, joints, and
actuators. The
<a href="matlab:powerwindowscript('open multi-body window');">window model</a>
consists of a
<a href="matlab:powerwindowscript('highlight worm gear');">worm gear</a>
and 
<a href="matlab:powerwindowscript('highlight lever');">lever</a>
to move the
<a href="matlab:powerwindowscript('highlight window');">window holder</a>
in the vertical direction.
The following figure shows how the mechanical parts move:
<blockquote>
    <blockquote>
        <p>
		<img src="pw_window2b.jpg" alt="" border="0" align="">
		</p>
    </blockquote>
</blockquote>

<p style="color:#990000; font-weight:bold; font-size:large">Design Iteration</p>

<p>
An important effect of the more detailed implementation is that there is no
window position measurement available. Instead, the current of the DC motor
is measured and used to detect the endstops and whether an obstacle is present.
This brings about the next stage in system design which now allows to analyze
the control and whether it indeed does not cause too large a force when an
obstacle is present.
</p>

<p>
In the originally designed system,
<a href="matlab:powerwindowscript('remove position detection');"><b>remove the obstacle and endstop detection</b></a>
based on the window position,
<a href="matlab:powerwindowscript('include current detection');"><b>replace it with a current based implementation</b></a>, and
<a href="matlab:powerwindowscript('connect current');"><b>connect the process</b></a>
to the controller and position and force measurements. This means that the data dictionary
has to be modified to reflect the different signals used.
</p>
<table width="100%" cellspacing="2" cellpadding="2" border="2">
<DIV CLASS=table>
  <tr BGCOLOR="#DDDDDD"><!-- Row 1 -->
    <td><b>AD0</b></td>
    <td COLSPAN=5>POWER WINDOW SYSTEM</td>
  </tr>
  <tr><!-- Row 4 -->
    <td>ARMATURE_CURRENT</td>
    <td>DATA</td>
    <td>CONTINUOUS</td>
    <td>REAL</td>
    <td>MIN: -20 [A]</td>
    <td>MAX: 20 [A}</td>
  </tr>
  <tr BGCOLOR="#DDDDDD"><!-- Row 25 -->
    <td><b>AD1.3</b></td>
    <td COLSPAN=5>DETECT_OBSTACLE_ENDSTOP</td>
  </tr>
  <tr><!-- Row 26 -->
    <td>ABSOLUTE_ARMATURE_CURRENT</td>
    <td>DATA</td>
    <td>CONTINUOUS</td>
    <td>REAL</td>
    <td>MIN: 0 [A]</td>
    <td>MAX: 20 [A]</td>
  </tr>
  <tr><!-- Row 27 -->
    <td>ENDSTOP_MAX</td>
    <td>DATA</td>
    <td>CONSTANT</td>
    <td>REAL</td>
    <td>VALUE: 15 [A]</td>
    <td>&nbsp;</td>
  </tr>
  <tr><!-- Row 27 -->
    <td>OBSTACLE_MAX</td>
    <td>DATA</td>
    <td>CONSTANT</td>
    <td>REAL</td>
    <td>VALUE: 2.5 [A]</td>
    <td>&nbsp;</td>
  </tr>
</DIV>
  
</table>

<p>
Let's also
<a href="matlab:powerwindowscript('add object switch');"><b>add a control mechanism</b></a>
to conveniently switch between the presence and absence of the object and 
<a href="matlab:powerwindowscript('resize for object switch');">resize the window</a>.
</p>

<p style="color:#990000; font-weight:bold; font-size:large">The System in Motion</p>

<p>
To view the geometrics of the system in motion, 
<a href="matlab:powerwindowscript('add VR world');"><b>add a virtual reality world</b></a>
and 
<a href="matlab:powerwindowscript('open VR world');">open it by double-clicking on the block</a>.
Select a stiff solver, e.g., the
<a href="matlab:powerwindowscript('ode23tb');">TR-BDF2</a> (an implicit Runge-Kutta formula).
In the <font face="Courier">Visualization</font> tab, check both options
<a href="matlab:powerwindowscript('subsystem passenger window up');">set the passenger up switch</a>
and
<a href="matlab:powerwindowscript('run');">run the simulation</a>
again. After some initial time
less than 1 [s] but more than 10 [ms] in simulation time (simulation time is displayed in the bottom-right corner of the model window status bar),
<a href="matlab:powerwindowscript('subsystem passenger window up release');">switch off the passenger up switch</a>
to initiate the auto-up behavior.
Notice how the window holder starts to move vertically to close the window.
When the object is encountered, the window is rolled down.
Click the
<a href="matlab:powerwindowscript('subsystem driver window down');">driver down switch</a>
to roll down the window completely. Again, after some initial time (less than one second simulation time)
<a href="matlab:powerwindowscript('subsystem driver window down release');">switch off the driver down switch</a>
to initiate the auto-down behavior.
</p>

<p>
When the window has reached the bottom of the frame,
<a href="matlab:powerwindowscript('stop');">stop the simulation</a>.
Now, open the
<a href="matlab:powerwindowscript('open position scope');"><font face="Courier">position</font> measurement</a> (in [m])
and the
<a href="matlab:powerwindowscript('open armature current scope');"><font face="Courier">armature current</font> (Ia) measurement</a> (in [A]).
Note that the absolute value of the
armature current transient during normal behavior does not exceed 10 [A].
The obstacle is detected when the absolute value of the 
armature current required to move the window up
exceeds 2.5 [A] (in fact, it less than -2.5 [A])
where during normal operation this is about 2 [A].
You probably have to zoom in to have a good look at this.
The window endstop
is detected when the absolute value of the armature current exceeds 15 [A].
</p>

<p>
Variation in the armature current during normal operation is due to
<a href="matlab:powerwindowscript('open friction');">friction</a>
that is included by sensing joint velocities and positions and
applying window specific coefficients. A
<a href="matlab:powerwindowscript('highlight friction table');">look-up table</a>
is used to this end
and noise is added to allow evaluation of the control robustness.  
</p>

<p style="color:#990000; font-weight:bold; font-size:large">Control Law Evaluation</p>

<p>
While the idealized continuous plant allowed access to the window position
for <font face="Courier">endStop</font> and <font face="Courier">obstacle</font> event generation, in the more
realistic situation, these events have to be generated from accessible 
physical variables. In case of the power window system, this typical is
the armature current, <font face="Courier">Ia</font>, of the DC motor that drives the worm gear.
</p>

<p>
While moving the window, this current will have a value around 2 [A] and 
when switched on, a transient current is drawn that may reach values of
around 10 [A]. End stop detection is activated when the current exceeds
a value of 15 [A], which is drawn when the angular velocity of the motor
is kept almost 0 despite a positive or negative input voltage.
</p>

<p>
Detecting the presence of an object is much more difficult in this setup.
Because safety restrictions prescribe that the window force should not 
exceed 100 [N], an object should be detected by an armature current much
less than 10 [A]. However, this conflicts with the transient values achieved
during normal operation.
</p>

<p>
Here, a control law is implemented that disables object detection during the
transient. Now, when an armature current that is more than 2 [A] is measured,
an object is considered to be present and the <font face="Courier">emergencyDown</font> state
of the discrete event control is entered.
Open the
<a href="matlab:powerwindowscript('open window force scope');"><font face="Courier">window force</font> measurement</a> (in [N])
to verify that the force exerted when an object is present and the window
reverses its velocity remains less than 100 [N].
</p>

<p>
Note that far more sophisticated
control laws are possible and implemented in reality. For example, neural-network
based learning feedforward control techniques can be implemented to emulate
the friction characteristic of each individual vehicle and its changes over
time.
</p>

<p style="color:#990000; font-weight:bold; font-size:large">Realistic Armature Measurement</p>

<p>
The armature current as used in the power window control is an ideal value
that is accessible because of the use of an actuator model. In a more realistic
situation, this current value has to be measured by data acquisition components.
To include these, first 
<a href="matlab:powerwindowscript('prepare realistic Ia');"><b>remove the ideal measurement</b></a>.
Next, 
<a href="matlab:powerwindowscript('include realistic Ia');"><b>add the more realistic measurement</b></a>
that include a signal conditioning block where the current is derived based on
a voltage measurement. This voltage is within the range of an analog-to-digital
converter (ADC) that discretizes based on a given number of bits. The resulting
value has to be scaled based on the value of the resistor that is used and
the range of the ADC that is chosen. 
<a href="matlab:powerwindowscript('fixed point processing');"><b>Include these operations as fixed point computations.</b></a>
Notice that 16 bits are required instead of 8 to achieve the necessary resolution with the given range.
</p>

<p>
Study the same scenario
<ul>
<li><a href="matlab:powerwindowscript('subsystem passenger window up');">set the passenger up switch</a></li>
<li><a href="matlab:powerwindowscript('run');">run the simulation</a></li>
<li>after some time <a href="matlab:powerwindowscript('subsystem passenger window up release');">switch off the passenger up switch</a>
<li>when the window has been rolled down, click the
<a href="matlab:powerwindowscript('subsystem driver window down');">driver down switch</a></li>
<li>after some time
<a href="matlab:powerwindowscript('subsystem driver window down release');">switch off the driver down switch</a></li>
<li>when the window has reached the bottom of the frame,
<a href="matlab:powerwindowscript('stop');">stop the simulation</a>.</li>
</ul>
Notice how the armature current now has a discretized appearance by
zooming in on it.
</p>

<p style="color:#990000; font-weight:bold; font-size:x-large">Reorganizing the Model</p>

<p>
To avoid cluttered diagrams, the designed model can be reorganized using
subsystems.
<ul>
<li>First, <a href="matlab:powerwindowscript('collapse DAQ subsystem');"><b>collapse the DAQ subsystem</b></a>
<li>Next, <a href="matlab:powerwindowscript('collapse process');"><b>collapse the actuator and plant subsystems</b></a>
</ul>
</p>

<p style="color:#990000; font-weight:bold; font-size:x-large">Communication</p>

<p>
Similar to the Stateflow output part, the input events have to be generated
by hardware, in this case the window control switches in the door 
and center control panels. These events are generated by local processors
and then communicated to the window controller by a CAN bus.
</p>

<p>
To include these phenomena, first
<a href="matlab:powerwindowscript('delete direct input');"><b>remove the idealized input</b></a>
and
<a href="matlab:powerwindowscript('add CAN input');"><b>add input from a CAN bus</b></a>.
Next,
<a href="matlab:powerwindowscript('add CAN output');"><b>add switch components</b></a>
that generate the events and put these on the CAN bus.
If you 
<a href="matlab:powerwindowscript('open switch subsystem');">open the switch subsystem</a> 
you note a structure very similar to the window control system:
again, there is a
<a href="matlab:powerwindowscript('highlight switch plant');">plant model</a> 
that represents the control switch, a
<a href="matlab:powerwindowscript('highlight switch DAQ');">data acquisition</a>
subsystem that includes, among other things, signal conditioning components, a
<a href="matlab:powerwindowscript('highlight switch control');">control module</a> 
to map the commands from the physical switch to logical commands, and a
<a href="matlab:powerwindowscript('highlight switch CAN module');">CAN module</a>
to post the events to the vehicle data bus. 
</p>

<p>
Additional communication effects (e.g., because of other systems using the CAN bus)
and more realism can be added similar to 
the described phases. Each of these phases allows analysis of the discrete
event controller in an increasingly realistic situation. Once a sufficient level of
detail is achieved, controller code can be automatically generated for
any specific target platform.
</p>

<p style="color:#990000; font-weight:bold; font-size:x-large">Code Generation</p>

<p>
To generate code of the  
<a href="matlab:powerwindowscript('highlight window control');">designed control</a>
first 
<a href="matlab:powerwindowscript('show sample rates');">check the sample rates</a>
of the controller by selecting
<font face="Courier">Sample time colors</font>
from the <font face="Courier">Port/Signal Displays</font> entry of
the <font face="Courier">Format</font> menu.
This shows that the controller runs at a uniform sample rate. 
</p>

<p>
Now, click your right mouse-button on the window control module 
and from <font face="Courier">Real-Time Workshop</font> select
<font face="Courier">Build Subsystem</font>
to build real-time code of the subsystem.
</p> 

<p>
<a href="matlab:powerwindowscript('closemodel');">Close</a>
the power window demonstration Simulink model.
</p>

<p style="color:#990000; font-weight:bold; font-size:x-large">References</p>

<p>
Pieter J. Mosterman, Janos Sztipanovits, and Sebastian Engell,
"Computer-Automated Multiparadigm Modeling in Control Systems Technology,"
<i>IEEE Transactions on Control Systems Technology</i>, vol. 12, no. 2, 
pp. 223-234, 2004.
</p>
<hr>

</body>
</html>
