function symtab=creatememobj(cc,address,type,size,varargin)
% Private. Creates a MEMORYOBJ object from ADDRESS.
% SYMOBJADDR(CC,ADDRESS,TYPE,SIZE) Creates either a NUMERIC memory object or a STRUCTURE 
% object. The default value for TYPE is 'UINT32' and for SIZE is 1.
%
% If TYPE is a NUMERIC type:
% SYMOBJADDR(CC,ADDRESS,TYPE,SIZE) Creates a NUMERIC memory object at the ADDRESS specified.
%
% If TYPE is a STRUCTURE type, VARARGIN contains the information needed to create the 
% structure object:
%
% SYMOBJADDR(CC,ADDRESS,TYPE,SIZE,VARARGIN) Creates a STRUCT object at the ADDRESS
% specified. The structure has TYPE as its struct datatype and has dimensions defined
% by SIZE. VARARGIN can be 
%
% {'STRUCTINFO', INFO} where INFO is a structure that contains information about 
% a variable having the SAME STRUCT TYPE as the STRUCT object being created. 
% INFO follows the structure format generated by the LIST(CC,'VARIABLE',VARNAME) method.
% 
% OR 
%
% {'MEMBERS',{'NAME1','TYPE1',SIZE1},
%            {'NAME2','TYPE2'},
%            {'NAME3','TYPE3',[]} }
%   where
%         NAMEn is the name of the nth structure member
%         TYPEn   is the data type of the nth structure member
%         SIZEn is the dimension of the nth structure member
%
% The order of member entries is followed when creating the structure object.
% 
% In cases where the SIZE value is not specified or is an empty entry,
% the SIZE property for the member defaults to 1.
% 
% NOTE: The latter implementation of SYMOBJADDR for structures will only accept members 
% having PRIMITIVE datatypes. If a structure member is another structure, set 
%   a) TYPE to UINT32 and 
%   b) SIZE to its equivalent uint32 elements 
% and use SYMOBJADDR again to create the STRUCT object.
%
% Copyright 2002-2003 The MathWorks, Inc.
%   $Revision: 1.3.4.1 $  $Date: 2003/11/30 23:06:55 $

p_errorif_ccarray(cc);

if ~ishandle(cc),
    error('First Parameter must be a CCSDSP Handle.');
end

if nargin==2
    type = 'uint32';
    size = 1;
elseif nargin==3
    size = 1;
end

% add default page, if necessary
if isnumeric(address) & length(address) == 1,
    address = [address cc.page];
elseif iscell(address) & length(address) == 1 & isnumeric(address{1}),
    address = [address{1} cc.page];
elseif iscellstr(address) & length(address) == 1,
    address = [hex2dec(address{1}) cc.page];
elseif ischar(address),
    address = [hex2dec(address) cc.page];
else
    error('ADDRESS entry is invalid');
end


if findstr('struct',type)
    % Create STRUCT info structure
    si = createStructInfo(address,type,size,varargin);
else
	% Create NUMERIC info structure
	si = struct('uclass','numeric','address',address,'type',type,'size',size,'dspendian',[]);
end

% Call object's class constructor using info structure 
symtab = createobj(cc,si);

% ----------------------------------
function stinfo = createStructInfo(address,type,size,args)

nargs = length(args);

% Create STRUCT object depending on the given information
switch lower(args{1})
    
case 'structinfo',

    stinfo = args{2};
    stinfo.isglobal = 0;
    stinfo.location = [];
    stinfo.address  = address;
    stinfo.size   = size;
    members         = fieldnames(stinfo.members);
    for i=1:length(members)
        memb          = stinfo.members.(members{i});
        memb.address  = [stinfo.address(1)+memb.offset, stinfo.address(2)];
        memb.location = [];
    end

case 'members',
    
	stinfo = struct('isglobal', 0, ...
                    'name', [], ...
                    'address', address, ...
                    'location',[], ...
                    'size',size, ...
                    'uclass','structure', ...
                    'sizeof', [], ...
                    'type', type, ...
                    'members',struct([]));

                
	% Get field/type pairs from argument list
    for i=2:nargs,
	
        % limit member uclass to NUMERIC; just CONVERT afterwards
        memberinfo = struct('offset' ,[],         'address' ,[], 'size' ,[], ...
                            'uclass' ,'numeric',  'bitsize' ,[], 'type'   ,[], ...
                            'storageunitspervalue'  ,[]);
                        
        % Important: STORAGEUNITSPERVALUE here is not the same as the STORAGEUNITSPERVALUE property of a memory object.
        % This STORAGEUNITSPERVALUE is the number of addressable units plus padding that TI follows when 
        % storing/arranging members in a structure. See Mary Ann's documentation.
        
        membprops = args{i};
        numprops = length(membprops);
        
        % 1st property - name of struct member
        membname = membprops{1};
        if ~ischar(membname) & ~(iscellstr(membname))
            error('MEMBER name must be a string entry.');
        end

        % defaults - 2nd and 3rd properties
        memberinfo.type = 'uint32';
        memberinfo.size = 1;
        % TYPE
        if isempty(membprops{2})
            memberinfo.type = 'uint32';
        elseif ischar(membprops{2})
            memberinfo.type = membprops{2};
		else
            error('TYPE must be a string entry.')
		end
        % size
        if numprops==3,
           val = membprops{3};
           if isnumeric(val) & ~isempty(val)
                memberinfo.size = val;
            elseif isnumeric(val) & isempty(val)
                memberinfo.size = 1;
            end
        end
        
        % BITSIZE
        switch lower(memberinfo.type)
        case {'int32','uint32','int','unsigned int','float'}
            memberinfo.bitsize = 32;
            memberinfo.storageunitspervalue = 4;  % storage units in a word = 32/aubits
        case {'short','unsigned short','int16','uint16'}
            memberinfo.bitsize = 16;    
            memberinfo.storageunitspervalue = 2;
        case {'char','unsigned char','int8','uint8'}
            memberinfo.bitsize = 8;    
            memberinfo.storageunitspervalue = 2;
        case {'double','long int','long double','unsigned long','long'}
            memberinfo.bitsize = 64;    
            memberinfo.storageunitspervalue = 8;
        otherwise
            warning('The TYPE entered is not supported. MEMBER will be set to UNSINGED INT.');
            memberinfo.bitsize = 16;
            memberinfo.storageunitspervalue = 2;
        end
        
        % OFFSET - compute offset for next member
        if i==2,
			memberinfo.offset = 0;
			next = memberinfo.size * memberinfo.storageunitspervalue;
        else
          [memberinfo.offset,next] = computeNextOffset(memberinfo,next);
		end
        
        % ADDRESS = base address plus member offset
        memberinfo.address = [address(1)+memberinfo.offset, address(2)];
        
        % ADD THIS MEMBER TO THE STRUCTURE
        stinfo.members(1).(membname) = memberinfo;
	end
	stinfo.sizeof = next; % initialize last stinfo property
    
   
otherwise,
    error(['FIELD ''' args{1} ''' not supported.']);
end

% [eof] symbobjstruct

%--------------------------------------------------------------------
function [offset,nextoffset] = computeNextOffset(member,nextoffset)

numberofstorageunits = prod(member.size) * member.storageunitspervalue;

extra = rem(nextoffset,4);
if member.bitsize>=32,   % storageunitspervalue >= 4
	offset = nextoffset - extra + 4*(extra~=0);
else    % storageunitspervalue = 2
	extra  = rem(extra,2);
	offset = nextoffset - extra + 2*(extra~=0);
end

nextoffset = offset + numberofstorageunits;


% [EOF] creatememobj.m