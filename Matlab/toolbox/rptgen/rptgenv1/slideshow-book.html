<HTML
><HEAD
><TITLE
>      Playshow Book
    </TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.56"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Playshow Book</A
></H1
><H2
CLASS="SUBTITLE"
>Shows Pages of a Slideshow</H2
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>        The MathWorks
      </A
></H3
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#AEN8"
>Playshow</A
></DT
><DT
><A
HREF="#AEN26"
>intro</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN28"
>PageNumber: 
        1</A
></DT
><DT
><A
HREF="#AEN32"
>PageNumber: 
        2</A
></DT
><DT
><A
HREF="#AEN36"
>PageNumber: 
        3</A
></DT
><DT
><A
HREF="#AEN40"
>PageNumber: 
        4</A
></DT
><DT
><A
HREF="#AEN44"
>PageNumber: 
        5</A
></DT
><DT
><A
HREF="#AEN48"
>PageNumber: 
        6</A
></DT
><DT
><A
HREF="#AEN52"
>PageNumber: 
        7</A
></DT
><DT
><A
HREF="#AEN56"
>PageNumber: 
        8</A
></DT
><DT
><A
HREF="#AEN60"
>PageNumber: 
        9</A
></DT
><DT
><A
HREF="#AEN64"
>PageNumber: 
        10</A
></DT
><DT
><A
HREF="#AEN68"
>PageNumber: 
        11</A
></DT
><DT
><A
HREF="#AEN72"
>PageNumber: 
        12</A
></DT
><DT
><A
HREF="#AEN76"
>PageNumber: 
        13</A
></DT
><DT
><A
HREF="#AEN80"
>PageNumber: 
        14</A
></DT
><DT
><A
HREF="#AEN84"
>PageNumber: 
        15</A
></DT
><DT
><A
HREF="#AEN88"
>PageNumber: 
        16</A
></DT
><DT
><A
HREF="#AEN92"
>PageNumber: 
        17</A
></DT
><DT
><A
HREF="#AEN96"
>PageNumber: 
        18</A
></DT
><DT
><A
HREF="#AEN100"
>PageNumber: 
        19</A
></DT
><DT
><A
HREF="#AEN104"
>PageNumber: 
        20</A
></DT
><DT
><A
HREF="#AEN108"
>PageNumber: 
        21</A
></DT
><DT
><A
HREF="#AEN112"
>PageNumber: 
        22</A
></DT
><DT
><A
HREF="#AEN116"
>PageNumber: 
        23</A
></DT
><DT
><A
HREF="#AEN120"
>PageNumber: 
        24</A
></DT
><DT
><A
HREF="#AEN124"
>PageNumber: 
        25</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN128"
>buckydem</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN130"
>PageNumber: 
        1</A
></DT
><DT
><A
HREF="#AEN134"
>PageNumber: 
        2</A
></DT
><DT
><A
HREF="#AEN138"
>PageNumber: 
        3</A
></DT
><DT
><A
HREF="#AEN142"
>PageNumber: 
        4</A
></DT
><DT
><A
HREF="#AEN146"
>PageNumber: 
        5</A
></DT
><DT
><A
HREF="#AEN150"
>PageNumber: 
        6</A
></DT
><DT
><A
HREF="#AEN154"
>PageNumber: 
        7</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN158"
>inverter</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN160"
>PageNumber: 
        1</A
></DT
><DT
><A
HREF="#AEN164"
>PageNumber: 
        2</A
></DT
><DT
><A
HREF="#AEN168"
>PageNumber: 
        3</A
></DT
><DT
><A
HREF="#AEN172"
>PageNumber: 
        4</A
></DT
><DT
><A
HREF="#AEN176"
>PageNumber: 
        5</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN180"
>e2pi</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN182"
>PageNumber: 
        1</A
></DT
><DT
><A
HREF="#AEN186"
>PageNumber: 
        2</A
></DT
><DT
><A
HREF="#AEN190"
>PageNumber: 
        3</A
></DT
><DT
><A
HREF="#AEN194"
>PageNumber: 
        4</A
></DT
><DT
><A
HREF="#AEN198"
>PageNumber: 
        5</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN202"
>sparsity</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN204"
>PageNumber: 
        1</A
></DT
><DT
><A
HREF="#AEN208"
>PageNumber: 
        2</A
></DT
><DT
><A
HREF="#AEN212"
>PageNumber: 
        3</A
></DT
><DT
><A
HREF="#AEN216"
>PageNumber: 
        4</A
></DT
><DT
><A
HREF="#AEN220"
>PageNumber: 
        5</A
></DT
><DT
><A
HREF="#AEN224"
>PageNumber: 
        6</A
></DT
><DT
><A
HREF="#AEN228"
>PageNumber: 
        7</A
></DT
><DT
><A
HREF="#AEN232"
>PageNumber: 
        8</A
></DT
><DT
><A
HREF="#AEN236"
>PageNumber: 
        9</A
></DT
><DT
><A
HREF="#AEN240"
>PageNumber: 
        10</A
></DT
><DT
><A
HREF="#AEN244"
>PageNumber: 
        11</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN248"
>matmanip</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN250"
>PageNumber: 
        1</A
></DT
><DT
><A
HREF="#AEN254"
>PageNumber: 
        2</A
></DT
><DT
><A
HREF="#AEN258"
>PageNumber: 
        3</A
></DT
><DT
><A
HREF="#AEN262"
>PageNumber: 
        4</A
></DT
><DT
><A
HREF="#AEN266"
>PageNumber: 
        5</A
></DT
><DT
><A
HREF="#AEN270"
>PageNumber: 
        6</A
></DT
><DT
><A
HREF="#AEN274"
>PageNumber: 
        7</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN278"
>fitdemo</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN280"
>PageNumber: 
        1</A
></DT
><DT
><A
HREF="#AEN284"
>PageNumber: 
        2</A
></DT
><DT
><A
HREF="#AEN288"
>PageNumber: 
        3</A
></DT
><DT
><A
HREF="#AEN292"
>PageNumber: 
        4</A
></DT
><DT
><A
HREF="#AEN296"
>PageNumber: 
        5</A
></DT
><DT
><A
HREF="#AEN300"
>PageNumber: 
        6</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN8"
>      Playshow
    </A
></H1
><P
>      The PLAYSHOW command creates a slide show which steps the user through a series of commands and displays them to the screen.  This report contains each page of output from the following slide shows:
    </P
><P
></P
><UL
COMPACT="COMPACT"
><LI
><P
>          
          intro
        </P
></LI
><LI
><P
>          
          buckydem
        </P
></LI
><LI
><P
>          
          inverter
        </P
></LI
><LI
><P
>          
          e2pi
        </P
></LI
><LI
><P
>          
          sparsity
        </P
></LI
><LI
><P
>          
          matmanip
        </P
></LI
><LI
><P
>          
          fitdemo
        </P
></LI
></UL
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN26"
>      intro
    </A
></H1
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN28"
>PageNumber: 
        1</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-0-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Welcome to MATLAB.  This demonstration (and the
 entire demo system) is written in MATLAB's fourth
 generation language.

 Here are the MATLAB commands used to produce the picture
 shown above.
 &#62;&#62; load logo
 &#62;&#62; surf(L,R), colormap(M), n = length(L(:,1));
 &#62;&#62; axis off, axis([1 n 1 n -.2 .8]), view(-37.5,30)
 &#62;&#62; title('MATLAB.  The Language of Techical Computing.');
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN32"
>PageNumber: 
        2</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-1-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> First, let's create a simple vector with 9 elements called 'a'.

 (During most of this demo, we will display the MATLAB
 commands typed at the command line prompt "&#62;&#62;" and the
 corresponding output in the figure window shown above.)
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN36"
>PageNumber: 
        3</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-2-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Now let's add 2 to each element of our vector, 'a', and store
 the result in a new vector.

 Notice how MATLAB requires no special handling of vector
 or matrix math.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN40"
>PageNumber: 
        4</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-3-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Creating graphs in MATLAB is as easy as one command.
 Let's plot the result of our vector addition with grid lines.

 &#62;&#62; plot(b)
 &#62;&#62; grid on
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN44"
>PageNumber: 
        5</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-4-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> MATLAB can make other graph types as well, with axis labels.

&#62;&#62;bar(b)
&#62;&#62;xlabel('Sample #')
&#62;&#62;ylabel('Pounds')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN48"
>PageNumber: 
        6</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-5-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> MATLAB can use symbols in plots as well. Here is an
 example using *'s to mark the points.  MATLAB offers a
 variety of other symbols and line types.

 &#62;&#62; plot(b,'*')
 &#62;&#62; axis([0 10 0 10])
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN52"
>PageNumber: 
        7</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-6-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> One area in which MATLAB excels is matrix computation.

 Creating a matrix is as easy as making a vector, using
 semicolons (;) to separate the rows of a matrix.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN56"
>PageNumber: 
        8</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-7-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>We can easily find the transpose of the matrix 'A'.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN60"
>PageNumber: 
        9</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-8-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Now let's multiply these two matrices together.

 Note again that MATLAB doesn't require you to deal with
 matrices as a collection of numbers.  MATLAB knows when
 you are dealing with matrices and adjusts your calculations
 accordingly.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN64"
>PageNumber: 
        10</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-9-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>Instead of doing a matrix multiply, we can multiply the
corresponding elements of two matrices or vectors
using the .* operator.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN68"
>PageNumber: 
        11</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-10-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Let's find the inverse of a matrix ...
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN72"
>PageNumber: 
        12</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-11-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> ... and then illustrate the fact that a matrix times its inverse is
 the identity matrix.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN76"
>PageNumber: 
        13</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-12-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> MATLAB has functions for nearly every type of common
 matrix calculation.

 There are functions to obtain eigenvalues ...
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN80"
>PageNumber: 
        14</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-13-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> ... as well as the singular value decomposition.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN84"
>PageNumber: 
        15</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-14-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> The "poly" function generates a vector containing the
 coefficients of the characteristic polynomial.

 The characteristic polynomial of a matrix A is

     det(lambda*I - A)
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN88"
>PageNumber: 
        16</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-15-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> We can easily find the roots of a polynomial using the
 "roots" function.

 These are actually the eigenvalues of the original matrix.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN92"
>PageNumber: 
        17</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-16-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> MATLAB has many applications beyond just matrix
 computation.

 To convolve two vectors ...
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN96"
>PageNumber: 
        18</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-17-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> ... or convolve again

 &#62;&#62; r = conv(p,q); plot(r)

 and plot the result.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN100"
>PageNumber: 
        19</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-18-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> At any time, we can get a listing of the variables we have
 stored in memory using the "who" or "whos" command.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN104"
>PageNumber: 
        20</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-19-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> You can get the value of a particular variable by typing its
 name.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN108"
>PageNumber: 
        21</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-20-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> You can have more than one statement on a single line by
 separating each statement with commas or semicolons.

 If you don't assign a variable to store the result of an operation,
 the result is stored in a temporary variable called "ans".
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN112"
>PageNumber: 
        22</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-21-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> In this case, since we separated the statements with commas,
 the result of each operation was echoed to the screen.

 As you can see, MATLAB easily deals with complex and
 infinite numbers in calculations.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN116"
>PageNumber: 
        23</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-22-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> MATLAB has functions which make it ideal as a signal
 processing tool.

 For more details, see the demos of the Signal
 Processing Toolbox

 &#62;&#62; A = zeros(32); A(14:16,14:16) = ones(3);
 &#62;&#62; y = fft2(A);
 &#62;&#62; mesh(abs(y));
 &#62;&#62; title('Magnitude of Two-Dimensional FFT of a Matrix')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN120"
>PageNumber: 
        24</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-23-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> MATLAB also allows you to create and analyze functions
 easily.
 For examples, see the demo "Functions of functions" under
 MATLAB Numerics.
 &#62;&#62; fplot(@humps,[0,2]), hold on
 &#62;&#62; patch([0.5 0.5:0.02:1 1 0.5],[0 humps(0.5:0.02:1) 0 0],'r');
 &#62;&#62; hold off
 &#62;&#62; title('A region under an interesting function.')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN124"
>PageNumber: 
        25</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-24-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>Thank you for viewing this introduction to MATLAB.



 &#62;&#62; membrane(5,15,9,9)
 &#62;&#62; axis([-1 1 -1 1 -1 .5])
 &#62;&#62; colormap(hot)
      </PRE
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN128"
>      buckydem
    </A
></H1
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN130"
>PageNumber: 
        1</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-25-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>[13x71 char]
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN134"
>PageNumber: 
        2</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-26-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> A graph can be represented by its adjacency matrix.

 To construct the adjacency matrix, the nodes are numbered
 1 to N.  Then element (i,j) of the matrix is set to 1 if node i is
 connected to node j, and 0 otherwise.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN138"
>PageNumber: 
        3</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-27-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Here are the nodes in one hemisphere of the bucky ball, numbered
 polygon by polygon.

   &#62;&#62; gplot(B(1:30,1:30),[x(1:30) y(1:30)],'b-')
   &#62;&#62; for j = 1:30, text(x(j),y(j),int2str(j)); end
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN142"
>PageNumber: 
        4</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-28-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>To visualize the adjacency matrix of this hemisphere, we use the SPY
function to plot the silhouette of the nonzero elements.

&#62;&#62; spy(B(1:30,1:30)), title('spy(B(1:30,1:30))')

Note that the matrix is symmetric, since if node i is connected to node j,
then node j is connected to node i.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN146"
>PageNumber: 
        5</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-29-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Now we extend our numbering scheme to the whole graph
 by reflecting the numbering of one hemisphere into the other.

  &#62;&#62; [B,V] = bucky;
  &#62;&#62; H = sparse(60,60);
  &#62;&#62; gplot(B-H,V,'b-');
  &#62;&#62; hold on
  &#62;&#62; gplot(H,V,'r-')
  &#62;&#62; for j = 31:60, text(x(j),y(j),int2str(j)); end
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN150"
>PageNumber: 
        6</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-30-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>Finally, here is a SPY plot of the final sparse matrix.

   &#62;&#62; spy(B), title('spy(B)')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN154"
>PageNumber: 
        7</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-31-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>In many useful graphs, each node is connected to only a few other
nodes.  As a result, the adjacency matrices contain
just a few nonzero entries per row.

This demo has shown one place where SPARSE matrices come in handy.
      </PRE
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN158"
>      inverter
    </A
></H1
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN160"
>PageNumber: 
        1</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-32-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Press the "Start" button to see a demonstration of the
 inversion of large matrices in MATLAB.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN164"
>PageNumber: 
        2</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-33-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> This is a graphic representation of a random matrix
 The RAND command creates the matrix, and the
 IMAGESC command plots an image of the matrix,
 automatically scaling the color map appropriately.
 &#62;&#62; n = 100;
 &#62;&#62; a = rand(n);
 &#62;&#62; imagesc(a);
 &#62;&#62; colormap(hot);
 &#62;&#62; axis square
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN168"
>PageNumber: 
        3</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-34-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> This is a representation of the inverse of that matrix. While the
 numbers in the previous matrix were completely random, the
 elements in this matrix are anything BUT random. In fact,
 each element in this matrix ("b") depends on every one of the
 ten thousand elements in the previous matrix ("a").

 &#62;&#62; b = inv(a);
 &#62;&#62; imagesc(b);
 &#62;&#62; axis square;
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN172"
>PageNumber: 
        4</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-35-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> But how do we know for sure if this is really the correct inverse
 for the original matrix? Multiply the two together and see if the
 result is correct, because just as 3*(1/3) = 1, so must
 a*inv(a) = I, the identity matrix.
 The identity matrix (almost always designated by I) is like an
 enormous number one. It is completely made up of zeros,
 except for ones running along the main diagonal.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN176"
>PageNumber: 
        5</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-36-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> This is the product of the matrix with its inverse: sure
 enough, it has the distinctive look of the identity matrix,
 with a band of ones streaming down the main diagonal,
 surrounded by a sea of zeros.

 &#62;&#62; imagesc(a*b);
 &#62;&#62; axis square;
      </PRE
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN180"
>      e2pi
    </A
></H1
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN182"
>PageNumber: 
        1</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-37-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Press the "Start" button to see an example of visualization
 in MATLAB applied to the question:

 "Which is greater, e^pi or pi^e?"
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN186"
>PageNumber: 
        2</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-38-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> The question is: which is greater, e^pi or pi^e? The easy way
 to find out is to type it directly at the MATLAB command
 prompt. But it motivates a more interesting question. What
 is the shape of the function z=x^y-y^x? Here is a plot of z.
 &#62;&#62; x=0:0.16:5; y=0:0.16:5;
 &#62;&#62; [xx,yy]=meshgrid(x,y); zz=xx.^yy-yy.^xx;
 &#62;&#62; h=surf(x,y,zz);
 &#62;&#62; set(h,'EdgeColor',[0.7 0.7 0.7]);
 &#62;&#62; view(20,50); colormap(hsv);
 &#62;&#62; title('z=x^y-y^x'); xlabel('x'); ylabel('y');
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN190"
>PageNumber: 
        3</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-39-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>[9x73 char]
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN194"
>PageNumber: 
        4</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-40-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Here is a plot of the integer solutions to the equation
 x^y-y^x=0. Notice 2^4=4^2 is the ONLY integer solution
 where x~=y.  And what is the intersection point of the two
 curves that define where x^y=y^x?

 &#62;&#62; h=plot([0:5 2 4],[0:5 4 2],'r.', ...
           'MarkerSize',25,'EraseMode','none');
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN198"
>PageNumber: 
        5</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-41-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Finally, we can see that e^pi is indeed larger than pi^e
 (though not by much) by plotting these points on our surface.
 &#62;&#62; e=exp(1);
 &#62;&#62; e^pi
 ans =
            23.1407
 &#62;&#62; pi^e
 ans =
            22.4592
      </PRE
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN202"
>      sparsity
    </A
></H1
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN204"
>PageNumber: 
        1</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-42-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Press the "Start" button to see a demonstration which
 shows that reordering the rows and columns of a
 sparse matrix S can affect the time and storage required
 for a matrix operation such as factoring S into its
 Cholesky decomposition, S=L*L'.
 &#62;&#62; spy(S), title('A Sparse Symmetric Matrix')
 &#62;&#62; nz = nnz(S);
 &#62;&#62; lblstr = sprintf('nonzeros=%d   (%.3f %%)',nz,nz*pct);
 &#62;&#62; set(get(gca,'XLabel'),'String',lblstr);
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN208"
>PageNumber: 
        2</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-43-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> A SPY plot shows the nonzero elements in a matrix.

 This spy plot shows a SPARSE symmetric positive definite
 matrix derived from a portion of the Harwell-Boeing test matrix
 "west0479", a matrix describing connections in a model
 of a diffraction column in a chemical plant.


 &#62;&#62; title('spy(S)')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN212"
>PageNumber: 
        3</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-44-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> Now we compute the Cholesky factor L, where S=L*L'.
 Notice that L contains MANY more nonzero elements than
 the unfactored S, because the computation of the Cholesky
 factorization creates "fill-in" nonzeros.  This slows down the
 algorithm and increases storage cost.

 &#62;&#62; tic, L = chol(S)'; t(1) = toc;
 &#62;&#62; spy(L), title('Cholesky decomposition of S')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN216"
>PageNumber: 
        4</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-45-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> By reordering the rows and columns of a matrix, it may be
 possible to reduce the amount of fill-in created by
 factorization, thereby reducing time and storage cost.

 We will now try three different orderings supported by
 MATLAB.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN220"
>PageNumber: 
        5</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-46-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> The SYMRCM command uses the reverse Cuthill-McKee
 reordering algorithm to move all nonzero elements closer to
 the diagonal, reducing the "bandwidth" of the original matrix.

 &#62;&#62; p = symrcm(S);
 &#62;&#62; spy(S(p,p)), title('S(p,p) after Cuthill-McKee ordering')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN224"
>PageNumber: 
        6</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-47-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> The fill-in produced by Cholesky factorization is confined to
 the band, so that factorization of the reordered matrix takes
 less time and less storage.

 &#62;&#62; tic, L = chol(S(p,p))'; t(2) = toc;
 &#62;&#62; spy(L), title('chol(S(p,p)) after Cuthill-McKee ordering')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN228"
>PageNumber: 
        7</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-48-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> The COLPERM command uses the column count reordering
 algorithm to move rows and columns with higher nonzero
 count towards the end of the matrix.

 &#62;&#62; q = colperm(S);
 &#62;&#62; spy(S(q,q)), title('S(q,q) after column count ordering')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN232"
>PageNumber: 
        8</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-49-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> For this example, the column count ordering happens to
 reduce the time and storage for Cholesky factorization, but
 this behavior cannot be expected in general.

 &#62;&#62; tic, L = chol(S(q,q))'; t(3) = toc;
 &#62;&#62; spy(L), title('chol(S(q,q)) after column count ordering')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN236"
>PageNumber: 
        9</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-50-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> The SYMMMD command uses the minimimum degree
 algorithm (a powerful graph-theoretic technique) to produce
 large blocks of zeros in the matrix.

 &#62;&#62; r = symmmd(S);
 &#62;&#62; spy(S(r,r)), title('S(r,r) after minimum degree ordering')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN240"
>PageNumber: 
        10</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-51-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> The blocks of zeros produced by the minimum degree
 algorithm are preserved during the Cholesky factorization.
 This can significantly reduce time and storage costs.

 &#62;&#62; tic, L = chol(S(r,r))'; t(4) = toc;
 &#62;&#62; spy(L), title('chol(S(r,r)) after minimum degree ordering')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN244"
>PageNumber: 
        11</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-52-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>  RESULTS SUMMARY
 original:      nonzero=13.23%  time=0.44 sec
 Cuthill-McKee: nonzero=10.56%  time=0.33 sec
 column count:  nonzero=6.48%   time=0.22 sec
 min degree:    nonzero=4.01%   time=0.11 sec

 &#62;&#62; bar(nc*pct), title('Nonzeros after Cholesky factorization')
 &#62;&#62; ylabel('Percent');
      </PRE
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN248"
>      matmanip
    </A
></H1
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN250"
>PageNumber: 
        1</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-53-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>Press the "Start" button to see some basic matrix manipulations
in MATLAB.

We start by creating a magic square and assigning it to the variable A.

&#62;&#62; A = magic(3);
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN254"
>PageNumber: 
        2</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-54-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>Here's how to add 2 to each element of A.

 &#62;&#62; A+2;

 Note that MATLAB requires no special handling of  matrix math.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN258"
>PageNumber: 
        3</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-55-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> The apostrophe symbol denotes the complex conjugate
 transpose of a matrix.

 Here's how to take the transpose of A.

 &#62;&#62; A' ;
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN262"
>PageNumber: 
        4</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-56-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> The symbol * denotes multiplication of matrices.

 Let's create a new matrix B and multiply A by B.

 &#62;&#62; B = 2*ones(3);
 &#62;&#62; A*B;
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN266"
>PageNumber: 
        5</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-57-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> We can also multiply each element of A with its
 corresponding element of B by using the  .* operator.

 &#62;&#62; A.*B;
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN270"
>PageNumber: 
        6</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-58-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> MATLAB has functions for nearly every type of common
 matrix calculation.  For example, we can find the eigenvalues
 of A using the "eig" command.

 &#62;&#62; eig(A);
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN274"
>PageNumber: 
        7</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-59-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> This concludes our brief tour of some MATLAB matrix
 handling capabilities.

      </PRE
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN278"
>      fitdemo
    </A
></H1
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN280"
>PageNumber: 
        1</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-60-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>Press the "Start" button to see a demonstration of the
optimal fitting of a nonlinear function to a set of data.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN284"
>PageNumber: 
        2</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-61-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>This example demonstrates fitting a nonlinear function
to a set of data.  We''ll use a function called FMINSEARCH
that implements the Nelder-Mead simplex (direct search) algorithm
for minimizing a nonlinear function of several variables.
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN288"
>PageNumber: 
        3</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-62-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
>  &#62;&#62; Data = ...
        [ 0.0000    5.8955
          ...
           2.0000    0.2636];
 &#62;&#62; t = Data(:,1);
 &#62;&#62; y = Data(:,2);
 &#62;&#62; plot(t,y,'ro')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN292"
>PageNumber: 
        4</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-63-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> We would like to fit the following function with 2 linear
 parameters and 2 nonlinear parameters to the data:

   y =  c(1)*exp(-lam(1)*t) + c(2)*exp(-lam(2)*t)
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN296"
>PageNumber: 
        5</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-64-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> To fit this function to the data, we write a function "fitfun"
 that returns the error in the fit given the nonlinear parameter
 "lam" and the data.  We can then guess for initial estimates of
 the nonlinear parameters, and invoke FMINSEARCH.

 &#62;&#62; plot(t,y,'EraseMode','xor')
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN300"
>PageNumber: 
        6</A
></H1
><P
><IMG
SRC="./slideshow-book_html_files/image-65-hg.png"></P
><PRE
CLASS="PROGRAMLISTING"
> And the optimal curve fit occurs automatically with the use
 of the FMINSEARCH command.

 &#62;&#62; lam = [1 0]';
 &#62;&#62; options = optimset('Display','off','TolX',0.1);
 &#62;&#62; lambda = fminsearch('fitfun',lam,options);
      </PRE
></DIV
></DIV
></DIV
></BODY
></HTML
>