!<arch>
autocor.asm/    1061588609  0     0     0       22693     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.7     Fri Mar 22 00:59:23 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_autocor -- Autocorrelation                                      *
*                                                                           *
*   REVISION DATE                                                           *
*       21-Jan-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void DSP_autocor                                                    *
*       (                                                                   *
*           short *restrict r,                                              *
*           const short *restrict x,                                        *
*           int          nx,                                                *
*           int          nr                                                 *
*       )                                                                   *
*                                                                           *
*       r[nr]   : output array                                              *
*       x[nr+nx]: input  array                                              *
*       nx      : length of autocorrelation                                 *
*       nr      : number of lags                                            *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine performs an autocorrelation of an input vector         *
*       x. The length of the autocorrelation is nx samples. Since nr        *
*       such autocorrelations are performed, input vector x needs to be     *
*       of length nx + nr. This produces nr output results which are        *
*       stored in an output array r.                                        *
*                                                                           *
*       The following diagram illustrates how the correlations are          *
*       obtained.                                                           *
*                                                                           *
*       Example for nr=8, nx=24:                                            *
*       0       nr                  nx+nr-1                                 *
*       |-------|----------------------|  <- x[]                            *
*       |       |----------------------|  -> r[0]                           *
*       |      |----------------------|   -> r[1]                           *
*       |     |----------------------|    -> r[2]                           *
*       |    |----------------------|     -> r[3]                           *
*       |   |----------------------|      -> r[4]                           *
*       |  |----------------------|       -> r[5]                           *
*       | |----------------------|        -> r[6]                           *
*                                                                           *
*       Note that x[0] is never used, but is required for padding to make   *
*       x[nr] double-word aligned.                                          *
*                                                                           *
*     TECHNIQUES                                                            *
*       Loop coalescing is implemented and both loops are colesced          *
*       together. Separate copies of inner loop counter are made to         *
*       de-couple input loads and output stores. Double word wide loads     *
*       are used on the input data array.                                   *
*                                                                           *
*     ASSUMPTIONS                                                           *
*       nx is a multiple of 8                                               *
*       nr is a multiple of 4                                               *
*       x[] is double-word aligned                                          *
*       No alignment restrictions on r[]                                    *
*                                                                           *
*     MEMORY NOTE                                                           *
*       No memory bank hits under any conditions.                           *
*       This code is a LITTLE ENDIAN implementation.                        *
*                                                                           *
*     NOTES                                                                 *
*       This code is interrupt tolerant but not interuptible                *
*                                                                           *
*    CYCLES                                                                 *
*       nx*nr/4 + 19                                                        *
*                                                                           *
*       e.g. nx=160, nr=32, cycles=1299                                     *
*                                                                           *
*    CODESIZE                                                               *
*       496 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_autocor
_DSP_autocor:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_r                         ;
        .asg            B4,         B_x                         ;
        .asg            A6,         A_nx                        ;
        .asg            B6,         B_nr                        ;
        .asg            A22,        A_xptr_rst                  ;
        .asg            B22,        B_yptr_rst                  ;
        .asg            A23,        A_ik_rst                    ;
        .asg            A30,        A_sum_0                     ;
        .asg            B30,        B_sum_1                     ;
        .asg            A31,        A_sum_2                     ;
        .asg            B31,        B_sum_3                     ;
        .asg            A19,        A_i                         ;
        .asg            B2,         B_lk                        ;
        .asg            B25,        B_lk_rst                    ;
        .asg            A1,         A_pd                        ;
        .asg            A2,         A_ik                        ;
        .asg            A21,        A_rptr                      ;
        .asg            B9,         B_rptr                      ;
        .asg            B31,        B_nr_4
        .asg            A31,        A_nx_8
        .asg            B7,         B_csr
        .asg            B0,         B_no_gie
        .asg            B3,         B_return
        .asg            A20,        A_xptr
        .asg            B23,        B_yptr
        .asg            B16,        B_xptr
        .asg            A25,        A_z0z1
        .asg            A24,        A_z2z3
        .asg            A27,        A_y3y2
        .asg            A26,        A_y1y0
* ========================================================================= *
        SHRU    .S2     B_nr,       2,          B_nr_4          ;[ 2,0]
||      SHRU    .S1     A_nx,       3,          A_nx_8          ;[ 3,0]
||      ADDAH   .D2     B_x,        B_nr,       B_yptr_rst      ;[ 5,0]
||      ZERO    .L1     A_ik                                    ;[ 6,0]

        MV      .D1X    B_yptr_rst, A_xptr_rst                  ;[ 7,0]
||      MVC     .S2     CSR,        B_csr                       ;
||[!A_ik]MV     .D2     B_yptr_rst, B_yptr                      ;[ 2,1]
||      MV      .L1     A_nx_8,     A_ik_rst                    ;[ 7,0]
||      MV      .L2X    A_nx_8,     B_lk_rst                    ;[ 6,0]

        MV      .L1     A_r,        A_rptr                      ;[ 5,0]
||      MPY     .M1X    A_nx_8,     B_nr_4,     A_i             ;[ 4,0]
||      AND     .L2     B_csr,      -4,         B_no_gie        ;
||[!A_ik]MV     .S1     A_xptr_rst, A_xptr                      ;[ 1,1]
||      MV      .S2     B_lk_rst,   B_lk                        ;[ 7,0]
||      LDDW    .D2T1   *-B_yptr[1],            A_z0z1:A_z2z3   ;[ 6,1]

        MVK     .S1     1,          A_pd                        ;[ 6,0]
||      MVC     .S2     B_no_gie,   CSR                         ;
||[!A_ik]MV     .D1     A_ik_rst,   A_ik                        ;[ 3,1]
||[!A_ik]SUB    .L2     B_yptr_rst, 8,          B_yptr_rst      ;[ 3,1]
||      ADD     .D2X    A_xptr,     8,          B_xptr          ;[ 6,1]

        ZERO    .L2     B_sum_3:B_sum_1                         ;[ 7,0]
||      ZERO    .L1     A_sum_2:A_sum_0                         ;[ 7,0]
||      SUB     .D1     A_i,        2,          A_i             ;[ 6,0]
||      LDDW    .D2T1   *B_yptr++,  A_y3y2:A_y1y0               ;[ 7,1]
||[ A_ik]SUB    .S1     A_ik,       1,          A_ik            ;[ 7,1]
||      B       .S2    L_8  + 20                                ;

        ;==== Branch occurs

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A22,        A_xptr_rst
        .asg            B22,        B_yptr_rst
        .asg            A23,        A_ik_rst
        .asg            A30,        A_sum_0
        .asg            B30,        B_sum_1
        .asg            A31,        A_sum_2
        .asg            B31,        B_sum_3
        .asg            A19,        A_i
        .asg            B2,         B_lk
        .asg            B25,        B_lk_rst
        .asg            A1,         A_pd
        .asg            A2,         A_ik
        .asg            A21,        A_rptr
        .asg            B9,         B_rptr
        .asg            A20,        A_xptr
        .asg            B23,        B_yptr
        .asg            B16,        B_xptr
        .asg            A29,        A_x3x2
        .asg            A28,        A_x1x0
        .asg            B29,        B_x7x6
        .asg            B28,        B_x5x4
        .asg            A25,        A_z0z1
        .asg            A24,        A_z2z3
        .asg            A27,        A_y3y2
        .asg            A26,        A_y1y0
        .asg            B27,        B_y7y6
        .asg            B26,        B_y5y4
        .asg            A17,        A_z1z2
        .asg            A18,        A_y0z0
        .asg            A7,         A_y2y1
        .asg            B21,        B_y4y3
        .asg            B19,        B_y6y5
        .asg            A24,        A_prod0
        .asg            A6,         A_prod1
        .asg            B20,        B_prod2
        .asg            B26,        B_prod3
        .asg            A8,         A_prod4
        .asg            A7,         A_prod5
        .asg            B24,        B_prod6
        .asg            B19,        B_prod7
        .asg            A6,         A_prod8
        .asg            A9,         A_prod9
        .asg            B27,        B_prodA
        .asg            B20,        B_prodB
        .asg            A9,         A_prodC
        .asg            A16,        A_prodD
        .asg            B24,        B_prodE
        .asg            B17,        B_prodF
        .asg            A25,        A_s0
        .asg            B20,        B_s0
        .asg            A24,        A_t0
        .asg            B19,        B_t0
        .asg            A9,         A_u0
        .asg            B21,        B_u0
        .asg            A24,        A_v0
        .asg            B24,        B_v0
        .asg            A27,        A_temp0
        .asg            B18,        B_temp1
        .asg            A9,         A_temp2
        .asg            B19,        B_temp3
        .asg            A29,        A_sum0s
        .asg            B24,        B_sum1s
        .asg            A16,        A_sum2s
        .asg            B27,        B_sum3s
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        LDDW    .D2T2   *B_xptr++[2],           B_x7x6:B_x5x4   ;[ 8,1]
||      LDDW    .D1T1   *A_xptr++[2],           A_x3x2:A_x1x0   ;[ 8,1]
||      ADD     .L2X    A_rptr,     2,          B_rptr          ;[ 7,0]
||      B       .S2     LOOP                                    ;

        LDDW    .D2T2   *B_yptr++,  B_y7y6:B_y5y4               ;[ 9,1]
||[!A_ik]MV     .L1     A_xptr_rst, A_xptr                      ;[ 1,2]

  [!A_ik]MV     .D2     B_yptr_rst, B_yptr                      ;[ 2,2]

  [!A_ik]MV     .D1     A_ik_rst,   A_ik                        ;[ 3,2]
||[!A_ik]SUB    .S2     B_yptr_rst, 8,          B_yptr_rst      ;[ 3,2]

        PACKLH2 .S1     A_y1y0,     A_z0z1,     A_y0z0          ;[12,1]
||      ADD     .L2     B_lk,       1,          B_lk            ;

* =========================== PIPE LOOP KERNEL ============================ *
LOOP:
  [!A_pd]ADD     .L1X   A_u0,       B_u0,       A_temp2         ;[22,1]
||[!A_pd]ADD    .L2     B_prod6,    B_prod7,    B_t0            ;[22,1]
||[!A_pd]ADD    .S1     A_prod4,    A_prod5,    A_t0            ;[22,1]
||[!A_pd]ADD    .D1     A_prod0,    A_prod1,    A_s0            ;[22,1]
||      DOTP2   .M1     A_x1x0,     A_z0z1,     A_prod8         ;[14,2]
||      DOTP2   .M2     B_x7x6,     B_y7y6,     B_prod3         ;[14,2]
||      LDDW    .D2T1   *-B_yptr[1],            A_z0z1:A_z2z3   ;[ 6,3]
||      ADD     .S2X    A_xptr,     8,          B_xptr          ;[ 6,3]

  [ B_lk]SUB    .S2     B_lk,       1,          B_lk            ;[23,1]
||[!A_pd]ADD    .D1     A_sum_2,    A_temp2,    A_sum_2         ;[23,1]
||      DOTP2   .M2     B_x7x6,     B_y5y4,     B_prodB         ;[15,2]
||      DOTP2   .M1     A_x1x0,     A_y0z0,     A_prod4         ;[15,2]
||      PACKLH2 .L2X    B_y5y4,     A_y3y2,     B_y4y3          ;[15,2]
||      PACKLH2 .S1     A_y3y2,     A_y1y0,     A_y2y1          ;[15,2]
||      LDDW    .D2T1   *B_yptr++,  A_y3y2:A_y1y0               ;[ 7,3]
||[ A_ik]SUB    .L1     A_ik,       1,          A_ik            ;[ 7,3]

        BDEC    .S1     LOOP,       A_i                         ;[24,1]
||[!A_pd]ADD    .L2X    B_t0,       A_t0,       B_temp1         ;[24,1]
||[!A_pd]ADD    .L1     A_prodC,    A_prodD,    A_v0            ;[24,1]
||      DOTP2   .M2     B_x5x4,     B_y4y3,     B_prod6         ;[16,2]
||      DOTP2   .M1     A_x3x2,     A_y2y1,     A_prod5         ;[16,2]
||      PACKLH2 .S2     B_y7y6,     B_y5y4,     B_y6y5          ;[16,2]
||      LDDW    .D2T2   *B_xptr++[2],           B_x7x6:B_x5x4   ;[ 8,3]
||      LDDW    .D1T1   *A_xptr++[2],           A_x3x2:A_x1x0   ;[ 8,3]

  [!A_pd]SHR    .S1     A_sum_2,    15,         A_sum2s         ;[25,1]
||[!A_pd]ADD    .S2     B_sum_1,    B_temp1,    B_sum_1         ;[25,1]
||[!A_pd]ADD    .D1X    A_s0,       B_s0,       A_temp0         ;[25,1]
||[!A_pd]ADD    .L2     B_prodE,    B_prodF,    B_v0            ;[25,1]
||      DOTP2   .M2     B_x5x4,     B_y5y4,     B_prod2         ;[17,2]
||      DOTP2   .M1     A_x3x2,     A_y3y2,     A_prod1         ;[17,2]
||      LDDW    .D2T2   *B_yptr++,  B_y7y6:B_y5y4               ;[ 9,3]
||[!A_ik]MV     .L1     A_xptr_rst, A_xptr                      ;[ 1,4]

  [!A_pd]SHR    .S2     B_sum_1,    15,         B_sum1s         ;[26,1]
||[!A_pd]ADD    .L1     A_sum_0,    A_temp0,    A_sum_0         ;[26,1]
||[!A_pd]ADD    .L2X    B_v0,       A_v0,       B_temp3         ;[26,1]
||      DOTP2   .M2     B_x7x6,     B_y6y5,     B_prod7         ;[18,2]
||      DOTP2   .M1     A_x1x0,     A_y1y0,     A_prod0         ;[18,2]
||[!A_ik]MV     .D2     B_yptr_rst, B_yptr                      ;[ 2,4]

  [ A_pd]SUB    .L1     A_pd,       1,          A_pd            ;[27,1]
||[!B_lk]STH    .D2T2   B_sum1s,    *B_rptr++[2]                ;[27,1]
||[!A_pd]SHR    .S1     A_sum_0,    15,         A_sum0s         ;[27,1]
||[!A_pd]ADD    .L2     B_sum_3,    B_temp3,    B_sum_3         ;[27,1]
||      DOTP2   .M2X    B_x5x4,     A_y2y1,     B_prodE         ;[19,2]
||      DOTP2   .M1     A_x3x2,     A_y0z0,     A_prodD         ;[19,2]
||[!A_ik]MV     .D1     A_ik_rst,   A_ik                        ;[ 3,4]
||[!A_ik]SUB    .S2     B_yptr_rst, 8,          B_yptr_rst      ;[ 3,4]

L_7:
  [!B_lk]ZERO   .L2     B_sum_3:B_sum_1                         ;[28,1]
||[!B_lk]STH    .D1T1   A_sum0s,    *A_rptr++[2]                ;[28,1]
||      SHR     .S2     B_sum_3,    15,         B_sum3s         ;[28,1]
||      ADD     .D2     B_prodA,    B_prodB,    B_u0            ;[20,2]
||      ADD     .L1     A_prod8,    A_prod9,    A_u0            ;[20,2]
||      DOTP2   .M2     B_x7x6,     B_y4y3,     B_prodF         ;[20,2]
||      DOTP2   .M1     A_x1x0,     A_z1z2,     A_prodC         ;[20,2]
||      PACKLH2 .S1     A_y1y0,     A_z0z1,     A_y0z0          ;[12,3]

L_8:
  [!B_lk]MV     .S2     B_lk_rst,   B_lk                        ;[29,1]
||[!B_lk]ZERO   .L1     A_sum_2:A_sum_0                         ;[29,1]
||[!B_lk]STH    .D2T2   B_sum3s,    *B_rptr++[2]                ;[29,1]
||[!B_lk]STH    .D1T1   A_sum2s,    *A_rptr++[2]                ;[29,1]
||      ADD     .L2     B_prod2,    B_prod3,    B_s0            ;[21,2]
||      DOTP2   .M2X    B_x5x4,     A_y3y2,     B_prodA         ;[13,3]
||      DOTP2   .M1     A_x3x2,     A_y1y0,     A_prod9         ;[13,3]
||      PACKLH2 .S1     A_z0z1,     A_z2z3,     A_z1z2          ;[13,3]

* =========================== PIPE LOOP EPILOG ============================ *

        ADD     .L1X    A_u0,       B_u0,       A_temp2         ;[22,4]
||      ADD     .L2     B_prod6,    B_prod7,    B_t0            ;[22,4]
||      ADD     .S1     A_prod4,    A_prod5,    A_t0            ;[22,4]
||      ADD     .D1     A_prod0,    A_prod1,    A_s0            ;[22,4]

  [ B_lk]SUB    .S2     B_lk,       1,          B_lk            ;[23,4]
||      ADD     .D1     A_sum_2,    A_temp2,    A_sum_2         ;[23,4]

        ADD     .L2X    B_t0,       A_t0,       B_temp1         ;[24,4]
||      ADD     .L1     A_prodC,    A_prodD,    A_v0            ;[24,4]
||      B       .S2     B_return                                ;

        SHR     .S1     A_sum_2,    15,         A_sum2s         ;[25,4]
||      ADD     .S2     B_sum_1,    B_temp1,    B_sum_1         ;[25,4]
||      ADD     .D1X    A_s0,       B_s0,       A_temp0         ;[25,4]
||      ADD     .L2     B_prodE,    B_prodF,    B_v0            ;[25,4]

        SHR     .S2     B_sum_1,    15,         B_sum1s         ;[26,4]
||      ADD     .L1     A_sum_0,    A_temp0,    A_sum_0         ;[26,4]
||      ADD     .L2X    B_v0,       A_v0,       B_temp3         ;[26,4]

  [ A_pd]SUB    .L1     A_pd,       1,          A_pd            ;[27,4]
||[!B_lk]STH    .D2T2   B_sum1s,    *B_rptr++[2]                ;[27,4]
||      SHR     .S1     A_sum_0,    15,         A_sum0s         ;[27,4]
||      ADD     .L2     B_sum_3,    B_temp3,    B_sum_3         ;[27,4]

  [!B_lk]STH    .D1T1   A_sum0s,    *A_rptr++[2]                ;[28,4]
||      SHR     .S2     B_sum_3,    15,         B_sum3s         ;[28,4]

 [!B_lk]STH    .D2T2   B_sum3s,    *B_rptr++[2]                 ;[29,4]
||[!B_lk]STH    .D1T1   A_sum2s,    *A_rptr++[2]                ;[29,4]
||       MVC    .S2     B_csr,       CSR                        ;

* ========================================================================= *
*   End of file:  dsp_autocor.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

bexp.asm/       1061588609  0     0     0       14564     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.6     Fri Mar 29 20:48:34 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_bexp -- Block exponent of a vector                              *
*                                                                           *
*   REVISION DATE                                                           *
*       12-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           int DSP_bexp                                                    *
*           (                                                               *
*               const int *x,     /* Input Data         */                  *
*               unsigned   nx     /* Number of elements */                  *
*           );                                                              *
*                                                                           *
*       The DSP_bexp routine accepts a list of 'num' input points and       *
*       performs the determination of the block exponent.  It returns       *
*       the minimum number of "redundant sign bits" observed on the         *
*       block of data.                                                      *
*                                                                           *
*   DESCRIPTION                                                             *
*       The DSP_bexp function, performs a determination of the block        *
*       exponent of the vector of elements and returns the maximum          *
*       exponent.  This information can then be used to re-normalize        *
*       the vector.  This operation is useful when auto-scaling is          *
*       required as in a FFT.  The DSP_bexp operation returns the minimum   *
*       norm of the vector.  The minimum norm corresponds to the            *
*       maximum exponent.                                                   *
*                                                                           *
*   C CODE                                                                  *
*       The following is a general C code description of the algorithm      *
*       without restrictions.  This implementation may have restrictions    *
*       as noted under 'ASSUMPTIONS' below.                                 *
*                                                                           *
*       int DSP_bexp(const int *x, short nx)                                *
*       {                                                                   *
*           int i;                                                          *
*           int mask, mag;                                                  *
*                                                                           *
*           mask = 0;                                                       *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Merge the absolute values of all the elements       */      *
*           /*  together.  The leftmost bit-change on this mask     */      *
*           /*  gives us the magnitude we desire.                   */      *
*           /* ---------------------------------------------------- */      *
*           for (i = 0; i < nx; i++)                                        *
*               mask |= x[i] ^ (x[i] >> 31);                                *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Find the magnitude of the mask.                     */      *
*           /* ---------------------------------------------------- */      *
*           for (mag = 0; (1 << mag) < mask; mag++)                         *
*               ;                                                           *
*                                                                           *
*           return 31 - mag;                                                *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx >= 8.                                                            *
*       nx % 8 == 0.                                                        *
*                                                                           *
*       The array 'x' is double-word aligned.                               *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt tolerant, but not interruptible.  It masks   *
*       interrupts for its entire duration with branch delay slots.         *
*                                                                           *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   SOURCE                                                                  *
*       DSPLIB.                                                             *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = nx/2 + 21, including 6 cycle function call overhead.       *
*       For nx = 32, cycles = 37.                                           *
*                                                                           *
*   CODESIZE                                                                *
*       216 bytes.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSP_bexp
_DSP_bexp:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x
        .asg            B4,         B_nx
        .asg            B3,         B_ret_addr
        .asg            A4,         A_ret_val
        .asg            B0,         B_i
        .asg            A0,         A_p
        .asg            B17,        B_x
        .asg            A9,         A_x7
        .asg            A8,         A_x6
        .asg            B9,         B_x5
        .asg            B8,         B_x4
        .asg            A7,         A_x3
        .asg            A6,         A_x2
        .asg            B7,         B_x1
        .asg            B6,         B_x0
        .asg            A16,        A_k31
        .asg            A18,        A_a7
        .asg            A17,        A_a6
        .asg            B16,        B_k31
        .asg            B19,        B_a5
        .asg            B18,        B_a4
        .asg            A18,        A_a3
        .asg            A17,        A_a2
        .asg            B19,        B_a1
        .asg            B18,        B_a0
        .asg            A9,         A_b7
        .asg            A17,        A_b6
        .asg            B9,         B_b5
        .asg            B18,        B_b4
        .asg            A7,         A_b3
        .asg            A17,        A_b2
        .asg            B7,         B_b1
        .asg            B18,        B_b0
        .asg            A5,         A_m
        .asg            B5,         B_m
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        B       .S1     loop
||      MVK     .L1     2,          A_p
||      ADD     .L2X    A_x,        8,          B_x
||      SHR     .S2     B_nx,       3,          B_i
||      ZERO    .D1     A_m
||      ZERO    .D2     B_m

        LDDW    .D1T2   *A_x[2],    B_x5:B_x4                   ;[ 1,1]
||      LDDW    .D2T1   *B_x[2],    A_x7:A_x6                   ;[ 1,1]
||      MVK     .S1     31,         A_k31
||      MVK     .S2     31,         B_k31
||      SUB     .L2     B_i,        1,          B_i
; ===== 2 stages of prolog collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!A_p]OR      .S2     B_b4,       B_m,        B_m             ;[10,1]
||[!A_p]OR      .S1     A_b6,       A_m,        A_m             ;[10,1]
||      XOR     .D2     B_x1,       B_a1,       B_b1            ;[10,1]
||      XOR     .D1     A_x3,       A_a3,       A_b3            ;[10,1]
||      SSHVR   .M2     B_x5,       B_k31,      B_a5            ;[ 6,2]
||      SSHVR   .M1     A_x7,       A_k31,      A_a7            ;[ 6,2]

  [!A_p]OR      .L2     B_b1,       B_m,        B_m             ;[11,1]
||[!A_p]OR      .S1     A_b3,       A_m,        A_m             ;[11,1]
||      XOR     .S2     B_x0,       B_a0,       B_b0            ;[11,1]
||      XOR     .L1     A_x2,       A_a2,       A_b2            ;[11,1]
||      SSHVR   .M2     B_x4,       B_k31,      B_a4            ;[ 7,2]
||      SSHVR   .M1     A_x6,       A_k31,      A_a6            ;[ 7,2]
||      LDDW    .D1T2   *A_x++[4],  B_x1:B_x0                   ;[ 3,3]
||      LDDW    .D2T1   *B_x++[4],  A_x3:A_x2                   ;[ 3,3]

  [!A_p]OR      .L2     B_b0,       B_m,        B_m             ;[12,1]
||[!A_p]OR      .D1     A_b2,       A_m,        A_m             ;[12,1]
||[ B_i]BDEC    .S2     loop,       B_i                         ;[ 8,2]
||[ A_p]SUB     .L1     A_p,        1,          A_p             ;[ 8,2]
||      XOR     .D2     B_x5,       B_a5,       B_b5            ;[ 8,2]
||      XOR     .S1     A_x7,       A_a7,       A_b7            ;[ 8,2]
||      SSHVR   .M2     B_x1,       B_k31,      B_a1            ;[ 8,2]
||      SSHVR   .M1     A_x3,       A_k31,      A_a3            ;[ 8,2]

  [!A_p]OR      .S2     B_b5,       B_m,        B_m             ;[ 9,2]
||[!A_p]OR      .L1     A_b7,       A_m,        A_m             ;[ 9,2]
||      XOR     .L2     B_x4,       B_a4,       B_b4            ;[ 9,2]
||      XOR     .S1     A_x6,       A_a6,       A_b6            ;[ 9,2]
||      SSHVR   .M2     B_x0,       B_k31,      B_a0            ;[ 9,2]
||      SSHVR   .M1     A_x2,       A_k31,      A_a2            ;[ 9,2]
||      LDDW    .D1T2   *A_x[2],    B_x5:B_x4                   ;[ 1,4]
||      LDDW    .D2T1   *B_x[2],    A_x7:A_x6                   ;[ 1,4]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 2 stages of epilog collasped
        OR      .L2     B_b4,       B_m,        B_m             ;[10,4]
||      OR      .S1     A_b6,       A_m,        A_m             ;[10,4]
||      XOR     .D2     B_x1,       B_a1,       B_b1            ;[10,4]
||      XOR     .D1     A_x3,       A_a3,       A_b3            ;[10,4]
||      B       .S2     B_ret_addr

        OR      .L2     B_b1,       B_m,        B_m             ;[11,4]
||      OR      .S1     A_b3,       A_m,        A_m             ;[11,4]
||      XOR     .S2     B_x0,       B_a0,       B_b0            ;[11,4]
||      XOR     .L1     A_x2,       A_a2,       A_b2            ;[11,4]

        OR      .L2     B_b0,       B_m,        B_m             ;[12,4]

        OR      .D1     A_b2,       A_m,        A_m             ;[12,4]

        OR      .L1X    A_m,        B_m,        A_m

        NORM    .L1     A_m,        A_ret_val
* ========================================================================= *
*   End of file:  dsp_bexp.asm                                              *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
bitrev_cpl.asm/ 1061588609  0     0     0       19986     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Tue Feb 26 13:35:28 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_bitrev_cplx                                                     *
*                                                                           *
*   REVISION DATE                                                           *
*       18-Sep-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       void DSP_bitrev_cplx(int *x, short *index, int nx)                  *
*                                                                           *
*       x[nx]  : Input array to be bit-reversed.                            *
*       index[]: Array of size ~sqrt(nx) created by the routine             *
*                bitrev_index to allow the fast implementation of the       *
*                bit-reversal.                                              *
*       nx     : Number of points in array x[]. Must be power of 2.         *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine performs the bit-reversal of the input array x[].      *
*       where x[] is an array of length nx 16-bit complex pairs of data.    *
*       This requires the index array provided by the program below.  This  *
*       index should be generated at compile time not by the DSP. The code  *
*       is given below.                                                     *
*                                                                           *
*       TI retains all rights, title and interest in this code and only     *
*       authorizes the use of the bit-reversal code and related table       *
*       generation code with TMS320-family DSPs manufactured by TI.         *
*                                                                           *
*       // ----------------------------------------------------------- //   *
*       //  This routine calculates the index for bit reversal of      //   *
*       //  an array of length n.  The length of the index table is    //   *
*       //  2^(2*ceil(k/2)) where n = 2^k.                             //   *
*       //                                                             //   *
*       //  In other words, the length of the index table is:          //   *
*       //                                                             //   *
*       //                 Even power      Odd Power                   //   *
*       //                  of radix        of radix                   //   *
*       //                  sqrt(n)        sqrt(2*n)                   //   *
*       //                                                             //   *
*       // ----------------------------------------------------------- //   *
*       void bitrev_index(short *index, int n)                              *
*       {                                                                   *
*           int   i, j, k, radix = 2;                                       *
*           short nbits, nbot, ntop, ndiff, n2, raddiv2;                    *
*                                                                           *
*           nbits = 0;                                                      *
*           i = n;                                                          *
*           while (i > 1)                                                   *
*           {                                                               *
*               i = i >> 1;                                                 *
*               nbits++;                                                    *
*           }                                                               *
*                                                                           *
*           raddiv2 = radix >> 1;                                           *
*           nbot    = nbits >> raddiv2;                                     *
*           nbot    = nbot << raddiv2 - 1;                                  *
*           ndiff   = nbits & raddiv2;                                      *
*           ntop    = nbot + ndiff;                                         *
*           n2      = 1 << ntop;                                            *
*                                                                           *
*           index[0] = 0;                                                   *
*           for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                 *
*           {                                                               *
*               index[i] = j - 1;                                           *
*                                                                           *
*               for (k = n2/radix; k*(radix-1) < j; k /= radix)             *
*                   j -= k*(radix-1);                                       *
*                                                                           *
*               j += k;                                                     *
*           }                                                               *
*           index[n2 - 1] = n2 - 1;                                         *
*       }                                                                   *
*                                                                           *
*     C CODE                                                                *
*         void bitrev(int *x, short *index, int nx)                         *
*         {                                                                 *
*             int     i;                                                    *
*             short       i0, i1, i2, i3;                                   *
*             short       j0, j1, j2, j3;                                   *
*             int     xi0, xi1, xi2, xi3;                                   *
*             int     xj0, xj1, xj2, xj3;                                   *
*             short       t;                                                *
*             int     a, b, ia, ib, ibs;                                    *
*             int     mask;                                                 *
*             int     nbits, nbot, ntop, ndiff, n2, halfn;                  *
*             short   *xs = (short *) x;                                    *
*                                                                           *
*             nbits = 0;                                                    *
*             i = nx;                                                       *
*             while (i > 1)                                                 *
*             {                                                             *
*                 i = i >> 1;                                               *
*                 nbits++;                                                  *
*             }                                                             *
*                                                                           *
*             nbot    = nbits >> 1;                                         *
*             ndiff   = nbits & 1;                                          *
*             ntop    = nbot + ndiff;                                       *
*             n2      = 1 << ntop;                                          *
*             mask    = n2 - 1;                                             *
*             halfn   = nx >> 1;                                            *
*                                                                           *
*             for (i0 = 0; i0 < halfn; i0 += 2)                             *
*             {                                                             *
*                 b   = i0 & mask;                                          *
*                 a   = i0 >> nbot;                                         *
*                 if (!b) ia  = index[a];                                   *
*                 ib  = index[b];                                           *
*                 ibs = ib << nbot;                                         *
*                                                                           *
*                 j0  = ibs + ia;                                           *
*                 t   = i0 < j0;                                            *
*                 xi0 = x[i0];                                              *
*                 xj0 = x[j0];                                              *
*                                                                           *
*                 if (t){x[i0] = xj0;                                       *
*                 x[j0] = xi0;}                                             *
*                                                                           *
*                 i1  = i0 + 1;                                             *
*                 j1  = j0 + halfn;                                         *
*                 xi1 = x[i1];                                              *
*                 xj1 = x[j1];                                              *
*                 x[i1] = xj1;                                              *
*                 x[j1] = xi1;                                              *
*                                                                           *
*                 i3  = i1 + halfn;                                         *
*                 j3  = j1 + 1;                                             *
*                 xi3 = x[i3];                                              *
*                 xj3 = x[j3];                                              *
*                 if (t){x[i3] = xj3;                                       *
*                 x[j3] = xi3;}                                             *
*             }                                                             *
*         }                                                                 *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx must be a power of 2.                                            *
*       The table from bitrev_index is already created.                     *
*       LITTLE ENDIAN configuration used.                                   *
*                                                                           *
*   NOTES                                                                   *
*       If N <= 4K one can use the char (8-bit) data type for               *
*       the "index" variable. This would require changing the LDH when      *
*       loading index values in the assembly routine to LDB. This would     *
*       further reduce the size of the Index Table by half its size.        *
*                                                                           *
*       This code is interrupt tolerant, but not interruptible.             *
*                                                                           *
*   CYCLES                                                                  *
*       (N/4 + 2) * 7 + 18                                                  *
*                                                                           *
*       e.g. N = 256, cycles = 480                                          *
*                                                                           *
*   CODESIZE                                                                *
*       352 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .text
        .global _DSP_bitrev_cplx
_DSP_bitrev_cplx:

;-
                LMBD.L1     1,  A6, A1      ; leftzeros = lmbd(1, nx)
    ||          MVK .S2     31, B0          ; constant 31
    ||          STW .D2     A15,*B15--[8]   ; push A15
    ||          MV  .S1X    B15,A15         ; copy stack pointer

                SUB .L1X    B0, A1, A8      ; nbits = 31 - leftzeros
    ||          SHR .S2X    A6, 1,  B6      ; halfn = nx >> 1
    ||          STW .D1     A10,*-A15[1]    ; push A10  B15[7]
    ||          STW .D2     B10,*+B15[6]    ; push B10  B15[6]
;-
                SHR .S1     A8, 1,  A0      ; nbot = nbits >> 1
    ||          AND .L1     A8, 1,  A11     ; ndiff = nbits & 1
    ||          SHR .S2     B6, 1,  B5      ; loop nx/4 +2 times
    ||          STW .D1     A11,*-A15[3]    ; push A11  B15[5]
    ||          STW .D2     B11,*+B15[4]    ; push B11  B15[4]
    ||          MV  .L2X    A4, B8          ; copy x
    ||          MPY .M2     B0, 0, B0
    ||          MPY .M1     A3, 0, A3       ; i0 = 0
;-
                ADD .D1     A0, A11,A11     ; ntop = nbot + ndiff
    ||          MVK .S1     1,  A2,         ; constant 1
    ||          ADD .L2     2,  B5, B2      ; loop nx/4 +2
    ||          MVK .S2     1,  B1          ; setup priming count
    ||          MV  .L1X    B4, A5          ; copy index

                SHL .S1     A2, A11,A1      ; n2 = 1 << ntop
    ||          STW .D1     A12,*-A15[5]    ; push A12  B15[3]
    ||          STW .D2     B12,*+B15[2]    ; push B12  B15[2]
;-
                SUB .L2X    A1, 1,  B13     ; mask = n2 - 1
    ||          ZERO.L1     A1              ; prevent stores on first iter
    ||          STW .D2     B13,*+B15[1]    ; push B13  B15[1]
    ||          ZERO.S1     A10             ; zero A10

                ZERO        A11
    ||          B   .S2     NO_INT_1

                LDH .D2     *B4[0],B0       ;** ib = index[b]
    ||          ADD .L2X    A3, 1,  B5      ;** i1 = i0 + 1
;-
                ADD         B5, B6, B7      ;** i3 = i1 + halfn

                LDW .D2     *B8[B7],B9      ;** xi3 = x[i3]
    ||          ZERO.D1     A12             ; zero A12
LOOP:
        [A1]    STW .D2     B9, *B8[B0]     ; if (t) x[j3] = xi3
    ||  [B2]    SUB         B2, 1,  B2      ; decrement loop counter
    ||          MPY .M1     A1, 1,  A2      ; copy t
    ||          LDW .D1     *A4[A3],A11     ;* xi0 = x[i0]
;-
        [A1]    STW .D1     A11,*A4[A10]    ; if (t) x[j0] = xi0
    ||  [B2]    B   .S2     LOOP            ; for loop
    ||          SHL .S1X    B0, A0, A10     ;* ibs = ib << nbot
    ||          ADD         A3, 2,  A3      ;* ai0 += 2
    ||          MPY .M2     B5, 1,  B10     ;* copy ai1
    ||          LDW .D2     *B8[B5],B11     ;* xi1 = x[i1]
    ||          MPY .M1     A3, 1,  A9      ;* copy ai0
;-
NO_INT_1:
        [!B1]   STW .D2     A11,*B8[B10]    ; x[i1] = xj1
    ||  [!B1]   STW .D1     B11,*A4[A6]     ; x[j1] = xi1
    ||          ADD         A10,A12,A10     ;* j0 = ibs + ia
    ||          SHR .S1     A3, A0, A11     ;** a = i0 >> nbot
    ||          AND .L2X    A3,B13, B0      ;** b = i0 & mask
;-
                ADD .L1X    A10,B6, A6      ;* j1 = j0 + halfn
    ||          MPY .M2     B7, 1,  B12     ;* copy ai3
    ||  [B1]    SUB .S2     B1, 1,  B1      ; decrement priming counter
    ||          LDH .D2     *B4[B0],B0      ;** ib = index[b]
    ||          ADD .L2X    A3, 1,  B5      ;** i1 = i1 + 1
    ||  [!B0]   LDH .D1     *A5[A11],A12    ;** if (!b) ia = index[a]
    ||  [B2]    B   .S1     NO_INT_1
;-
        [A1]    STW .D2     B0, *B8[B12]    ; if (t) x[i3] = xj3
    ||          ADD .L2X    A6, 1,  B0      ;* j3 = j0 + 1
    ||  [!B1]   CMPLT.L1    A9, A10,A1      ;* t = i0 < j0
    ||          LDW .D1     *A4[A6],A11     ;* xj1 = x[j1]
    ||  [B1]    MPY .M1     A4, 0,  A1      ; prime conditional store
    ||          ADD         B5, B6, B7      ;** i3 = i1 + halfn

                LDW .D1     *A4[A10],A7     ;* xj0 = x[j0]
    ||          LDW .D2     *B8[B7],B9      ;** xi3 = x[i3]
;-
        [A2]    STW .D1     A7, *A4[A8]     ; if (t) x[i0] = xj0
    ||          LDW .D2     *B8[B0],B0      ;* xj3 = x[j3]
    ||          MPY .M1     A9, 1,  A8      ;* copy ai0 again
END_LOOP:
                LDW .D1     *-A15[1],A10    ; pop A10  B15[7]
    ||          LDW .D2     *+B15[6],B10    ; pop B10  B15[6]

                LDW .D1     *-A15[3],A11    ; pop A11  B15[5]
    ||          LDW .D2     *+B15[4],B11    ; pop B11  B15[4]
;-
                LDW .D1     *-A15[5],A12    ; pop A12  B15[3]
    ||          LDW .D2     *+B15[2],B12    ; pop B12  B15[2]
    ||          B   .S2     B3              ; return

                LDW .D1     *-A15[7],B13    ; pop B13  B15[1]
    ||          LDW .D2     *++B15[8],A15   ; pop A15

                NOP 4
;-
* ========================================================================= *
*   End of file:  dsp_bitrev_cplx.asm                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
blk_eswap0.asm/ 1061588609  0     0     0       9475      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.1     Thu Sep  6 18:22:21 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_blk_eswap16 -- Endian-swap a block of 16-bit values             *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           void DSP_blk_eswap16                                            *
*           (                                                               *
*               void *restrict src,     /* Source data                 */   *
*               void *restrict dst,     /* Destination array           */   *
*               int  n_hwords           /* Number of halfwords to swap */   *
*           );                                                              *
*                                                                           *
*       This function performs an endian-swap on the data in the "src"      *
*       array, writing the results to "dst".  If NULL is passed in for      *
*       the destination, then the endian-swap is performed in-place.        *
*       The "n_hwords" argument gives the total length of the array in      *
*       half-words.                                                         *
*                                                                           *
*   DESCRIPTION                                                             *
*       The data in the "src" array is endian swapped, meaning that the     *
*       byte-order of the bytes within each word of the src[] array is      *
*       reversed.  This is meant to facilitate moving big-endian data       *
*       to a little-endian system or vice-versa.                            *
*                                                                           *
*       When the "dst" pointer is non-NULL, the endian-swap occurs          *
*       out-of-place, similar to a block move.  When the "dst" pointer      *
*       is NULL, the endian-swap occurs in-place, allowing the swap to      *
*       occur without using any additional storage.                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays do not overlap, except in the very          *
*       specific case that "dst == NULL" so that the operation occurs       *
*       in-place.                                                           *
*                                                                           *
*       The input array and output array are expected to be double-word     *
*       aligned, and a multiple of 8 half-words must be processed.          *
*                                                                           *
*   NOTES                                                                   *
*       This function locks out interrupts for its entire duration.         *
*       It is interrupt tolerant, but not interruptible.                    *
*                                                                           *
*   CODESIZE                                                                *
*       104 bytes                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 18 + n_hwords / 8.                                         *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_blk_eswap16
_DSP_blk_eswap16:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_src
        .asg            B4,         B_dst
        .asg            A6,         A_n_hwords
        .asg            B3,         B_ret_addr
        .asg            A0,         A_i
        .asg            B9,         B_x3
        .asg            B8,         B_x2
        .asg            B5,         B_src
        .asg            A9,         A_x1
        .asg            A8,         A_x0
        .asg            B7,         B_y3
        .asg            B6,         B_y2
        .asg            A7,         A_y1
        .asg            A6,         A_y0
        .asg            A5,         A_dst
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *

        B               loop
||      MV      .D2     B_dst,      B0
||      ADD     .L2X    A_src,      8,          B_src
||      SHR     .S1     A_n_hwords, 3,          A_i

        LDDW    .D2T1   *B_src++[2],            A_x1:A_x0       ;[ 1,1]
||      LDDW    .D1T2   *A_src++[2],            B_x3:B_x2       ;[ 1,1]
||[!B0] SUB     .L2     B_src,      8,          B_dst
||[A_i] SUB             A_i,        1,          A_i

  [A_i] BDEC            loop,       A_i

        LDDW    .D2T1   *B_src++[2],            A_x1:A_x0       ;[ 1,2]
||      LDDW    .D1T2   *A_src++[2],            B_x3:B_x2       ;[ 1,2]
||      ADD     .L1X    B_dst,      8,          A_dst
||      MVK     .S2     2,          B0

; ===== 2 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!B0] STDW    .D1T1   A_y1:A_y0,  *A_dst++[2]                 ;[ 8,1]
||[!B0] STDW    .D2T2   B_y3:B_y2,  *B_dst++[2]                 ;[ 8,1]
||      SWAP4   .L1     A_x1,       A_y1                        ;[ 6,2]
||      SWAP4   .L2     B_x2,       B_y2                        ;[ 6,2]
||[A_i] BDEC    .S1     loop,       A_i                         ;[ 4,3]

        SWAP4   .L1     A_x0,       A_y0                        ;[ 7,2]
||      SWAP4   .L2     B_x3,       B_y3                        ;[ 7,2]
||      LDDW    .D2T1   *B_src++[2],            A_x1:A_x0       ;[ 1,5]
||      LDDW    .D1T2   *A_src++[2],            B_x3:B_x2       ;[ 1,5]
||[ B0] SUB     .S2     B0,         1,          B0

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 3 epilog stages collapsed
        STDW    .D1T1   A_y1:A_y0,  *A_dst                      ;[ 8,5]
||      STDW    .D2T2   B_y3:B_y2,  *B_dst                      ;[ 8,5]
||      BNOP            B_ret_addr, 5

* ========================================================================= *
*   End of file:  dsp_blk_eswap16.asm                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

blk_eswap1.asm/ 1061588609  0     0     0       9763      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.2     Thu Sep  6 18:22:22 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_blk_eswap32 -- Endian-swap a block of 32-bit values             *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           void DSP_blk_eswap32                                            *
*           (                                                               *
*               void *restrict src,     /* Source data             */       *
*               void *restrict dst,     /* Destination array       */       *
*               int  n_words            /* Number of words to swap */       *
*           );                                                              *
*                                                                           *
*       This function performs an endian-swap on the data in the "src"      *
*       array, writing the results to "dst".  If NULL is passed in for      *
*       the destination, then the endian-swap is performed in-place.        *
*       The "n_words" argument gives the total length of the array.         *
*                                                                           *
*   DESCRIPTION                                                             *
*       The data in the "src" array is endian swapped, meaning that the     *
*       byte-order of the bytes within each word of the src[] array is      *
*       reversed.  This is meant to facilitate moving big-endian data       *
*       to a little-endian system or vice-versa.                            *
*                                                                           *
*       When the "dst" pointer is non-NULL, the endian-swap occurs          *
*       out-of-place, similar to a block move.  When the "dst" pointer      *
*       is NULL, the endian-swap occurs in-place, allowing the swap to      *
*       occur without using any additional storage.                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays do not overlap, except in the very          *
*       specific case that "dst == NULL" so that the operation occurs       *
*       in-place.                                                           *
*                                                                           *
*       The input array and output array are expected to be double-word     *
*       aligned, and a multiple of 4 words must be processed.               *
*                                                                           *
*   NOTES                                                                   *
*       This function locks out interrupts for its entire duration.         *
*       It is interrupt tolerant, but not interruptible.                    *
*                                                                           *
*   CODESIZE                                                                *
*       116 bytes                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 20 + n_words / 4.                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_blk_eswap32
_DSP_blk_eswap32:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_src
        .asg            B4,         B_dst
        .asg            A6,         A_n_words
        .asg            B3,         B_ret_addr
        .asg            A0,         A_i
        .asg            B9,         B_x3
        .asg            B8,         B_x2
        .asg            B5,         B_src
        .asg            A9,         A_x1
        .asg            A8,         A_x0
        .asg            B6,         B_y3
        .asg            B16,        B_y2
        .asg            A16,        A_y1
        .asg            A7,         A_y0
        .asg            B27,        B_z3
        .asg            B26,        B_z2
        .asg            A27,        A_z1
        .asg            A26,        A_z0
        .asg            A5,         A_dst
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *

        B       .S2     loop
||      MV      .D2     B_dst,      B0
||      ADD     .L2X    A_src,      8,          B_src
||      SHR     .S1     A_n_words,  2,          A_i

        LDDW    .D2T1   *B_src++[2],            A_x1:A_x0       ;[ 1,1]
||      LDDW    .D1T2   *A_src++[2],            B_x3:B_x2       ;[ 1,1]
||[!B0] SUB     .L2     B_src,      8,          B_dst

  [A_i] BDEC    .S1     loop,       A_i
||      MVK     .S2     3,          B0

        LDDW    .D2T1   *B_src++[2],            A_x1:A_x0       ;[ 1,2]
||      LDDW    .D1T2   *A_src++[2],            B_x3:B_x2       ;[ 1,2]
||      ADD     .L1X    B_dst,      8,          A_dst
; ===== 3 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!B0] STDW    .D1T1   A_z1:A_z0,  *A_dst++[2]                 ;[10,1]
||[!B0] STDW    .D2T2   B_z3:B_z2,  *B_dst++[2]                 ;[10,1]
||      ROTL    .M1     A_y1,       16,         A_z1            ;[ 8,2]
||      ROTL    .M2     B_y2,       16,         B_z2            ;[ 8,2]
||[A_i] BDEC    .S1     loop,       A_i                         ;[ 6,3]
||      SWAP4   .L1     A_x0,       A_y0                        ;[ 6,3]
||      SWAP4   .L2     B_x3,       B_y3                        ;[ 6,3]

        ROTL    .M1     A_y0,       16,         A_z0            ;[ 7,3]
||      ROTL    .M2     B_y3,       16,         B_z3            ;[ 7,3]
||      SWAP4   .L1     A_x1,       A_y1                        ;[ 7,3]
||      SWAP4   .L2     B_x2,       B_y2                        ;[ 7,3]
||[A_i] LDDW    .D2T1   *B_src++[2],            A_x1:A_x0       ;[ 1,6]
||[A_i] LDDW    .D1T2   *A_src++[2],            B_x3:B_x2       ;[ 1,6]
||[ B0] SUB     .S2     B0,         1,          B0
* =========================== PIPE LOOP EPILOG ============================ *

        BNOP    .S2     B_ret_addr, 5
||[!B0] STDW    .D1T1   A_z1:A_z0,  *A_dst                      ;[10,6]
||[!B0] STDW    .D2T2   B_z3:B_z2,  *B_dst                      ;[10,6]

* ========================================================================= *
*   End of file:  dsp_blk_eswap32.asm                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

blk_eswap2.asm/ 1061588609  0     0     0       9763      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.3     Thu Sep  6 18:22:22 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_blk_eswap64 -- Endian-swap a block of 64-bit values             *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           void DSP_blk_eswap64                                            *
*           (                                                               *
*               void *restrict src, /* Source data                    */    *
*               void *restrict dst, /* Destination array              */    *
*               int  n_dbls         /* Number of double-words to swap */    *
*           );                                                              *
*                                                                           *
*       This function performs an endian-swap on the data in the "src"      *
*       array, writing the results to "dst".  If NULL is passed in for      *
*       the destination, then the endian-swap is performed in-place.        *
*       The "n_words" argument gives the total length of the array.         *
*                                                                           *
*   DESCRIPTION                                                             *
*       The data in the "src" array is endian swapped, meaning that the     *
*       byte-order of the bytes within each word of the src[] array is      *
*       reversed.  This is meant to facilitate moving big-endian data       *
*       to a little-endian system or vice-versa.                            *
*                                                                           *
*       When the "dst" pointer is non-NULL, the endian-swap occurs          *
*       out-of-place, similar to a block move.  When the "dst" pointer      *
*       is NULL, the endian-swap occurs in-place, allowing the swap to      *
*       occur without using any additional storage.                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays do not overlap, except in the very          *
*       specific case that "dst == NULL" so that the operation occurs       *
*       in-place.                                                           *
*                                                                           *
*       The input array and output array are expected to be double-word     *
*       aligned, and a multiple of 2 double-words must be processed.        *
*                                                                           *
*   NOTES                                                                   *
*       This function locks out interrupts for its entire duration.         *
*       It is interrupt tolerant, but not interruptible.                    *
*                                                                           *
*   CODESIZE                                                                *
*       116 bytes                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 20 + n_dbls / 2.                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_blk_eswap64
_DSP_blk_eswap64:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_src
        .asg            B4,         B_dst
        .asg            A6,         A_n_words
        .asg            B3,         B_ret_addr
        .asg            A0,         A_i
        .asg            B9,         B_x3
        .asg            B8,         B_x2
        .asg            B5,         B_src
        .asg            A9,         A_x1
        .asg            A8,         A_x0
        .asg            B6,         B_y3
        .asg            B16,        B_y2
        .asg            A16,        A_y1
        .asg            A7,         A_y0
        .asg            B27,        B_z2
        .asg            B26,        B_z3
        .asg            A27,        A_z0
        .asg            A26,        A_z1
        .asg            A5,         A_dst
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *

        B       .S2     loop
||      MV      .D2     B_dst,      B0
||      ADD     .L2X    A_src,      8,          B_src
||      SHR     .S1     A_n_words,  1,          A_i

        LDDW    .D2T1   *B_src++[2],            A_x1:A_x0       ;[ 1,1]
||      LDDW    .D1T2   *A_src++[2],            B_x3:B_x2       ;[ 1,1]
||[!B0] SUB     .L2     B_src,      8,          B_dst

  [A_i] BDEC    .S1     loop,       A_i
||      MVK     .S2     3,          B0

        LDDW    .D2T1   *B_src++[2],            A_x1:A_x0       ;[ 1,2]
||      LDDW    .D1T2   *A_src++[2],            B_x3:B_x2       ;[ 1,2]
||      ADD     .L1X    B_dst,      8,          A_dst
; ===== 3 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!B0] STDW    .D1T1   A_z0:A_z1,  *A_dst++[2]                 ;[10,1]
||[!B0] STDW    .D2T2   B_z2:B_z3,  *B_dst++[2]                 ;[10,1]
||      ROTL    .M1     A_y1,       16,         A_z1            ;[ 8,2]
||      ROTL    .M2     B_y2,       16,         B_z2            ;[ 8,2]
||[A_i] BDEC    .S1     loop,       A_i                         ;[ 6,3]
||      SWAP4   .L1     A_x0,       A_y0                        ;[ 6,3]
||      SWAP4   .L2     B_x3,       B_y3                        ;[ 6,3]

        ROTL    .M1     A_y0,       16,         A_z0            ;[ 7,3]
||      ROTL    .M2     B_y3,       16,         B_z3            ;[ 7,3]
||      SWAP4   .L1     A_x1,       A_y1                        ;[ 7,3]
||      SWAP4   .L2     B_x2,       B_y2                        ;[ 7,3]
||[A_i] LDDW    .D2T1   *B_src++[2],            A_x1:A_x0       ;[ 1,6]
||[A_i] LDDW    .D1T2   *A_src++[2],            B_x3:B_x2       ;[ 1,6]
||[ B0] SUB     .S2     B0,         1,          B0
* =========================== PIPE LOOP EPILOG ============================ *

        BNOP    .S2     B_ret_addr, 5
||[!B0] STDW    .D1T1   A_z0:A_z1,  *A_dst                      ;[10,6]
||[!B0] STDW    .D2T2   B_z2:B_z3,  *B_dst                      ;[10,6]

* ========================================================================= *
*   End of file:  dsp_blk_eswap64.asm                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

blk_move.asm/   1061588609  0     0     0       8192      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.3     Thu Sep  6 18:22:23 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_blk_move -- Move a block of memory.  Endian Neutral             *
*                                                                           *
*   REVISION DATE                                                           *
*       19-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_blk_move(const short *restrict x, short *restrict r, int nx); *
*                                                                           *
*           x  --- block of data to be moved                                *
*           r  --- destination of block of data                             *
*           nx --- number of elements in block                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       Move nx 16-bit elements from one memory location                    *
*       to another.                                                         *
*                                                                           *
*       void DSP_blk_move(const short *restrict x, short *restrict r, int nx); *
*       {                                                                   *
*           int i;                                                          *
*           for (i = 0 ; i < nx; i++)                                       *
*               r[i] = x[i];                                                *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx greater than or equal to 32                                      *
*       nx a multiple of 8                                                  *
*                                                                           *
*   TECHNIQUES                                                              *
*       Twin input and output pointers are used.                            *
*                                                                           *
*   INTERRUPT NOTE                                                          *
*       This code is interrupt tolerant but not interruptible.              *
*                                                                           *
*   CYCLES                                                                  *
*       nx/4 + 15                                                           *
*                                                                           *
*       nx = 1024, cycles = 271.                                            *
*                                                                           *
*   CODESIZE                                                                *
*       76 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_blk_move
_DSP_blk_move:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A1,         A_i
        .asg            A4,         A_x
        .asg            A5,         A_r
        .asg            A6,         A_count
        .asg            A6,         A_in10
        .asg            A7,         A_in32
        .asg            B4,         B_r
        .asg            B5,         B_x
        .asg            B6,         B_in54
        .asg            B7,         B_in76
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        ADD             A_x,        8,          B_x
||      SHR             A_count,    3,          A_i

        BDEC    .S1     loop,       A_i                         ;[ 1,1]
||      LDDW    .D2T2   *B_x++[2],  B_in76:B_in54               ;[ 1,1]
||      LDDW    .D1T1   *A_x++[2],  A_in32:A_in10               ;[ 1,1]

        ADD             B_r,        8,          A_r

        BDEC    .S1     loop,       A_i                         ;[ 1,2]
||      LDDW    .D2T2   *B_x++[2],  B_in76:B_in54               ;[ 1,2]
||      LDDW    .D1T1   *A_x++[2],  A_in32:A_in10               ;[ 1,2]

        SUB             A_i,        3,          A_i
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        BDEC    .S1     loop,       A_i                         ;[ 1,3]
||      LDDW    .D2T2   *B_x++[2],  B_in76:B_in54               ;[ 1,3]
||      LDDW    .D1T1   *A_x++[2],  A_in32:A_in10               ;[ 1,3]

        STDW    .D1T2   B_in76:B_in54,          *A_r++[2]       ;[ 6,1]
||      STDW    .D2T1   A_in32:A_in10,          *B_r++[2]       ;[ 6,1]

* =========================== PIPE LOOP EPILOG ============================ *
; 1 epilog stage collapsed
        B               B3

        STDW    .D1T2   B_in76:B_in54,          *A_r            ;[ 6,3]
||      STDW    .D2T1   A_in32:A_in10,          *B_r            ;[ 6,3]

        NOP             4

* ========================================================================= *
*   End of file:  dsp_blk_move.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
dotp_sqr.asm/   1061588609  0     0     0       12278     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.8     Fri Mar 29 20:12:29 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*    TEXAS INSTRUMENTS, INC.                                                *
*                                                                           *
*   NAME                                                                    *
*       DSP_dotp_sqr                                                        *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and can be called as:                   *
*                                                                           *
*           int DSP_dotp_sqr                                                *
*           (                                                               *
*               int G,            /* Sum-of-y-squared initial value */      *
*               const short  *x,  /* First input array.             */      *
*               const short  *y,  /* Second input array.            */      *
*               int *restrict r,  /* Accumulation of x[] * y[].     */      *
*               int nx            /* Length of the input vector.    */      *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine computes the dot product of x[] and y[] arrays,        *
*       adding it to the value in the location pointed to by 'd'.           *
*                                                                           *
*       Additionally, it computes the sum of the squares of the terms       *
*       in the y[] array, adding it to the argument G.  The final value     *
*       of G is given as the return value of the function.  This value      *
*       is used by the VSELP vocoder.                                       *
*                                                                           *
*       The following C code is an implementation of the algorithm          *
*       without restrictions.  Optimized implementations may add            *
*       restrictions as noted under the heading "ASSUMPTIONS."              *
*                                                                           *
*       int DSP_dotp_sqr                                                    *
*       (                                                                   *
*           int G,            /* Sum-of-y-squared initial value */          *
*           const short  *x,  /* First input array.             */          *
*           const short  *y,  /* Second input array.            */          *
*           int *restrict r,  /* Accumulation of x[] * y[].     */          *
*           int nx            /* Length of the input vector.    */          *
*       )                                                                   *
*       {                                                                   *
*           int i;                                                          *
*                                                                           *
*           for (i = 0; i < nx; i++)                                        *
*           {                                                               *
*               *r += x[i] * y[i];                                          *
*               G  += y[i] * y[i];                                          *
*           }                                                               *
*                                                                           *
*           return G;                                                       *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx >= 12, nx % 4 == 0.                                              *
*                                                                           *
*   TECHNIQUES                                                              *
*       Unrolled 4 times to maximize multiplier utilization.                *
*                                                                           *
*   NOTES                                                                   *
*       This function is interrupt tolerant, but not interruptible.         *
*       It locks out interrupts for its entire duration.                    *
*                                                                           *
*   MEMORY NOTE                                                             *
*       Non-aligned accesses are used, so there are no alignment            *
*       constraints.  Also, as a result, no bank conflicts should occur.    *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = nx/2 + 21.                                                 *
*       For nx == 16,  cycles == 29.                                        *
*       For nx == 100, cycles == 71.                                        *
*                                                                           *
*   CODESIZE                                                                *
*       128 bytes.                                                          *
*                                                                           *
*   SOURCE                                                                  *
*       DSPLIB.                                                             *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_dotp_sqr
_DSP_dotp_sqr:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_g
        .asg            B4,         B_x
        .asg            A6,         A_y
        .asg            B6,         B_r
        .asg            A8,         A_nx
        .asg            A0,         A_y10
        .asg            A1,         A_y32
        .asg            A2,         A_i
        .asg            A9,         A_s10
        .asg            A9,         A_s32
        .asg            B0,         B_x10
        .asg            B1,         B_x32
        .asg            B2,         B_p
        .asg            B5,         B_p10
        .asg            B7,         B_x10_
        .asg            B8,         B_sum
        .asg            B9,         B_p32
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        LDW             *B_r,       B_sum

        LDNDW   .D2T2   *B_x++[1],  B_x32:B_x10                 ;[ 1,1]
||      SHR             A_nx,       2,          A_i

        LDNDW   .D1T1   *A_y++[1],  A_y32:A_y10                 ;[ 2,1]
||[ A_i]BDEC            loop,       A_i

        LDNDW   .D2T2   *B_x++[1],  B_x32:B_x10                 ;[ 1,2]

        LDNDW   .D1T1   *A_y++[1],  A_y32:A_y10                 ;[ 2,2]
||[ A_i]BDEC            loop,       A_i

        LDNDW   .D2T2   *B_x++[1],  B_x32:B_x10                 ;[ 1,3]
||      MVK             3,          B_p
; ===== 3 prolog stages removed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!B_p]ADD     .L1     A_s10,      A_g,        A_g             ;[12,1]
||[!B_p]ADD     .S2     B_p10,      B_sum,      B_sum           ;[12,1]
||[ A_i]BDEC    .S1     loop,       A_i                         ;[ 8,3]
||      DOTP2   .M1     A_y10,      A_y10,      A_s10           ;[ 8,3]
||      DOTP2   .M2X    B_x10_,     A_y10,      B_p10           ;[ 8,3]
||[ A_i]LDNDW   .D1T1   *A_y++[1],  A_y32:A_y10                 ;[ 2,6]
||[ B_p]SUB     .L2     B_p,        1,          B_p

  [!B_p]ADD     .D1     A_s32,      A_g,        A_g             ;[11,2]
||[!B_p]ADD     .L2     B_p32,      B_sum,      B_sum           ;[11,2]
||      DOTP2   .M1     A_y32,      A_y32,      A_s32           ;[ 7,4]
||      DOTP2   .M2X    B_x32,      A_y32,      B_p32           ;[ 7,4]
||      MV      .S2     B_x10,      B_x10_                      ;[ 7,4]
||[ A_i]LDNDW   .D2T2   *B_x++[1],  B_x32:B_x10                 ;[ 1,7]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 4 epilog stages removed
        ADD     .L1     A_s10,      A_g,        A_g             ;[12,6]
||      ADD     .L2     B_p10,      B_sum,      B_sum           ;[12,6]
||      B               B3

        ADD     .D1     A_s32,      A_g,        A_g             ;[11,7]
||      ADD     .L2     B_p32,      B_sum,      B_sum           ;[11,7]

        ADD     .L1     A_s10,      A_g,        A_g             ;[12,7]
||      ADD     .S2     B_p10,      B_sum,      B_sum           ;[12,7]

        STW             B_sum,      *B_r

        NOP             2

* ========================================================================= *
*   End of file:  dsp_dotp_sqr.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
dotprod.asm/    1061588609  0     0     0       11737     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.13    Fri Mar 29 15:27:32 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_dotprod                                                         *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*       int DSP_dotprod                                                     *
*       (                                                                   *
*           const short *m,       /* Pointer to first vector  */            *
*           const short *n,       /* Pointer to second vector */            *
*           int          count    /* Length of vectors.       */            *
*       );                                                                  *
*                                                                           *
*       This routine returns the dot product as its return value.           *
*                                                                           *
*   DESCRIPTION                                                             *
*       The "DSP_dotprod" function implements a dot product of two input    *
*       vectors, returning the scalar result.  Each element of the          *
*       first array is multiplied with the corresponding element of the     *
*       second array, and the products are summed.  The sum is returned.    *
*                                                                           *
*       int DSP_dotprod                                                     *
*       (                                                                   *
*           const short *m,       /* Pointer to first vector  */            *
*           const short *n,       /* Pointer to second vector */            *
*           int          count    /* Length of vectors.       */            *
*       )                                                                   *
*       {                                                                   *
*           int i, sum = 0;                                                 *
*                                                                           *
*           for (i = 0; i < count; i++)                                     *
*               sum += m[i] * n[i];                                         *
*                                                                           *
*           return sum;                                                     *
*       }                                                                   *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code has some restrictions, as          *
*       noted below.                                                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       The code is unrolled 4 times to enable full memory and multiplier   *
*       bandwidth to be utilized.                                           *
*                                                                           *
*       Interrupts are masked by branch delay slots only.                   *
*                                                                           *
*       Prolog collapsing has been performed to reduce codesize.            *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input length is a multiple of 4 and greater than 0.             *
*                                                                           *
*       The input data and coeeficients are stored on double word           *
*       aligned boundaries.                                                 *
*                                                                           *
*       This code is not interruptible.  Interrupts are masked by           *
*       branch delay slots during the entire duration of this               *
*       function.                                                           *
*                                                                           *
*   MEMORY NOTE                                                             *
*       To avoid bank conflicts, The input arrays 'm' and 'n' must          *
*       be offset by 4 half-words (8 bytes).                                *
*                                                                           *
*       The code is ENDIAN NEUTRAL.                                         *
*                                                                           *
*   CODESIZE                                                                *
*       108 bytes                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = count/4 + 15                                               *
*       For count = 720, cycles = 195.                                      *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_dotprod
_DSP_dotprod:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg   A4,    A_m     ; pointer to vector m
        .asg   B4,    B_n     ; pointer to vector n
        .asg   A6,    A_count ; number of elements in each vector
        .asg   A0,    A_i     ; loop count
        .asg   A16,   A_sum   ; partial sum a
        .asg   A17,   A_prod  ; sum of products a[i]*b[i]+a[i+1]*b[i+1]
        .asg   B16,   B_sum   ; partial sum b
        .asg   B17,   B_prod  ; product sum a[i+2]*b[i+2]+a[i+3]*b[i+3]
        .asg   A9,    A_reg1  ; elements a[i+3] a[i+2]
        .asg   A8,    A_reg0  ; elements a[i+1] a[i]
        .asg   B7,    B_reg1  ; elements b[i+3] b[i+2]
        .asg   B6,    B_reg0  ; elements b[i+1] b[i]
        .asg   A4,    A_sumt  ; total sum a + b returned to caller
* ========================== PIPE LOOP PROLOG ============================= *
        B     .S2     loop                             ; prime loop
||      LDDW  .D2T2   *B_n++,     B_reg1:B_reg0        ; load b[i+3]...b[i]
||      LDDW  .D1T1   *A_m++,     A_reg1:A_reg0        ; load a[i+3]...a[i]

        B     .S2     loop                             ; prime loop
||      LDDW  .D2T2   *B_n++,     B_reg1:B_reg0        ; load b[i+3]...b[i]
||      LDDW  .D1T1   *A_m++,     A_reg1:A_reg0        ; load a[i+3]...a[i]
||      SHRU  .S1     A_count,    2,          A_i      ; calc loop count

        B     .S1     loop                             ; prime loop
||[A_i] LDDW  .D2T2   *B_n++,     B_reg1:B_reg0        ; load b[i+3]...b[i]
||[A_i] LDDW  .D1T1   *A_m++,     A_reg1:A_reg0        ; load a[i+3]...a[i]

  [A_i] BDEC  .S1     loop,       A_i                  ; prime loop
||[A_i] LDDW  .D2T2   *B_n++,     B_reg1:B_reg0        ; load b[i+3]...b[i]
||[A_i] LDDW  .D1T1   *A_m++,     A_reg1:A_reg0        ; load a[i+3]...a[i]

  [A_i] BDEC  .S1     loop,       A_i                  ; prime loop
||[A_i] LDDW  .D2T2   *B_n++,     B_reg1:B_reg0        ; load b[i+3]...b[i]
||[A_i] LDDW  .D1T1   *A_m++,     A_reg1:A_reg0        ; load a[i+3]...a[i]
||      ZERO  .L1     A_prod:A_sum
||      ZERO  .L2     B_prod:B_sum
* ========================== PIPE LOOP KERNEL ============================= *
loop:
        ADD   .L2     B_sum,      B_prod,     B_sum    ; sum += productb
||      ADD   .L1     A_sum,      A_prod,     A_sum    ; sum += producta
||[A_i] LDDW  .D2T2   *B_n++,     B_reg1:B_reg0        ; load b[i+3]...b[i]
||[A_i] LDDW  .D1T1   *A_m++,     A_reg1:A_reg0        ; load a[i+3]...a[i]
||      DOTP2 .M2X    A_reg0,     B_reg0,     B_prod   ; a[0]*b[0]+a[1]*b[1]
||      DOTP2 .M1X    A_reg1,     B_reg1,     A_prod   ; a[2]*b[2]+a[3]*b[3]
||[A_i] BDEC  .S1     loop,       A_i                  ; iterate loop
* ========================== PIPE LOOP EPILOG ============================= *

        BNOP  .S2     B3,         4                    ; Return to caller

        ADD   .L1X    A_sum,      B_sum,      A_sumt   ; final sum
; ===== Branch Occurs

* ========================================================================= *
*   End of file:  dsp_dotprod.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

fft.asm/        1061588609  0     0     0       71646     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.12    Sun Mar 10 01:10:26 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_fft                                                             *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       16-Oct-2000                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fft(const short *w, int nsamp, short *x, short *y);        *
*                                                                           *
*       nsamp = length of DSP_fft in complex samples                        *
*       x     = pointer to complex data input, time domain                  *
*       w     = pointer to complex twiddle factors                          *
*       y     = pointer to complex data output, frequency domain            *
*                                                                           *
*   DESCRIPTION                                                             *
*       This code performs a Radix-4 FFT with digit reversal.  The code     *
*       uses a special ordering of twiddle factors and memory accesses      *
*       to improve performance in the presence of cache.  It operates       *
*       largely in-place, but the final digit-reversed output is written    *
*       out-of-place.                                                       *
*                                                                           *
*       This code requires a special sequence of twiddle factors stored     *
*       in Q.15 fixed-point format.  The following C code illustrates       *
*       one way to generate the desired twiddle-factor array:               *
*                                                                           *
*       #include <math.h>                                                   *
*                                                                           *
*       #ifndef PI                                                          *
*       # define PI (3.14159265358979323846)                                *
*       #endif                                                              *
*                                                                           *
*       short d2s(double d)                                                 *
*       {                                                                   *
*           d = floor(0.5 + d);  /* Explicit rounding to integer */         *
*           if (d >=  32767.0) return  32767;                               *
*           if (d <= -32768.0) return -32768;                               *
*           return (short)d;                                                *
*       }                                                                   *
*                                                                           *
*       void gen_twiddle(short *w, int n)                                   *
*       {                                                                   *
*           double M = 32767.5;                                             *
*           int i, j, k;                                                    *
*                                                                           *
*           for (j = 1, k = 0; j < n >> 2; j = j << 2)                      *
*           {                                                               *
*               for (i = 0; i < n >> 2; i += j << 1)                        *
*               {                                                           *
*                   w[k + 11] = d2s(M * cos(6.0 * PI * (i + j) / n));       *
*                   w[k + 10] = d2s(M * sin(6.0 * PI * (i + j) / n));       *
*                   w[k +  9] = d2s(M * cos(6.0 * PI * (i    ) / n));       *
*                   w[k +  8] = d2s(M * sin(6.0 * PI * (i    ) / n));       *
*                                                                           *
*                   w[k +  7] = d2s(M * cos(4.0 * PI * (i + j) / n));       *
*                   w[k +  6] = d2s(M * sin(4.0 * PI * (i + j) / n));       *
*                   w[k +  5] = d2s(M * cos(4.0 * PI * (i    ) / n));       *
*                   w[k +  4] = d2s(M * sin(4.0 * PI * (i    ) / n));       *
*                                                                           *
*                   w[k +  3] = d2s(M * cos(2.0 * PI * (i + j) / n));       *
*                   w[k +  2] = d2s(M * sin(2.0 * PI * (i + j) / n));       *
*                   w[k +  1] = d2s(M * cos(2.0 * PI * (i    ) / n));       *
*                   w[k +  0] = d2s(M * sin(2.0 * PI * (i    ) / n));       *
*                                                                           *
*                   k += 12;                                                *
*               }                                                           *
*           }                                                               *
*           w[2*n - 1] = w[2*n - 3] = w[2*n - 5] = 32767;                   *
*           w[2*n - 2] = w[2*n - 4] = w[2*n - 6] = 0;                       *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       n must be a power of 4 and n >= 16 & n < 32768.                     *
*       FFT data x are aligned on a double word boundary, in real/imag      *
*       pairs, FFT twiddle factors w are also aligned on a double word      *
*       boundary in real/imaginary pairs.                                   *
*                                                                           *
*       Input FFT coeffs. are in signed Q.15 format.                        *
*       The memory Configuration is LITTLE ENDIAN.                          *
*       The complex data will be returned in natural order. This code is    *
*       uninteruptable, interupts are disabled on entry to the function and *
*       re-enabled on exit.                                                 *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflict stalls occur in this code.                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       A special sequence of coefficients. are used (as generated above)   *
*       to produce the DSP_fft. This collapses the inner 2 loops in the     *
*       taditional Burrus and Parks implementation Fortran Code.            *
*                                                                           *
*      The following C code represents an implementation of the Cooley      *
*      Tukey radix 4 DIF FFT. It accepts the inputs in normal order and     *
*      produces the outputs in digit reversed order. The natural C code     *
*      shown in this file on the other hand, accepts the inputs in nor-     *
*      mal order and produces the outputs in normal order.                  *
*                                                                           *
*      Several transformations have been applied to the original Cooley     *
*      Tukey code to produce the natural C code description shown here.     *
*      In order to understand these it would first be educational to        *
*      understand some of the issues involved in the conventional Cooley    *
*      Tukey FFT code.                                                      *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*---------------------------------------------------------------------------*
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*---------------------------------------------------------------------------*
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*---------------------------------------------------------------------------*
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order.                            *
*                                                                           *
*       The DSP_fft() code shown here performs the bulk of the computation  *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part os the         *
*       complex multiply is implemented using _dotp2. The imaginary         *
*       part of the complex multiply is implemented using _dotpn2           *
*       after the twiddle factors are swizzled within the half word.        *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 1.25*nsamp*log4(nsamp) - 0.5*nsamp + 23*log4(nsamp) - 1    *
*                                                                           *
*       For nsamp = 1024,  cycles = 6002                                    *
*       For nsamp = 256,   cycles = 1243                                    *
*       For nsamp = 64,    cycles = 276                                     *
*                                                                           *
*   CODESIZE                                                                *
*       984 bytes                                                           *
*                                                                           *
*   C CODE                                                                  *
*       This is the C equivalent of the assembly code without restrictions: *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
* void DSP_fft(short *ptr_w, int n, short *ptr_x, short *ptr_y)             *
* {                                                                         *
*    int   i, j, l1, l2, h2, predj, tw_offset, stride, fft_jmp;             *
*    short xt0_0, yt0_0, xt1_0, yt1_0, xt2_0, yt2_0;                        *
*    short xt0_1, yt0_1, xt1_1, yt1_1, xt2_1, yt2_1;                        *
*    short xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0;      *
*    short xh0_1, xh1_1, xh20_1, xh21_1, xl0_1, xl1_1, xl20_1, xl21_1;      *
*    short x_0, x_1, x_2, x_3, x_l1_0, x_l1_1, x_l1_2, x_l1_3, x_l2_0:      *
*    short x_10, x_11, x_12, x_13, x_14, x_15, x_16, x_17, x_l2_1, x_h2_3;  *
*    short x_4, x_5, x_6, x_7, x_l2_2, x_l2_3, x_h2_0, x_h2_1, x_h2_2;      *
*    short si10, si20, si30, co10, co20, co30;                              *
*    short si11, si21, si31, co11, co21, co31;                              *
*    short * x, *w, * x2, * x0;                                             *
*    short * y0, * y1, * y2, *y3;                                           *
*                                                                           *
*    stride = n; -* n is the number of complex samples *-                   *
*    tw_offset = 0;                                                         *
*    while (stride > 4)  /* for all strides > 4 */                          *
*    {                                                                      *
*        j = 0;                                                             *
*        fft_jmp = stride + (stride>>1);                                    *
*        h2 = stride>>1;                          /* n/4 */                 *
*        l1 = stride;                             /* n/2 */                 *
*        l2 = stride + (stride>>1);               /* 3n/4 */                *
*        x = ptr_x;                                                         *
*        w = ptr_w + tw_offset;                                             *
*        tw_offset += fft_jmp;                                              *
*        stride = stride>>2;                                                *
*                                                                           *
*        for (i = 0; i < n>>1; i += 4)                                      *
*        {                                                                  *
*            co10 = w[j+1];    si10 = w[j+0];   /* W  */                    *
*            co11 = w[j+3];    si11 = w[j+2];                               *
*            co20 = w[j+5];    si20 = w[j+4];   /* W^2 */                   *
*            co21 = w[j+7];    si21 = w[j+6];                               *
*            co30 = w[j+9];    si30 = w[j+8];   /* W^3 */                   *
*            co31 = w[j+11];   si31 = w[j+10];                              *
*                                                                           *
*            x_0 = x[0];       x_1 = x[1];         /* perform 2 parallel */ *
*            x_2 = x[2];       x_3 = x[3];         /* radix4 butterflies */ *
*                                                                           *
*            x_l1_0 = x[l1  ]; x_l1_1 = x[l1+1];                            *
*            x_l1_2 = x[l1+2]; x_l1_3 = x[l1+3];                            *
*                                                                           *
*            x_l2_0 = x[l2  ]; x_l2_1 = x[l2+1];                            *
*            x_l2_2 = x[l2+2]; x_l2_3 = x[l2+3];                            *
*                                                                           *
*            x_h2_0 = x[h2  ]; x_h2_1 = x[h2+1];                            *
*            x_h2_2 = x[h2+2]; x_h2_3 = x[h2+3];                            *
*                                                                           *
*            xh0_0  = x_0    + x_l1_0; xh1_0  = x_1    + x_l1_1;            *
*            xh0_1  = x_2    + x_l1_2; xh1_1  = x_3    + x_l1_3;            *
*                                                                           *
*            xl0_0  = x_0    - x_l1_0; xl1_0  = x_1    - x_l1_1;            *
*            xl0_1  = x_2    - x_l1_2; xl1_1  = x_3    - x_l1_3;            *
*                                                                           *
*            xh20_0 = x_h2_0 + x_l2_0; xh21_0 = x_h2_1 + x_l2_1;            *
*            xh20_1 = x_h2_2 + x_l2_2; xh21_1 = x_h2_3 + x_l2_3;            *
*                                                                           *
*            xl20_0 = x_h2_0 - x_l2_0; xl21_0 = x_h2_1 - x_l2_1;            *
*            xl20_1 = x_h2_2 - x_l2_2; xl21_1 = x_h2_3 - x_l2_3;            *
*                                                                           *
*            x0 = x;                                                        *
*            x2 = x0;                 /* copy pointers for output*/         *
*                                                                           *
*            j += 12;                                                       *
*            x += 4;                                                        *
*            predj = (j - fft_jmp);   /* check if reached end of */         *
*            if (!predj) x += fft_jmp;/* current twiddle factor section */  *
*            if (!predj) j = 0;                                             *
*                                                                           *
*            x0[0] = xh0_0 + xh20_0; x0[1] = xh1_0 + xh21_0;                *
*            x0[2] = xh0_1 + xh20_1; x0[3] = xh1_1 + xh21_1;                *
*                                                                           *
*            xt0_0 = xh0_0 - xh20_0;  yt0_0 = xh1_0 - xh21_0;               *
*            xt0_1 = xh0_1 - xh20_1;  yt0_1 = xh1_1 - xh21_1;               *
*                                                                           *
*            xt1_0 = xl0_0 + xl21_0;  yt2_0 = xl1_0 + xl20_0;               *
*            xt2_0 = xl0_0 - xl21_0;  yt1_0 = xl1_0 - xl20_0;               *
*            xt1_1 = xl0_1 + xl21_1;  yt2_1 = xl1_1 + xl20_1;               *
*            xt2_1 = xl0_1 - xl21_1;  yt1_1 = xl1_1 - xl20_1;               *
*                                                                           *
*            x2[h2  ] = (si10 * yt1_0 + co10 * xt1_0) >> 15;                *
*            x2[h2+1] = (co10 * yt1_0 - si10 * xt1_0) >> 15;                *
*                                                                           *
*            x2[h2+2] = (si11 * yt1_1 + co11 * xt1_1) >> 15;                *
*            x2[h2+3] = (co11 * yt1_1 - si11 * xt1_1) >> 15;                *
*                                                                           *
*            x2[l1  ] = (si20 * yt0_0 + co20 * xt0_0) >> 15;                *
*            x2[l1+1] = (co20 * yt0_0 - si20 * xt0_0) >> 15;                *
*                                                                           *
*            x2[l1+2] = (si21 * yt0_1 + co21 * xt0_1) >> 15;                *
*            x2[l1+3] = (co21 * yt0_1 - si21 * xt0_1) >> 15;                *
*                                                                           *
*            x2[l2  ] = (si30 * yt2_0 + co30 * xt2_0) >> 15;                *
*            x2[l2+1] = (co30 * yt2_0 - si30 * xt2_0) >> 15;                *
*                                                                           *
*            x2[l2+2] = (si31 * yt2_1 + co31 * xt2_1) >> 15;                *
*            x2[l2+3] = (co31 * yt2_1 - si31 * xt2_1) >> 15;                *
*        }                                                                  *
*    }-* end while *-                                                       *
*                                                                           *
*    y0 = ptr_y;                                                            *
*    y1 = y0 + (int)(n>>1);                                                 *
*    y2 = y1 + (int)(n>>1);                                                 *
*    y3 = y2 + (int)(n>>1);                                                 *
*    x0 = ptr_x;                                                            *
*    x2 = ptr_x + (int)(n>>1);                                              *
*    l1 = _norm(n) + 2;                                                     *
*    j = 0;                                                                 *
*    for (i = 0; i < n; i += 8)                                             *
*    {                                                                      *
*        h2 = _deal(j);                                                     *
*        h2 = _bitr(h2);                                                    *
*        h2 = _rotl(h2, 16);                                                *
*        h2 = _shfl(h2);                                                    *
*        h2 >>= l1;                                                         *
*                                                                           *
*        x_0 = x0[0]; x_1 = x0[1];                                          *
*        x_2 = x0[2]; x_3 = x0[3];                                          *
*        x_4 = x0[4]; x_5 = x0[5];                                          *
*        x_6 = x0[6]; x_7 = x0[7];                                          *
*        x0 += 8;                                                           *
*                                                                           *
*        xh0_0  = x_0 + x_4; xh1_0  = x_1 + x_5;                            *
*        xl0_0  = x_0 - x_4; xl1_0  = x_1 - x_5;                            *
*        xh20_0 = x_2 + x_6; xh21_0 = x_3 + x_7;                            *
*        xl20_0 = x_2 - x_6; xl21_0 = x_3 - x_7;                            *
*                                                                           *
*        xt0_0 = xh0_0 - xh20_0;                                            *
*        yt0_0 = xh1_0 - xh21_0;                                            *
*        xt1_0 = xl0_0 + xl21_0;                                            *
*        yt2_0 = xl1_0 + xl20_0;                                            *
*        xt2_0 = xl0_0 - xl21_0;                                            *
*        yt1_0 = xl1_0 - xl20_0;                                            *
*                                                                           *
*        y0[2*h2  ] = xh0_0 + xh20_0;                                       *
*        y0[2*h2+1] = xh1_0 + xh21_0;                                       *
*        y1[2*h2  ] = xt1_0;                                                *
*        y1[2*h2+1] = yt1_0;                                                *
*        y2[2*h2  ] = xt0_0;                                                *
*        y2[2*h2+1] = yt0_0;                                                *
*        y3[2*h2  ] = xt2_0;                                                *
*        y3[2*h2+1] = yt2_0;                                                *
*                                                                           *
*        x_10 = x2[0]; x_11 = x2[1];                                        *
*        x_12 = x2[2]; x_13 = x2[3];                                        *
*        x_14 = x2[4]; x_15 = x2[5];                                        *
*        x_16 = x2[6]; x_17 = x2[7];                                        *
*        x2 += 8;                                                           *
*                                                                           *
*        xh0_1  = x_10 + x_14; xh1_1  = x_11 + x_15;                        *
*        xl0_1  = x_10 - x_14; xl1_1  = x_11 - x_15;                        *
*        xh20_1 = x_12 + x_16; xh21_1 = x_13 + x_17;                        *
*        xl20_1 = x_12 - x_16; xl21_1 = x_13 - x_17;                        *
*                                                                           *
*        xt0_1 = xh0_1 - xh20_1;                                            *
*        yt0_1 = xh1_1 - xh21_1;                                            *
*        xt1_1 = xl0_1 + xl21_1;                                            *
*        yt2_1 = xl1_1 + xl20_1;                                            *
*        xt2_1 = xl0_1 - xl21_1;                                            *
*        yt1_1 = xl1_1 - xl20_1;                                            *
*                                                                           *
*        y0[2*h2+2] = xh0_1 + xh20_1;                                       *
*        y0[2*h2+3] = xh1_1 + xh21_1;                                       *
*        y1[2*h2+2] = xt1_1;                                                *
*        y1[2*h2+3] = yt1_1;                                                *
*        y2[2*h2+2] = xt0_1;                                                *
*        y2[2*h2+3] = yt0_1;                                                *
*        y3[2*h2+2] = xt2_1;                                                *
*        y3[2*h2+3] = yt2_1;                                                *
*                                                                           *
*        j += 4;                                                            *
*        if (j == n>>2)                                                     *
*        {                                                                  *
*          j  += n>>2;                                                      *
*          x0 += (int) n>>1;                                                *
*          x2 += (int) n>>1;                                                *
*        }                                                                  *
*      }                                                                    *
*  }                                                                        *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_fft
_DSP_fft:
*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
       .asg         B15,        B_SP            ;Stack pointer, B datapath
       .asg         A31,        A_SP            ;Copy of stack pointer
       .asg         A4,         A_ptr_w         ;poiter to twiddle factors
       .asg         B4,         B_n             ;number of points in transform
       .asg         A6,         A_ptr_x         ;pointer to timne domain data
       .asg         B6,         B_ptr_y         ;pointer to frequency domain
       .asg         B12,        B_stride        ;offset to n/2 complex pt
       .asg         B5,         B_stride_1      ;offset to n/4 complex pt
       .asg         A12,        A_tw_offset     ;increment to twiddle table
       .asg         A3,         A_w0            ;pointer to twiddle factor
       .asg         B5,         B_fft_jmp_1     ;jump factor for time data
       .asg         A20,        A_zero          ;cont = 0
       .asg         B16,        B_w0            ;pointer to twiddle factor
       .asg         A21,        A_w1            ;twiddle factor + 2 dword
       .asg         B17,        B_w2            ;twiddle factor + 4 dword
       .asg         B11,        B_j             ;counter for twiddle factors
       .asg         A19,        A_j             ;counter for twiddle factors
       .asg         B10,        B_x             ;pointer to time domaindata
       .asg         B18,        B_h2            ;offset to n/4 time points
       .asg         B19,        B_l1            ;offset to n/2 time points
       .asg         B20,        B_l2            ;offset to 3n/4 time points
       .asg         A22,        A_fft_jmp       ;jump for twiddle factors
       .asg         B21,        B_fft_jmp       ;jump for twiddle factors
       .asg         A0,         A_p0            ;prolog collapse variable
       .asg         A2,         A_i             ;1st loop counter
       .asg         A25,        A_h2            ;offset to n/4 freq. points
       .asg         A23,        A_l1            ;offset to n/2 freq. points
       .asg         A24,        A_l2            ;offset to 3n/4 freq. points
       .asg         A31,        A_co11_si11     ;W^n+1
       .asg         A30,        A_co10_si10     ;W^n
       .asg         B29,        B_co21_si21     ;W^2n+1
       .asg         B28,        B_co20_si20     ;W^2n
       .asg         B31,        B_co31_si31     ;W^3n+1
       .asg         B30,        B_co30_si30     ;W^3n
       .asg         A29,        A_x_3_x_2       ;data into butterflies
       .asg         A28,        A_x_1_x_0       ;data into butterflies
       .asg         A27,        A_xh2_3_xh2_2   ;data itno butterflies
       .asg         A26,        A_xh2_1_xh2_0   ;data into butterflies
       .asg         B23,        B_xl1_3_xl1_2   ;data into butterflies
       .asg         B22,        B_xl1_1_xl1_0   ;data into butterflies
       .asg         B25,        B_xl2_3_xl2_2   ;data into butterflies
       .asg         B24,        B_xl2_1_xl2_0   ;data into butterflies
       .asg         B22,        B_xh1_0_xh0_0   ;data into butterflies
       .asg         B8,         B_xh1_1_xh0_1   ;data into butterflies
       .asg         A7,         A_xl1_0_xl0_0   ;data into butterflies
       .asg         A16,        A_xl1_1_xl0_1   ;data into butterflies
       .asg         B26,        B_xh21_0_xh20_0 ;data into butterflies
       .asg         B5,         B_xh21_1_xh20_1 ;data into butterflies
       .asg         A3,         A_xl21_0_xl20_0 ;data into butterflies
       .asg         A7,         A_xl21_1_xl20_1 ;data into butterflies
       .asg         A18,        A_x_            ;copy of freq. pointer
       .asg         A10,        A_x__           ;copy of freq. pointer
       .asg         A1,         A_ifj           ;jump condition for DSP_fft
       .asg         B26,        B_x_1_x_0       ;data out of butterflies
       .asg         B27,        B_x_3_x_2       ;data out of butterflies
       .asg         B7,         B_yt0_0_xt0_0   ;data out of butterflies
       .asg         B8,         B_yt0_1_xt0_1   ;data out of butterflies
       .asg         A3,         A_xl20_0_xl21_0 ;data out of butterflies
       .asg         A5,         A_xl20_1_xl21_1 ;data out of butterflies
       .asg         A8,         A_yt2_0_xt1_0   ;data out of butterflies
       .asg         A11,        A_yt2_1_xt1_1   ;data out of butterflies
       .asg         A9,         A_yt1_0_xt2_0   ;data out of butterflies
       .asg         A16,        A_yt1_1_xt2_1   ;data out of butterflies
       .asg         A7,         A_xt1_0_yt1_0   ;data out of butterflies
       .asg         A5,         A_xt1_1_yt1_1   ;data out of butterflies
       .asg         A8,         A_xt2_0_yt2_0   ;data out of butterflies
       .asg         A28,        A_xt2_1_yt2_1   ;data out of butterflies
       .asg         B26,        B_xt0_0_yt0_0   ;data out of butterflies
       .asg         B9,         B_xt0_1_yt0_1   ;data out of butterflies
       .asg         A1,         A_yt1_0_xt1_0   ;data out of butterflies
       .asg         A5,         A_yt1_1_xt1_1   ;data out of butterflies
       .asg         A3,         A_yt2_0_xt2_0   ;data out of butterflies
       .asg         A3,         A_yt2_1_xt2_1   ;data out of butterflies
       .asg         A26,        A_x_h2_0        ;frequency >> 15
       .asg         A27,        A_x_h2_1        ;frequency >> 15
       .asg         A17,        A_x_h2_2        ;frequency >> 15
       .asg         A29,        A_x_h2_3        ;frequency >> 15
       .asg         B0,         B_x_l1_0        ;frequency >> 15
       .asg         B2,         B_x_l1_1        ;frequency >> 15
       .asg         B23,        B_x_l1_2        ;frequency >> 15
       .asg         B5,         B_x_l1_3        ;frequency >> 15
       .asg         B1,         B_x_l2_0        ;frequency >> 15
       .asg         B27,        B_x_l2_1        ;frequency >> 15
       .asg         B2,         B_x_l2_2        ;frequency >> 15
       .asg         B7,         B_x_l2_3        ;frequency >> 15
       .asg         A28,        A_xh2_1_0       ;packed frequencies
       .asg         A29,        A_xh2_3_2       ;packed frequencies
       .asg         B22,        B_xl1_1_0       ;packed frequencies
       .asg         B23,        B_xl1_3_2       ;packed frequencies
       .asg         B24,        B_xl2_1_0       ;packed frequencies
       .asg         B25,        B_xl2_3_2       ;packed frequencies
       .asg         B0,         B_whl           ;outer while loop condition
       .asg         B13,        B_csr           ;CSR before function call
       .asg         B10,        B_no_gie        ;CSR before with GIE bit off
*==============================================================================*
        MV.L1X     B_SP,          A_SP                          ;make cpy of SP
||      STW.D2T2   B12,           *-B_SP[7]                     ;Save B12
||      SHRU.S2    B_n,           3,               B_h2         ;h2=n/8
||      B.S1       LOOP_WHILE                                   ; no ints!

        STW.D2T1   A12,           *-B_SP[6]                     ;Save A12
||      MV.L2      B_n,           B_stride                      ;stride = n
||      STW.D1T2   B13,           *-A_SP[9]                     ;Save B13
||      MVC.S2     CSR,           B_csr                         ;save CSR
;-
        STW.D2T2   B11,           *-B_SP[5]                     ;Save B11
||      STW.D1T1   A11,           *-A_SP[4]                     ;Save A11
||      ZERO.L1    A_tw_offset                                  ;tw_offset=0

        STW.D2T2   B10,           *-B_SP[3]                     ;Save B10
||      STW.D1T1   A10,           *-A_SP[2]                     ;Save A10
||      AND.S2     B_csr,         -2,              B_no_gie     ;kill gie bit
;-
        MV.L2X     A_ptr_x,       B_x                           ;x= ptr_x
||      ADDAH.D2   B_h2,          B_h2,            B_l2         ;l2=3*h2
||      MVC.S2     B_no_gie,      CSR                           ;disable intrpt.

        LDDW.D2T2  *B_x[B_l2],    B_xl2_3_xl2_2:B_xl2_1_xl2_0   ;x[l2+0..3]
||      SHRU.S1X   B_n,           3,               A_i          ;i=n>>3
||      SHL.S2     B_stride,      1,               B_stride_1   ;stride/2
*============================= PIPE LOOP PROLOG ===============================*
LOOP_WHILE:
        LDDW.D2T1  *B_x[B_h2],    A_xh2_3_xh2_2:A_xh2_1_xh2_0   ;x[h2+0..3]
||      MV.L1X     B_l2,          A_l2                          ;l2 copy
||      SHRU.S2    B_stride,      2,               B_l1         ;fft_jmp=
||      ADD.L2     B_stride,      B_stride_1,      B_fft_jmp    ;1.5*stride
;-
        SHRU.S2    B_fft_jmp,     1,               B_fft_jmp_1  ;fft_jmp/2
||      MV.S1X     B_h2,          A_h2                          ;copy h2

        B.S2       LOOP_Y5 + 24                                 ;trunc. prolog
||      SHRU.S1X   B_fft_jmp,     3,               A_fft_jmp    ;w=ptr_w+
||      ADDAH.D1   A_ptr_w,       A_tw_offset,     A_w0         ;tw_offset

        LDDW.D2T2  *B_x[B_l1],    B_xl1_3_xl1_2:B_xl1_1_xl1_0   ;xl1[+0..3]
||      B.S1       LOOP_Y6 + 12                                 ;trunc. prolog
||      MV.D1X     B_l1,          A_l1                          ;cpy l1
;-
        LDDW.D2T1  *B_x[0],       A_x_3_x_2:A_x_1_x_0           ;x0..3]
||      B.S2       LOOP_Y7 + 12                                 ;proloG collapse
||      SUB.L1     A_fft_jmp,     3,               A_fft_jmp    ;tw_offset+=
||      ADD.S1X    A_tw_offset,   B_fft_jmp_1,     A_tw_offset  ;  fft_jmp

        SUB2.S1X   A_xh2_1_xh2_0, B_xl2_1_xl2_0, A_xl21_0_xl20_0;x[h2]-x[l2]
||      B.S2       LOOP_Y8 + 12                                 ;trunc prolog
||      MV.L2X     A_w0,          B_w0                          ;cpy w0
||      ADD.L1     A_w0,          8,               A_w1         ;w1=w0+1
;-
        LDDW.D1T2  *A_w1[0],      B_co21_si21:B_co20_si20       ;W^2n+1,W^2n
||      LDDW.D2T1  *B_w0[0],      A_co11_si11:A_co10_si10       ;W^n+1,W^n
||      ADD2.L2X   B_xl2_1_xl2_0, A_xh2_1_xh2_0, B_xh21_0_xh20_0;xh2=x[l2]+x[h2]
||      SUB2.L1X   A_xh2_3_xh2_2, B_xl2_3_xl2_2, A_xl21_1_xl20_1;xl2=x[l2]-x[h2]
||      B.S2       LOOP_Y9 + 16
||      MPYSU.M1   0,             A_zero,          A_zero       ;zero = 0
||      MV.S1      A_fft_jmp,     A_ifj                         ;ify=fft_jmp
;-
        MVD.M1X    B_x,           A_x_                          ;x_=x
||      BDEC.S1    LOOP_Y,        A_i                           ;trunc prolog
||      SHRU.S2    B_stride,      2,               B_stride     ;stride>>=2
||      MPYSU.M2   0,             B_j,             B_j          ;j = 0
||      ZERO.D1    A_j                                          ;j = 0
||      MVK.L1     1,             A_p0                          ;p0=1
||      ADD.L2X    A_w1,          8,               B_w2         ;w2=w1+1
*============================= PIPE LOOP KERNEL ===============================*
LOOP_Y:
        ADD.S2     B_x_l1_1,      B_x_l1_1,        B_x_l1_1     ;x[l1+1]>>15
||      DOTP2.M2X  B_co31_si31,   A_xt2_1_yt2_1,   B_x_l2_2     ;Im{W^3n+1*x2}
||      ADD.S1     A_x_h2_1,      A_x_h2_1,        A_x_h2_1     ;x[h2+1]>>15
||      ROTL.M1    A_xt1_0_yt1_0, 16,              A_yt1_0_xt1_0;xt1<=>yt1
||      PACKLH2.L1 A_yt2_1_xt1_1, A_yt1_1_xt2_1,   A_xt1_1_yt1_1;repack data
||      ADD.D1     A_j,           3,               A_j          ;j+=3
||[!A_ifj]ZERO.L2  B_j                                          ;j=0 if at end
||      LDDW.D2T2  *B_x[B_l1],    B_xl1_3_xl1_2:B_xl1_1_xl1_0   ;x[l1+0..3]

        PACKH2.S2  B_x_l1_1,      B_x_l1_0,        B_xl1_1_0    ;repack data
||      PACKH2.L1  A_x_h2_1,      A_x_h2_0,        A_xh2_1_0    ;repack data
||      ADD2.L2    B_xh21_0_xh20_0, B_xh1_0_xh0_0, B_x_1_x_0    ;xh2x+xhx
||      ROTL.M2    B_yt0_0_xt0_0, 16,              B_xt0_0_yt0_0;repack data
||      DOTP2.M1   A_xt1_1_yt1_1, A_co11_si11,     A_x_h2_2     ;Im{W^n+1*X1}
||      PACKLH2.S1 A_xt1_1_yt1_1, A_xt1_1_yt1_1,   A_yt1_1_xt1_1;repack data
||[!A_ifj]ZERO.D1  A_j                                          ;j=0?
||      LDDW.D2T1  *B_x[0],       A_x_3_x_2:A_x_1_x_0           ;x[0..3]

        ADD.S2     B_x_l2_0,      B_x_l2_0,        B_x_l2_0     ;x[l2]>>15
||      ADD.L2     B_x_l1_3,      B_x_l1_3,        B_x_l1_3     ;x[l1+3]>>15
||      ADD.D2     B_x_l1_2,      B_x_l1_2,        B_x_l1_2     ;x[l1+2]>>15
||      DOTPN2.M2X B_co31_si31,   A_yt2_1_xt2_1,   B_x_l2_3     ;Re{W^3n+1*X2}
||      STDW.D1T2  B_x_3_x_2:B_x_1_x_0,            *A_x_[0]     ;write x[0..3]
||      DOTPN2.M1  A_yt1_0_xt1_0, A_co10_si10,     A_x_h2_1     ;Re{X1*W^n}
||      SUB2.S1X   A_xh2_1_xh2_0, B_xl2_1_xl2_0, A_xl21_0_xl20_0;x[h2]-x[l2]
||      SUB.L1     A_fft_jmp,     A_j,             A_ifj        ;(fft_jmp==j)?

        PACKH2.S2  B_x_l1_3,      B_x_l1_2,        B_xl1_3_2    ;repack data
||      ADD.S1     A_x_h2_3,      A_x_h2_3,        A_x_h2_3     ;x[h2+3]>>15
||      DOTP2.M2   B_xt0_0_yt0_0, B_co20_si20,     B_x_l1_0     ;Im{W^2n*X0}
||      DOTP2.M1   A_xt1_0_yt1_0, A_co10_si10,     A_x_h2_0     ;Im{W^n*X1}
||      LDDW.D1T2  *A_w1[A_j],    B_co21_si21:B_co20_si20       ;W^2n+1,W^2n
||      LDDW.D2T1  *B_w0[B_j],    A_co11_si11:A_co10_si10       ;W^n+1,W^n
||      ADD2.L2X   B_xl2_1_xl2_0, A_xh2_1_xh2_0, B_xh21_0_xh20_0;xl2+xh2
||      SUB2.L1X   A_xh2_3_xh2_2, B_xl2_3_xl2_2, A_xl21_1_xl20_1;xh2-xl2

  [ A_i]BDEC.S1    LOOP_Y,        A_i                           ;} end for
||      ADD.D2     B_x_l2_1,      B_x_l2_1,        B_x_l2_1     ;x[l2+1]>>15
||[!A_p0]STDW.D1T2 B_xl1_3_2:B_xl1_1_0,            *A_x__[A_l1] ;save x[l1+0..3]
||      ADD.L2     B_x_l2_2,      B_x_l2_2,        B_x_l2_2     ;x[l2+2]>>15
||      PACKH2.L1  A_x_h2_3,      A_x_h2_2,        A_xh2_3_2    ;repack data
||      DOTPN2.M2  B_yt0_1_xt0_1, B_co21_si21,     B_x_l1_3     ;Im{W^2n+1*X0}
||[!A_ifj]ADD.S2   B_x,           B_fft_jmp,       B_x          ;x+=fft_fmp?
||      MVD.M1X    B_x,           A_x_                          ;x_=x
LOOP_Y5:
        PACKH2.S2  B_x_l2_1,      B_x_l2_0,        B_xl2_1_0    ;repack data
||[!A_p0]STDW.D1T1 A_xh2_3_2:A_xh2_1_0,            *A_x__[A_h2] ;save x[h2+0..3]
||      PACKLH2.S1 A_yt1_0_xt2_0, A_yt2_0_xt1_0,   A_xt2_0_yt2_0;repack datat
||      ADD.L1     A_x_h2_2,      A_x_h2_2,        A_x_h2_2     ;x[h2+2]>>15
||      DOTPN2.M1  A_yt1_1_xt1_1, A_co11_si11,     A_x_h2_3     ;Re{W^n+1*X1}
||      DOTPN2.M2  B_yt0_0_xt0_0, B_co20_si20,     B_x_l1_1     ;Re{W^2n*X0}
||      ADD2.D2X   B_xl2_3_xl2_2, A_xh2_3_xh2_2, B_xh21_1_xh20_1;xl2+xh2
||      ADD.L2     B_x,           8,               B_x          ;x+=8
LOOP_Y6:
        ADD.L2     B_x_l2_3,      B_x_l2_3,        B_x_l2_3     ;x[l2+3]>>15
||      ROTL.M1    A_xt2_0_yt2_0, 16,              A_yt2_0_xt2_0;repack data
||      DOTP2.M2   B_xt0_1_yt0_1, B_co21_si21,     B_x_l1_2     ;Im{W^2n+1*X0}
||      ADD2.S2X   B_xl1_3_xl1_2, A_x_3_x_2,       B_xh1_1_xh0_1;x[l1]+x[0]
||      PACKLH2.L1 A_xl21_1_xl20_1,A_xl21_1_xl20_1,A_xl20_1_xl21_1;repack data
||      PACKLH2.S1 A_xl21_0_xl20_0,A_xl21_0_xl20_0,A_xl20_0_xl21_0;repack data
||      SUB2.D1X   A_x_1_x_0,     B_xl1_1_xl1_0,   A_xl1_0_xl0_0;x[0]-x[l1]
||      LDDW.D2T2  *B_x[B_l2],    B_xl2_3_xl2_2:B_xl2_1_xl2_0   ;x[l2+0..3]
LOOP_Y7:
        DOTP2.M2X  B_co30_si30,   A_xt2_0_yt2_0,   B_x_l2_0     ;Im{W^3n*X3}
||      ADD.D1     A_x_h2_0,      A_x_h2_0,        A_x_h2_0     ;x[h2]>>15
||      MVD.M1     A_x_,          A_x__                         ;x__=x_
||      SUB2.L1    A_xl1_0_xl0_0, A_xl20_0_xl21_0, A_yt1_0_xt2_0;xl1-xl20
||      ADD2.S1    A_xl1_0_xl0_0, A_xl20_0_xl21_0, A_yt2_0_xt1_0;xl1+xl20
||      ADD2.L2    B_xh21_1_xh20_1, B_xh1_1_xh0_1, B_x_3_x_2    ;xh21+xh1
||      SUB2.S2    B_xh1_1_xh0_1, B_xh21_1_xh20_1, B_yt0_1_xt0_1;xh1-xh21
||      LDDW.D2T1  *B_x[B_h2],    A_xh2_3_xh2_2:A_xh2_1_xh2_0   ;x[h2+0..3]
LOOP_Y8:
        PACKH2.L2  B_x_l2_3,      B_x_l2_2,        B_xl2_3_2    ;repack data
||      MVD.M1     A_zero,        A_p0                          ;disable prolog
||      PACKLH2.S1 A_yt1_1_xt2_1, A_yt2_1_xt1_1,   A_xt2_1_yt2_1;reformat
||      ROTL.M2    B_yt0_1_xt0_1, 16,              B_xt0_1_yt0_1;repack data
||      PACKLH2.L1 A_yt2_0_xt1_0, A_yt1_0_xt2_0,   A_xt1_0_yt1_0;repack data
||      SUB2.D1X   A_x_3_x_2,     B_xl1_3_xl1_2,   A_xl1_1_xl0_1;x[0]-x[l1]
||      ADD2.S2X   B_xl1_1_xl1_0, A_x_1_x_0,       B_xh1_0_xh0_0;x[0]+x[l1]
||      LDDW.D2T2  *B_w2[B_j],    B_co31_si31:B_co30_si30       ;W^3n+1,W^3n
LOOP_Y9:
  [!A_p0]STDW.D1T2 B_xl2_3_2:B_xl2_1_0,            *A_x__[A_l2] ;x[l2+0..3]
||      DOTPN2.M2X B_co30_si30,   A_yt2_0_xt2_0,   B_x_l2_1     ;Re{W^3n*X2}
||      ADD.L2     B_x_l1_0,      B_x_l1_0,        B_x_l1_0     ;x[l1]>>15
||      ROTL.M1    A_xt2_1_yt2_1, 16,              A_yt2_1_xt2_1;repack data
||      SUB2.S2    B_xh1_0_xh0_0, B_xh21_0_xh20_0, B_yt0_0_xt0_0;xh1-xh21
||      ADD.D2     B_j,           3,               B_j          ;j+=3
||      ADD2.L1    A_xl1_1_xl0_1, A_xl20_1_xl21_1, A_yt2_1_xt1_1;xl1+xl20
||      SUB2.S1    A_xl1_1_xl0_1, A_xl20_1_xl21_1, A_yt1_1_xt2_1;xl1-xl20
*============================= PIPE LOOP EPILOG ===============================*
        ADD.D2     B_x_l1_1,      B_x_l1_1,        B_x_l1_1     ;x[l1+1]>>15
||      DOTP2.M2X  B_co31_si31,   A_xt2_1_yt2_1,   B_x_l2_2     ;Im{W^3n+1*X2}
||      ADD.S1     A_x_h2_1,      A_x_h2_1,        A_x_h2_1     ;x[h2+1]>>15
||      SHRU.S2    B_stride,      3,               B_h2         ;h2=stride/8

        PACKH2.S2  B_x_l1_1,      B_x_l1_0,        B_xl1_1_0    ;repack data
||      PACKH2.L1  A_x_h2_1,      A_x_h2_0,        A_xh2_1_0    ;repack data
||      MV.L2X     A_ptr_x,       B_x                           ;x= ptr_x
||      ADDAH.D2   B_h2,          B_h2,            B_l2         ;l2=3*h2
;-
        ADD.S2     B_x_l2_0,      B_x_l2_0,        B_x_l2_0     ;x[l2]>>15
||      ADD.L2     B_x_l1_3,      B_x_l1_3,        B_x_l1_3     ;x[l1+3]>>15
||      ADD.D2     B_x_l1_2,      B_x_l1_2,        B_x_l1_2     ;x[l1+2]>>15
||      DOTPN2.M2X B_co31_si31,   A_yt2_1_xt2_1,   B_x_l2_3     ;Re{W^3n+1*X2}

        PACKH2.S2  B_x_l1_3,      B_x_l1_2,        B_xl1_3_2    ;repack data
||      ADD.S1     A_x_h2_3,      A_x_h2_3,        A_x_h2_3     ;x[h2+3]>>15
||      CMPLTU.L2  4,             B_stride,        B_whl        ;stride>4 ?
||      MV.L1X     B_SP,          A_SP                          ;cp B_SP
;-
        ADD.D2     B_x_l2_1,      B_x_l2_1,        B_x_l2_1     ;x[l2+1]>>15
||      STDW.D1T2  B_xl1_3_2:B_xl1_1_0,            *A_x__[A_l1] ;save x[l1+0..3]
||      ADD.L2     B_x_l2_2,      B_x_l2_2,        B_x_l2_2     ;x[l2+2]>>15
||      PACKH2.L1  A_x_h2_3,      A_x_h2_2,        A_xh2_3_2    ;repack data
||[B_whl]B.S1      LOOP_WHILE                                   ;}end while

        PACKH2.S2  B_x_l2_1,      B_x_l2_0,        B_xl2_1_0    ;repack data
||      STDW.D1T1  A_xh2_3_2:A_xh2_1_0,            *A_x__[A_h2] ;save x[h2+0..3]

        ADD.L2     B_x_l2_3,      B_x_l2_3,        B_x_l2_3     ;x[l2+3]>>15
;-
        PACKH2.L2  B_x_l2_3,      B_x_l2_2,        B_xl2_3_2    ;repack data
||      SHL.S2     B_stride,      1,               B_stride_1   ;2*stride
||      SHRU.S1X   B_n,           3,               A_i          ;i=n>>3
*======================= SYMBOLIC rEGISTER ASSIGNMENTS ========================*
       .asg        B4,         B_n            ;number of complex points
       .asg        A6,         A_ptr_x        ;pointer to n-1th transformed data
       .asg        B6,         B_ptr_y        ;pointer to frequency domain
       .asg        A6,         A_x0           ;even samples
       .asg        B16,        B_x0           ;even samples
       .asg        A24,        A_x1           ;odd samples
       .asg        B17,        B_x1           ;odd samples
       .asg        A25,        A_i            ;loop count
       .asg        B1,         B_j            ;index to input
       .asg        B18,        B_nm2          ;n-2
       .asg        A26,        A_n_2          ;n/4
       .asg        A2,         A_p0           ;prolog collapse counter
       .asg        A27,        A_n            ;number of complex points
       .asg        B19,        B_y0           ;y[i]
       .asg        B20,        B_y1           ;y[i+n/4]
       .asg        B21,        B_y2           ;y[i+n/2]
       .asg        B22,        B_y3           ;y[i+3*n/4]
       .asg        B23,        B_l1           ;shift for digit reverse
       .asg        A19,        A_h0           ;partial digit reverse
       .asg        A17,        A_h1           ;partial digit reverse
       .asg        B28,        B_h2           ;partial digit reverse
       .asg        B24,        B_h3           ;partial digit reverse
       .asg        B8,         B_h4           ;digit reversed index
       .asg        A28,        A_x1x0         ;x[i+1],x[i+0]
       .asg        A29,        A_x3x2         ;x[i+3],x[i+2]
       .asg        B24,        B_x5x4         ;x[i+5],x[i+4]
       .asg        B25,        B_x7x6         ;x[i+7],x[i+6]
       .asg        A30,        A_x9x8         ;x[i+9],x[i+8]
       .asg        A31,        A_xbxa         ;x[i+11],x[i+10]
       .asg        B28,        B_xdxc         ;x[i+13],x[i+12]
       .asg        B29,        B_xfxe         ;x[i+15],x[i+14]
       .asg        B26,        B_xh1_0_xh0_0  ;stageI outputs from butterflies
       .asg        B28,        B_xh21_0_xh20_0;stageI outputs from butterflies
       .asg        A18,        A_xl1_0_xl0_0  ;stageI outputs from butterflies
       .asg        A20,        A_xl21_0_xl20_0;stageI outputs from butterflies
       .asg        A19,        A_xl0_0_xl1_0  ;stageI outputs from butterflies
       .asg        B26,        B_yt0_0_xt0_0  ;stageI outputs from butterflies
       .asg        A20,        A_xt1_0_yt2_0  ;stageI outputs from butterflies
       .asg        A30,        A_xt2_0_yt1_0  ;stageI outputs from butterflies
       .asg        B9,         B_xh1_1_xh0_1  ;stageII outputs from butterflies
       .asg        B27,        B_xh21_1_xh20_1;stageII outputs from butterflies
       .asg        A30,        A_xl1_1_xl0_1  ;stageII outputs from butterflies
       .asg        A22,        A_xl21_1_xl20_1;stageII outputs from butterflies
       .asg        A19,        A_xl0_1_xl1_1  ;stageII outputs from butterflies
       .asg        B27,        B_yt0_1_xt0_1  ;stageII outputs from butterflies
       .asg        A21,        A_xt1_1_yt2_1  ;stageII outputs from butterflies
       .asg        A22,        A_xt2_1_yt1_1  ;stageII outputs from butterflies
       .asg        B30,        B_y1y0         ;complex frequencies
       .asg        A30,        A_y3y2         ;complex frequencies
       .asg        A28,        A_y7y6         ;complex frequencies
       .asg        B31,        B_y9y8         ;complex frequencies
       .asg        A31,        A_ybya         ;complex frequencies
       .asg        A29,        A_yfye         ;complex frequencies
       .asg        B2,         B_ifi          ;jump condition for digit reversal
*============================PIPE LOOP PROLOG =================================*
        SHRU.S1X   B_n,           2,               A_n_2          ;n/4
||      STDW.D1T2  B_xl2_3_2:B_xl2_1_0,            *A_x__[A_l2]   ;x[l2+...3]
;-
        SHRU.S2    B_n,           3,               B_j            ;j=n/8
||      ADD.S1X    A_ptr_x,       B_n,             A_x1           ;n/4 words
||      LDW.D1T1   *-A_SP[4],     A11                             ;Restore A11
||[B_whl]LDDW.D2T2 *B_x[B_l2],    B_xl2_3_xl2_2:B_xl2_1_xl2_0     ;x[l2]+0..3]

        ADD.L2     B_ptr_y,       B_n,             B_y1           ;y1=y+n/4
||      SUB.S2X    4,             A_n_2,           B_nm2          ;4 - n/4
||      LDW.D1T1   *-A_SP[2],     A10                             ;Restore A10
||      LDW.D2T2   *-B_SP[5],     B11                             ;Restore B11
;-
        MVK.S1     0xFFFF8000,    A_p0                            ;kill prolog
||      NORM.L2    B_n,           B_l1                            ;_norm(n)+3
||      ADD.D2     B_y1,          B_n,             B_y2           ;y2=y1+n/4
||      ADD.S2X    A_x1,          8,               B_x1           ;ptr_x+n/2

        ADD.S2     B_y2,          B_n,             B_y3           ;y3=y2+n/4
||      ADD.L2X    A_ptr_x,       8,               B_x0           ;x = ptr_x
||      MV.L1X     B_n,           A_n                             ;copy n
||      LDW.D2T2   *-B_SP[3],     B10                             ;Restore B10
;-
        MVK.L2     1,             B_ifi                           ;if(j==n>>2){
||      MVK.L1     4,             A_i                             ;j += 4;
||      LDDW.D2T2  *B_x1++[2],    B_xfxe:B_xdxc                   ;x[15..12]
||      LDDW.D1T1  *A_x0++[2],    A_x3x2:A_x1x0                   ;x[3..0]
||      MPYSU.M1   0,             A_h0,            A_h0           ;h2=_deal(j)
||      ADD.S2     B_l1,          3,               B_l1           ;rev dwords
||      ROTL.M2    B_ptr_y,       0,               B_y0           ;y0= y
*============================= PIPE LOOP KERNEL2===============================*
LOOP_Z:
  [ B_j]BDEC.S2    LOOP_Z,        B_j                             ;}end for
||      SUB2.L1    A_xl0_0_xl1_0, A_xl21_0_xl20_0, A_xt2_0_yt1_0  ;xl0-xl21
||      ADD2.S1    A_xl0_0_xl1_0, A_xl21_0_xl20_0, A_xt1_0_yt2_0  ;xl0+xl21
||      ROTL.M1    A_xl1_1_xl0_1, 16,              A_xl0_1_xl1_1  ;repack data
||      ADD2.L2X   B_x7x6,        A_x3x2,          B_xh21_0_xh20_0;x7+x3
||      SHFL.M2    B_h2,          B_h3                            ;h2=_shfl(h2)
||      LDDW.D1T1  *A_x1++[2],    A_xbxa:A_x9x8                   ;x[11..8]
||      LDDW.D2T2  *B_x0++[2],    B_x7x6:B_x5x4                   ;x[7..4]

 [!A_p0]STDW.D2T2  B_yt0_1_xt0_1:B_yt0_0_xt0_0,    *B_y2[B_h4]    ;store freq.
||      PACKLH2.S1 A_xt1_0_yt2_0, A_xt2_0_yt1_0,   A_y7y6         ;repack data
||      SUB2.D1X   A_x1x0,        B_x5x4,          A_xl1_0_xl0_0  ;x1-x5
||      ADD2.S2X   B_x5x4,        A_x1x0,          B_xh1_0_xh0_0  ;x5+x1
||[!B_ifi]ADD.L2   B_x1,          B_n,             B_x1           ;x2+=n>>1
||[!B_ifi]ADD.L1   A_i,           A_n_2,           A_i            ;j+=n>>2
||      BITR.M1    A_h0,          A_h1                            ;h2=_bitr(h2)

 [!A_p0]STDW.D2T2  B_y9y8:B_y1y0, *B_y0[B_h4]                     ;store freq.
||      PACKLH2.S1 A_xt1_1_yt2_1, A_xt2_1_yt1_1,   A_yfye         ;repack data
||      PACKLH2.L1 A_xt2_0_yt1_0, A_xt1_0_yt2_0,   A_y3y2         ;repack data
||      ADD2.S2X   B_xfxe,        A_xbxa,          B_xh21_1_xh20_1;x[15]+x[11]
||      ADD2.L2    B_xh1_0_xh0_0, B_xh21_0_xh20_0, B_y1y0         ;xh1+xh21
||      SUB2.D1X   A_x3x2,        B_x7x6,          A_xl21_0_xl20_0;x3-x7

 [!A_p0]STDW.D2T1  A_yfye:A_y7y6, *B_y3[B_h4]                     ;store freq.
||      MPYSU.M1   2,             A_p0,            A_p0           ;prolog count
||      PACKLH2.S1 A_xt2_1_yt1_1, A_xt1_1_yt2_1,   A_ybya         ;repack data
||      ADD2.L2    B_xh1_1_xh0_1, B_xh21_1_xh20_1, B_y9y8         ;xh1+xh21
||      SUB2.D1X   A_xbxa,        B_xfxe,          A_xl21_1_xl20_1;x[11]-x[15]
||      SUB2.S2    B_xh1_0_xh0_0, B_xh21_0_xh20_0, B_yt0_0_xt0_0  ;xh1-xh21
||[!B_ifi]ADD.L1   A_x0,          A_n,             A_x0           ;x0 += n>>1
||      AVG2.M2X   A_i,           B_nm2,           B_ifi          ;if(j==n>>2){

 [!A_p0]STDW.D2T1  A_ybya:A_y3y2, *B_y1[B_h4]                     ;store freq.
||      SUB2.S1    A_xl0_1_xl1_1, A_xl21_1_xl20_1, A_xt2_1_yt1_1  ;xl0-xl21
||      ADD2.D1    A_xl0_1_xl1_1, A_xl21_1_xl20_1, A_xt1_1_yt2_1  ;xl0+xl21
||      ROTL.M1    A_xl1_0_xl0_0, 16,              A_xl0_0_xl1_0  ;repack data
||      SHRU.S2    B_h3,          B_l1,            B_h4           ;h2 >>= l1
||[!B_ifi]ADD.L1   A_x1,          A_n,             A_x1           ;x2 += n>>1
||[!B_ifi]ADD.L2   B_x0,          B_n,             B_x0           ;x0 += n>>1
||      ROTL.M2X   A_h1,          16,              B_h2           ;rotl(h2, 16)

        SUB2.S2    B_xh1_1_xh0_1, B_xh21_1_xh20_1, B_yt0_1_xt0_1  ;xh1-xh21
||      SUB2.L1X   A_x9x8,        B_xdxc,          A_xl1_1_xl0_1  ;x[9]-x[13]
||      ADD2.L2X   B_xdxc,        A_x9x8,          B_xh1_1_xh0_1  ;x[13]+x[9]
||      ADD.S1     A_i,           4,               A_i            ;j += 4;
||      LDDW.D2T2  *B_x1++[2],    B_xfxe:B_xdxc                   ;x[15..12]
||      LDDW.D1T1  *A_x0++[2],    A_x3x2:A_x1x0                   ;x[3..0]
||      DEAL.M1    A_i,           A_h0                            ;h2=_deal(j)
*============================= PIPE LOOP EPILOG ===============================*
        SUB2.L1    A_xl0_0_xl1_0, A_xl21_0_xl20_0, A_xt2_0_yt1_0  ;xl1-xl21
||      ADD2.S1    A_xl0_0_xl1_0, A_xl21_0_xl20_0, A_xt1_0_yt2_0  ;xl1+xl21
||      LDW.D2T2   *-B_SP[7],     B12                             ;Restore B12
||      MV         B_SP,          A_SP
||      B.S2       B3                                             ;Rtrn to call

        LDW.D2T1   *-B_SP[6],     A12                             ;Restore A12
||      LDW.D1T2   *-A_SP[9],     B13                             ;Restore B13
||      PACKLH2.S1 A_xt1_0_yt2_0, A_xt2_0_yt1_0,   A_y7y6         ;repack data
;-
        STDW.D2T2  B_yt0_1_xt0_1:B_yt0_0_xt0_0,    *B_y2[B_h4]    ;store freq.
||      PACKLH2.S1 A_xt1_1_yt2_1, A_xt2_1_yt1_1,   A_yfye         ;repack data
||      PACKLH2.L1 A_xt2_0_yt1_0, A_xt1_0_yt2_0,   A_y3y2         ;repack data

        STDW.D2T1  A_yfye:A_y7y6, *B_y3[B_h4]                     ;store freq.
||      PACKLH2.S1 A_xt2_1_yt1_1, A_xt1_1_yt2_1,   A_ybya         ;repack data
||      MVC.S2     B_csr,         CSR                             ;rstr interupt

        STDW.D2T2  B_y9y8:B_y1y0, *B_y0[B_h4]                     ;store freq.

        STDW.D2T1  A_ybya:A_y3y2, *B_y1[B_h4]                     ;store freq.
        ;Branch Occurs

* ========================================================================= *
*   End of file:  dsp_fft.asm                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
fft16x16r.asm/  1061588609  0     0     0       80756     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.7     Thu Sep  6 18:22:31 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================== *
*                                                                            *
*   TEXAS INSTRUMENTS, INC.                                                  *
*                                                                            *
*   NAME                                                                     *
*         DSP_fft16x16r : 16x16 FFT with rounding and scaling                *
*                                                                            *
*                                                                            *
*   REVISION DATE                                                            *
*       12-Sep-2000                                                          *
*                                                                            *
*   USAGE                                                                    *
*         This routine is C-callable and can be called as:                   *
*                                                                            *
*         void DSP_fft16x16r                                                 *
*         (                                                                  *
*             int                       n,                                   *
*             short *restrict           ptr_x,                               *
*             const short *restrict     ptr_w,                               *
*             unsigned char *restrict   brev,                                *
*             short *restrict           ptr_y,                               *
*             int                       radix,                               *
*             int                       offset,                              *
*             int                       nmax                                 *
*         )                                                                  *
*                                                                            *
*         N      = length of fft in complex samples, power of 2 <=16384      *
*         ptr_x  = pointer to complex data input                             *
*         ptr_w  = pointer to complex twiddle factor (see below)             *
*         brev   = pointer to bit reverse table containing 64 entries        *
*         n_min  = smallest fft butterfly used in computation                *
*                  used for decomposing fft into subffts, see notes          *
*         offset = index in complex samples of sub-fft from start of main ff *
*         n_max  = size of main fft in complex samples                       *
*                                                                            *
*   DESCRIPTION                                                              *
*        The benchmark performs a mixed radix forwards fft using             *
*        a special sequence of coefficients generated in the following       *
*        way:                                                                *
*                                                                            *
*          -* generate vector of twiddle factors for optimized algorithm *-  *
*         void tw_gen(short * w, int N)                                      *
*         {                                                                  *
*           int j, k;                                                        *
*           double x_t, y_t, theta1, theta2, theta3;                         *
*           const double PI = 3.141592654, M = 32767.0;                      *
*                                        -* M is 16383 for scale by 4 *-     *
*                                                                            *
*           for (j=1, k=0; j <= N>>2; j = j<<2)                              *
*           {                                                                *
*               for (i=0; i < N>>2; i+=j)                                    *
*               {                                                            *
*                   theta1 = 2*PI*i/N;                                       *
*                   x_t = M*cos(theta1);                                     *
*                   y_t = M*sin(theta1);                                     *
*                   w[k]   =  (short)x_t;                                    *
*                   w[k+1] =  (short)y_t;                                    *
*                                                                            *
*                   theta2 = 4*PI*i/N;                                       *
*                   x_t = M*cos(theta2);                                     *
*                   y_t = M*sin(theta2);                                     *
*                   w[k+2] =  (short)x_t;                                    *
*                   w[k+3] =  (short)y_t;                                    *
*                                                                            *
*                   theta3 = 6*PI*i/N;                                       *
*                   x_t = M*cos(theta3);                                     *
*                   y_t = M*sin(theta3);                                     *
*                   w[k+4] =  (short)x_t;                                    *
*                   w[k+5] =  (short)y_t;                                    *
*                   k+=6;                                                    *
*               }                                                            *
*           }                                                                *
*         }                                                                  *
*        This redundent set of twiddle factors is size 2*N short samples.    *
*        As pointed out later dividing these twiddle factors by 2 will give  *
*        an effective divide by 4 at each stage to guarentee no overflow.    *
*        The function is accurate to about 68dB of signal to noise ratio     *
*        to the DFT function below:                                          *
*                                                                            *
*         void dft(int n, short x[], short y[])                              *
*         {                                                                  *
*            int k,i, index;                                                 *
*            const double PI = 3  4159654;                                   *
*            short * p_x;                                                    *
*            double arg, fx_0, fx_1, fy_0, fy_1, co, si;                     *
*                                                                            *
*            for(k = 0; k<n; k++)                                            *
*            {                                                               *
*              p_x = x;                                                      *
*              fy_0 = 0;                                                     *
*              fy_1 = 0;                                                     *
*              for(i=0; i<n; i++)                                            *
*              {                                                             *
*                fx_0 = (double)p_x[0];                                      *
*                fx_1 = (double)p_x[1];                                      *
*                p_x += 2;                                                   *
*                index = (i*k) % n;                                          *
*                arg = 2*PI*index/n;                                         *
*                co = cos(arg);                                              *
*                si = -sin(arg);                                             *
*                fy_0 += ((fx_0 * co) - (fx_1 * si));                        *
*                fy_1 += ((fx_1 * co) + (fx_0 * si));                        *
*              }                                                             *
*              y[2*k] = (short)2*fy_0/sqrt(N);                               *
*              y[2*k+1] = (short)2*fy_1/sqrt(N);                             *
*            }                                                               *
*         }                                                                  *
*        Scaling takes place at each stage except the last one.              *
*        This is a divide by 2 to prevent overflow. All shifts are rounded t *
*        reduce truncation noise power by 3dB.                               *
*        The function takes the table and input data and calculates the fft  *
*        producing the frequency domain data in the Y array.                 *
*        As the fft allows every input point to effect every output point in *
*        a cache based system such as the c6211, this causes cache thrashing *
*        This is mitigated by allowing the main fft of size N to be divided  *
*        into several steps, allowing as much data reuse as possible.        *
*                                                                            *
*        For example the following function:                                 *
*                                                                            *
*        DSP_fft16x16r  (1024, &x_asm[0],&w[0],y_asm,brev,4,  0,1024);       *
*                                                                            *
*        is equvalent to:                                                    *
*                                                                            *
*        DSP_fft16x16r  (1024,&x_asm[2*0],  &w[0]  ,y_asm,brev,256, 0,1024); *
*        DSP_fft16x16r  (256, &x_asm[2*0],  &w[2*768],y_asm,brev,4, 0,1024); *
*        DSP_fft16x16r (256, &x_asm[2*256],&w[2*768],y_asm,brev,4, 256,1024); *
*        DSP_fft16x16r (256, &x_asm[2*512],&w[2*768],y_asm,brev,4, 512,1024); *
*        DSP_fft16x16r (256, &x_asm[2*768],&w[2*768],y_asm,brev,4, 768,1024); *
*                                                                            *
*        Notice how the 1st fft function is called on the entire 1K data set *
*        it covers the 1st pass of the fft until the butterfly size is 256.  *
*        The following 4 ffts do 256 pt ffts 25% of the size. These continue *
*        down to the end when the buttefly is of size 4. The use an index to *
*        the main twiddle factor array of 0.75*2*N. This is because the      *
*        twiddle factor array is composed of successively decimated versions *
*        of the main array.                                                  *
*                                                                            *
*        N not equal to a power of 4 can be used, i.e. 512. In this case to  *
*        decompose the fft the following would be needed :                   *
*                                                                            *
*        DSP_fft16x16r   (512, &x_asm[0],&w[0],y_asm,brev,2,  0,512);        *
*                                                                            *
*        is equvalent to:                                                    *
*                                                                            *
*        DSP_fft16x16r   (512, &x_asm[0],    &w[0],  y_asm,brev,128, 0,512); *
*        DSP_fft16x16r   (128, &x_asm[2*0],  &w[2*384],y_asm,brev,2, 0,512); *
*        DSP_fft16x16r (128, &x_asm[2*128],&w[2*384],y_asm,brev,2, 128,512); *
*        DSP_fft16x16r (128, &x_asm[2*256],&w[2*384],y_asm,brev,2, 256,512); *
*        DSP_fft16x16r (128, &x_asm[2*384],&w[2*384],y_asm,brev,2, 384,512); *
*                                                                            *
*        The twiddle factor array is composed of log4(N) sets of twiddle     *
*        factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*        array for each stage of the fft is calculated by summing these      *
*        indices up appropriately.                                           *
*        For multiple ffts they can share the same table by calling the smal *
*        ffts from further down in the twiddle factor array. In the same way *
*        as the decomposition works for more data reuse.                     *
*                                                                            *
*        Thus, the above decomposition can be summarized for a general N ,   *
*        radix "rad" as follows:                                             *
*                                                                            *
*   DSP_fft16x16r(N,  &x[0],         &w[0],        brev, y_cn, N/4, 0,    N) *
*   DSP_fft16x16r(N/4,&x[0],         &w[2*(3*N/4)],brev, y_cn, rad, 0,    N) *
*   DSP_fft16x16r(N/4,&x[2*(N/4)],   &w[2*(3*N/4)],brev, y_cn, rad, N/4,  N) *
*   DSP_fft16x16r(N/4,&x[2*(N/2)],   &w[2*(3*N/4)],brev, y_cn, rad, N/2,  N) *
*   DSP_fft16x16r(N/4,&x[2*(3*N/4)], &w[2*3*N/4)], brev, y_cn, rad, 3*N/4, N) *
*                                                                            *
*        As discussed previously, N can be either a power of 4 or 2.  If  N  *
*        N is a power  of 4, rad = 4, and if N is a power of 2, and not  a   *
*        power of 4, then rad = 2. "rad" is used to control how many stages  *
*        of decomposition are performed. It is also used to dtermine whether *
*        a radix4 or radix2 decomposition should be performed at the last    *
*        stage. Hence when "rad" is set to "N/4" the first stage of the      *
*        transform alone is performed and the code exits. To complete the    *
*        FFT four other calls are required to perform N/4 size FFT's. In     *
*        fact the ordering of these 4 FFT's amonst themselves does not       *
*        matter and hence from a cahe perspective it helps to go through     *
*        the remaining 4 FFT's in exactly the opposite order to the first.   *
*                                                                            *
*        This is illustrated as follows:                                     *
*                                                                            *
*   DSP_fft16x16r(N,  &x[0],         &w[0],        brev, y_cn, N/4, 0,    N) *
*   DSP_fft16x16r(N/4,&x[2*(3*N/4)], &w[2*3*N/4)], brev, y_cn, rad, 3*N/4, N) *
*   DSP_fft16x16r(N/4,&x[2*(N/2)],   &w[2*(3*N/4)],brev, y_cn, rad, N/2,  N) *
*   DSP_fft16x16r(N/4,&x[2*(N/4)],   &w[2*(3*N/4)],brev, y_cn, rad, N/4,  N) *
*   DSP_fft16x16r(N/4,&x[0],         &w[2*(3*N/4)],brev, y_cn, rad, 0,    N) *
*                                                                            *
*        In addition this function can be used to minimize call overhead, by *
*        completing the FFT with one function call invocation as shown below *
*                                                                            *
*        DSP_fft16x16r(N, &x_cn[0], &w[0], y_cn, brev, rad, 0, N)            *
*                                                                            *
*    ASSUMPTIONS:                                                            *
*        n must be a power of 2 and n >= 8  n <= 16384 points.               *
*        Complex time data x and twiddle facotrs w are aligned on double     *
*        word boundares. Real values are stored in even word positions and   *
*        imaginary values in odd positions.                                  *
*                                                                            *
*        All data is in short precision integer fixed point form. The        *
*        complex frequency data will be returned in linear order.            *
*                                                                            *
*        If Interupts are required the decomposition can be used to allow    *
*        interupts to occur in between function calls. In this way interupts *
*        Can occur roughly every 20%  of the time through the function.      *
*                                                                            *
*    MEMORY NOTE:                                                            *
*        Configuration is LITTLE ENDIAN the code will not function if the -m *
*        flag is enabled but it can be modified for BIG ENDIAN usage.        *
*                                                                            *
*    TECHNIQUES                                                              *
*        A special sequence of coeffs. used as generated above               *
*        produces the fft. This collapses the inner 2 loops in the           *
*        taditional Burrus and Parks implementation Fortran Code.            *
*                                                                            *
*        The revised FFT uses a redundant sequence of twiddle factors to     *
*        allow a linear access through the data. This linear access enables  *
*        data and instruction level parallelism.                             *
*        The data produced by the DSP_fft16x16r fft is in normal form, the   *
*        whole data array is written into a new output buffer.               *
*                                                                            *
*        The DSP_fft16x16r butterfly is bit reversed, i.e. the inner 2 points of *
*        the butterfly are corssed over, this has the effect of making the   *
*        data come out in bit reversed rather than in radix 4 digit reversed *
*        order. This simplifies the last pass of the loop. A simple table    *
*        is used to do the bit reversal out of place.                        *
*                                                                            *
*            unsigned char brev[64] = {                                      *
*                  0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,             *
*                  0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,             *
*                  0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,             *
*                  0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,             *
*                  0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,             *
*                  0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,             *
*                  0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,             *
*                  0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f              *
*            };                                                              *
*                                                                            *
*         This function no longer uses the lookup table to perform bit       *
*         reversal. It is performed using the _bitr instruction on C64x      *
*         architecture. It is performed using a macro BIT_REV instead.       *
*                                                                            *
*    NOTES                                                                   *
*        For more aggressive overflow control the shift in the DC term can b *
*        adjusted to 2 and the twiddle factors shifted right by 1. This give *
*        a divide by 4 at each stage. For better accuracy the data can be pr *
*        asserted left by so many bits so that as it builds in magnitude the *
*        divide by 2 prevents too much growth. An optimal point for example  *
*        with an 8192pt fft with input data precision of 8 bits is to asert  *
*        the input 4 bits left to make it 12 bits. This gives an SNR of 68dB *
*        at the output. By trying combinations the optimal can be found.     *
*        If scaling isnot required it is possible to replace the MPY by SMPY *
*        this will give a shift left by 1 so a shift right by 16 gives a     *
*        total 15 bit shift right. The DC term must be adjusted to give a    *
*        zero shift.                                                         *
*                                                                            *
*    C CODE                                                                  *
*        The following code is the traditional Burrus and Parks implemen-    *
*        tation, which performs a mixed radix FFT capable of 2^M, 4^M.       *
*        However it does not support multiple calls. It uses a traditional   *
*        twiddle factor array wn, generated as follows:                      *
*                                                                            *
*        const double M = 32767.0;                                           *
*        const double PI = 3  41592654;                                      *
*                                                                            *
*        for (i=0, k = 0; i < 3*(N>>2); i++)                                 *
*        {                                                                   *
*           theta1 = 2*PI*i/N;                                               *
*           x_t = M*cos(theta1);                                             *
*           y_t = M*sin(theta1);                                             *
*           wn[k]   = (short) x_t;                                           *
*           if (x_t >= M) wn[k  ] = 0x7fff;                                  *
*           wn[k+1] = (short) y_t;                                           *
*           if (y_t >= M) wn[k+1] = 0x7fff;                                  *
*           k+=2;                                                            *
*        }                                                                   *
*                                                                            *
*        The C code that implements the traditional mixed radix FFT is       *
*        shown below. It has three nested loops, one for the stages,         *
*        one for the groups of butterflies, one for the passes.              *
*                                                                            *
*  void DSP_fft16x16r(int n, short x[], short wn[],                          *
*        unsigned char brev[], short y[], int radix, int offset, int nmax)   *
*  {                                                                         *
*      int    n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, i, l0;              *
*      short  co1, co2, co3, si1, si2, si3;                                  *
*      short  xt0, yt0, xt1, yt1, xt2, yt2;                                  *
*      short  xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                           *
*      short * ptr_x0, * y0;                                                 *
*      unsigned int  j0, j1, k0, k1, k, j;                                   *
*      short x0, x1, x2, x3, x4, x5, x6, x7;                                 *
*      short xh0_0, xh1_0, xh0_1, xh1_1;                                     *
*      short xl0_0, xl1_0, xl0_1, xl1_1;                                     *
*      short yt3, yt4, yt5, yt6, yt7;                                        *
*                                                                            *
*      n2 = n;                                                               *
*      ie = 1;                                                               *
*      for (k = n; k > radix; k >>= 2)                                       *
*      {                                                                     *
*          n1 = n2;                                                          *
*          n2 >>= 2;                                                         *
*          ia1 = 0;                                                          *
*          for (j = 0; j < n2; j++)                                          *
*          {                                                                 *
*              ia2 = ia1 + ia1;                                              *
*              ia3 = ia2 + ia1;                                              *
*              co1 = w[2 * ia1    ];                                         *
*              si1 = w[2 * ia1 + 1];                                         *
*              co2 = w[2 * ia2    ];                                         *
*              si2 = w[2 * ia2 + 1];                                         *
*              co3 = w[2 * ia3    ];                                         *
*              si3 = w[2 * ia3 + 1];                                         *
*              ia1 = ia1 + ie;                                               *
*              for (i0 = j; i0 < n; i0 += n1)                                *
*              {                                                             *
*                  i1 = i0 + n2;                                             *
*                  i2 = i1 + n2;                                             *
*                  i3 = i2 + n2;                                             *
*                                                                            *
*                  xh0  = x[2 * i0    ] + x[2 * i2    ];                     *
*                  xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];                     *
*                  xl0  = x[2 * i0    ] - x[2 * i2    ];                     *
*                  xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];                     *
*                                                                            *
*                  xh20 = x[2 * i1    ] + x[2 * i3    ];                     *
*                  xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];                     *
*                  xl20 = x[2 * i1    ] - x[2 * i3    ];                     *
*                  xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];                     *
*                                                                            *
*                  x[2 * i0    ] = (xh0 + xh20 + 1)>>1;                      *
*                  x[2 * i0 + 1] = (xh1 + xh21 + 1)>>1;                      *
*                                                                            *
*                  xt0  = xh0 - xh20;                                        *
*                  yt0  = xh1 - xh21;                                        *
*                  xt1  = xl0 + xl21;                                        *
*                  yt2  = xl1 + xl20;                                        *
*                  xt2  = xl0 - xl21;                                        *
*                  yt1  = xl1 - xl20;                                        *
*                                                                            *
*                  x[2 * i2    ]= (xt1 * co1 + yt1 * si1 + 0x00008000)>> 16; *
*                  x[2 * i2 + 1]= (yt1 * co1 - xt1 * si1 + 0x00008000)>> 16; *
*                  x[2 * i1    ]= (xt0 * co2 + yt0 * si2 + 0x00008000)>> 16; *
*                  x[2 * i1 + 1]= (yt0 * co2 - xt0 * si2 + 0x00008000)>> 16; *
*                  x[2 * i3    ]= (xt2 * co3 + yt2 * si3 + 0x00008000)>> 16; *
*                  x[2 * i3 + 1]= (yt2 * co3 - xt2 * si3 + 0x00008000)>> 16; *
*              }                                                             *
*          }                                                                 *
*                                                                            *
*          ie <<= 2;                                                         *
*     }                                                                      *
*                                                                            *
*     j = 0;                                                                 *
*     ptr_x0 = x;                                                            *
*     y0 = y;                                                                *
*     l0 = _norm(n) - 17;                                                    *
*                                                                            *
*     if(radix == 2 || radix  == 4) for (i = 0; i < n; i += 4)               *
*     {                                                                      *
*                                                                            *
*                                                                            *
*             j0 = (j     ) & 0x3F;                                          *
*             j1 = (j >> 6) & 0x3F;                                          *
*             k0 = brev[j0];                                                 *
*             k1 = brev[j1];                                                 *
*             k = (k0 << 6) |  k1;                                           *
*             if (l0 < 0) k = k << -l0;                                      *
*             else        k = k >> l0;                                       *
*             j++;                                                           *
*                                                                            *
*             x0   = ptr_x0[0];  x1 = ptr_x0[1];                             *
*             x2   = ptr_x0[2];  x3 = ptr_x0[3];                             *
*             x4   = ptr_x0[4];  x5 = ptr_x0[5];                             *
*             x6   = ptr_x0[6];  x7 = ptr_x0[7];                             *
*             ptr_x0 += 8;                                                   *
*                                                                            *
*             xh0_0  = x0 + x4;                                              *
*             xh1_0  = x1 + x5;                                              *
*             xh0_1  = x2 + x6;                                              *
*             xh1_1  = x3 + x7;                                              *
*                                                                            *
*             if (radix == 2)                                                *
*             {                                                              *
*                 xh0_0 = x0;                                                *
*                 xh1_0 = x1;                                                *
*                 xh0_1 = x2;                                                *
*                 xh1_1 = x3;                                                *
*             }                                                              *
*                                                                            *
*             yt0  = xh0_0 + xh0_1;                                          *
*             yt1  = xh1_0 + xh1_1;                                          *
*             yt4  = xh0_0 - xh0_1;                                          *
*             yt5  = xh1_0 - xh1_1;                                          *
*                                                                            *
*             xl0_0  = x0 - x4;                                              *
*             xl1_0  = x1 - x5;                                              *
*             xl0_1  = x2 - x6;                                              *
*             xl1_1  = x3 - x7;                                              *
*                                                                            *
*             if (radix == 2)                                                *
*             {                                                              *
*                   xl0_0 = x4;                                              *
*                   xl1_0 = x5;                                              *
*                   xl1_1 = x6;                                              *
*                   xl0_1 = x7;                                              *
*             }                                                              *
*                                                                            *
*             yt2  = xl0_0 + xl1_1;                                          *
*             yt3  = xl1_0 - xl0_1;                                          *
*                                                                            *
*             yt6  = xl0_0 - xl1_1;                                          *
*             yt7  = xl1_0 + xl0_1;                                          *
*                                                                            *
*             if (radix == 2)                                                *
*             {                                                              *
*                  yt7  = xl1_0 - xl0_1;                                     *
*                  yt3  = xl1_0 + xl0_1;                                     *
*             }                                                              *
*                                                                            *
*             y0[k] = yt0; y0[k+1] = yt1;                                    *
*             k += n>>1                                                      *
*             y0[k] = yt2; y0[k+1] = yt3;                                    *
*             k += n>>1;                                                     *
*             y0[k] = yt4; y0[k+1] = yt5;                                    *
*             k += n>>1;                                                     *
*             y0[k] = yt6; y0[k+1] = yt7;                                    *
*        }                                                                   *
*    }                                                                       *
*                                                                            *
*        Although code shown above is the simplest equivalent way of writing *
*        this code, it already carries several optimization ideas. It has    *
*        a special last stage to avoid multiplication by 1. In addition it   *
*        was shown by Panos Papamichalis that if the two middle legs of a    *
*        radix 4 butterfly are reversed, the outputs for a radix4 transform  *
*        end up in the bit reversed fashion. The code also carries a linear  *
*        time look up table for bit reversal. This can be used as shown in   *
*        the code to construct a bit reversed index. The last stage perfo-   *
*        rms either a radix4 or radix2 as the case may be.                   *
*                                                                            *
*        The code shown below performs loop coalescing as it is realized     *
*        that while the "i" and "j" loop individually iterate for variable   *
*        number of times, together they always iterate for N/4 times. The    *
*        natural C code and the code shown below use a modified twiddle      *
*        factor array to allow for vectorization of the loop. In addition    *
*        bit-reversal is performed by a macro BIT_REV. This makes the bit-   *
*        reversal table redundant.                                           *
*                                                                            *
*        This is the C equivalent of the assembly code without restrictions: *
*        Note that the assembly code is hand optimized and restrictions may  *
*        apply.                                                              *
*                                                                            *
*                                                                            *
*       void DSP_fft16x16r(int n, short ptr_x[], short ptr_w[], short ptr_y[] *
*                    unsigned char brev[], int n_min, int offset, int n_max) *
*       {                                                                    *
*          int  i, j, k, l1, l2, h2, predj;                                  *
*          int  tw_offset, stride, fft_jmp;                                  *
*                                                                            *
*          short x0, x1, x2, x3,x4,x5,x6,x7;                                 *
*          short xt0, yt0, xt1, yt1, xt2, yt2, yt3;                          *
*          short yt4, yt5, yt6, yt7;                                         *
*          short si1,si2,si3,co1,co2,co3;                                    *
*          short xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                        *
*          short x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;        *
*          short xl0_0, xl1_0, xl0_1, xl1_1;                                 *
*          short xh0_0, xh1_0, xh0_1, xh1_1;                                 *
*          short *x,*w;                                                      *
*          int   k0, k1, j0, j1, l0, radix;                                  *
*          short * y0, * ptr_x0, * ptr_x2;                                   *
*                                                                            *
*          radix = n_min;                                                    *
*                                                                            *
*          stride = n; -* n is the number of complex samples *-              *
*          tw_offset = 0;                                                    *
*          while (stride > radix)                                            *
*          {                                                                 *
*              j = 0;                                                        *
*              fft_jmp = stride + (stride>>1);                               *
*              h2 = stride>>1;                                               *
*              l1 = stride;                                                  *
*              l2 = stride + (stride>>1);                                    *
*              x = ptr_x;                                                    *
*              w = ptr_w + tw_offset;                                        *
*                                                                            *
*              for (i = 0; i < n; i += 4)                                    *
*              {                                                             *
*                  co1 = w[j];                                               *
*                  si1 = w[j+1];                                             *
*                  co2 = w[j+2];                                             *
*                  si2 = w[j+3];                                             *
*                  co3 = w[j+4];                                             *
*                  si3 = w[j+5];                                             *
*                                                                            *
*                  x_0    = x[0];                                            *
*                  x_1    = x[1];                                            *
*                  x_h2   = x[h2];                                           *
*                  x_h2p1 = x[h2+1];                                         *
*                  x_l1   = x[l1];                                           *
*                  x_l1p1 = x[l1+1];                                         *
*                  x_l2   = x[l2];                                           *
*                  x_l2p1 = x[l2+1];                                         *
*                                                                            *
*                  xh0  = x_0    + x_l1;                                     *
*                  xh1  = x_1    + x_l1p1;                                   *
*                  xl0  = x_0    - x_l1;                                     *
*                  xl1  = x_1    - x_l1p1;                                   *
*                                                                            *
*                  xh20 = x_h2   + x_l2;                                     *
*                  xh21 = x_h2p1 + x_l2p1;                                   *
*                  xl20 = x_h2   - x_l2;                                     *
*                  xl21 = x_h2p1 - x_l2p1;                                   *
*                                                                            *
*                  ptr_x0 = x;                                               *
*                  ptr_x0[0] = ((short) (xh0 + xh20))>>1; can be changed to  *
*                  ptr_x0[1] = ((short) (xh1 + xh21))>>1; can be changed to  *
*                                                                            *
*                  ptr_x2 = ptr_x0;                                          *
*                  x += 2;                                                   *
*                  j += 6;                                                   *
*                  predj = (j - fft_jmp);                                    *
*                  if (!predj) x += fft_jmp;                                 *
*                  if (!predj) j = 0;                                        *
*                                                                            *
*                  xt0 = xh0 - xh20;                                         *
*                  yt0 = xh1 - xh21;                                         *
*                  xt1 = xl0 + xl21;                                         *
*                  yt2 = xl1 + xl20;                                         *
*                  xt2 = xl0 - xl21;                                         *
*                  yt1 = xl1 - xl20;                                         *
*                                                                            *
*                  ptr_x2[l1  ] = (xt1 * co1 + yt1 * si1 + 0x8000)>>16;      *
*                  ptr_x2[l1+1] = (yt1 * co1 - xt1 * si1 + 0x8000)>>16;      *
*                  ptr_x2[h2  ] = (xt0 * co2 + yt0 * si2 + 0x8000)>>16;      *
*                  ptr_x2[h2+1] = (yt0 * co2 - xt0 * si2 + 0x8000)>>16;      *
*                  ptr_x2[l2  ] = (xt2 * co3 + yt2 * si3 + 0x8000)>>16;      *
*                  ptr_x2[l2+1] = (yt2 * co3 - xt2 * si3 + 0x8000)>>16;      *
*              }                                                             *
*              tw_offset += fft_jmp;                                         *
*              stride = stride>>2;                                           *
*          }-* end while *-                                                  *
*                                                                            *
*          j = offset>>2;                                                    *
*                                                                            *
*          ptr_x0 = ptr_x;                                                   *
*          y0 = ptr_y;                                                       *
*          l0 = _norm(nmax) - 17; -* get size of fft *-                      *
*                                                                            *
*          if (radix <= 4) for (i = 0; i < n; i += 4)                        *
*          {                                                                 *
*                  -* reversal computation *-                                *
*                                                                            *
*                  j0 = (j     ) & 0x3F;                                     *
*                  j1 = (j >> 6) & 0x3F;                                     *
*                  k0 = brev[j0];                                            *
*                  k1 = brev[j1];                                            *
*                  k = (k0 << 6) |  k1;                                      *
*                  k = k >> l0;                                              *
*                  j++;        -* multiple of 4 index *-                     *
*                                                                            *
*                  x0   = ptr_x0[0];  x1 = ptr_x0[1];                        *
*                  x2   = ptr_x0[2];  x3 = ptr_x0[3];                        *
*                  x4   = ptr_x0[4];  x5 = ptr_x0[5];                        *
*                  x6   = ptr_x0[6];  x7 = ptr_x0[7];                        *
*                  ptr_x0 += 8;                                              *
*                                                                            *
*                  xh0_0  = x0 + x4;                                         *
*                  xh1_0  = x1 + x5;                                         *
*                  xh0_1  = x2 + x6;                                         *
*                  xh1_1  = x3 + x7;                                         *
*                                                                            *
*                  if (radix == 2) {                                         *
*                    xh0_0 = x0;                                             *
*                    xh1_0 = x1;                                             *
*                    xh0_1 = x2;                                             *
*                    xh1_1 = x3;                                             *
*                  }                                                         *
*                                                                            *
*                  yt0  = xh0_0 + xh0_1;                                     *
*                  yt1  = xh1_0 + xh1_1;                                     *
*                  yt4  = xh0_0 - xh0_1;                                     *
*                  yt5  = xh1_0 - xh1_1;                                     *
*                                                                            *
*                  xl0_0  = x0 - x4;                                         *
*                  xl1_0  = x1 - x5;                                         *
*                  xl0_1  = x2 - x6;                                         *
*                  xl1_1  = x3 - x7;                                         *
*                                                                            *
*                  if (radix == 2) {                                         *
*                    xl0_0 = x4;                                             *
*                    xl1_0 = x5;                                             *
*                    xl1_1 = x6;                                             *
*                    xl0_1 = x7;                                             *
*                  }                                                         *
*                                                                            *
*                  yt2  = xl0_0 + xl1_1;                                     *
*                  yt3  = xl1_0 - xl0_1;                                     *
*                  yt6  = xl0_0 - xl1_1;                                     *
*                  yt7  = xl1_0 + xl0_1;                                     *
*                                                                            *
*                  if (radix == 2) {                                         *
*                    yt7  = xl1_0 - xl0_1;                                   *
*                    yt3  = xl1_0 + xl0_1;                                   *
*                  }                                                         *
*                                                                            *
*                  y0[k] = yt0; y0[k+1] = yt1;                               *
*                  k += n>>1;                                                *
*                  y0[k] = yt2; y0[k+1] = yt3;                               *
*                  k += n>>1;                                                *
*                  y0[k] = yt4; y0[k+1] = yt5;                               *
*                  k += n>>1;                                                *
*                  y0[k] = yt6; y0[k+1] = yt7;                               *
*          }                                                                 *
*      }                                                                     *
*                                                                            *
*   REFERENCES                                                               *
*   [1] C. S. Burrus and T.W. Parks (1985) "DFT/FFT and Convolution Algos -  *
*       Theory and Implementation", J. Wiley.                                *
*   [2] Implementation of Various Precision Fast Fourier Transforms on the   *
*       TMS320C6400 processor - DJH, ESC 2000                                *
*   [3] Burrus - Rice University and Papamichalis - TI (1988) - Paper on the *
*       convertion of radix4 to radix2 digit reversal.                       *
*                                                                            *
*   SPECIAL NOTES                                                            *
*   1. Complex multiplies are performed using _dotp2 and _dotpn2. _dotpn2    *
*   requires the data to be swizzled about the halfword, so that an extra    *
*   negate can be avoided.                                                   *
*   2. The intermediate adds and subtracts are performed using _add2's,      *
*   _sub2's.                                                                 *
*   3. Data is loaded in using the intrinsic _amemd8 as a double word, and   *
*   the low and high halves are accessed using _lo and _hi intrinsic.        *
*   4. Middle two legs of radix4 butterfly are swapped to get intermediate   *
*   outputs in bit reversed order. Final output in the output array "y" is   *
*   in normal order.                                                         *
*                                                                            *
*  CYCLES                                                                    *
*      Cycle count formula is  for single pass only.                         *
*      ceil(log4(N) - 1) * (5 * N/4 + 25) + 5 * N/4 + 26                     *
*                                                                            *
*      N = 128  cycles = 756  cycles    Single pass                          *
*      N = 128  cycles = 1041 cycles    Multi  pass                          *
*      N = 256  cycles = 1383 cycles    Single pass                          *
*      N = 256  cycles = 1683 cycles    Multi  pass                          *
*      N = 512  cycles = 3337 cycles    Single pass                          *
*      N = 512  cycles = 3699 cycles    Multi  pass                          *
*                                                                            *
*  CODESIZE                                                                  *
*      868 bytes                                                             *
*                                                                            *
*=========================================================================== *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*=========================================================================== *

        .text
        .global _DSP_fft16x16r
_DSP_fft16x16r:
*======================= SYMBOLIC REGISTER ASSIGNMENTS =====================*
        .asg    B15,        B_SP        ;stack pointer
        .asg    A7,         A_SP        ;copy of stack pointer
        .asg    B7,         B_csr       ;copy of CSR
        .asg    B9,         B_csr_no_gie;copy of CSR with interupts disabled
        .asg    B0,         B_wh        ;while predicate for outer loop
        .asg    B0,         B_early     ;while predicate for outer loop
        .asg            A4,         A_n
        .asg            B4,         B_ptr_x
        .asg            A6,         A_ptr_w
        .asg            B6,         B_brev                      ;NC
        .asg            A8,         A_ptr_y
        .asg            B8,         B_radix
        .asg            A10,        A_offset
        .asg            B10,        B_nmax
        .asg            B30,        B_stride
        .asg            A30,        A_tw_offset
        .asg            A16,        A_j
        .asg            B9,         B_j
        .asg            B1,         B_stride_1
        .asg            B17,        B_fft_jmp
        .asg            A18,        A_fft_jmp
        .asg            B13,        B_h2
        .asg            B0,         B_l1
        .asg            B16,        B_l2
        .asg            A20,        A_l1
        .asg            A19,        A_h2
        .asg            A21,        A_l2
        .asg            B7,         B_x
        .asg            A0,         A_w0
        .asg            B11,        B_w0
        .asg            A17,        A_w1
        .asg            B12,        B_w2
        .asg            B1,         B_fft_jmp_1
        .asg            A28,        A_i
        .asg            A5,         A_rnd
        .asg            B31,        B_rnd
        .asg            A0,         A_p0
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            B11,        B_w0
        .asg            A17,        A_w1
        .asg            B12,        B_w2
        .asg            B7,         B_x
        .asg            B13,        B_h2
        .asg            B0,         B_l1
        .asg            B16,        B_l2
        .asg            A0,         A_p0
        .asg            A28,        A_i
        .asg            A16,        A_j
        .asg            B9,         B_j
        .asg            A18,        A_fft_jmp
        .asg            B17,        B_fft_jmp
        .asg            A19,        A_h2
        .asg            A20,        A_l1
        .asg            A21,        A_l2
        .asg            A5,         A_rnd
        .asg            B31,        B_rnd
        .asg            A13,        A_co11_si11
        .asg            A12,        A_co10_si10
        .asg            B27,        B_co21_si21
        .asg            B26,        B_co20_si20
        .asg            B29,        B_co31_si31
        .asg            B28,        B_co30_si30
        .asg            A25,        A_x_3_x_2
        .asg            A24,        A_x_1_x_0
        .asg            A27,        A_xh2_3_xh2_2
        .asg            A26,        A_xh2_1_xh2_0
        .asg            B19,        B_xl1_3_xl1_2
        .asg            B18,        B_xl1_1_xl1_0
        .asg            B21,        B_xl2_3_xl2_2
        .asg            B20,        B_xl2_1_xl2_0
        .asg            B18,        B_xh1_0_xh0_0
        .asg            B24,        B_xh1_1_xh0_1
        .asg            A7,         A_xl1_0_xl0_0
        .asg            A23,        A_xl1_1_xl0_1
        .asg            B19,        B_xh21_0_xh20_0
        .asg            B2,         B_xh21_1_xh20_1
        .asg            A7,         A_xl21_0_xl20_0
        .asg            A9,         A_xl21_1_xl20_1
        .asg            A3,         A_x_
        .asg            A11,        A_x__
        .asg            A1,         A_ifj
        .asg            B22,        B_x_1_x_0
        .asg            B23,        B_x_3_x_2
        .asg            B5,         B_yt0_0_xt0_0
        .asg            B22,        B_yt0_1_xt0_1
        .asg            A23,        A_xl20_0_xl21_0
        .asg            A9,         A_xl20_1_xl21_1
        .asg            A9,         A_yt2_0_xt1_0
        .asg            A23,        A_yt2_1_xt1_1
        .asg            A7,         A_yt1_0_xt2_0
        .asg            A24,        A_yt1_1_xt2_1
        .asg            A27,        A_xt1_0_yt1_0
        .asg            A2,         A_xt1_1_yt1_1
        .asg            A7,         A_xt2_0_yt2_0
        .asg            A9,         A_xt2_1_yt2_1
        .asg            B18,        B_xt0_0_yt0_0
        .asg            B22,        B_xt0_1_yt0_1
        .asg            A26,        A_yt1_0_xt1_0
        .asg            A9,         A_yt1_1_xt1_1
        .asg            A7,         A_yt2_0_xt2_0
        .asg            A29,        A_yt2_1_xt2_1
        .asg            A31,        A_x_h2_0
        .asg            A22,        A_x_h2_1
        .asg            A25,        A_x_h2_2
        .asg            A9,         A_x_h2_3
        .asg            B21,        B_x_l1_0
        .asg            B22,        B_x_l1_1
        .asg            B1,         B_x_l1_2
        .asg            B27,        B_x_l1_3
        .asg            B6,         B_x_l2_0
        .asg            B1,         B_x_l2_1
        .asg            B5,         B_x_l2_2
        .asg            B20,        B_x_l2_3
        .asg            A22,        A_xh2_1_0
        .asg            A23,        A_xh2_3_2
        .asg            B24,        B_xl1_1_0
        .asg            B25,        B_xl1_3_2
        .asg            B24,        B_xl2_1_0
        .asg            B25,        B_xl2_3_2
* =========================== PIPE LOOP PROLOG ============================ *
        B      .S1      LOOP_1                                        ;

        STW    .D2T2    B13,           *--B_SP[8]                     ; [9,0]
||      MVC    .S2      CSR,           B_csr                          ; GIE

        STW    .D2T1    A13,           *+B_SP[1]                      ; [7,0]
||      AND    .L2      B_csr,         -2,              B_csr_no_gie  ; NGIE

        STW    .D2T2    B12,           *+B_SP[2]                      ; [6,0]
||      MV     .L1X     B_SP,          A_SP                           ;
||      MVC    .S2      B_csr_no_gie,  CSR                            ; Dis.int

        STW    .D2T2    B11,           *+B_SP[3]                      ; [7,0]
||      STW    .D1T1    A11,           *+A_SP[4]                      ; [5,0]

        STW    .D2T2    B_csr,         *+B_SP[5]                      ; CSR
||      STW    .D1T1    A12,           *+A_SP[6]                      ; [6,0]
||      ZERO   .L1      A_tw_offset                                   ; [3,0]
||      MV     .L2X     A_n,           B_stride                       ; [3,0]

LOOP_1:
        SHRU    .S2     B_stride,      3,               B_h2            ;[5,0]

LOOP_WHILE:

        MVKL    .S1     08000h,        A_rnd                            ;[7,0]
||      SHRU    .S2     B_stride,      2,               B_l1            ;[6,0]


        MVKLH   .S1     00h,           A_rnd                            ;[8,0]
||      ADDAH   .D1     A_ptr_w,       A_tw_offset,     A_w0            ;[8,0]
||      ADD     .L2     B_l1,          B_h2,            B_l2            ;[7,0]

        ADD     .D1     A_w0,          8,               A_w1            ;[9,0]
||      MV      .L1X    B_l2,          A_l2                             ;[9,0]
||      SHL     .S2     B_stride,      1,               B_stride_1      ;[9,0]

        MV      .L2X    A_rnd,         B_rnd                            ;[10,0]
||      MV      .S1X    B_h2,          A_h2                             ;[10,0]
||      ADD     .D2     B_stride,      B_stride_1,      B_fft_jmp       ;[10,0]
||      MV      .S2     B_ptr_x,       B_x                              ;[13,0]

        SHRU    .S1     A_n,           3,               A_i             ;[11,0]
||      ADD     .L2X    A_w1,          8,               B_w2            ;[11,0]
||      MV      .D1X    B_l1,          A_l1                             ;[11,0]
||      SHRU    .S2     B_fft_jmp,     1,               B_fft_jmp_1     ;[11,0]
||      LDDW    .D2T1   *B_x[B_h2],    A_xh2_3_xh2_2:A_xh2_1_xh2_0      ;[ 1,1]

        CMPEQ   .L1     A_p0,          A_p0,            A_p0            ;[12,0]
||      SUB     .D1     A_i,           2,               A_i             ;[12,0]
||      MV      .L2X    A_w0,          B_w0                             ;[12,0]
||      SHRU    .S1X    B_fft_jmp,     3,               A_fft_jmp       ;[12,0]
||      MPY     .M2     B_j,           0,               B_j             ;
||      LDDW    .D2T2   *B_x[B_l2],    B_xl2_3_xl2_2:B_xl2_1_xl2_0      ;[ 2,1]

        SUB     .L1     A_fft_jmp,     3,               A_fft_jmp       ;[13,0]
||      MPY     .M1     A_j,           0,               A_j             ;[13,0]
||      ADD     .D1X    A_tw_offset,   B_fft_jmp_1,     A_tw_offset     ;[13,0]
||      SHRU    .S2     B_stride,      2,               B_stride        ;[13,0]
||      LDDW    .D2T1   *B_x[0],       A_x_3_x_2:A_x_1_x_0              ;[ 3,1]
||      B       .S1     LOOP_Y5 + 20                                    ;

        LDDW    .D2T2   *B_x[B_l1],    B_xl1_3_xl1_2:B_xl1_1_xl1_0      ;[ 4,1]
||      B       .S1     LOOP_Y6 + 16                                    ;

        B       .S1     LOOP_Y7 + 8                                     ;
||      SUB     .D1     A_fft_jmp,     A_j,             A_ifj           ;[ 4,1]

        ADD     .L1     A_j,           3,               A_j             ;[ 6,1]
||      LDDW    .D1T2   *A_w1[A_j],    B_co21_si21:B_co20_si20          ;[ 6,1]
||      LDDW    .D2T1   *B_w0[B_j],    A_co11_si11:A_co10_si10          ;[6,1]
||      B       .S1     LOOP_Y8 + 8                                     ;

 [!A_ifj]ZERO  .L1      A_j                                             ;[ 7,1]
||      ADD     .S2     B_j,           3,               B_j             ;[ 7,1]
||      SUB2    .D1X    A_xh2_1_xh2_0, B_xl2_1_xl2_0,   A_xl21_0_xl20_0 ;[ 7,1]
||      LDDW    .D2T2   *B_w2[B_j],    B_co31_si31:B_co30_si30          ;[ 7,1]
||      B       .S1     LOOP_Y9 + 8                                     ;

  [!A_ifj]ZERO  .L2     B_j                                             ;[ 8,1]
||[!A_ifj]ADD   .S2     B_x,            B_fft_jmp,       B_x            ;[ 8,1]
||      MVD     .M1X    B_x,            A_x_                            ;[ 8,1]
||      ADD2    .D2X    B_xl2_3_xl2_2,  A_xh2_3_xh2_2,   B_xh21_1_xh20_1;[ 8,1]
||      B       .S1     LOOP_Y                                          ;

* =========================== PIPE LOOP KERNEL ============================ *
LOOP_Y:
        PACKH2 .S2     B_x_l1_1,        B_x_l1_0,        B_xl1_1_0      ;[24,1]
||      ADD    .L2     B_rnd,           B_x_l2_3,        B_x_l2_3       ;[24,1]
||      ADD    .L1     A_rnd,           A_x_h2_3,        A_x_h2_3       ;[24,1]
||      DOTP2  .M2X    B_co30_si30,     A_xt2_0_yt2_0,   B_x_l2_0       ;[14,2]
||      DOTP2  .M1     A_xt1_0_yt1_0,   A_co10_si10,     A_x_h2_0       ;[14,2]
||      PACKLH2.S1     A_yt2_1_xt1_1,   A_yt1_1_xt2_1,   A_xt1_1_yt1_1  ;[14,2]
||      SUB    .D1     A_fft_jmp,       A_j,             A_ifj          ;[ 4,3]
||      LDDW   .D2T2   *B_x[B_l1],      B_xl1_3_xl1_2:B_xl1_1_xl1_0     ;[ 4,3]

        PACKH2 .L2     B_x_l2_3,        B_x_l2_2,        B_xl2_3_2      ;[25,1]
||      PACKH2 .S2     B_x_l2_1,        B_x_l2_0,        B_xl2_1_0      ;[25,1]
||      PACKH2 .S1     A_x_h2_3,        A_x_h2_2,        A_xh2_3_2      ;[25,1]
||      DOTPN2 .M1     A_yt1_0_xt1_0,   A_co10_si10,     A_x_h2_1       ;[15,2]
||      PACKLH2.L1     A_yt1_1_xt2_1,   A_yt2_1_xt1_1,   A_xt2_1_yt2_1  ;[15,2]
||      SUB2   .D2     B_xh1_0_xh0_0,   B_xh21_0_xh20_0, B_yt0_0_xt0_0  ;[15,2]
||      AVG2   .M2     B_xh21_0_xh20_0, B_xh1_0_xh0_0,   B_x_1_x_0      ;[15,2]
||[!A_p0]STDW  .D1T2   B_xl1_3_2:B_xl1_1_0,              *A_x__[A_h2]   ;[25,1]

        ADD    .S1     A_rnd,           A_x_h2_1,        A_x_h2_1       ;[26,1]
||      ADD    .L2     B_rnd,           B_x_l1_2,        B_x_l1_2       ;[16,2]
||      DOTPN2 .M2X    B_co30_si30,     A_yt2_0_xt2_0,   B_x_l2_1       ;[16,2]
||      ROTL   .M1     A_xt1_1_yt1_1,   16,              A_yt1_1_xt1_1  ;[16,2]
||      PACKLH2.S2     B_yt0_0_xt0_0,   B_yt0_0_xt0_0,   B_xt0_0_yt0_0  ;[16,2]
||      ADD    .L1     A_j,             3,               A_j            ;[ 6,3]
||      LDDW   .D1T2   *A_w1[A_j],      B_co21_si21:B_co20_si20         ;[ 6,3]
||      LDDW   .D2T1   *B_w0[B_j],      A_co11_si11:A_co10_si10         ;[ 6,3]

        PACKH2 .L1     A_x_h2_1,        A_x_h2_0,        A_xh2_1_0      ;[27,1]
||      ADD    .L2     B_rnd,           B_x_l1_3,        B_x_l1_3       ;[17,2]
||      DOTP2  .M2X    B_co31_si31,     A_xt2_1_yt2_1,   B_x_l2_2       ;[17,2]
||      ROTL   .M1     A_xt2_1_yt2_1,   16,              A_yt2_1_xt2_1  ;[17,2]
||[!A_ifj]ZERO .S1     A_j                                              ;[ 7,3]
||      ADD    .S2     B_j,             3,               B_j            ;[ 7,3]
||      SUB2   .D1X    A_xh2_1_xh2_0,   B_xl2_1_xl2_0,   A_xl21_0_xl20_0;[ 7,3]
||      LDDW   .D2T2   *B_w2[B_j],      B_co31_si31:B_co30_si30         ;[ 7,3]

        BDEC   .S1     LOOP_Y,          A_i                             ;[28,1]
||      ADD    .L1     A_rnd,           A_x_h2_0,        A_x_h2_0       ;[18,2]
||      DOTP2  .M2     B_xt0_0_yt0_0,   B_co20_si20,     B_x_l1_0       ;[18,2]
||[!A_ifj]ZERO .L2     B_j                                              ;[ 8,3]
||[!A_ifj]ADD  .S2     B_x,             B_fft_jmp,       B_x            ;[ 8,3]
||      MVD    .M1X    B_x,             A_x_                            ;[ 8,3]
||      ADD2   .D2X    B_xl2_3_xl2_2,   A_xh2_3_xh2_2,   B_xh21_1_xh20_1;[ 8,3]
||[!A_p0]STDW  .D1T1   A_xh2_3_2:A_xh2_1_0,              *A_x__[A_l1]   ;[28,1]

LOOP_Y5:
  [!A_p0]STDW   .D1T2   B_xl2_3_2:B_xl2_1_0,             *A_x__[A_l2]   ;[29,1]
||      PACKH2  .L2     B_x_l1_3,       B_x_l1_2,        B_xl1_3_2      ;[19,2]
||      ADD     .S2     B_rnd,          B_x_l2_0,        B_x_l2_0       ;[19,2]
||      DOTPN2  .M2     B_yt0_0_xt0_0,  B_co20_si20,     B_x_l1_1       ;[19,2]
||      DOTP2   .M1     A_xt1_1_yt1_1,  A_co11_si11,     A_x_h2_2       ;[19,2]
||      PACKLH2 .S1     A_xl21_0_xl20_0,A_xl21_0_xl20_0, A_xl20_0_xl21_0;[ 9,3]
||      SUB2    .L1X    A_x_1_x_0,      B_xl1_1_xl1_0,   A_xl1_0_xl0_0  ;[ 9,3]
||      ADD2    .D2X    B_xl1_3_xl1_2,  A_x_3_x_2,       B_xh1_1_xh0_1  ;[ 9,3]

LOOP_Y6:
        ADD     .D2     B_rnd,          B_x_l2_1,        B_x_l2_1       ;[20,2]
||      DOTPN2  .M2X    B_co31_si31,    A_yt2_1_xt2_1,   B_x_l2_3       ;[20,2]
||      DOTPN2  .M1     A_yt1_1_xt1_1,  A_co11_si11,     A_x_h2_3       ;[20,2]
||      STDW    .D1T2   B_x_3_x_2:B_x_1_x_0,             *A_x_[0]       ;[20,2]
||      SUB2    .S1     A_xl1_0_xl0_0,  A_xl20_0_xl21_0, A_yt1_0_xt2_0  ;[10,3]
||      ADD2    .L1     A_xl1_0_xl0_0,  A_xl20_0_xl21_0, A_yt2_0_xt1_0  ;[10,3]
||      SUB2    .S2     B_xh1_1_xh0_1,  B_xh21_1_xh20_1, B_yt0_1_xt0_1  ;[10,3]
||      ADD     .L2     B_x,            8,               B_x            ;[10,3]

LOOP_Y7:
        ADD     .L2     B_rnd,          B_x_l2_2,        B_x_l2_2       ;[21,2]
||      MVD     .M1     A_x_,           A_x__                           ;[21,2]
||      DOTPN2  .M2     B_yt0_1_xt0_1,  B_co21_si21,     B_x_l1_3       ;[11,3]
||      PACKLH2 .S2     B_yt0_1_xt0_1,  B_yt0_1_xt0_1,   B_xt0_1_yt0_1  ;[11,3]
||      PACKLH2 .L1     A_yt1_0_xt2_0,  A_yt2_0_xt1_0,   A_xt2_0_yt2_0  ;[11,3]
||      PACKLH2 .S1     A_yt2_0_xt1_0,  A_yt1_0_xt2_0,   A_xt1_0_yt1_0  ;[11,3]
||      SUB2    .D1X    A_xh2_3_xh2_2,  B_xl2_3_xl2_2,   A_xl21_1_xl20_1;[11,3]
||      LDDW    .D2T1   *B_x[B_h2],     A_xh2_3_xh2_2:A_xh2_1_xh2_0     ;[ 1,4]

LOOP_Y8:
        ZERO    .L1     A_p0                                            ;
||      ADD     .L2     B_rnd,          B_x_l1_0,        B_x_l1_0       ;[22,2]
||      DOTP2   .M2     B_xt0_1_yt0_1,  B_co21_si21,     B_x_l1_2       ;[12,3]
||      ROTL    .M1     A_xt1_0_yt1_0,  16,              A_yt1_0_xt1_0  ;[12,3]
||      PACKLH2 .S1     A_xl21_1_xl20_1,A_xl21_1_xl20_1, A_xl20_1_xl21_1;[12,3]
||      SUB2    .D1X    A_x_3_x_2,      B_xl1_3_xl1_2,   A_xl1_1_xl0_1  ;[12,3]
||      ADD2    .S2X    B_xl1_1_xl1_0,  A_x_1_x_0,       B_xh1_0_xh0_0  ;[12,3]
||      LDDW    .D2T2   *B_x[B_l2],     B_xl2_3_xl2_2:B_xl2_1_xl2_0     ;[ 2,4]

LOOP_Y9:
        ADD     .S2     B_rnd,          B_x_l1_1,        B_x_l1_1       ;[23,2]
||      ADD     .S1     A_rnd,          A_x_h2_2,        A_x_h2_2       ;[23,2]
||      ROTL    .M1     A_xt2_0_yt2_0,  16,              A_yt2_0_xt2_0  ;[13,3]
||      SUB2    .L1     A_xl1_1_xl0_1,  A_xl20_1_xl21_1, A_yt1_1_xt2_1  ;[13,3]
||      ADD2    .D1     A_xl1_1_xl0_1,  A_xl20_1_xl21_1, A_yt2_1_xt1_1  ;[13,3]
||      AVG2    .M2     B_xh21_1_xh20_1,B_xh1_1_xh0_1,   B_x_3_x_2      ;[13,3]
||      ADD2    .L2X    B_xl2_1_xl2_0,  A_xh2_1_xh2_0,   B_xh21_0_xh20_0;[13,3]
||      LDDW    .D2T1   *B_x[0],        A_x_3_x_2:A_x_1_x_0             ;[ 3,4]

* =========================== PIPE LOOP EPILOG ============================ *

        PACKH2  .S2     B_x_l1_1,       B_x_l1_0,        B_xl1_1_0      ;[24,4]
||      ADD     .D2     B_rnd,          B_x_l2_3,        B_x_l2_3       ;[24,4]
||      ADD     .L1     A_rnd,          A_x_h2_3,        A_x_h2_3       ;[24,4]
||      CMPGTU  .L2     B_stride,       B_radix,         B_wh           ;

        PACKH2  .L2     B_x_l2_3,       B_x_l2_2,        B_xl2_3_2      ;[25,4]
||      PACKH2  .S2     B_x_l2_1,       B_x_l2_0,        B_xl2_1_0      ;[25,4]
||[!A_p0]STDW   .D1T2   B_xl1_3_2:B_xl1_1_0,             *A_x__[A_h2]   ;[25,4]
||      PACKH2  .L1     A_x_h2_3,       A_x_h2_2,        A_xh2_3_2      ;[25,4]
||[B_wh]B       .S1     LOOP_WHILE                                      ;

        ADD     .S1     A_rnd,          A_x_h2_1,        A_x_h2_1       ;[26,4]
||[B_wh]SHRU    .S2     B_stride,       3,               B_h2           ;[5,0]

        PACKH2  .L1     A_x_h2_1,       A_x_h2_0,        A_xh2_1_0      ;[27,4]

  [!A_p0]STDW   .D1T1   A_xh2_3_2:A_xh2_1_0,             *A_x__[A_l1]   ;[28,4]

  [!A_p0]STDW   .D1T2   B_xl2_3_2:B_xl2_1_0,             *A_x__[A_l2]   ;[29,4]

        CMPGTU  .L2     B_radix,        4,               B_early        ;
        ;BRANCH OCCURS

 [B_early]B     .S1     EARLY_EXIT                                      ;

        ;BRANCH OCCURS
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_n
        .asg            B8,         B_radix
        .asg            B4,         B_ptr_x
        .asg            B10,        B_nmax
        .asg            A8,         A_ptr_y
        .asg            A10,        A_offset
        .asg            A0,         A_r2
        .asg            A3,         A_zero
        .asg            B18,        B_zero
        .asg            A9,         A_x0
        .asg            B20,        B_x0
        .asg            B19,        B_l1
        .asg            A7,         A_i
        .asg            B21,        B_j
        .asg            B0,         B_p0
        .asg            B17,        B_y0
        .asg            B16,        B_y1
        .asg            B9,         B_y2
        .asg            B5,         B_y3
* ========================================================================= *
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            B21,        B_j
        .asg            B19,        B_l1
        .asg            A9,         A_x0
        .asg            B20,        B_x0
        .asg            A0,         A_r2
        .asg            A3,         A_zero
        .asg            B18,        B_zero
        .asg            A7,         A_i
        .asg            B17,        B_y0
        .asg            B16,        B_y1
        .asg            B9,         B_y2
        .asg            B5,         B_y3
        .asg            B0,         B_p0
        .asg            B23,        B_h3
        .asg            B25,        B_h4
        .asg            A5,         A_x3x2
        .asg            A4,         A_x1x0
        .asg            B7,         B_x7x6
        .asg            B6,         B_x5x4
        .asg            A16,        A_x7x6
        .asg            A6,         A_xl1_0_xl0_0
        .asg            A18,        A_xl1_1_xl0_1
        .asg            A17,        A_xl0_1_xl1_1
        .asg            A18,        A_mx7mx6
        .asg            A18,        A_yt7_yt2
        .asg            A17,        A_yt3_yt6
        .asg            A4,         A_y3y2
        .asg            A17,        A_y7y6
        .asg            B6,         B_xh1_0_xh0_0
        .asg            B7,         B_xh1_1_xh0_1
        .asg            B24,        B_y1y0
        .asg            B22,        B_y5y4
* =========================== PIPE LOOP PROLOG ============================ *
        MV      .D2X    A_ptr_y,        B_y0                            ;[ 3,0]

        ADD     .S2     B_y0,           B_nmax,         B_y1            ;[ 4,0]
||      CMPEQ   .L2     B_p0,           B_p0,           B_p0            ;[ 4,0]

        ADD     .D2     B_y1,           B_nmax,         B_y2            ;[ 5,0]

        ADD     .D2     B_y2,           B_nmax,         B_y3            ;[ 6,0]
||      SHRU    .S2X    A_offset,       2,              B_j             ;[ 6,0]
||      SHRU    .S1     A_n,            2,              A_i             ;[ 6,0]
||      MV      .D1X    B_ptr_x,        A_x0                            ;[ 6,0]
||      NORM    .L2     B_nmax,         B_l1                            ;[ 6,0]

        SUB     .D1     A_i,            1,              A_i             ;[ 7,0]
||      ADD     .D2     B_l1,           4,              B_l1            ;[ 7,0]
||      ADD     .S2     B_ptr_x,        8,              B_x0            ;[ 7,0]
||      ZERO    .L2     B_zero                                          ;[ 7,0]
||      ZERO    .L1     A_zero                                          ;[ 7,0]

        LDDW    .D1T1   *A_x0++[2],     A_x3x2:A_x1x0                   ;[ 1,1]
||      LDDW    .D2T2   *B_x0++[2],     B_x7x6:B_x5x4                   ;[ 1,1]

        SUB             B_j,            1,              B_j

        SUB     .S1X    B_radix,        2,              A_r2            ;[ 7,0]

  [!A_r2]MPY2   .M2     B_zero,         B_zero,         B_x7x6:B_x5x4   ;[ 4,1]

        BDEC    .S1     LOOP_Z,         A_i                             ;[10,1]

* =========================== PIPE LOOP KERNEL ============================ *
LOOP_Z:
        ADD     .L2     B_j,            1,              B_j             ;[11,1]
||      SHRU    .S2     B_h3,           B_l1,           B_h4            ;[11,1]
||[!A_r2]PACKHL2.L1     A_mx7mx6,       A_x7x6,         A_xl0_1_xl1_1   ;[11,1]
||      ROTL    .M1X    B_x7x6,         0,              A_x7x6          ;[ 6,2]
||      LDDW    .D1T1   *A_x0++[2],     A_x3x2:A_x1x0                   ;[ 1,3]
||      LDDW    .D2T2   *B_x0++[2],     B_x7x6:B_x5x4                   ;[ 1,3]

  [!B_p0]STW    .D2T2   B_y5y4,         *B_y2[B_h4]                     ;[12,1]
||      ADD2    .L1     A_xl1_0_xl0_0,  A_xl0_1_xl1_1,  A_yt7_yt2       ;[12,1]
||      SUB2    .D1     A_xl1_0_xl0_0,  A_xl0_1_xl1_1,  A_yt3_yt6       ;[12,1]
||      BITR    .M2     B_j,            B_h3                            ;[ 7,2]
||      SUB2    .S1X    A_x1x0,         B_x5x4,         A_xl1_0_xl0_0   ;[ 7,2]
||[!A_r2]ROTL   .M1X    B_x5x4,         0,              A_xl1_0_xl0_0   ;[ 7,2]

  [!B_p0]STW    .D2T2   B_y1y0,         *B_y0[B_h4]                     ;[13,1]
||      PACKHL2 .L1     A_yt3_yt6,      A_yt7_yt2,      A_y3y2          ;[13,1]
||      PACKHL2 .S1     A_yt7_yt2,      A_yt3_yt6,      A_y7y6          ;[13,1]
||      ADD2    .S2X    B_x5x4,         A_x1x0,         B_xh1_0_xh0_0   ;[ 8,2]
||      SUB2    .D1     A_x3x2,         A_x7x6,         A_xl1_1_xl0_1   ;[ 8,2]

  [!B_p0]STW    .D2T1   A_y7y6,         *B_y3[B_h4]                     ;[14,1]
||      ADD2    .L2X    B_x7x6,         A_x3x2,         B_xh1_1_xh0_1   ;[ 9,2]
||      ROTL    .M1     A_xl1_1_xl0_1,  16,             A_xl0_1_xl1_1   ;[ 9,2]
||[!A_r2]MPY2   .M2     B_zero,         B_zero,         B_x7x6:B_x5x4   ;[ 4,3]

        MPYSU   .M2     0,              B_p0,           B_p0            ;[15,1]
||[!B_p0]STW    .D2T1   A_y3y2,         *B_y1[B_h4]                     ;[15,1]
||      SUB2    .D1     A_zero,         A_x7x6,         A_mx7mx6        ;[10,2]
||      ADD2    .L2     B_xh1_0_xh0_0,  B_xh1_1_xh0_1,  B_y1y0          ;[10,2]
||      SUB2    .S2     B_xh1_0_xh0_0,  B_xh1_1_xh0_1,  B_y5y4          ;[10,2]
||      BDEC    .S1     LOOP_Z,         A_i                             ;[10,2]

* =========================== PIPE LOOP EPILOG ============================ *

EARLY_EXIT:

        MV     .L1X     B_SP,           A_SP                            ;
||      LDW    .D2T2    *+B_SP[2],      B12                             ;[ 6,0]

        LDW    .D2T2    *+B_SP[0],      B13                             ;[ 9,0]
||      LDW    .D1T1    *+A_SP[1],      A13                             ;[ 7,0]

        LDW    .D2T2    *+B_SP[5],      B_csr                           ; CSR
||      LDW    .D1T1    *+A_SP[6],      A12                             ;[ 6,0]
||      B      .S2      B3                                              ;

        LDW    .D2T2    *+B_SP[3],      B11                             ;[ 7,0]
||      LDW    .D1T1    *+A_SP[4],      A11                             ;[ 5,0]

        NOP             2                                               ;
        ADDAW  .D2      B_SP,           8,          B_SP                ;

        MVC    .S2      B_csr,          CSR                             ;GIE

        ;BRANCH OCCURS HERE

*===========================================================================*
* End of DSP_fft16x16r assembly code                                        *
*===========================================================================*
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*===========================================================================*
fft16x16t.asm/  1061588609  0     0     0       55483     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.5     Tue Nov  6 20:14:27 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*      fft: Mixed radix FFT for 2^M and 4^M, 16x16 with truncation          *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       09-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*     void DSP_fft16x16t(const short * ptr_w, int  npoints, short * ptr_x,  *
*                    short * ptr_y)                                         *
*                                                                           *
*   where:                                                                  *
*   ptr_w: pointer to an array of twiddle factors generated as explained    *
*   below.                                                                  *
*   npoints: Number of points for the FFT transform, can be a multiple of   *
*   2 or 4.                                                                 *
*   ptr_x: Pointer to input data to be transformed.                         *
*   ptr_y: Pointer that contains the final FFT results in normal order.     *
*                                                                           *
*   DESCRIPTION                                                             *
*       This code performs a mixed radix FFT with digit reversal. The code  *
*       uses a special ordering of twiddle factors and memory accesses      *
*       to improve performance in the presence of cache.  It operates       *
*       largely in-place, but the final digit-reversed output is written    *
*       out-of-place.                                                       *
*                                                                           *
*       This code requires a special sequence of twiddle factors stored     *
*       in Q.15 fixed-point format.  The following C code illustrates       *
*       one way to generate the desired twiddle-factor array:               *
*                                                                           *
*       #include <math.h>                                                   *
*                                                                           *
*       #ifndef PI                                                          *
*       # define PI (3.14159265358979323846)                                *
*       #endif                                                              *
*                                                                           *
*       short d2s(double d)                                                 *
*       {                                                                   *
*           d = floor(0.5 + d);  /* Explicit rounding to integer */         *
*           if (d >=  32767.0) return  32767;                               *
*           if (d <= -32768.0) return -32768;                               *
*           return (short)d;                                                *
*       }                                                                   *
*                                                                           *
*       void gen_twiddle(short *w, int n)                                   *
*       {                                                                   *
*           double M = 32767.5;                                             *
*           int i, j, k;                                                    *
*                                                                           *
*           for (j = 1, k = 0; j < n >> 2; j = j << 2)                      *
*           {                                                               *
*               for (i = 0; i < n >> 2; i += j << 1)                        *
*               {                                                           *
*                   w[k + 11] = d2s(M * cos(6.0 * PI * (i + j) / n));       *
*                   w[k + 10] = d2s(M * sin(6.0 * PI * (i + j) / n));       *
*                   w[k +  9] = d2s(M * cos(6.0 * PI * (i    ) / n));       *
*                   w[k +  8] = d2s(M * sin(6.0 * PI * (i    ) / n));       *
*                                                                           *
*                   w[k +  7] = d2s(M * cos(4.0 * PI * (i + j) / n));       *
*                   w[k +  6] = d2s(M * sin(4.0 * PI * (i + j) / n));       *
*                   w[k +  5] = d2s(M * cos(4.0 * PI * (i    ) / n));       *
*                   w[k +  4] = d2s(M * sin(4.0 * PI * (i    ) / n));       *
*                                                                           *
*                   w[k +  3] = d2s(M * cos(2.0 * PI * (i + j) / n));       *
*                   w[k +  2] = d2s(M * sin(2.0 * PI * (i + j) / n));       *
*                   w[k +  1] = d2s(M * cos(2.0 * PI * (i    ) / n));       *
*                   w[k +  0] = d2s(M * sin(2.0 * PI * (i    ) / n));       *
*                                                                           *
*                   k += 12;                                                *
*               }                                                           *
*           }                                                               *
*           w[2*n - 1] = w[2*n - 3] = w[2*n - 5] = 32767;                   *
*           w[2*n - 2] = w[2*n - 4] = w[2*n - 6] = 0;                       *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The size of the FFT, n, must be a power of 4 or 2 and greater than  *
*       or equal to 16 and less than 32768.                                 *
*                                                                           *
*       The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         *
*       double-word boundary for the "optimized" implementations.           *
*                                                                           *
*       The input and output data are complex, with the real/imaginary      *
*       components stored in adjacent locations in the array.  The real     *
*       components are stored at even array indices, and the imaginary      *
*       components are stored at odd array indices.                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in nor-    *
*       mal order and produces the outputs in normal order.                 *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*-------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*-------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*-------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order. In addition if the number  *
*       of points to be transformed is a power of 2, the final stage        *
*       applies a radix2 pass instead of a radix 4. In any case the         *
*       outputs are returned in normal order.                               *
*                                                                           *
*       The fft() code shown here performs the bulk of the computation      *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part os the         *
*       complex multiply is implemented using _dotp2. The imaginary         *
*       part of the complex multiply is implemented using _dotpn2           *
*       after the twiddle factors are swizzled within the half word.        *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The optimized implementations are written for LITTLE ENDIAN.        *
*       N/8 bank conflicts occur                                            *
*                                                                           *
*   SPECIAL TECHNIQUES                                                      *
*       a) The _norm operator is used in determining the size of the        *
*       fft and also in dtermining whether a radix4 or radix2 stage         *
*       for the last pass of the transform.                                 *
*       b) The _dotp2 and _dotpn2 instructions are used for implementing    *
*       the complex multiplies. The subtract operator is not commutative.   *
*       Hence the use of the _dotpn2 instruction enforces a certain ord-    *
*       ering. This causes the data to be swizzled about the halfword,      *
*       using either a packlh or a rotate.                                  *
*       c) Individual stores to memory are accumulated and performed        *
*       as double word wide accesses as are loads from memory for data      *
*       which serves as the main inspiration for all the optimizations      *
*       performed on the FFT.                                               *
*       d) The digit reversal is performed through the combination of       *
*       deal, shfl, bitr, rotl. This helps to obtain a digit reversed       *
*       index from the normal index.                                        *
*                                                                           *
*   INTERRUPTS                                                              *
*       This code is interrupt tolerant but not interruptible. It masks out *
*       interrupts for the entire duration of the code.                     *
*                                                                           *
*   CYCLES                                                                  *
*       (10 * N/8 + 19) * ceil(log4(N) - 1) + (N/8 + 2) * 7  + 28 + BC      *
*       BC = N/8 bank conflicts                                             *
*                                                                           *
*       N=256, cycles = (320 + 19) * 3 + 34 * 7 + 28 + 32 = 1321            *
*       N=512, cycles = (640 + 19) * 4 + 66 * 7 + 28 + 64 = 3190            *
*                                                                           *
*   CODESIZE                                                                *
*       1004 bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

*============================================================================*
        .text
        .global _DSP_fft16x16t
_DSP_fft16x16t: 
*================ SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            A0,         A_csr       ; CSR value to restore
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            B3,         B_ret       ; Return address
*======================= SYMBOLIC REGISTER ASSIGNMENTS ======================*
        .asg            A4,         A_ptr_w
        .asg            B4,         B_n
        .asg            A6,         A_ptr_x
        .asg            B6,         B_ptr_y
        .asg            A30,        A_radix
        .asg            B0,         B_radix2
        .asg            B31,        B_stride
        .asg            A31,        A_tw_offset
        .asg            B0,         B_stride_1
        .asg            A0,         A_w0
        .asg            B2,         B_fft_jmp_1
        .asg            B1,         B_w0
        .asg            A19,        A_w1
        .asg            B0,         B_w2
        .asg            B9,         B_x
        .asg            B17,        B_h2
        .asg            B16,        B_l1
        .asg            B30,        B_l2
        .asg            A1,         A_p0
        .asg            A16,        A_i
        .asg            A18,        A_j
        .asg            B2,         B_j
        .asg            A20,        A_fft_jmp
        .asg            B8,         B_fft_jmp
        .asg            A21,        A_h2
        .asg            A22,        A_l1
        .asg            A23,        A_l2
        .asg            A29,        A_co11_si11
        .asg            A28,        A_co10_si10
        .asg            B29,        B_co21_si21
        .asg            B28,        B_co20_si20
        .asg            B25,        B_co31_si31
        .asg            B24,        B_co30_si30
        .asg            A27,        A_x_3_x_2
        .asg            A26,        A_x_1_x_0
        .asg            A25,        A_xh2_3_xh2_2
        .asg            A24,        A_xh2_1_xh2_0
        .asg            B27,        B_xl1_3_xl1_2
        .asg            B26,        B_xl1_1_xl1_0
        .asg            B21,        B_xl2_3_xl2_2
        .asg            B20,        B_xl2_1_xl2_0
        .asg            B5,         B_xh1_0_xh0_0
        .asg            B19,        B_xh1_1_xh0_1
        .asg            A5,         A_xl1_0_xl0_0
        .asg            A7,         A_xl1_1_xl0_1
        .asg            B10,        B_xh21_0_xh20_0
        .asg            B21,        B_xh21_1_xh20_1
        .asg            A3,         A_xl21_0_xl20_0
        .asg            A9,         A_xl21_1_xl20_1
        .asg            A17,        A_x_
        .asg            A2,         A_x__
        .asg            A0,         A_ifj
        .asg            B22,        B_x_1_x_0
        .asg            B23,        B_x_3_x_2
        .asg            B29,        B_yt0_0_xt0_0
        .asg            B27,        B_yt0_1_xt0_1
        .asg            A10,        A_xl20_0_xl21_0
        .asg            A9,         A_xl20_1_xl21_1
        .asg            A5,         A_yt2_0_xt1_0
        .asg            A7,         A_yt2_1_xt1_1
        .asg            A3,         A_yt1_0_xt2_0
        .asg            A9,         A_yt1_1_xt2_1
        .asg            A5,         A_xt1_0_yt1_0
        .asg            A27,        A_xt1_1_yt1_1
        .asg            A8,         A_xt2_0_yt2_0
        .asg            A3,         A_xt2_1_yt2_1
        .asg            B18,        B_xt0_0_yt0_0
        .asg            B5,         B_xt0_1_yt0_1
        .asg            A5,         A_yt1_0_xt1_0
        .asg            A7,         A_yt1_1_xt1_1
        .asg            A2,         A_yt2_0_xt2_0
        .asg            A3,         A_yt2_1_xt2_1
        .asg            A25,        A_x_h2_0
        .asg            A9,         A_x_h2_1
        .asg            A24,        A_x_h2_2
        .asg            A2,         A_x_h2_3
        .asg            B20,        B_x_l1_0
        .asg            B18,        B_x_l1_1
        .asg            B5,         B_x_l1_2
        .asg            B7,         B_x_l1_3
        .asg            B7,         B_x_l2_0
        .asg            B27,        B_x_l2_1
        .asg            B22,        B_x_l2_2
        .asg            B26,        B_x_l2_3
        .asg            A26,        A_xh2_1_0
        .asg            A27,        A_xh2_3_2
        .asg            B18,        B_xl1_1_0
        .asg            B19,        B_xl1_3_2
        .asg            B18,        B_xl2_1_0
        .asg            B19,        B_xl2_3_2
        .asg            A0,         A_whl
*============================= PIPE LOOP PROLOG =============================*
        B       .S1     LOOP_WHILE                              ;

        MVC     .S2     CSR,        B_csr                       ; Capture CSR

        AND     .L2     B_csr,      -2,         B_no_gie        ; Clear GIE
||      STW     .D2T1   A10,        *-B_SP[ 1]                  ; Save A10

        NORM    .L2     B_n,        B_radix2                    ;[ 2,0]
||      STW     .D2T2   B10,        *-B_SP[ 2]                  ;Save B10
||      MVC     .S2     B_no_gie,   CSR                         ;Dis int.

        ;Interrupts masked

        AND     .L2     B_radix2,   1,          B_radix2        ;norm(n)&1
||      MVK     .D1     4,          A_radix                     ;radix = 4?
||      STW     .D2T2   B11,        *-B_SP[ 4]                  ; Save B11

  [ B_radix2]MVK.D1     2,          A_radix                     ;radix = 2
||      ZERO    .L1     A_tw_offset                             ;tw_offset = 0
||      MV      .S2     B_n,        B_stride                    ;stride=n
||      STW     .D2T2   B_csr,      *-B_SP[ 3]                  ; Save CSR

LOOP_WHILE:

        SHRU    .S2     B_stride,   3,          B_h2            ;[ 6,0]
||      MV      .L2X    A_ptr_x,    B_x                         ;x = ptr_x

        ADDAH   .D2     B_h2,       B_h2,       B_l2            ;[ 8,0]
||      SHRU    .S1X    B_n,        3,          A_i             ;[ 9,0] n>>3

LOOP_WHILE_N:

        ADDAH   .D1     A_ptr_w,    A_tw_offset,A_w0            ;ptr_w+twoffst
||      SHRU    .S2     B_stride,   2,          B_l1            ;[ 7,0]

        ADD     .L1     A_w0,       8,          A_w1            ;[10,0]
||      MV      .D1X    B_l2,       A_l2                        ;[10,0]
||      SHL     .S2     B_stride,   1,          B_stride_1      ;[10,0]
||      LDDW    .D2T2   *B_x[B_l2], B_xl2_3_xl2_2:B_xl2_1_xl2_0 ;[ 1,1]
||      B       .S1     LOOP_Y5 + 20                            ;

        MV      .L1X    B_h2,       A_h2                        ;[11,0]
||      ADD     .L2     B_stride,   B_stride_1, B_fft_jmp       ;1.5*stride
||      SHRU    .S2     B_stride,   2,          B_stride        ;stride/=2
||      LDDW    .D2T1   *B_x[B_h2], A_xh2_3_xh2_2:A_xh2_1_xh2_0 ;[ 2,1]
||      B       .S1     LOOP_Y6 + 24                            ;

        MVK     .L1     1,          A_p0                        ;[13,0]
||      ADD     .L2X    A_w1,       8,          B_w2            ;[12,0]
||      MV      .D1X    B_l1,       A_l1                        ;[12,0]
||      SHRU    .S2     B_fft_jmp,  1,          B_fft_jmp_1     ;[12,0]
||      LDDW    .D2T2   *B_x[B_l1], B_xl1_3_xl1_2:B_xl1_1_xl1_0 ;[ 3,1]
||      B       .S1     LOOP_Y7 + 8                             ;

        SUB     .L1     A_i,        2,          A_i             ;[13,0]
||      MV      .L2X    A_w0,       B_w0                        ;[13,0]
||      SHRU    .S1X    B_fft_jmp,  3,          A_fft_jmp       ;[13,0]
||      LDDW    .D2T1   *B_x[0],    A_x_3_x_2:A_x_1_x_0         ;[ 4,1]
||      B       .S2     LOOP_Y8 + 12                            ;

        SUB     .L1     A_fft_jmp,  3,          A_fft_jmp       ;[14,0]
||      MPYSU   .M2     0,          B_j,        B_j             ;[14,0] j = 0
||      MPYSU   .M1     0,          A_j,        A_j             ;[14,0] j = 0
||      ADD     .S1X    A_tw_offset,B_fft_jmp_1,A_tw_offset     ;fft_jmp
||      LDDW    .D1T2   *A_w1[0],   B_co21_si21:B_co20_si20     ;[ 5,1]
||      B       .S2     LOOP_Y9 + 16                            ;

        B       .S2     LOOP_Y                                  ;
; ============================ PIPE LOOP KERNEL ==============================
LOOP_Y:
        ADD     .L2     B_x_l1_1,   B_x_l1_1,   B_x_l1_1        ;[22,1] >>15
||      DOTPN2  .M2X    B_co31_si31,A_yt2_1_xt2_1, B_x_l2_3     ;[22,1]
||      MVD     .M1     A_x_,       A_x__                       ;[22,1]
||      PACKLH2 .S1     A_yt2_1_xt1_1,A_yt1_1_xt2_1,A_xt1_1_yt1_1  ;[12,2] |
||      SUB2    .L1     A_xl1_0_xl0_0,A_xl20_0_xl21_0,A_yt1_0_xt2_0;[12,2]
||      ADD2    .D1     A_xl1_0_xl0_0,A_xl20_0_xl21_0,A_yt2_0_xt1_0;[12,2]
||      ADD2    .S2     B_xh21_1_xh20_1,B_xh1_1_xh0_1,B_x_3_x_2 ;[12,2]
||      LDDW    .D2T1   *B_x[B_h2], A_xh2_3_xh2_2:A_xh2_1_xh2_0 ;[ 2,3]

        PACKH2  .L2     B_x_l1_3,   B_x_l1_2,   B_xl1_3_2       ;[23,1]
||      ADD     .S2     B_x_l1_0,   B_x_l1_0,   B_x_l1_0        ;[23,1] >>15
||      ADD     .D1     A_x_h2_0,   A_x_h2_0,   A_x_h2_0        ;[23,1] >>15
||      ROTL    .M1     A_xt1_1_yt1_1,16,       A_yt1_1_xt1_1   ;[13,2] |
||      ROTL    .M2     B_yt0_1_xt0_1,16,       B_xt0_1_yt0_1   ;[13,2]
||      PACKLH2 .S1     A_yt1_0_xt2_0,A_yt2_0_xt1_0,A_xt2_0_yt2_0;[13,2] |
||      PACKLH2 .L1     A_yt2_0_xt1_0,A_yt1_0_xt2_0,A_xt1_0_yt1_0;[13,2] \
||      LDDW    .D2T2   *B_x[B_l1], B_xl1_3_xl1_2:B_xl1_1_xl1_0 ;[ 3,3]

        ADD     .L2     B_x_l2_0,   B_x_l2_0,   B_x_l2_0        ;[24,1] >>15
||      ADD     .L1     A_x_h2_3,   A_x_h2_3,   A_x_h2_3        ;[24,1] >>15
||      DOTPN2  .M2     B_yt0_1_xt0_1,B_co21_si21, B_x_l1_3     ;[14,2]
||      DOTP2   .M1     A_xt1_0_yt1_0,A_co10_si10, A_x_h2_0     ;[14,2]
||      PACKLH2 .S1     A_yt1_1_xt2_1,A_yt2_1_xt1_1,A_xt2_1_yt2_1;[14,2]
||[!A_ifj]ZERO  .D1     A_j                                     ;[14,2]
||      ADD     .S2     B_j,        3,          B_j             ;[14,2]
||      LDDW    .D2T1   *B_x[0],    A_x_3_x_2:A_x_1_x_0         ;[ 4,3]

        PACKH2  .L2     B_x_l1_1,   B_x_l1_0,   B_xl1_1_0       ;[25,1]
||      PACKH2  .L1     A_x_h2_3,   A_x_h2_2,   A_xh2_3_2       ;[25,1]
||      ADD     .S2     B_x_l2_1,   B_x_l2_1,   B_x_l2_1        ;[25,1] >>15
||      ADD     .S1     A_x_h2_1,   A_x_h2_1,   A_x_h2_1        ;[25,1] >>15
||      DOTP2   .M2     B_xt0_1_yt0_1,B_co21_si21,B_x_l1_2      ;[15,2]
||      DOTP2   .M1     A_xt1_1_yt1_1,A_co11_si11,A_x_h2_2      ;[15,2]
||      ADD2    .D2X    B_xl1_1_xl1_0,A_x_1_x_0,B_xh1_0_xh0_0   ;[15,2]
||      LDDW    .D1T2   *A_w1[A_j], B_co21_si21:B_co20_si20     ;[ 5,3]

        BDEC    .S1     LOOP_Y,     A_i                         ;[26,1]
||      PACKH2  .L2     B_x_l2_1,   B_x_l2_0,   B_xl2_1_0       ;[26,1]
||[!A_p0]STDW   .D1T2   B_xl1_3_2:B_xl1_1_0,    *A_x__[A_l1]    ;[26,1]
||      PACKH2  .L1     A_x_h2_1,   A_x_h2_0,   A_xh2_1_0       ;[26,1]
||      ADD     .D2     B_x_l2_3,   B_x_l2_3,   B_x_l2_3        ;[26,1] >>15
||      DOTP2   .M2X    B_co31_si31,A_xt2_1_yt2_1,B_x_l2_2      ;[16,2]
||      ROTL    .M1     A_xt1_0_yt1_0,16,A_yt1_0_xt1_0          ;[16,2]
||      SUB2    .S2     B_xh1_0_xh0_0,B_xh21_0_xh20_0,B_yt0_0_xt0_0 ;[16,2]

LOOP_Y5:
        PACKH2  .S2     B_x_l2_3,   B_x_l2_2,   B_xl2_3_2       ;[27,1]
||[!A_p0]STDW   .D1T1   A_xh2_3_2:A_xh2_1_0,    *A_x__[A_h2]    ;[27,1]
||      ROTL    .M1     A_xt2_0_yt2_0,16,       A_yt2_0_xt2_0   ;[17,2] |
||      ROTL    .M2     B_yt0_0_xt0_0,16,       B_xt0_0_yt0_0   ;[17,2]
||[!A_ifj]ZERO  .L2     B_j                                     ;[17,2]
||      SUB     .S1     A_fft_jmp,  A_j,        A_ifj           ;[ 7,3]
||      SUB2    .L1X    A_xh2_3_xh2_2,B_xl2_3_xl2_2,A_xl21_1_xl20_1;[ 7,3]
||      ADD2    .D2X    B_xl2_3_xl2_2,A_xh2_3_xh2_2,B_xh21_1_xh20_1;[ 7,3]

LOOP_Y6:
        ZERO    .L1     A_p0                                    ;[28,1]
||[!A_p0]STDW   .D1T2   B_xl2_3_2:B_xl2_1_0,    *A_x__[A_l2]    ;[28,1]
||      ADD     .S2     B_x_l1_3,   B_x_l1_3,   B_x_l1_3        ;[18,2] >>15
||      DOTPN2  .M2     B_yt0_0_xt0_0,  B_co20_si20, B_x_l1_1   ;[18,2]
||      ROTL    .M1     A_xt2_1_yt2_1,  16,     A_yt2_1_xt2_1   ;[18,2] /
||      ADD2    .D2     B_xh21_0_xh20_0,B_xh1_0_xh0_0,B_x_1_x_0 ;[18,2]
||      SUB2    .S1X    A_xh2_1_xh2_0,  B_xl2_1_xl2_0,A_xl21_0_xl20_0 ;[ 8,3]
||      ADD2    .L2X    B_xl2_1_xl2_0,  A_xh2_1_xh2_0,B_xh21_0_xh20_0 ;[ 8,3]

LOOP_Y7:
        DOTP2   .M2     B_xt0_0_yt0_0,  B_co20_si20,B_x_l1_0    ;[19,2]
||      STDW    .D1T2   B_x_3_x_2:B_x_1_x_0,    *A_x_[0]        ;[19,2]
||      SWAP2   .S1     A_xl21_1_xl20_1,        A_xl20_1_xl21_1 ;[ 9,3]
||      SWAP2   .L1     A_xl21_0_xl20_0,        A_xl20_0_xl21_0 ;[ 9,3]
||[!A_ifj]ADD   .L2     B_x,        B_fft_jmp,  B_x             ;[ 9,3]
||      MVD     .M1X    B_x,        A_x_                        ;[ 9,3]
||      ADD2    .S2X    B_xl1_3_xl1_2,A_x_3_x_2,  B_xh1_1_xh0_1 ;[ 9,3]
||      LDDW    .D2T1   *B_w0[B_j], A_co11_si11:A_co10_si10     ;[ 9,3]

LOOP_Y8:
        ADD     .S1     A_x_h2_2,   A_x_h2_2,   A_x_h2_2        ;[20,2] >>15
||      DOTP2   .M2X    B_co30_si30,  A_xt2_0_yt2_0,  B_x_l2_0  ;[20,2]
||      DOTPN2  .M1     A_yt1_1_xt1_1,A_co11_si11,    A_x_h2_3  ;[20,2]
||      SUB2    .S2     B_xh1_1_xh0_1,B_xh21_1_xh20_1,B_yt0_1_xt0_1;[10,3]
||      ADD     .L2     B_x,        8,          B_x             ;[10,3]
||      ADD     .L1     A_j,        3,          A_j             ;[10,3]
||      SUB2    .D1X    A_x_3_x_2,  B_xl1_3_xl1_2, A_xl1_1_xl0_1;[10,3]
||      LDDW    .D2T2   *B_w2[B_j], B_co31_si31:B_co30_si30     ;[10,3]

LOOP_Y9:
        ADD     .L2     B_x_l2_2,   B_x_l2_2,   B_x_l2_2        ;[21,2] >>15
||      ADD     .S2     B_x_l1_2,   B_x_l1_2,   B_x_l1_2        ;[21,2] >>15
||      DOTPN2  .M2X    B_co30_si30,  A_yt2_0_xt2_0,  B_x_l2_1  ;[21,2]
||      DOTPN2  .M1     A_yt1_0_xt1_0,A_co10_si10,    A_x_h2_1  ;[21,2]
||      SUB2    .D1     A_xl1_1_xl0_1,A_xl20_1_xl21_1,A_yt1_1_xt2_1;[11,3]
||      ADD2    .S1     A_xl1_1_xl0_1,A_xl20_1_xl21_1,A_yt2_1_xt1_1;[11,3]
||      SUB2    .L1X    A_x_1_x_0,  B_xl1_1_xl1_0, A_xl1_0_xl0_0;[11,3]
||      LDDW    .D2T2   *B_x[B_l2], B_xl2_3_xl2_2:B_xl2_1_xl2_0 ;[ 1,4]

;============================ PIPE LOOP EPILOG ==============================

        ADD     .L2     B_x_l1_1,   B_x_l1_1,   B_x_l1_1        ;[22,4] >>15
||      DOTPN2  .M2X    B_co31_si31,A_yt2_1_xt2_1,B_x_l2_3      ;[22,4]
||      MVD     .M1     A_x_,       A_x__                       ;[22,4]
||      CMPLTU  .L1     A_radix,    B_stride,   A_whl           ;(stride>4,2)?

        PACKH2  .L2     B_x_l1_3,   B_x_l1_2,   B_xl1_3_2       ;[23,4]
||      ADD     .S2     B_x_l1_0,   B_x_l1_0,   B_x_l1_0        ;[23,4] >>15
||      ADD     .D1     A_x_h2_0,   A_x_h2_0,   A_x_h2_0        ;[23,4] >>15
||[A_whl]B      .S1     LOOP_WHILE_N                            ;while {

        ADD     .L2     B_x_l2_0,   B_x_l2_0,   B_x_l2_0        ;[24,4] >>15
||      ADD     .L1     A_x_h2_3,   A_x_h2_3,   A_x_h2_3        ;[24,4] >>15

        PACKH2  .L2     B_x_l1_1,   B_x_l1_0,   B_xl1_1_0       ;[25,4]
||      PACKH2  .L1     A_x_h2_3,   A_x_h2_2,   A_xh2_3_2       ;[25,4]
||      ADD     .S2     B_x_l2_1,   B_x_l2_1,   B_x_l2_1        ;[25,4] >>15
||      ADD     .S1     A_x_h2_1,   A_x_h2_1,   A_x_h2_1        ;[25,4] >>15

        PACKH2  .L2     B_x_l2_1,   B_x_l2_0,   B_xl2_1_0       ;[26,4]
||[!A_p0]STDW   .D1T2   B_xl1_3_2:B_xl1_1_0,    *A_x__[A_l1]    ;[26,4]
||      PACKH2  .L1     A_x_h2_1,   A_x_h2_0,   A_xh2_1_0       ;[26,4]
||      ADD     .D2     B_x_l2_3,   B_x_l2_3,   B_x_l2_3        ;[26,4] >>15

        PACKH2  .L2     B_x_l2_3,   B_x_l2_2,   B_xl2_3_2       ;[27,4]
||[!A_p0]STDW   .D1T1   A_xh2_3_2:A_xh2_1_0,    *A_x__[A_h2]    ;[27,4]
||[A_whl]SHRU   .S2     B_stride,   3,          B_h2            ;[ 6,0]
||[A_whl]MV     .D2X    A_ptr_x,    B_x                         ;x = ptr_x

  [!A_p0]STDW   .D1T2   B_xl2_3_2:B_xl2_1_0,    *A_x__[A_l2]    ;[28,4]
||[A_whl]ADDAH  .D2     B_h2,       B_h2,       B_l2            ;[ 8,0]
||[A_whl]SHRU   .S1X    B_n,        3,          A_i             ;[ 9,0] n>>3

*======================= SYMBOLIC REGISTER ASSIGNMENTS ======================*
        .asg            A30,        A_radix
        .asg            A6,         A_ptr_x
        .asg            B4,         B_n
        .asg            B6,         B_ptr_y
        .asg            B16,        B_l1
        .asg            A16,        A_i
        .asg            B23,        B_j
        .asg            A0,         A_r2
        .asg            A3,         A_x0
        .asg            B18,        B_x0
        .asg            A29,        A_n
        .asg            A0,         A_x1
        .asg            B17,        B_x1
        .asg            B6,         B_y0
        .asg            B10,        B_y2
        .asg            B9,         B_y1
        .asg            B8,         B_y3
        .asg            B7,         B_n_4
        .asg            A2,         A_n_4
        .asg            B0,         B_n_2
        .asg            B5,         B_nm2
        .asg            B11,        B_j0
        .asg            B1,         B_p1
        .asg            B17,        B_h2
        .asg            B26,        B_h0
        .asg            B30,        B_h1
        .asg            B19,        B_h3
        .asg            B21,        B_h4
        .asg            A19,        A_xbxa
        .asg            A18,        A_x9x8
        .asg            B27,        B_xfxe
        .asg            B26,        B_xdxc
        .asg            A9,         A_x3x2
        .asg            A8,         A_x1x0
        .asg            B29,        B_x7x6
        .asg            B28,        B_x5x4
        .asg            B20,        B_xh1_0_xh0_0
        .asg            B24,        B_xh21_0_xh20_0
        .asg            B30,        B_y5y4
        .asg            B24,        B_y1y0
        .asg            A22,        A_xl1_0_xl0_0
        .asg            A20,        A_xl21_0_xl20_0
        .asg            A21,        A_xl0_0_xl1_0
        .asg            A6,         A_xt1_0_yt2_0
        .asg            A21,        A_xt2_0_yt1_0
        .asg            A4,         A_y3y2
        .asg            A6,         A_y7y6
        .asg            B22,        B_xh1_1_xh0_1
        .asg            B20,        B_xh21_1_xh20_1
        .asg            B31,        B_ydyc
        .asg            B25,        B_y9y8
        .asg            A4,         A_xl1_1_xl0_1
        .asg            A20,        A_xl21_1_xl20_1
        .asg            A18,        A_xl0_1_xl1_1
        .asg            A9,         A_xt1_1_yt2_1
        .asg            A17,        A_xt2_1_yt1_1
        .asg            A7,         A_yfye
        .asg            A5,         A_ybya
        .asg            B2,         B_ifj
*============================= PIPE LOOP PROLOG =============================*
        ADD     .L1X    A_ptr_x,    B_n,        A_x1            ;n/4 words
||      MVK     .L2     1,          B_p1                        ;prolog count

        SHL     .S2     B_p1,       29,         B_p1            ;0x20000000
||      MV      .D1X    B_n,        A_n                         ;[ 3,0]

        ADD     .D2X    A_x1,       8,          B_x1            ;ptr_x + n>>1
||      SUB     .D1     A_radix,    2,          A_r2            ;[ 6,0]
||      SHRU    .S2     B_n,        2,          B_n_2           ;n0 = n>>2
||      MVK     .L2     1,          B_ifj                       ;if(j==n>>2){

        MVK     .D2     4,          B_j0                        ;[ 7,0] j0 = 4
||      SUB     .L2     4,          B_n_2,      B_nm2           ;[ 7,0] 4 - n/4
||[!A_r2]SHRU   .S2     B_n,        1,          B_n_2           ;n0 = n>>1

  [!A_r2]MVK    .D2     8,          B_j0                        ;[ 8,0] j0 = 8
||[!A_r2]SUB    .L2     8,          B_n_2,      B_nm2           ;[ 8,0] 8 - n/4
||      MV      .S2     B_ptr_y,    B_y0                        ;[ 8,0]

        SHRU    .S2     B_n,        3,          B_n_4           ;n/4 dword
||      ADDAH   .D2     B_y0,       B_n,        B_y2            ;[ 9,0]
||      NORM    .L2     B_n,        B_l1                        ;l1=_norm(n)+2
||      MVK     .S1     1,          A_p0                        ;prolog count

        ADD     .S2     B_y2,       B_n,        B_y3            ;[10,0]
||      ADD     .D2     B_y0,       B_n,        B_y1            ;[10,0]
||      ADD     .L2     B_l1,       3,          B_l1            ;[10,0]
||      SHL     .S1     A_p0,       14,         A_p0            ;0x2000

  [!A_r2]ADD    .S2     B_y2,       B_n_2,      B_y3            ;[11,0]
||[!A_r2]ADD    .D2     B_y0,       B_n_2,      B_y1            ;[11,0]
||      SHRU    .S1X    B_n,        3,          A_i             ;[11,0]
||[!A_r2]NORM   .L2     B_n,        B_l1                        ;l1=_norm(n)+1

        SHRU    .S1X    B_n,        3,          A_n_4           ;n/4 dwords
||      ADD     .S2X    A_ptr_x,    8,          B_x0            ;x = ptr_x
||      MV      .L1     A_ptr_x,    A_x0                        ;[12,0]
||      SUB     .D1     A_i,        0,          A_i             ;[12,0]
||[!A_r2]ADD    .D2     B_l1,       2,          B_l1            ;[12,0]
||      MV      .L2     B_j0,       B_j                         ;j  += j0;
||      MPYSU   .M2     0,          B_h1,       B_h1            ;h2=_bitr(h2)

; ============================ PIPE LOOP KERNEL ==============================
LOOP_Z:
 [!A_p0]STDW    .D2T2   B_ydyc:B_y5y4,          *B_y2[B_h4]     ;[25,4]
||      SUB2    .D1     A_xl0_1_xl1_1,A_xl21_1_xl20_1,A_xt2_1_yt1_1;[18,5]
||      ADD2    .L1     A_xl0_1_xl1_1,A_xl21_1_xl20_1,A_xt1_1_yt2_1;[18,5]
||      SUB2    .S2     B_xh1_1_xh0_1, B_xh21_1_xh20_1, B_ydyc  ;[18,5]
||[!A_r2]ROTL   .M1X    B_x7x6,     0,          A_xl21_0_xl20_0 ;[18,5]
||      SUB2    .S1X    A_x3x2,     B_x7x6,     A_xl21_0_xl20_0 ;[18,5]
||[!A_r2]ROTL   .M2X    A_x3x2,     0,          B_xh21_0_xh20_0 ;[18,5]
||      ADD2    .L2X    B_x7x6,     A_x3x2,     B_xh21_0_xh20_0 ;[18,5]

        BDEC    .S1     LOOP_Z,     A_i                         ;[47,1] }end
||[!A_p0]STDW    .D2T1   A_ybya:A_y3y2,          *B_y1[B_h4]    ;[26,4]
||      PACKLH2 .L1     A_xt2_1_yt1_1, A_xt1_1_yt2_1,   A_ybya  ;[19,5]
||      ADD2    .L2     B_xh1_1_xh0_1, B_xh21_1_xh20_1, B_y9y8  ;[19,5]
||[!A_r2]ROTL   .M1X    B_x5x4,     0,          A_xl0_0_xl1_0   ;[19,5]
||[!A_r2]ROTL   .M2X    A_x1x0,     0,          B_xh1_0_xh0_0   ;[19,5]
||      ADD2    .S2X    B_x5x4,     A_x1x0,     B_xh1_0_xh0_0   ;[19,5]

  [!A_p0]STDW    .D2T1   A_yfye:A_y7y6,          *B_y3[B_h4]    ;[27,4]
||[!A_r2]MV     .L1     A_xt1_1_yt2_1,          A_ybya          ;[20,5]
||      PACKLH2 .S1     A_xt1_1_yt2_1,  A_xt2_1_yt1_1,A_yfye    ;[20,5]
||      SHRU    .S2     B_h3,       B_l1,       B_h4            ;[20,5] h2
||      SUB2    .D1X    A_x9x8,     B_xdxc,     A_xl1_1_xl0_1   ;[13,6]
||      ADD2    .L2X    B_xdxc,     A_x9x8,     B_xh1_1_xh0_1   ;[13,6]
||      SHFL    .M2     B_h2,       B_h3                        ;[13,6] h2
||      MPYSU   .M1     2,          A_p0,       A_p0            ;prolog

        SUB2    .L1     A_xl0_0_xl1_0,A_xl21_0_xl20_0,A_xt2_0_yt1_0;[21,5]
||      ADD2    .D1     A_xl0_0_xl1_0,A_xl21_0_xl20_0,A_xt1_0_yt2_0;[21,5]
||      SUB2    .S2     B_xh1_0_xh0_0,B_xh21_0_xh20_0,B_y5y4    ;[21,5]
||      ROTL    .M1     A_xl1_1_xl0_1,16,         A_xl0_1_xl1_1 ;[14,6]
||      SUB2    .S1X    A_xbxa,     B_xfxe,     A_xl21_1_xl20_1 ;[14,6]
||[!B_ifj]ADD   .L2     B_j,        B_n_2,      B_j             ;[ 7,7] j+= n0;
||      LDDW    .D2T2   *B_x0[B_n_4],           B_xfxe:B_xdxc   ;[ 7,7]
||      ROTL    .M2     B_h1,       16,         B_h2            ;[ 7,7]h2

  [!A_r2]ROTL   .M1     A_xt1_0_yt2_0,0,          A_y3y2        ;[22,5]
||      PACKLH2 .L1     A_xt2_0_yt1_0,A_xt1_0_yt2_0, A_y3y2     ;[22,5]
||[!A_r2]ADD    .S2X    A_x9x8,     0,          B_xh1_1_xh0_1   ;[15,6]
||      SUB2    .S1X    A_x1x0,     B_x5x4,     A_xl1_0_xl0_0   ;[15,6]
||      LDDW    .D2T2   *B_x0++[2], B_x7x6:B_x5x4               ;[ 8,7]
||      LDDW    .D1T1   *A_x0[A_n_4],           A_xbxa:A_x9x8   ;[ 8,7]
||      DEAL    .M2     B_j,        B_h0                        ;[1,8]h2
||      ADD     .L2     B_p1,       B_p1,       B_p1            ;prolog

        PACKLH2 .S1     A_xt1_0_yt2_0,A_xt2_0_yt1_0,    A_y7y6  ;[23,5]
||      ADD2    .L2     B_xh1_0_xh0_0,B_xh21_0_xh20_0,  B_y1y0  ;[23,5]
||[!A_r2]MV     .L1X    B_xdxc,     A_xl0_1_xl1_1               ;[16,6]
||      ADD2    .D2X    B_xfxe,     A_xbxa,     B_xh21_1_xh20_1 ;[16,6]
||      ROTL    .M1     A_xl1_0_xl0_0, 16,      A_xl0_0_xl1_0   ;[16,6]
||      LDDW    .D1T1   *A_x0++[2], A_x3x2:A_x1x0               ;[ 9,7]
||      ADD     .S2     B_j,        B_j0,       B_j             ;j  += j0;
||      AVG2    .M2     B_j,        B_nm2,      B_ifj           ;if(j==n>>2){

  [!B_p1]STDW    .D2T2   B_y9y8:B_y1y0,         *B_y0[B_h4]     ;[24,5]
||[!A_r2]MV     .S1     A_xt2_1_yt1_1,          A_yfye          ;[24,5]
||[!A_r2]ROTL   .M1     A_xt2_0_yt1_0, 0,       A_y7y6          ;[24,5]
||[!A_r2]MV     .D1X    B_xfxe,     A_xl21_1_xl20_1             ;[17,6]
||[!A_r2]ADD    .L2X    A_xbxa,     0,          B_xh21_1_xh20_1 ;[17,6]
||[!B_ifj]ADD   .S2     B_x0,       B_n,        B_x0            ;x0+=(int)n>>1
||[!B_ifj]ADD   .L1     A_x0,       A_n,        A_x0            ;x0+=(int)n>>1
||      BITR    .M2     B_h0,       B_h1                        ;h2=_bitr(h2);
*============================= PIPE LOOP EPILOG =============================*

        STDW    .D2T2   B_ydyc:B_y5y4,          *B_y2[B_h4]     ;[25,8]

        STDW    .D2T1   A_ybya:A_y3y2,          *B_y1[B_h4]     ;[26,8]

        STDW    .D2T1   A_yfye:A_y7y6,          *B_y3[B_h4]     ;[27,8]

        LDW     .D2T2   *-B_SP[ 4], B11                         ;Restore B11

        LDW     .D2T1   *-B_SP[ 3], A_csr                       ;CSR's value

        LDW     .D2T2   *-B_SP[ 2], B10                         ;Restore B10
||      B       .S2     B_ret                                   ;Return-caller

        LDW     .D2T1   *-B_SP[ 1], A10                         ;Restore A10

        MVC     .S2X    A_csr,      CSR                         ;Restore CSR

        ;Interruptibility state restored

        NOP             3
        ;Branch Occurs
*============================================================================*
*=  End of file:  dsp_fft16x16t.asm                                         =*
*============================================================================*
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*============================================================================*

fft16x32.asm/   1061588609  0     0     0       56708     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.3     Thu Sep  6 18:22:32 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


*========================================================================== *
*      TEXAS INSTRUMENTS, INC.                                              *
*                                                                           *
*      NAME                                                                 *
*            DSP_fft16x32                                                   *
*                                                                           *
*      USAGE                                                                *
*            This routine is C-callable and can be called as:               *
*                                                                           *
*           void DSP_fft16x32(const short * ptr_w, int  npoints,            *
*                            int   * ptr_x, int  *ptr_y ) ;                 *
*                                                                           *
*             ptr_w   =  input twiddle factors                              *
*             npoints =  number of points                                   *
*             ptr_x   =  transformed data reversed                          *
*             ptr_y   =  linear transformed data                            *
*                                                                           *
*            (See the C compiler reference guide.)                          *
*                                                                           *
*   DESCRIPTION                                                             *
*       The following code performs a mixed radix FFT for "npoints" which   *
*       is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  *
*       transform and performs either a radix2 or radix4 transform on the   *
*       last stage depending on "npoints". If "npoints" is a multiple of 4, *
*       then this last stage is also a radix4 transform, otherwise it is a  *
*       radix2 transform. This program is available as a C compilable file  *
*       to automatically generate the twiddle factors "twiddle_split.c"     *
*                                                                           *
*         int i, j, k, n = N;                                               *
*         double theta1, theta2, theta3, x_t, y_t;                          *
*         const double M = 32768.0, PI = 3  41592654;                       *
*                                                                           *
*         for (j=1, k=0; j < n>>2; j = j<<2)                                *
*         {                                                                 *
*             for (i=0; i < n>>2; i += j<<1)                                *
*             {                                                             *
*                 theta1 = 2*PI*i/n;                                        *
*                 x_t = M*cos(theta1);                                      *
*                 y_t = M*sin(theta1);                                      *
*                 w[k+1] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+1] = 0x7fff;                            *
*                 w[k+0] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+0] = 0x7fff;                            *
*                                                                           *
*                 theta1 = 2*PI*(i+j)/n;                                    *
*                 x_t = M*cos(theta1);                                      *
*                 y_t = M*sin(theta1);                                      *
*                 w[k+7] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+3] = 0x7fff;                            *
*                 w[k+6] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+2] = 0x7fff;                            *
*                                                                           *
*                 theta2 = 4*PI*i/n;                                        *
*                 x_t = M*cos(theta2);                                      *
*                 y_t = M*sin(theta2);                                      *
*                 w[k+3] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+5] = 0x7fff;                            *
*                 w[k+2] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+4] = 0x7fff;                            *
*                                                                           *
*                 theta2 = 4*PI*(i+j)/n;                                    *
*                 x_t = M*cos(theta2);                                      *
*                 y_t = M*sin(theta2);                                      *
*                 w[k+9] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+7] = 0x7fff;                            *
*                 w[k+8] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+6] = 0x7fff;                            *
*                                                                           *
*                 theta3 = 6*PI*i/n;                                        *
*                 x_t = M*cos(theta3);                                      *
*                 y_t = M*sin(theta3);                                      *
*                 w[k+5] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+9] = 0x7fff;                            *
*                 w[k+4] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+8] = 0x7fff;                            *
*                                                                           *
*                 theta3 = 6*PI*(i+j)/n;                                    *
*                 x_t = M*cos(theta3);                                      *
*                 y_t = M*sin(theta3);                                      *
*                 w[k+11] = (short) x_t;                                    *
*                 if (x_t >= M) w[k+11] = 0x7fff;                           *
*                 w[k+10] = (short) y_t;                                    *
*                 if (y_t >= M) w[k+10] = 0x7fff;                           *
*                                                                           *
*                 k += 12;                                                  *
*             }                                                             *
*         }                                                                 *
*         w[2*n-1] = w[2*n-3] = w[2*n-5] = 0x7fff;                          *
*         w[2*n-2] = w[2*n-4] = w[2*n-6] = 0x0000;                          *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This code works for  both "npoints" a multiple of 2 or 4.           *
*       The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         *
*       double-word boundary for the "optimized" implementations.           *
*                                                                           *
*       The input and output data are complex, with the real/imaginary      *
*       components stored in adjacent locations in the array.  The real     *
*       components are stored at even array indices, and the imaginary      *
*       components are stored at odd array indices.                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in nor-    *
*       mal order and produces the outputs in normal order.                 *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*-------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*-------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*-------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 .  . Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order.                            *
*                                                                           *
*       The fft() code shown here performs the bulk of the computation      *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part os the         *
*       complex multiply is implemented using _dotp2. The imaginary         *
*       part of the complex multiply is implemented using the 16x32         *
*       multiply instruction "mpylir" or "mpyhir".                          *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The optimized implementations are written for LITTLE ENDIAN.        *
*                                                                           *
*   INTERRUPTS                                                              *
*       This code is interrupt tolerant but not interruptible. It masks out *
*   interrupts for the entire duration of the code.                         *
*                                                                           *
*   CYCLES                                                                  *
*       (13 * N/8 + 24) * ceil(log4(N) - 1) + (N + 8) * 1.5 + 27            *
*                                                                           *
*       N = 512, (13 * 64 + 24) * 4 + 520 * 1.5 + 27 = 4231 cycles          *
*                                                                           *
*   CODESIZE                                                                *
*       1068 bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

*============================================================================*
        .text
        .global _DSP_fft16x32
_DSP_fft16x32: 
*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ====================*
        .asg            B15,        B_SP          ; Stack pointer, B datapath
        .asg            A31,        A_SP          ; Stack pointer, A datapath
        .asg            B0,         B_csr         ; CSR's value
        .asg            B1,         B_no_gie      ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr         ; Copy of CSR's value
        .asg            B3,         B_ret         ; Return address
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A0,         A_whl
*============================================================================*
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T1   A15,        *B_SP--[14]   ; Reserve stack, Save A15

        MV      .S1X    B_SP,       A_SP          ; Twin Stack Pointer

        STW     .D1T1   A14,        *+A_SP[12]    ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]    ; Save B14
||      MVC     .S2     CSR,        B_csr         ; Capture CSR's state

        STW     .D1T1   A13,        *+A_SP[10]    ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]    ; Save B13
||      AND     .L2     B_csr,      -2,B_no_gie   ; Clear GIE

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_ptr_w
        .asg            B4,         B_n
        .asg            A6,         A_ptr_x
        .asg            B6,         B_ptr_y
        .asg            B14,        B_radix
        .asg            B0,         B_radix2
        .asg            B18,        B_h2
        .asg            B13,        B_tw_offset
        .asg            B0,         B_stride
        .asg            B1,         B_j
        .asg            B19,        B_fft_jmp
        .asg            A19,        A_fft_jmp
        .asg            B16,        B_l1
        .asg            B17,        B_l2
        .asg            A16,        A_l1
        .asg            A18,        A_h2
        .asg            A17,        A_l2
        .asg            B0,         B_x
        .asg            A15,        A_w0
        .asg            B0,         B_fft_jmp_1
        .asg            A14,        A_i
        .asg            B2,         B_pro
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A15,        A_w0
        .asg            B1,         B_j
        .asg            B0,         B_x
        .asg            B16,        B_l1
        .asg            B17,        B_l2
        .asg            B18,        B_h2
        .asg            A16,        A_l1
        .asg            A17,        A_l2
        .asg            A18,        A_h2
        .asg            A19,        A_fft_jmp
        .asg            B19,        B_fft_jmp
        .asg            A14,        A_i
        .asg            A5,         A_j
        .asg            B5,         B_w1
        .asg            A8,         A_w2
        .asg            B29,        B_co20_si20
        .asg            B28,        B_co10_si10
        .asg            A25,        A_co11_si11
        .asg            A24,        A_co30_si30
        .asg            A31,        A_co31_si31
        .asg            A30,        A_co21_si21
        .asg            B31,        B_x_1
        .asg            B30,        B_x_0
        .asg            B25,        B_xl1_1i
        .asg            B24,        B_xl1_0i
        .asg            B27,        B_xl2_1i
        .asg            B26,        B_xl2_0i
        .asg            B21,        B_xh2_1i
        .asg            B20,        B_xh2_0i
        .asg            A10,        A_x
        .asg            A27,        A_x_3
        .asg            A26,        A_x_2
        .asg            A25,        A_xl1_3i
        .asg            A24,        A_xl1_2i
        .asg            A25,        A_xl2_3i
        .asg            A24,        A_xl2_2i
        .asg            A23,        A_xh2_3i
        .asg            A22,        A_xh2_2i
        .asg            B31,        B_xh1_0
        .asg            B7,         B_xh0_0
        .asg            A29,        A_xh1_1
        .asg            A0,         A_xh0_1
        .asg            B25,        B_xl1_0
        .asg            B3,         B_xl0_0
        .asg            A20,        A_xl1_1
        .asg            A1,         A_xl0_1
        .asg            B20,        B_xh21_0
        .asg            B12,        B_xh20_0
        .asg            A11,        A_xh21_1
        .asg            A8,         A_xh20_1
        .asg            B28,        B_xl21_0
        .asg            B26,        B_xl20_0
        .asg            A7,         A_xl21_1
        .asg            A5,         A_xl20_1
        .asg            A13,        A_x_
        .asg            B11,        B_x__
        .asg            A2,         A_ifj
        .asg            B25,        B_x_1o
        .asg            B24,        B_x_0o
        .asg            A29,        A_x_3o
        .asg            A28,        A_x_2o
        .asg            B3,         B_yt0_0
        .asg            B7,         B_xt0_0
        .asg            A9,         A_yt0_1
        .asg            A3,         A_xt0_1
        .asg            B9,         B_yt1_0
        .asg            B7,         B_xt1_0
        .asg            A3,         A_yt2_1
        .asg            A22,        A_xt1_1
        .asg            B23,        B_yt2_0
        .asg            B10,        B_xt2_0
        .asg            A20,        A_yt1_1
        .asg            A28,        A_xt2_1
        .asg            B5,         B_p0
        .asg            B8,         B_p1
        .asg            B22,        B_xh2_0o
        .asg            B14,        B_p2
        .asg            B8,         B_p3
        .asg            B23,        B_xh2_1o
        .asg            A8,         A_p4
        .asg            A23,        A_p5
        .asg            A22,        A_xh2_2o
        .asg            A9,         A_p6
        .asg            A23,        A_p7
        .asg            A23,        A_xh2_3o
        .asg            B21,        B_p8
        .asg            B8,         B_p9
        .asg            B26,        B_xl1_0o
        .asg            B27,        B_pa
        .asg            B9,         B_pb
        .asg            B27,        B_xl1_1o
        .asg            A27,        A_pc
        .asg            A26,        A_pd
        .asg            A26,        A_xl1_2o
        .asg            A21,        A_pe
        .asg            A23,        A_pf
        .asg            A27,        A_xl1_3o
        .asg            B29,        B_co30_si30
        .asg            B5,         B_p10
        .asg            B8,         B_p11
        .asg            B30,        B_xl2_0o
        .asg            B5,         B_p12
        .asg            B8,         B_p13
        .asg            B31,        B_xl2_1o
        .asg            A24,        A_p14
        .asg            A7,         A_p15
        .asg            A20,        A_xl2_2o
        .asg            A23,        A_p16
        .asg            A21,        A_p17
        .asg            A21,        A_xl2_3o
        .asg            A12,        A_x__
        .asg            B20,        B_l1c
        .asg            A1,         A_pro
; ============================================================================

        ZERO    .L2     B_tw_offset                             ;tw_offset = 0;
||      MV      .S2     B_n,        B_h2                        ;stride=n
||      STW     .D1T1   A12,        *+A_SP[ 8]                  ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]                  ; Save B12

        SHRU    .S2     B_h2,       2,          B_h2            ;[ 7,0]
||      STW     .D1T1   A11,        *+A_SP[ 6]                  ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]                  ; Save B11
||      MV      .L1X    B_csr,      A_csr                       ;

        ADDAH   .D2     B_h2,       B_h2,       B_l2            ;[ 8,0]

        SHRU    .S1X    B_n,        3,          A_i             ;[ 9,0] n>>3
||      STW     .D1T1   A10,        *+A_SP[ 4]                  ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]                  ; Save B10
||      MVC     .S2     B_no_gie,   CSR                         ; Disable

        MV      .L1X    B_l2,       A_l2                        ;[10,0]
||      SHL     .S2     B_h2,       1,          B_l1            ;[10,0]
||      MPYSU   .M2     8,          B_l2,       B_fft_jmp       ;1.5*stride

        MV      .S1X    B_h2,       A_h2                        ;[11,0]
||      STW     .D1T1   A_csr,      *+A_SP[ 2]                  ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]                  ; return


        MV      .L1X    B_l1,       A_l1                        ;[12,0]
||      LDDW    .D1T2   *A_ptr_x[A_h2], B_xh2_1i:B_xh2_0i       ;[ 1,1]

LOOP_WHILE_N:

        SHRU    .S1X    B_fft_jmp,  4,          A_fft_jmp       ;[13,0]
||      MVK     .L2     1,          B_pro                       ;
||      ADD     .L1     A_ptr_x,    8,          A_x             ;[ 2,1]

        ADD     .D1X    A_ptr_w,    B_tw_offset,A_w0            ;[14,0]
||      SHRU    .S2     B_fft_jmp,  2,          B_fft_jmp_1     ;[14,0]
||      MPYSU   .M2     0,          B_j,        B_j             ;[14,0] j = 0

        MV      .L2X    A_ptr_x,    B_x                         ;[15,0] ptr_x
||      SUB     .D1     A_fft_jmp,  3,          A_fft_jmp       ;[15,0]
||      ADD     .L1X    A_w0,       B_tw_offset,A_w0            ;[15,0]
||      ADD     .D2     B_tw_offset,B_fft_jmp_1,B_tw_offset     ;[15,0] fft_jmp

        MVD     .M1X    B_x,        A_x_                        ;[ 5,1]
||      LDDW    .D2T2   *B_x[B_l2], B_xl2_1i:B_xl2_0i           ;[ 5,1]
||      BDEC    .S1     LOOP_Y8 + 20, A_i

        SUB     .S1     A_fft_jmp,  0,          A_ifj           ;[ 6,1]
||      LDDW    .D1T1   *A_x[0],    A_x_3:A_x_2                 ;[ 6,1]
||      LDDW    .D2T2   *B_x[0],    B_x_1:B_x_0                 ;[ 6,1]
||      B       .S2     LOOP_Y9 + 16

  [!A_ifj]ADD   .S2     B_x,        B_fft_jmp,  B_x             ;[ 7,1]
||      LDDW    .D2T2   *B_x[B_l1], B_xl1_1i:B_xl1_0i           ;[ 7,1]
||      MV      .L1X    B_j,        A_j                         ;[ 7,1]
||      BDEC    .S1     LOOP_Y10 + 16, A_i

        LDDW    .D1T1   *A_x[A_h2], A_xh2_3i:A_xh2_2i           ;[ 8,1]
||      B       .S1     LOOP_Y11 + 12

        LDDW    .D1T1   *A_x[A_l2], A_xl2_3i:A_xl2_2i           ;[ 9,1]
||      ADD     .L2X    A_w0,       8,          B_w1            ;[ 9,1]
||      B       .S1     LOOP_Y12 + 16

        SUB     .L2     B_xh2_0i,   B_xl2_0i,   B_xl20_0        ;[10,1]
||      ADD     .S2     B_xl2_0i,   B_xh2_0i,   B_xh20_0        ;[10,1]
||      ADD     .D2     B_xl2_1i,   B_xh2_1i,   B_xh21_0        ;[10,1]
||      B       .S1     LOOP_Y
; ============================ PIPE LOOP KERNEL ==============================
LOOP_Y:
  [!B_pro]STDW  .D1T1   A_xl2_3o:A_xl2_2o,      *A_x__[A_l2]    ;[29,1]
||[!B_pro]STDW  .D2T2   B_xh2_1o:B_xh2_0o,      *B_x__[B_h2]    ;[29,1]
||      MPYHIR  .M2     B_co30_si30,            B_xt2_0,B_p11   ;[29,1]
||      MPYHIR  .M1     A_co21_si21,            A_xt0_1,A_pd    ;[29,1]
||      SUB     .L2     B_xl0_0,    B_xl21_0,   B_xt2_0         ;[16,2]
||[!A_ifj]ZERO  .S2     B_j                                     ;[16,2]
||      SUB     .L1     A_x_2,      A_xl1_2i,   A_xl0_1         ;[16,2]
||      SUB     .S1     A_x_3,      A_xl1_3i,   A_xl1_1         ;[16,2]

  [!B_pro]STDW  .D1T1   A_x_3o:A_x_2o,          *A_x__[0]       ;[30,1]
||      MPYLIR  .M1     A_co21_si21,A_xt0_1,    A_pf            ;[30,1]
||      ADD     .D2     B_p8,       B_p9,       B_xl1_0o        ;[30,1]
||      MPYLIR  .M2     B_co10_si10,B_yt1_0,    B_p0            ;[17,2]
||      SUB     .S1     A_xl0_1,    A_xl21_1,   A_xt2_1         ;[17,2]
||      ADD     .L2     B_xl1_0,    B_xl20_0,   B_yt2_0         ;[17,2]
||      ADD     .L1     A_xl1_1,    A_xl20_1,   A_yt2_1         ;[17,2]
||      SUB     .S2     B_xh1_0,    B_xh21_0,   B_yt0_0         ;[17,2]

        SUB     .S2     B_p12,      B_p13,      B_xl2_1o        ;[31,1]
||      SUB     .S1     A_p6,       A_p7,       A_xh2_3o        ;[31,1]
||      MPYHIR  .M2     B_co10_si10,B_xt1_0,    B_p1            ;[18,2]
||      ADD     .L2     B_xh21_0,   B_xh1_0,    B_x_1o          ;[18,2]
||      ADD     .D1     A_xl1_2i,   A_x_2,      A_xh0_1         ;[18,2]
||      ADD     .L1     A_xl1_3i,   A_x_3,      A_xh1_1         ;[18,2]
||      MVD     .M1X    B_x,        A_x_                        ;[ 5,3]
||      LDDW    .D2T2   *B_x[B_l2], B_xl2_1i:B_xl2_0i           ;[ 5,3]

        MPYHIR  .M1     A_co31_si31,A_xt2_1,    A_p15           ;[19,2]
||      MPYLIR  .M2     B_co10_si10,B_xt1_0,    B_p3            ;[19,2]
||      SUB     .L1     A_xl1_1,    A_xl20_1,   A_yt1_1         ;[19,2]
||      ADD     .S2     B_xl1_0i,   B_x_0,      B_xh0_0         ;[19,2]
||      SUB     .S1X    A_fft_jmp,  B_j,        A_ifj           ;[ 6,3]
||      LDDW    .D1T1   *A_x[0],    A_x_3:A_x_2                 ;[ 6,3]
||      LDDW    .D2T2   *B_x[0],    B_x_1:B_x_0                 ;[ 6,3]

  [!B_pro]STDW  .D1T1   A_xh2_3o:A_xh2_2o,      *A_x__[A_h2]    ;[33,1]
||      ADD     .L2     B_p10,      B_p11,      B_xl2_0o        ;[33,1]
||      MPYLIR  .M1     A_co31_si31,A_xt2_1,    A_p17           ;[20,2]
||      SUB     .S1     A_xh1_1,    A_xh21_1,   A_yt0_1         ;[20,2]
||      MVD     .M2X    A_x_,       B_x__                       ;[20,2]
||[!A_ifj]ADD   .S2     B_x,        B_fft_jmp,  B_x             ;[ 7,3]
||      LDDW    .D2T2   *B_x[B_l1], B_xl1_1i:B_xl1_0i           ;[ 7,3]
||      MV      .L1X    B_j,        A_j                         ;[ 7,3]

  [!B_pro]STDW  .D2T2   B_xl2_1o:B_xl2_0o,      *B_x__[B_l2]    ;[34,1]
||      MPYHIR  .M1     A_co31_si31,A_yt2_1,    A_p16           ;[21,2]
||      MPYHIR  .M2     B_co20_si20,B_yt0_0,    B_pa            ;[21,2]
||      ADD     .S1     A_xl0_1,    A_xl21_1,   A_xt1_1         ;[21,2]
||      SUB     .L2     B_xh0_0,    B_xh20_0,   B_xt0_0         ;[21,2]
||      ADD     .L1     A_xh20_1,   A_xh0_1,    A_x_2o          ;[21,2]
||      ADD     .S2     B_xh20_0,   B_xh0_0,    B_x_0o          ;[21,2]
||      LDDW    .D1T1   *A_x[A_h2], A_xh2_3i:A_xh2_2i           ;[ 8,3]

  [!B_pro]STDW  .D2T2   B_xl1_1o:B_xl1_0o,      *B_x__[B_l1]    ;[35,1]
||      SUB     .L1     A_pe,       A_pf,       A_xl1_3o        ;[35,1]
||      ADD     .S1     A_pc,       A_pd,       A_xl1_2o        ;[35,1]
||      MPYLIR  .M1     A_co31_si31,A_yt2_1,    A_p14           ;[22,2]
||      MPYLIR  .M2     B_co20_si20,B_yt0_0,    B_p8            ;[22,2]
||      ADD     .S2     B_p0,       B_p1,       B_xh2_0o        ;[22,2]
||      LDDW    .D1T1   *A_x[A_l2], A_xl2_3i:A_xl2_2i           ;[ 9,3]
||      ADD     .L2X    A_w0,       8,          B_w1            ;[ 9,3]

        BDEC    .S1     LOOP_Y,     A_i                         ;} end for
||[!B_pro]STDW  .D1T1   A_xl1_3o:A_xl1_2o,      *A_x__[A_l1]    ;[36,1]
||      MPYLIR  .M2     B_co20_si20,B_xt0_0,    B_pb            ;[23,2]
||      MPYLIR  .M1     A_co11_si11,A_yt1_1,    A_p4            ;[23,2]
||      SUB     .L1     A_xh0_1,    A_xh20_1,   A_xt0_1         ;[23,2]
||      SUB     .L2     B_xh2_0i,   B_xl2_0i,   B_xl20_0        ;[10,3]
||      ADD     .S2     B_xl2_0i,   B_xh2_0i,   B_xh20_0        ;[10,3]
||      ADD     .D2     B_xl2_1i,   B_xh2_1i,   B_xh21_0        ;[10,3]
LOOP_Y8:
        ZERO    .S2     B_pro                                   ;
||      STDW    .D2T2   B_x_1o:B_x_0o,          *B_x__[0]       ;[24,2]
||      MPYHIR  .M1     A_co11_si11,A_xt1_1,    A_p5            ;[24,2]
||      MPYHIR  .M2     B_co10_si10,B_yt1_0,    B_p2            ;[24,2]
||      ADD     .S1     A_xh21_1,   A_xh1_1,    A_x_3o          ;[24,2]
||      SUB     .L2     B_xh2_1i,   B_xl2_1i,   B_xl21_0        ;[11,3]
||      LDDW    .D1T1   *A_x[A_l1], A_xl1_3i:A_xl1_2i           ;[11,3]
||      ADD     .L1X    B_w1,       8,          A_w2            ;[11,3]
LOOP_Y9:
        SUB     .S1     A_p16,      A_p17,      A_xl2_3o        ;[25,2]
||      MV      .S2X    A_co30_si30,            B_co30_si30     ;[25,2]
||      MPYHIR  .M2     B_co20_si20,B_xt0_0,    B_p9            ;[25,2]
||      MPYLIR  .M1     A_co11_si11,A_xt1_1,    A_p7            ;[25,2]
||      ADD     .D2     B_x,        16,         B_x             ;[12,3]
||      SUB     .L2     B_x_0,      B_xl1_0i,   B_xl0_0         ;[12,3]
||      LDDW    .D1T2   *A_w0[A_j], B_co20_si20:B_co10_si10     ;[12,3]
LOOP_Y10:
        ADD     .S1X    B_x__,      8,          A_x__           ;[26,2]
||      ADD     .L1     A_p14,      A_p15,      A_xl2_2o        ;[26,2]
||      MPYHIR  .M2     B_co30_si30,B_yt2_0,    B_p12           ;[26,2]
||      MPYHIR  .M1     A_co11_si11,A_yt1_1,    A_p6            ;[26,2]
||      ADD     .S2     B_xl0_0,    B_xl21_0,   B_xt1_0         ;[13,3]
||      SUB     .L2     B_x_1,      B_xl1_1i,   B_xl1_0         ;[13,3]
||      ADD     .D2     B_xl1_1i,   B_x_1,      B_xh1_0         ;[13,3]
||      LDDW    .D1T1   *A_w2[A_j], A_co31_si31:A_co21_si21     ;[13,3]
LOOP_Y11:
        MPYLIR  .M2     B_co30_si30,B_xt2_0,    B_p13           ;[27,2]
||      MPYHIR  .M1     A_co21_si21,A_yt0_1,    A_pe            ;[27,2]
||      SUB     .S2     B_pa,       B_pb,       B_xl1_1o        ;[27,2]
||      SUB     .L2     B_xl1_0,    B_xl20_0,   B_yt1_0         ;[14,3]
||      SUB     .S1     A_xh2_2i,   A_xl2_2i,   A_xl20_1        ;[14,3]
||      SUB     .D1     A_xh2_3i,   A_xl2_3i,   A_xl21_1        ;[14,3]
||      ADD     .L1     A_xl2_3i,   A_xh2_3i,   A_xh21_1        ;[14,3]
||      LDDW    .D2T2   *B_x[B_h2], B_xh2_1i:B_xh2_0i           ;[ 1,4]
LOOP_Y12:
        MPYLIR  .M2     B_co30_si30,B_yt2_0,    B_p10           ;[28,2]
||      MPYLIR  .M1     A_co21_si21,A_yt0_1,    A_pc            ;[28,2]
||      ADD     .L1     A_p4,       A_p5,       A_xh2_2o        ;[28,2]
||      SUB     .S2     B_p2,       B_p3,       B_xh2_1o        ;[28,2]
||      ADD     .L2     B_j,        3,          B_j             ;[15,3]
||      ADD     .S1     A_xl2_2i,   A_xh2_2i,   A_xh20_1        ;[15,3]
||      LDDW    .D2T1   *B_w1[B_j], A_co11_si11:A_co30_si30     ;[15,3]
||      ADD     .D1X    B_x,        8,          A_x             ;[ 2,4]
; ============================ PIPE LOOP EPILOG ==============================
        STDW    .D1T1   A_xl2_3o:A_xl2_2o,      *A_x__[A_l2]    ;[29,4]
||      STDW    .D2T2   B_xh2_1o:B_xh2_0o,      *B_x__[B_h2]    ;[29,4]
||      MPYHIR  .M2     B_co30_si30,B_xt2_0,    B_p11           ;[29,4]
||      MPYHIR  .M1     A_co21_si21,A_xt0_1,    A_pd            ;[29,4]
||      NORM    .L2     B_n,        B_radix2                    ;[ 2,0]

        STDW    .D1T1   A_x_3o:A_x_2o,          *A_x__[0]       ;[30,4]
||      MPYLIR  .M1     A_co21_si21,A_xt0_1,    A_pf            ;[30,4]
||      ADD     .D2     B_p8,       B_p9,       B_xl1_0o        ;[30,4]
||      AND     .S2     B_radix2,   1,          B_radix2        ;norm(npoints)&1
||      MVK     .L2     4,          B_radix                     ; radix = 4?

        SUB     .L2     B_p12,      B_p13,      B_xl2_1o        ;[31,4]
||      SUB     .L1     A_p6,       A_p7,       A_xh2_3o        ;[31,4]
||[B_radix2]MVK .D2     2,          B_radix                     ;radix = 2

        CMPGTU  .L1X    A_h2,       B_radix,    A_whl           ;

        STDW    .D1T1   A_xh2_3o:A_xh2_2o,      *A_x__[A_h2]    ;[33,4]
||      ADD     .L2     B_p10,      B_p11,      B_xl2_0o        ;[33,4]
||[A_whl]B      .S1     LOOP_WHILE_N                            ;} end while

        STDW    .D2T2   B_xl2_1o:B_xl2_0o,      *B_x__[B_l2]    ;[34,4]
||[A_whl]SHRU   .S2     B_h2,       2,          B_h2            ;[ 7,0]


        STDW    .D2T2   B_xl1_1o:B_xl1_0o,      *B_x__[B_l1]    ;[35,4]
||      SUB     .L1     A_pe,       A_pf,       A_xl1_3o        ;[35,4]
||      ADD     .D1     A_pc,       A_pd,       A_xl1_2o        ;[35,4]
||[A_whl]SHRU   .S1X    B_n,        3,          A_i             ;[ 9,0] n>>3

        STDW    .D1T1   A_xl1_3o:A_xl1_2o,      *A_x__[A_l1]    ;[36,4]
||[A_whl]ADDAH  .D2     B_h2,       B_h2,       B_l2            ;[ 8,0]
||[A_whl]MV     .L1X    B_h2,       A_h2                       ;[11,0]

  [A_whl]MV      .L1X    B_l2,       A_l2                       ;[10,0]
||[A_whl]SHL     .S2     B_h2,       1,         B_l1            ;[10,0]
||[A_whl]MPYSU   .M2     8,          B_l2,      B_fft_jmp       ;1.5*stride

  [A_whl]MV      .S1X    B_l1,       A_l1                        ;[12,0]
||[A_whl]LDDW    .D1T2   *A_ptr_x[A_h2], B_xh2_1i:B_xh2_0i       ;[ 1,1]
||[!A_whl]NORM   .L2     B_n,        B_l1c                       ;l1=_norm(n)+2
||[!A_whl]MVK    .L1     1,          A_pro                       ;

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B14,        B_radix
        .asg            A6,         A_ptr_x
        .asg            B6,         B_ptr_y
        .asg            B4,         B_n
        .asg            A0,         A_r2
        .asg            A20,        A_p_x0
        .asg            B8,         B_p_x0
        .asg            B22,        B_p_y2
        .asg            B23,        B_p_y1
        .asg            B3,         B_p_y3
        .asg            B20,        B_l1
        .asg            B19,        B_j0
        .asg            A18,        A_i
        .asg            B9,         B_j
        .asg            A1,         A_pro
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B9,         B_j
        .asg            A18,        A_i
        .asg            B19,        B_j0
        .asg            B20,        B_l1
        .asg            B23,        B_p_y1
        .asg            B22,        B_p_y2
        .asg            B3,         B_p_y3
        .asg            A20,        A_p_x0
        .asg            B8,         B_p_x0
        .asg            A0,         A_r2
        .asg            B25,        B_h0
        .asg            B7,         B_h1
        .asg            B7,         B_h2
        .asg            B5,         B_h3
        .asg            B16,        B_h4
        .asg            A27,        A_x1
        .asg            A26,        A_x0
        .asg            B29,        B_x3
        .asg            B28,        B_x2
        .asg            A5,         A_x5
        .asg            A4,         A_x4
        .asg            B5,         B_x7
        .asg            B4,         B_x6
        .asg            A21,        A_xh0_0
        .asg            A3,         A_xh1_0
        .asg            B24,        B_xh0_1
        .asg            B26,        B_xh1_1
        .asg            B24,        B_y0
        .asg            B25,        B_y1
        .asg            B31,        B_y5
        .asg            B30,        B_y4
        .asg            A16,        A_xl0_0
        .asg            A19,        A_xl1_0
        .asg            B18,        B_xl0_1
        .asg            B17,        B_xl1_1
        .asg            A16,        A_y2
        .asg            A17,        A_y3
        .asg            A8,         A_y6
        .asg            A9,         A_y7
        .asg            A22,        A_temp
; ============================ PIPE LOOP PROLOG ==============================
        ZERO    .L2     B_j                                     ;[ 3,0]
||      SUB     .D1X    B_radix,    2,          A_r2            ;[ 3,0]
||      ADD     .S2     B_l1,       2,          B_l1            ;[ 3,0]
||      ADDAW   .D2     B_ptr_y,    B_n,        B_p_y2          ;[ 3,0]

        MVK     .S2     4,          B_j0                        ;[ 4,0] j0 = 4
||      ADDAH   .D2     B_p_y2,     B_n,        B_p_y3          ;[ 4,0]
||      SHL     .S1     A_pro,      15,         A_pro           ;

        SHRU    .S1X    B_n,        2,          A_i             ;[ 5,0]
||[!A_r2]MVK    .S2     8,          B_j0                        ;[ 5,0] j0 = 8
||[!A_r2]SUB    .L2     B_l1,       1,          B_l1            ;[ 5,0]
||      ADDAH   .D2     B_ptr_y,    B_n,        B_p_y1          ;[ 5,0]

  [!A_r2]ADD    .S2     B_p_y2,     B_n,        B_p_y3          ;[ 6,0]
||[!A_r2]ADD    .L2     B_ptr_y,    B_n,        B_p_y1          ;[ 6,0]
||      ADD     .D2X    A_ptr_x,    8,          B_p_x0          ;x = ptr_x
; ============================ PIPE LOOP KERNEL ==============================
LOOP_Z:
  [!A_r2]ROTL   .M1     A_x4,       0,          A_xl0_0         ;[13,1]
||      SUB     .L1X    A_xl1_0,    B_xl0_1,    A_y3            ;[13,1]
||      ADD     .S2X    A_xh1_0,    B_xh1_1,    B_y1            ;[13,1]
||      BDEC    .S1     LOOP_Z,     A_i                         ;[13,1] }end for
||      ADD     .L2     B_j,        B_j0,       B_j             ;j  += j0;
||      LDDW    .D2T2   *B_p_x0++[2],           B_x3:B_x2       ;[ 1,3]
||      LDDW    .D1T1   *A_ptr_x++[2],          A_x1:A_x0       ;[ 1,3]
||      DEAL    .M2     B_j,        B_h0                        ;h2=_deal(j);

 [!A_pro]STDW   .D2T2   B_y1:B_y0,  *B_ptr_y[B_h4]              ;[14,1]
||      MV      .S1     A_y3,       A_temp                      ;[14,1]
||      ADD     .L1X    A_xl1_0,    B_xl0_1,    A_y7            ;[14,1]
||      SUB     .L2     B_x2,       B_x6,       B_xl0_1         ;[ 8,2]
||      ADD     .S2     B_x6,       B_x2,       B_xh0_1         ;[ 8,2]
||      ADD     .D1     A_x4,       A_x0,       A_xh0_0         ;[ 8,2]
||[!A_r2]ROTL   .M1     A_x0,       0,          A_xh0_0         ;[ 8,2]
||[!A_r2]ROTL   .M2     B_x2,       0,          B_xh0_1         ;[ 8,2]

        SUB     .L1X    A_xl0_0,    B_xl1_1,    A_y6            ;[15,1]
||      SUB     .L2X    A_xh1_0,    B_xh1_1,    B_y5            ;[15,1]
||      ADD     .S1     A_x5,       A_x1,       A_xh1_0         ;[ 9,2]
||[!A_r2]ROTL   .M1     A_x1,       0,          A_xh1_0         ;[ 9,2]
||[!A_r2]MV     .S2     B_x7,       B_xl0_1                     ;[ 9,2]
||      SHFL    .M2     B_h2,       B_h3                        ;h2= _shfl(h2);
||      LDDW    .D1T1   *A_ptr_x++[2],          A_x5:A_x4       ;[ 3,3]
||      LDDW    .D2T2   *B_p_x0++[2],           B_x7:B_x6       ;[ 3,3]

        ADD     .S1X    A_xl0_0,    B_xl1_1,    A_y2            ;[16,1]
||[!A_r2]MV     .D1     A_y7,       A_y3                        ;[16,1]
||[!A_pro]STDW  .D2T2   B_y5:B_y4,  *B_p_y2[B_h4]               ;[16,1]
||      SUB     .L1     A_x1,       A_x5,       A_xl1_0         ;[10,2]
||[!A_r2]ROTL   .M1     A_x5,       0,          A_xl1_0         ;[10,2]
||      ADD     .S2     B_x7,       B_x3,       B_xh1_1         ;[10,2]
||      SUB     .L2     B_x3,       B_x7,       B_xl1_1         ;[10,2]
||      BITR    .M2     B_h0,       B_h1                        ;h2=_bitr(h2);

  [!A_r2]MV     .L1     A_temp,     A_y7                        ;[17,1]
||[!A_pro]STDW  .D2T1   A_y3:A_y2,  *B_p_y1[B_h4]               ;[17,1]
||      SUB     .D1     A_x0,       A_x4,       A_xl0_0         ;[11,2]
||      ADD     .L2X    A_xh0_0,    B_xh0_1,    B_y0            ;[11,2]
||      SUB     .S2X    A_xh0_0,    B_xh0_1,    B_y4            ;[11,2]
||[!A_r2]ROTL   .M2     B_x3,       0,          B_xh1_1         ;[11,2]

 [!A_pro]STDW   .D2T1   A_y7:A_y6,  *B_p_y3[B_h4]               ;[18,1]
||      SHRU    .S2     B_h3,       B_l1,       B_h4            ;h2 >>= l1;
||[!A_r2]MV     .L2     B_x6,       B_xl1_1                     ;[12,2]
||      ROTL    .M2     B_h1,       16,         B_h2            ;h2=_rotl(h2,16)
||      MPYSU   .M1     2,          A_pro,      A_pro           ;10000
||      MV      .S1X    B_SP,       A_SP        ; Twin Stack Pointer
; ============================ PIPE LOOP EPILOG ==============================
        LDW     .D1T2   *+A_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr       ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10         ; Restore A10

        LDW     .D1T2   *+A_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11         ; Restore A11

        LDW     .D1T2   *+A_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12         ; Restore A12

        LDW     .D1T2   *+A_SP[ 9], B13         ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13         ; Restore A13

        LDW     .D1T2   *+A_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14         ; Restore A14

        LDW     .D2T1   *++B_SP[14],A15         ; Restore A15
||      BNOP    .S2     B_ret, 4                ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
*====== Interruptibility state restored
;====== Branch Occurs =====

*============================================================================*
*=  End of file:  fft32x16_h.asm                                            =*
*============================================================================*
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*============================================================================*
fft32x32.asm/   1061588609  0     0     0       50673     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.5     Thu Sep  6 18:22:32 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


*========================================================================== *
*      TEXAS INSTRUMENTS, INC.                                              *
*                                                                           *
*      NAME                                                                 *
*            DSP_fft32x32: Double Precision FFT                             *
*                                                                           *
*      USAGE                                                                *
*            This routine is C-callable and can be called as:               *
*                                                                           *
*           void DSP_fft32x32(const int  * ptr_w, int  npoints,             *
*                            int   * ptr_x, int  * ptr_y ) ;                *
*                                                                           *
*             ptr_w   =  input twiddle factors                              *
*             npoints =  number of points                                   *
*             ptr_x   =  transformed data reversed                          *
*             ptr_y   =  linear transformed data                            *
*                                                                           *
*            (See the C compiler reference guide.)                          *
*                                                                           *
*   DESCRIPTION                                                             *
*       The following code performs a mixed radix FFT for "npoints" which   *
*       is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  *
*       transform and performs either a radix2 or radix4 transform on the   *
*       last stage depending on "npoints". If "npoints" is a multiple of 4, *
*       then this last stage is also a radix4 transform, otherwise it is a  *
*       radix2 transform. This program is available as a C compilable file  *
*       to automatically generate the twiddle factors "twiddle_split.c"     *
*                                                                           *
*       Generate special vector of twiddle factors                          *
*                                                                           *
*       for (j=1, k=0; j < npoints>>2; j = j <<2 )                          *
*       {                                                                   *
*           for (i=0; i < npoints>>2; i += j)                               *
*           {                                                               *
*               theta1 = 2*PI*i/npoints;                                    *
*               x_t = M*cos(theta1);                                        *
*               y_t = M*sin(theta1);                                        *
*               ptr_w[k+1] = (int) x_t;                                     *
*               if (x_t >= M) ptr_w[k+1] = 0x7fffffff;                      *
*               ptr_w[k+0] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+0] = 0x7fffffff;                      *
*                                                                           *
*               theta2 = 4*PI*i/npoints;                                    *
*               x_t = M*cos(theta2);                                        *
*               y_t = M*sin(theta2);                                        *
*               ptr_w[k+3] = (int) x_t;                                     *
*                                                                           *
*               if (x_t >= M) ptr_w[k+3] = 0x7fffffff;                      *
*               ptr_w[k+2] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+2] = 0x7fffffff;                      *
*                                                                           *
*               theta3 = 6*PI*i/npoints;                                    *
*               x_t = M*cos(theta3);                                        *
*               y_t = M*sin(theta3);                                        *
*               ptr_w[k+5] = (int) x_t;                                     *
*               if (x_t >= M) ptr_w[k+5] = 0x7fffffff;                      *
*               ptr_w[k+4] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+4] = 0x7fffffff;                      *
*               k += 6;                                                     *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This code works for  both "npoints" a multiple of 2 or 4.           *
*       The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         *
*       double-word boundary for the "optimized" implementations.           *
*       The input and output data are complex, with the real/imaginary      *
*       components stored in adjacent locations in the array.  The real     *
*       components are stored at even array indices, and the imaginary      *
*       components are stored at odd array indices. The input, twiddle      *
*       factors are in 32 bit precision. The 32 by 32 multiplies are        *
*       done with a 1.5 bit loss in accuracy. This comes about because      *
*       the contribution of the low sixteen bits to the 32 bit result       *
*       is not computed. In addition the contribution of the low * high     *
*       term is shifted by 16 as opposed to 15, for a loss 0f 0.5 bits      *
*       after rounding. To illustrate real part of complex multiply of:     *
*       (X + jY) ( C + jS) =                                                *
*                                                                           *
*       _mpyhir(si10 , yt1_0)  + _mpyhir(co10 , xt1_0) +                    *
*                        (((MPYLUHS(si10,yt1_0) + MPYLUHS(co10, xt1_0)      *
*                                               + 0x8000)  >> 16) << 1)     *
*                                                                           *
*       The intrinsic C version of this code performs this function as:     *
*                                                                           *
*       _mpyhir(si10 , yt1_0)  + _mpyhir(co10 , xt1_0) +                    *
*                        (_dotprsu2(yt1_0xt1_0, si10co10) << 1);            *
*                                                                           *
*                                                                           *
*       where the functions _mpyhir, MPYLUHS are as follows:                *
*                                                                           *
*   #define _mpyhir(x,y) \                                                  *
*   (((int)((short)(x>>16)*(unsigned short)(y&0x0000FFFF)+0x4000) >> 15)    *
*    + \ ((int)((short)(x >> 16) * (short)((y) >> 16)) << 1))               *
*                                                                           *
*   #define MPYLUHS(x,y)   \                                                *
*       ( (int) ((unsigned short)(x & 0x0000FFFF) * (short) (y >> 16)) )    *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in nor-    *
*       mal order and produces the outputs in normal order.                 *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*-------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*-------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*-------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 .  . Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order.                            *
*                                                                           *
*       The fft() code shown here performs the bulk of the computation      *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       In the folllowing code since all data elements are 32 bits, add2    *
*       sub2 are replaced with normal 32 bit add's and subtracts.           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part of the         *
*       multiply and the imaginary part of the multiply are performed       *
*       as 16x32 multiplies using MPYLIR and MPYHIR                         *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The optimized implementations are written for LITTLE ENDIAN.        *
*                                                                           *
*   CYCLES                                                                  *
*       [(N/4 + 1) * 10 + 10] * ceil(log4(N) - 1) + 6 * (N/4 + 2) + 27      *
*                                                                           *
*       N = 512, [1290 + 10] * 4 + 6 * 130 + 27 = 6007 cycles               *
*                                                                           *
*   CODESIZE                                                                *
*       932 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

*============================================================================*
        .text
        .global _DSP_fft32x32
_DSP_fft32x32: 
*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ====================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A31,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
        .asg            A0,         A_whl
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_ptr_w
        .asg            B4,         B_n
        .asg            A6,         A_ptr_x
        .asg            B6,         B_ptr_y
        .asg            A15,        A_stride
        .asg            A13,        A_tw_offset
        .asg            A14,        A_radix
        .asg            B0,         B_radix2
        .asg            A17,        A_j
        .asg            A23,        A_fft_jmp
        .asg            B20,        B_fft_jmp
        .asg            A19,        A_h2
        .asg            A18,        A_l1
        .asg            A20,        A_l2
        .asg            B21,        B_l1
        .asg            B22,        B_h2
        .asg            B23,        B_l2
        .asg            A10,        A_x
        .asg            A21,        A_w0
        .asg            B19,        B_w1
        .asg            A22,        A_w2
        .asg            A3,         A_fft_jmp_1
        .asg            A2,         A_i
        .asg            A1,         A_pro
        .asg            B2,         B_pro2
        .asg            B25,        B_xp1
        .asg            B24,        B_xp0
        .asg            A25,        A_xl1p1
        .asg            A24,        A_xl1p0
        .asg            B29,        B_xh2p1
        .asg            B28,        B_xh2p0
        .asg            A27,        A_xl2p1
        .asg            A26,        A_xl2p0
        .asg            A9,         A_xh0
        .asg            A24,        A_xh1
        .asg            B30,        B_xl0
        .asg            B27,        B_xl1
        .asg            A8,         A_xh20
        .asg            A29,        A_xh21
        .asg            B5,         B_xl20
        .asg            B7,         B_xl21
        .asg            A26,        A_y_h1_0
        .asg            A27,        A_y_h1_1
        .asg            B26,        B_j
        .asg            B29,        B_co10
        .asg            B28,        B_si10
        .asg            A31,        A_co20
        .asg            A30,        A_si20
        .asg            B27,        B_co30
        .asg            B26,        B_si30
        .asg            A5,         A_xt0
        .asg            A7,         A_yt0
        .asg            B8,         B_xt1
        .asg            B0,         B_yt2
        .asg            B9,         B_xt2
        .asg            B3,         B_yt1
        .asg            B5,         B_co10si10
        .asg            A5,         A_co20si20
        .asg            B3,         B_co30si30
        .asg            B8,         B_si10co10
        .asg            A8,         A_si20co20
        .asg            B5,         B_si30co30
        .asg            A7,         A_yt0xt0
        .asg            B16,        B_yt1xt1
        .asg            B9,         B_yt2xt2
        .asg            A5,         A_si10
        .asg            B18,        B_p0r
        .asg            A11,        A_p1r
        .asg            B30,        B_y_h2_0
        .asg            B3,         B_p01r
        .asg            B7,         B_p0c
        .asg            A3,         A_p1c
        .asg            B31,        B_y_h2_1
        .asg            B9,         B_p01c
        .asg            A27,        A_p2r
        .asg            A3,         A_p3r
        .asg            A28,        A_y_l1_0
        .asg            A24,        A_p23r
        .asg            A25,        A_p2c
        .asg            A3,         A_p3c
        .asg            A29,        A_y_l1_1
        .asg            A3,         A_p23c
        .asg            B7,         B_p4r
        .asg            B26,        B_p5r
        .asg            B24,        B_y_l2_0
        .asg            B8,         B_p45r
        .asg            B25,        B_p4c
        .asg            B24,        B_p5c
        .asg            B25,        B_y_l2_1
        .asg            B5,         B_p45c
        .asg            A16,        A_x_1
        .asg            B17,        B_x__
        .asg            A0,         A_ifj
        .asg            A0,         A_whl
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T1 A15,        *B_SP--[14]          ; Reserve stack, Save A15

        MV      .S1X  B_SP,       A_SP                 ; Twin Stack Pointer

        STW     .D1T1 A14,        *+A_SP[12]           ; Save A14
||      STW     .D2T2 B14,        *+B_SP[11]           ; Save B14
||      MVC     .S2   CSR,        B_csr                ; Capture CSR's state

        STW     .D1T1 A13,        *+A_SP[10]           ; Save A13
||      STW     .D2T2 B13,        *+B_SP[ 9]           ; Save B13
||      AND     .L2   B_csr, -2,  B_no_gie             ; Clear GIE
;-
        STW     .D1T1 A12,        *+A_SP[ 8]           ; Save A12
||      STW     .D2T2 B12,        *+B_SP[ 7]           ; Save B12

        STW     .D1T1 A11,        *+A_SP[ 6]           ; Save A11
||      STW     .D2T2 B11,        *+B_SP[ 5]           ; Save B11
||      MV      .L1X  B_csr,      A_csr                ; Partitioning MV

        STW     .D1T1 A10,        *+A_SP[ 4]           ; Save A10
||      STW     .D2T2 B10,        *+B_SP[ 3]           ; Save B10
||      MVC     .S2   B_no_gie,   CSR                  ; Disable interrupts
||      NORM    .L2   B_n,        B_radix2             ;[ 2,0]

; ===== Interrupts masked here =====

        AND     .L2   B_radix2,   1,B_radix2           ;[ 3,0] _norm(npoints) & 1
||      MVK     .S1   4,          A_radix              ;[ 3,0] radix = 4?
||      STW     .D1T1 A_csr,      *+A_SP[ 2]           ; Save CSR
||      STW     .D2T2 B_ret,      *+B_SP[ 1]           ; Remember return address

  [ B_radix2]MVK.D1   2,          A_radix              ;[ 4,0] radix = 2
||      ZERO    .L1   A_tw_offset                      ;[ 4,0] tw_offset = 0;
||      MV      .S1X  B_n,        A_stride             ;[ 4,0] stride=n

; ============================ PIPE LOOP PROLOG ==============================

        ADDAH   .D1   A_ptr_w,A_tw_offset,A_w0         ;[ 6,0]  ptr_w + tw_offset
||      SHRU    .S1   A_stride,   2,A_h2               ;[ 6,0]
||      MVK     .L1   1,          A_pro                ;[11,0]

        ADDAH   .D1   A_h2,       A_h2,A_l2            ;[ 7,0]
||      MVK     .L2   1,          B_pro2               ;
||      SHL     .S1   A_pro,      29,A_pro             ;


        ADD     .L2X  A_w0,       8,B_w1               ;[ 8,0]
||      MPYSU   .M1   6,A_stride, A_fft_jmp            ;fft_jmp=stride+stride>>1


        SHRU    .S1X  B_n,        2,A_i                ;[ 9,0] n>>3
||      MV      .D2X  A_l2,       B_l2                 ;[ 9,0]

        MV      .L2X  A_h2,       B_h2                 ;[10,0]
||      SHRU    .S1   A_stride,   1,A_l1               ;[10,0]
||      ROTL    .M1   A_ptr_x,    0,A_x                ;x = ptr_x
||      ADD     .D1X  B_w1,       8,A_w2               ;[12,0]

LOOP_WHILE_N:

        SUB     .L1   A_i,        1,A_i                ;[11,0]
||      SHRU    .S2X  A_fft_jmp,  3,B_fft_jmp          ;[11,0]
||      SHRU    .S1   A_fft_jmp,  1,A_fft_jmp_1        ;[11,0]
||      MPYSU   .M1   0,          A_j,A_j              ;[11,0] j = 0
||      LDDW    .D1T2 *A_ptr_x[0],B_xp1:B_xp0          ;x[0]  (0)

        MV      .S2X  A_l1,       B_l1                 ;[12,0]
||      ADD     .L1   A_tw_offset,A_fft_jmp_1,A_tw_offset;[12,0]tw_offset+=
||      SUB     .L2   B_fft_jmp,  3,B_fft_jmp          ;[12,0]          fft_jmp
||      SHRU    .S1   A_stride,   2,A_stride           ;[12,0] stride = stride>>2
||      LDDW    .D1T1 *A_ptr_x[A_l1], A_xl1p1:A_xl1p0  ;x[l1] (N/2)
; ============================ PIPE LOOP KERNEL ==============================
LOOP_Y:
        ADD     .S1   A_p2r,      A_p3r,   A_y_l1_0    ;[23,2]y[l1] = (si20*yt0+c
||      ADDAH   .D2   B_y_h2_1,   B_p01c,  B_y_h2_1    ;[23,2] o20*xt0)>>15
||      MPYHIR  .M2   B_co10,     B_xt1,   B_p0r       ;[13,3]
||      PACKH2  .S2   B_yt1,      B_xt1,   B_yt1xt1    ;[13,3]
||      ADD     .L2   B_xl20,     B_xl1,   B_yt2       ;[13,3] yt2=xl1+xl20
||      SUB     .L1   A_xh1,      A_xh21,  A_yt0       ;[13,3] yt0=xh1-xh21
||      LDDW    .D1T1 *A_x[A_l2], A_xl2p1:A_xl2p0      ;[ 3,4] x[l2] (3N/4)

        ADD     .L1   A_pro,      A_pro,   A_pro       ;[34,1]
||      ADDAH   .D2   B_y_l2_1,   B_p45c,  B_y_l2_1    ;[24,2]
||      MPYHIR  .M2   B_si30,     B_yt2,   B_p5r       ;[14,3]
||      MPYHIR  .M1X  A_si10,     B_yt1,   A_p1r       ;[14,3]
||      PACK2   .S2   B_si30,     B_co30,  B_si30co30  ;[14,3] ()>>16
||      SUB     .L2   B_xl0,      B_xl21,  B_xt2       ;[14,3] xt2=xl0-xl21
||      ADD     .S1   A_xh21,     A_xh1,   A_y_h1_1    ;[14,3] y[1]=xh1+xh21
||      LDDW    .D1T2 *A_x[A_h2], B_xh2p1:B_xh2p0      ;[ 4,4] x[h2] (N/4)

  [!A_pro]STDW  .D2T2 B_y_l2_1:B_y_l2_0,  *B_x__[B_l2] ;[25,2]
||      SUB     .L1   A_p2c,      A_p3c,   A_y_l1_1    ;[25,2]y[l1+1]=co20*yt0-
||      ADDAH   .D1   A_y_l1_0,   A_p23r,  A_y_l1_0    ;[25,2] si20*xt0)>>15
||      ADD     .L2X  B_p0r,      A_p1r,   B_y_h2_0    ;[25,2]y[h2] = (si10*yt1+
||      MPYHIR  .M2   B_co30,     B_yt2,   B_p4c       ;[15,3] co10*xt1)>>15
||      MPYHIR  .M1X  A_si10,     B_xt1,   A_p1c       ;[15,3]
||      PACK2   .S2   B_si10,     B_co10,  B_si10co10  ;[15,3] ()>>16
||      SUB     .S1   A_xh0,      A_xh20,  A_xt0       ;[15,3] xt0=xh0-xh20

        ADDAH   .D2   B_y_h2_0,   B_p01r,  B_y_h2_0    ;[26,2]
||[!B_pro2]STDW .D1T1 A_y_h1_1:A_y_h1_0,    *A_x_1[0]  ;[16,3]
||      MPYHIR  .M2   B_si30,     B_xt2,   B_p5c       ;[16,3]
||      MPYHIR  .M1   A_co20,     A_yt0,   A_p2c       ;[16,3]
||      PACK2   .S1   A_si20,     A_co20,  A_si20co20  ;[16,3] ()>>16
||      PACK2   .L2   B_co30,     B_si30,  B_co30si30  ;[16,3] ()>>16
||      SUB     .L1X  B_fft_jmp,  A_j,     A_ifj       ;[ 6,4] ifj = (j - fft_jmp)
||      MV      .S2X  A_j,        B_j                  ;[ 6,4]

        BDEC    .S1   LOOP_Y,     A_i                  ;[37,1]
||      MPYHIR  .M2   B_co30,     B_xt2,   B_p4r       ;[17,3]
||      MPYHIR  .M1   A_si20,     A_yt0,   A_p3r       ;[17,3]
||      PACKH2  .S2   B_yt2,      B_xt2,   B_yt2xt2    ;[17,3]
||      LDDW    .D2T1 *B_w1[B_j], A_co20:A_si20        ;[ 7,4]
||      LDDW    .D1T2 *A_w0[A_j], B_co10:B_si10        ;[ 7,4]
||      SUB     .L2X  B_xp1,      A_xl1p1, B_xl1       ;[ 7,4] xl1=x[1]-x[l1p1]
||      ADD     .L1X  B_xp0,      A_xl1p0, A_xh0       ;[ 7,4] xh0=x[0]+x[l1]

  [!A_pro]STDW  .D2T2 B_y_h2_1:B_y_h2_0, *B_x__[B_h2]  ;[28,2]
||      ADDAH   .D1   A_y_l1_1,   A_p23c,  A_y_l1_1    ;[28,2]
||      DOTPRSU2.M2   B_yt2xt2,   B_si30co30, B_p45r   ;[18,3]
||      MPYHIR  .M1   A_co20,     A_xt0,   A_p2r       ;[18,3]
||      PACKH2  .L1   A_yt0,      A_xt0,   A_yt0xt0    ;[18,3]
||      PACK2   .S2   B_co10,     B_si10,  B_co10si10  ;[18,3] ()>>16
||      SUB     .L2X  B_xp0,      A_xl1p0, B_xl0       ;[ 8,4] xl0=x[0]-x[l1]
||      ADD     .S1X  B_xp1,      A_xl1p1, A_xh1       ;[ 8,4] xh1=x[1]+x[l1p1]

        DOTPNRSU2.M2  B_yt1xt1,   B_co10si10, B_p01c   ;[19,3]
||[!A_ifj]ADD   .L1   A_x,        A_fft_jmp, A_x       ;[ 9,4]if(!predj)x+=fft_jmp
||      ADD     .S1   A_j,        3,       A_j         ;[ 9,4] j += 1
||      MVD     .M1   A_x,        A_x_1                ;[ 9,4]
||      LDDW    .D1T2 *A_w2[A_j], B_co30:B_si30        ;[ 9,4]
||      SUB     .D2X  B_xh2p0,    A_xl2p0, B_xl20      ;[ 9,4] xl20=x[h2]  -x[l2]
||      ZERO    .L2   B_pro2

  [!A_pro]STDW  .D2T1 A_y_l1_1:A_y_l1_0, *B_x__[B_l1]  ;[30,2]
||      DOTPNRSU2.M2  B_yt2xt2,   B_co30si30, B_p45c   ;[20,3]
||      SUB     .S2X  B_p0c,      A_p1c,   B_y_h2_1    ;[20,3] y[h2+1]=(co10*yt1-
||      MPYHIR  .M1   A_si20,     A_xt0,   A_p3c       ;[20,3] si10*xt1)>>15
||[!A_ifj]ZERO  .D1   A_j                              ;[10,4] if (!predj) j = 0
||      ADD     .L1   A_x,        8,       A_x         ;[10,4]
||      SUB     .L2   B_xl1,      B_xl20,  B_yt1       ;[10,4] yt1=xl1-xl20
||      ADD     .S1X  B_xh2p1,    A_xl2p1, A_xh21      ;[10,4]xh21=x[h2p1]+x[l2p1]

        SUB     .S2   B_p4c,      B_p5c,   B_y_l2_1    ;[21,3]y[l2+1]=(si30*yt2-
||      DOTPRSU2.M1   A_yt0xt0,   A_si20co20, A_p23r   ;[21,3]       co30*xt2)>>15
||      ADD     .L2   B_p4r,      B_p5r,   B_y_l2_0    ;[21,3]y[l2]=(co30*yt2+
||      DOTPRSU2.M2   B_yt1xt1,   B_si10co10, B_p01r   ;[21,3] si30*xt2)>>15
||      PACK2   .L1   A_co20,     A_si20,  A_co20si20  ;()>>16
||      SUB     .D2X  B_xh2p1,    A_xl2p1, B_xl21      ;xl21=x[h2p1]-x[l2p1]
||      ADD     .S1X  B_xh2p0,    A_xl2p0, A_xh20      ;xh20=x[h2]+x[l2]
||      LDDW    .D1T2 *A_x[0],    B_xp1:B_xp0          ;x[0]  (0)

        MV      .S2X  A_x_1,      B_x__                ;[22,3]
||      ADDAH   .D2   B_y_l2_0,   B_p45r,  B_y_l2_0    ;[22,3]
||      DOTPNRSU2.M1  A_yt0xt0,   A_co20si20, A_p23c   ;[22,3]
||      MPYHIR  .M2   B_co10,     B_yt1,   B_p0c       ;[12,4]
||      MV      .L1X  B_si10,     A_si10               ;[12,4]
||      ADD     .L2   B_xl21,     B_xl0,   B_xt1       ;xt1=xl0+xl21
||      ADD     .S1   A_xh20,     A_xh0,   A_y_h1_0    ;y[0]=xh0+xh20
||      LDDW    .D1T1 *A_x[A_l1], A_xl1p1:A_xl1p0      ;x[l1] (N/2)
; ============================ PIPE LOOP EPILOG ==============================
        ADD     .S1   A_p2r,      A_p3r,   A_y_l1_0    ;[23,5] y[l1] = (si20*yt0
||      ADDAH   .D2   B_y_h2_1,   B_p01c,  B_y_h2_1    ;[23,5] +co20*xt0)>>15

        ADDAH   .D2   B_y_l2_1,   B_p45c,  B_y_l2_1    ;[24,5]
||      CMPGTU  .L1   A_stride,   A_radix, A_whl       ;while (stride > radix) do

        STDW  .D2T2   B_y_l2_1:B_y_l2_0,   *B_x__[B_l2];[25,5]
||      SUB     .L1   A_p2c,      A_p3c,   A_y_l1_1    ;[25,5] y[l1+1]=(co20*yt0-
||      ADDAH   .D1   A_y_l1_0,   A_p23r,  A_y_l1_0    ;[25,5] si20*xt0)>>15
||[A_whl]B      .S1   LOOP_WHILE_N                     ;} end while
||      ADD     .L2X  B_p0r,      A_p1r,   B_y_h2_0    ;[25,5] y[h2] = (si10*yt1+
                                                       ;co10*xt1)>>15
        ADDAH   .D2   B_y_h2_0,   B_p01r,  B_y_h2_0    ;[26,5]
||      ADDAH   .D1   A_ptr_w,A_tw_offset,A_w0         ;[ 6,0]  ptr_w + tw_offset
||      SHRU    .S1   A_stride,   2,A_h2               ;[ 6,0]
||      MVK     .L1   1,          A_pro                ;[11,0]

        NOP           1
||      ADDAH   .D1   A_h2,       A_h2,     A_l2       ;[ 7,0]
||      MVK     .L2   1,          B_pro2               ;
||      SHL     .S1   A_pro,      29,       A_pro      ;

        STDW    .D2T2  B_y_h2_1:B_y_h2_0,   *B_x__[B_h2];[28,5]
||      ADDAH   .D1   A_y_l1_1,   A_p23c,  A_y_l1_1    ;[28,5]
||      ADD     .L2X  A_w0,       8,B_w1               ;[ 8,0]
||      MPYSU   .M1   6,A_stride, A_fft_jmp            ;fft_jmp=stride+stride>>1

        NOP           1
||      SHRU    .S1X  B_n,        2,A_i                ;[ 9,0] n>>3
||      MV      .D2X  A_l2,       B_l2                 ;[ 9,0]

        STDW    .D2T1 A_y_l1_1:A_y_l1_0,   *B_x__[B_l1];[30,5]
||      MV      .L2X  A_h2,       B_h2                 ;[10,0]
||      SHRU    .S1   A_stride,   1,A_l1               ;[10,0]
||      ROTL    .M1   A_ptr_x,    0,A_x                ;x = ptr_x
||      ADD     .D1X  B_w1,       8,A_w2               ;[12,0]

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A14,        A_radix
        .asg            A6,         A_ptr_x
        .asg            B6,         B_ptr_y
        .asg            B4,         B_n
        .asg            A0,         A_r2
        .asg            A20,        A_p_x0
        .asg            B8,         B_p_x0
        .asg            B21,        B_p_y0
        .asg            B22,        B_p_y2
        .asg            B23,        B_p_y1
        .asg            B3,         B_p_y3
        .asg            B20,        B_l1
        .asg            B19,        B_j0
        .asg            A18,        A_i
        .asg            B9,         B_j
        .asg            A1,         A_pro
        .asg            B25,        B_h0
        .asg            B7,         B_h1
        .asg            B7,         B_h2
        .asg            B5,         B_h3
        .asg            B16,        B_h4
        .asg            A7,         A_x1
        .asg            A6,         A_x0
        .asg            B29,        B_x3
        .asg            B28,        B_x2
        .asg            A5,         A_x5
        .asg            A4,         A_x4
        .asg            B5,         B_x7
        .asg            B4,         B_x6
        .asg            A21,        A_xh0_0
        .asg            A3,         A_xh1_0
        .asg            B24,        B_xh0_1
        .asg            B26,        B_xh1_1
        .asg            B24,        B_y0
        .asg            B25,        B_y1
        .asg            B6,         B_y4
        .asg            B7,         B_y5
        .asg            A16,        A_xl0_0
        .asg            A19,        A_xl1_0
        .asg            B18,        B_xl0_1
        .asg            B17,        B_xl1_1
        .asg            A16,        A_y2
        .asg            A17,        A_y3
        .asg            A8,         A_y6
        .asg            A9,         A_y7
        .asg            A22,        A_temp
; ============================ PIPE LOOP PROLOG ==============================
        NORM    .L2     B_n,        B_l1               ;[ 2,0] l1 = _norm(n)+2
||      MV      .D2     B_ptr_y,    B_p_y0             ;[ 2,0]
||      MVK     .L1     1,          A_pro              ;

        ZERO    .L2     B_j                            ;[ 3,0]
||      SUB     .D1     A_radix,    2,     A_r2        ;[ 3,0]
||      ADD     .S2     B_l1,       2,     B_l1        ;[ 3,0]
||      ADDAW   .D2     B_p_y0,     B_n,   B_p_y2      ;[ 3,0]

        MVK     .S2     4,          B_j0               ;[ 4,0] j0 = 4
||[!A_r2]NORM   .L2     B_n,        B_l1               ;[ 4,0] l1 = _norm(n)+1;
||      ADDAH   .D2     B_p_y2,     B_n,   B_p_y3      ;[ 4,0]
||      SHL     .S1     A_pro,      15,    A_pro       ;

        SHRU    .S1X    B_n,        2,     A_i         ;[ 5,0]
||[!A_r2]MVK    .S2     8,          B_j0               ;[ 5,0] j0 = 8
||[!A_r2]ADD    .L2     B_l1,       1,     B_l1        ;[ 5,0]
||      ADDAH   .D2     B_p_y0,     B_n,   B_p_y1      ;[ 5,0]

  [!A_r2]ADD    .S2     B_p_y2,     B_n,   B_p_y3      ;[ 6,0]
||[!A_r2]ADD    .L2     B_p_y0,     B_n,   B_p_y1      ;[ 6,0]
||      ADD     .D2X    A_ptr_x,    8,     B_p_x0      ;[ 6,0] x = ptr_x
||      MV      .L1     A_ptr_x,    A_p_x0             ;[ 6,0]
; ============================ PIPE LOOP KERNEL ==============================
LOOP_Z:
  [!A_r2]ROTL   .M1     A_x4,       0,     A_xl0_0     ;[13,1]
||      SUB     .L1X    A_xl1_0,    B_xl0_1, A_y3      ;[13,1]
||      ADD     .S2X    A_xh1_0,    B_xh1_1, B_y1      ;[13,1]
||      BDEC    .S1     LOOP_Z,     A_i                ;[13,1] }end for
||      ADD     .L2     B_j,        B_j0,  B_j         ;[ 1,3] j  += j0;
||      LDDW    .D2T2   *B_p_x0++[2],      B_x3:B_x2   ;[ 1,3]
||      LDDW    .D1T1   *A_p_x0++[2],      A_x1:A_x0   ;[ 1,3]
||      DEAL    .M2     B_j,        B_h0               ;[ 1,3] h2 = _deal(j);

 [!A_pro]STDW   .D2T2   B_y1:B_y0,  *B_p_y0[B_h4]      ;[14,1]
||      MV      .S1     A_y3,       A_temp             ;[14,1]
||      ADD     .L1X    A_xl1_0,    B_xl0_1,A_y7       ;[14,1]
||      SUB     .L2     B_x2,       B_x6,  B_xl0_1     ;[ 8,2]
||      ADD     .S2     B_x6,       B_x2,  B_xh0_1     ;[ 8,2]
||      ADD     .D1     A_x4,       A_x0,  A_xh0_0     ;[ 8,2]
||[!A_r2]ROTL   .M1     A_x0,       0,     A_xh0_0     ;[ 8,2]
||[!A_r2]ROTL   .M2     B_x2,       0,     B_xh0_1     ;[ 8,2]

        SUB     .L1X    A_xl0_0,    B_xl1_1,A_y6       ;[15,1]
||      SUB     .L2X    A_xh1_0,    B_xh1_1,B_y5       ;[15,1]
||      ADD     .S1     A_x5,       A_x1,  A_xh1_0     ;[ 9,2]
||[!A_r2]ROTL   .M1     A_x1,       0,     A_xh1_0     ;[ 9,2]
||[!A_r2]MV     .S2     B_x7,       B_xl0_1            ;[ 9,2]
||      SHFL    .M2     B_h2,       B_h3               ;[ 9,2] h2 = _shfl(h2);
||      LDDW    .D1T1   *A_p_x0++[2],      A_x5:A_x4   ;[ 3,3]
||      LDDW    .D2T2   *B_p_x0++[2],      B_x7:B_x6   ;[ 3,3]

        ADD     .S1X    A_xl0_0,    B_xl1_1,A_y2       ;[16,1]
||[!A_r2]MV     .D1     A_y7,       A_y3               ;[16,1]
||[!A_pro]STDW  .D2T2   B_y5:B_y4,  *B_p_y2[B_h4]      ;[16,1]
||      SUB     .L1     A_x1,       A_x5,  A_xl1_0     ;[10,2]
||[!A_r2]ROTL   .M1     A_x5,       0,     A_xl1_0     ;[10,2]
||      ADD     .S2     B_x7,       B_x3,  B_xh1_1     ;[10,2]
||      SUB     .L2     B_x3,       B_x7,  B_xl1_1     ;[10,2]
||      BITR    .M2     B_h0,       B_h1               ;[ 4,3] h2 = _bitr(h2);

  [!A_r2]MV     .L1     A_temp,     A_y7               ;[17,1]
||[!A_pro]STDW  .D2T1   A_y3:A_y2,  *B_p_y1[B_h4]      ;[17,1]
||      SUB     .D1     A_x0,       A_x4,  A_xl0_0     ;[11,2]
||      ADD     .L2X    A_xh0_0,    B_xh0_1,B_y0       ;[11,2]
||      SUB     .S2X    A_xh0_0,    B_xh0_1,B_y4       ;[11,2]
||[!A_r2]ROTL   .M2     B_x3,       0,     B_xh1_1     ;[11,2]

 [!A_pro]STDW   .D2T1   A_y7:A_y6,  *B_p_y3[B_h4]      ;[18,1]
||      SHRU    .S2     B_h3,       B_l1,  B_h4        ;[12,2] h2 >>= l1;
||[!A_r2]MV     .L2     B_x6,       B_xl1_1            ;[12,2]
||      ROTL    .M2     B_h1,       16,    B_h2        ;[ 6,3] h2=_rotl(h2, 16)
||      MPYSU   .M1     2,          A_pro, A_pro       ;10000
||      MV      .S1X    B_SP,       A_SP               ; Twin Stack Pointer
; ============================ PIPE LOOP EPILOG ==============================
        LDW     .D1T2   *+A_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr       ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10         ; Restore A10

        LDW     .D1T2   *+A_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11         ; Restore A11

        LDW     .D1T2   *+A_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12         ; Restore A12

        LDW     .D1T2   *+A_SP[ 9], B13         ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13         ; Restore A13

        LDW     .D1T2   *+A_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14         ; Restore A14

        LDW     .D2T1   *++B_SP[14],A15         ; Restore A15
||      BNOP    .S2     B_ret, 4                ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
*====== Interruptibility state restored
;====== Branch Occurs =====

*============================================================================*
*=  End of file:  dsp_fft32x32.asm                                          =*
*============================================================================*
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*============================================================================*

fft32x32s.asm/  1061588610  0     0     0       52600     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Thu Sep  6 18:22:33 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


*========================================================================== *
*      TEXAS INSTRUMENTS, INC.                                              *
*                                                                           *
*      NAME                                                                 *
*            DSP_fft32x32s: Double Precision FFT with scaling               *
*                                                                           *
*      USAGE                                                                *
*            This routine is C-callable and can be called as:               *
*                                                                           *
*           void DSP_fft32x32s(const int  * ptr_w, int  npoints,            *
*                            int   * ptr_x, int  * ptr_y ) ;                *
*                                                                           *
*             ptr_w   =  input twiddle factors                              *
*             npoints =  number of points                                   *
*             ptr_x   =  transformed data reversed                          *
*             ptr_y   =  linear transformed data                            *
*                                                                           *
*            (See the C compiler reference guide.)                          *
*                                                                           *
*   DESCRIPTION                                                             *
*       The following code performs a mixed radix FFT for "npoints" which   *
*       is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  *
*       transform and performs either a radix2 or radix4 transform on the   *
*       last stage depending on "npoints". If "npoints" is a multiple of 4, *
*       then this last stage is also a radix4 transform, otherwise it is a  *
*       radix2 transform. This program is available as a C compilable file  *
*       to automatically generate the twiddle factors "twiddle_split.c"     *
*                                                                           *
*       Generate special vector of twiddle factors                          *
*                                                                           *
*       for (j=1, k=0; j < npoints>>2; j = j <<2 )                          *
*       {                                                                   *
*           for (i=0; i < npoints>>2; i += j)                               *
*           {                                                               *
*               theta1 = 2*PI*i/npoints;                                    *
*               x_t = M*cos(theta1);                                        *
*               y_t = M*sin(theta1);                                        *
*               ptr_w[k+1] = (int) x_t;                                     *
*               if (x_t >= M) ptr_w[k+1] = 0x7fffffff;                      *
*               ptr_w[k+0] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+0] = 0x7fffffff;                      *
*                                                                           *
*               theta2 = 4*PI*i/npoints;                                    *
*               x_t = M*cos(theta2);                                        *
*               y_t = M*sin(theta2);                                        *
*               ptr_w[k+3] = (int) x_t;                                     *
*                                                                           *
*               if (x_t >= M) ptr_w[k+3] = 0x7fffffff;                      *
*               ptr_w[k+2] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+2] = 0x7fffffff;                      *
*                                                                           *
*               theta3 = 6*PI*i/npoints;                                    *
*               x_t = M*cos(theta3);                                        *
*               y_t = M*sin(theta3);                                        *
*               ptr_w[k+5] = (int) x_t;                                     *
*               if (x_t >= M) ptr_w[k+5] = 0x7fffffff;                      *
*               ptr_w[k+4] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+4] = 0x7fffffff;                      *
*               k += 6;                                                     *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This code works for  both "npoints" a multiple of 2 or 4.           *
*       The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         *
*       double-word boundary for the "optimized" implementations.           *
*       The input and output data are complex, with the real/imaginary      *
*       components stored in adjacent locations in the array.  The real     *
*       components are stored at even array indices, and the imaginary      *
*       components are stored at odd array indices. The input, twiddle      *
*       factors are in 32 bit precision. The 32 by 32 multiplies are        *
*       done with a 1.5 bit loss in accuracy. This comes about because      *
*       the contribution of the low sixteen bits to the 32 bit result       *
*       is not computed. In addition the contribution of the low * high     *
*       term is shifted by 16 as opposed to 15, for a loss 0f 0.5 bits      *
*       after rounding. To illustrate real part of complex multiply of:     *
*       (X + jY) ( C + jS) =                                                *
*                                                                           *
*       _mpyhir(si10 , yt1_0)  + _mpyhir(co10 , xt1_0) +                    *
*                        (((MPYLUHS(si10,yt1_0) + MPYLUHS(co10, xt1_0)      *
*                                               + 0x8000)  >> 16) << 1)     *
*                                                                           *
*       The intrinsic C version of this code performs this function as:     *
*                                                                           *
*       _mpyhir(si10 , yt1_0)  + _mpyhir(co10 , xt1_0) +                    *
*                        (_dotprsu2(yt1_0xt1_0, si10co10) << 1);            *
*                                                                           *
*                                                                           *
*       where the functions _mpyhir, MPYLUHS are as follows:                *
*                                                                           *
*   #define _mpyhir(x,y) \                                                  *
*   (((int)((short)(x>>16)*(unsigned short)(y&0x0000FFFF)+0x4000) >> 15)    *
*    + \ ((int)((short)(x >> 16) * (short)((y) >> 16)) << 1))               *
*                                                                           *
*   #define MPYLUHS(x,y)   \                                                *
*       ( (int) ((unsigned short)(x & 0x0000FFFF) * (short) (y >> 16)) )    *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in nor-    *
*       mal order and produces the outputs in normal order.                 *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 + yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 - xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 + yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 - xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 + yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 - xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*-------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*-------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*-------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 .  . Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order.                            *
*                                                                           *
*       The fft() code shown here performs the bulk of the computation      *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       In the folllowing code since all data elements are 32 bits, add2    *
*       sub2 are replaced with normal 32 bit add's and subtracts.           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part of the         *
*       multiply and the imaginary part of the multiply are performed       *
*       as 16x32 multiplies using MPYLIR and MPYHIR                         *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The optimized implementations are written for LITTLE ENDIAN.        *
*                                                                           *
*   CYCLES                                                                  *
*       [(N/4 + 1) * 10 + 10] * ceil(log4(N) - 1) + 6 * (N/4 + 2) + 27      *
*                                                                           *
*       N = 512, [1290 + 10] * 4 + 6 * 130 + 27 = 6007 cycles               *
*                                                                           *
*   CODESIZE                                                                *
*       932 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

*============================================================================*
        .text
        .global _DSP_fft32x32s
_DSP_fft32x32s:


*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A31,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
        .asg            A0,         A_whl
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_ptr_w
        .asg            B4,         B_n
        .asg            A6,         A_ptr_x
        .asg            B6,         B_ptr_y
        .asg            A15,        A_stride
        .asg            A13,        A_tw_offset
        .asg            A14,        A_radix
        .asg            B0,         B_radix2
        .asg            A17,        A_j
        .asg            A23,        A_fft_jmp
        .asg            B19,        B_fft_jmp
        .asg            A19,        A_h2
        .asg            A18,        A_l1
        .asg            A20,        A_l2
        .asg            B5,         B_l1
        .asg            B20,        B_h2
        .asg            B21,        B_l2
        .asg            A11,        A_x
        .asg            A21,        A_w0
        .asg            B18,        B_w1
        .asg            A22,        A_w2
        .asg            A3,         A_fft_jmp_1
        .asg            B3,         B_i
        .asg            B1,         B_pro
        .asg            A1,         A_pro
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A11,        A_x
        .asg            A18,        A_l1
        .asg            A19,        A_h2
        .asg            A20,        A_l2
        .asg            A21,        A_w0
        .asg            B18,        B_w1
        .asg            A22,        A_w2
        .asg            A17,        A_j
        .asg            A23,        A_fft_jmp
        .asg            B19,        B_fft_jmp
        .asg            B5,         B_l1
        .asg            B20,        B_h2
        .asg            B21,        B_l2
        .asg            B3,         B_i
        .asg            B1,         B_pro
        .asg            B29,        B_xp1
        .asg            B28,        B_xp0
        .asg            A25,        A_xl1p1
        .asg            A24,        A_xl1p0
        .asg            B23,        B_xh2p1
        .asg            B22,        B_xh2p0
        .asg            A27,        A_xl2p1
        .asg            A26,        A_xl2p0
        .asg            A8,         A_xh0
        .asg            A25,        A_xh1
        .asg            B7,         B_xl0
        .asg            B10,        B_xl1
        .asg            A5,         A_xh20
        .asg            A9,         A_xh21
        .asg            B9,         B_xl20
        .asg            B22,        B_xl21
        .asg            A26,        A_y_h1_0
        .asg            A27,        A_y_h1_1
        .asg            B7,         B_j
        .asg            B31,        B_co10
        .asg            B30,        B_si10
        .asg            A31,        A_co20
        .asg            A30,        A_si20
        .asg            B27,        B_co30
        .asg            B26,        B_si30
        .asg            A9,         A_xt0
        .asg            A5,         A_yt0
        .asg            B8,         B_xt1
        .asg            B24,        B_yt2
        .asg            B25,        B_xt2
        .asg            B16,        B_yt1
        .asg            B26,        B_co10si10
        .asg            A7,         A_co20si20
        .asg            B26,        B_co30si30
        .asg            B8,         B_si10co10
        .asg            A29,        A_si20co20
        .asg            B9,         B_si30co30
        .asg            A10,        A_yt0xt0
        .asg            B9,         B_yt1xt1
        .asg            B22,        B_yt2xt2
        .asg            A7,         A_si10
        .asg            B2,         B_p0r
        .asg            A24,        A_p1r
        .asg            B24,        B_y_h2_0
        .asg            B7,         B_p01r
        .asg            B10,        B_p0c
        .asg            A2,         A_p1c
        .asg            B25,        B_y_h2_1
        .asg            B23,        B_p01c
        .asg            A3,         A_p2r
        .asg            A28,        A_p3r
        .asg            A28,        A_y_l1_0
        .asg            A3,         A_p23r
        .asg            A3,         A_p2c
        .asg            A7,         A_p3c
        .asg            A29,        A_y_l1_1
        .asg            A3,         A_p23c
        .asg            B8,         B_p4r
        .asg            B0,         B_p5r
        .asg            B28,        B_y_l2_0
        .asg            B30,        B_p45r
        .asg            B2,         B_p4c
        .asg            B27,        B_p5c
        .asg            B29,        B_y_l2_1
        .asg            B16,        B_p45c
        .asg            A16,        A_x_1
        .asg            B17,        B_x__
        .asg            A0,         A_ifj
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T1   A15,        *B_SP--[14]                 ; Save A15

        MV      .S1X    B_SP,       A_SP                        ; Twin Stack

        STW     .D1T1   A14,        *+A_SP[12]                  ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]                  ; Save B14
||      MVC     .S2     CSR,        B_csr                       ; CSR's

        STW     .D1T1   A13,        *+A_SP[10]                  ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]                  ; Save B13
||      AND     .L2     B_csr,      -2,         B_no_gie        ; Clear GIE
;-
        STW     .D1T1   A12,        *+A_SP[ 8]                  ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]                  ; Save B12

        STW     .D1T1   A11,        *+A_SP[ 6]                  ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]                  ; Save B11
||      MV      .L1X    B_csr,      A_csr                       ; Part. MV
||      NORM    .L2     B_n,        B_radix2                    ;[ 2,0]

        STW     .D1T1   A10,        *+A_SP[ 4]                  ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]                  ; Save B10
||      MVC     .S2     B_no_gie,   CSR                         ; Disable int.
||      AND     .L2     B_radix2,   1,          B_radix2        ;_norm(n)& 1
||      MVK     .S1     4,          A_radix                     ;radix = 4?
||      ZERO    .L1     A_tw_offset                             ;tw_offset = 0;

; ===== Interrupts masked here =====

        STW     .D1T1   A_csr,      *+A_SP[ 2]                  ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]                  ; return
||[ B_radix2]MVK.L1     2,          A_radix                     ;radix = 2
||      MV      .S1X    B_n,        A_stride                    ;stride=n
; ============================ PIPE LOOP PROLOG ==============================
        ADDAH   .D1     A_ptr_w,    A_tw_offset,A_w0            ;
||      SHRU    .S1     A_stride,   2,          A_h2            ;[ 6,0]

        ADDAH   .D1     A_h2,       A_h2,       A_l2            ;[ 7,0]
||      MVK     .L1     1,          A_pro                       ;
||      MVK     .L2     1,          B_pro                       ;[11,0]

        ADD     .L2X    A_w0,       8,          B_w1            ;[ 8,0]
||      MPYSU   .M1     6,          A_stride,   A_fft_jmp       ;
||      SHRU    .S1     A_stride,   1,          A_l1            ;[10,0]

        MV      .D2X    A_l2,       B_l2                        ;[ 9,0]
||      SHL     .S2     B_pro,      30,         B_pro           ;[11,0]
||      LDDW    .D1T1   *A_ptr_x[A_l1], A_xl1p1:A_xl1p0         ;

LOOP_WHILE:

        SHRU    .S2     B_n,        2,          B_i             ;[10,0]
||      MV      .L2X    A_h2,       B_h2                        ;[10,0]
||      ROTL    .M1     A_ptr_x,    0,          A_x             ;
||      LDDW    .D1T2   *A_ptr_x[0],    B_xp1:B_xp0             ;

        SHRU    .S2X    A_fft_jmp,  3,          B_fft_jmp       ;[11,0]
||      SHRU    .S1     A_fft_jmp,  1,          A_fft_jmp_1     ;[11,0]
||      MPYSU   .M1     0,          A_j,        A_j             ;[11,0]
||      ADD     .L1X    B_w1,       8,          A_w2            ;[12,0]
||      LDDW    .D1T2   *A_ptr_x[A_h2], B_xh2p1:B_xh2p0         ;

        SUB     .D2     B_i,        1,          B_i             ;[12,0]
||      MV      .S2X    A_l1,       B_l1                        ;[12,0]
||      SUB     .L2     B_fft_jmp,  3,          B_fft_jmp       ;[12,0]
||      ADD     .L1     A_tw_offset,A_fft_jmp_1,A_tw_offset     ;
||      SHRU    .S1     A_stride,   2,          A_stride        ;
||      LDDW    .D1T1   *A_ptr_x[A_l2], A_xl2p1:A_xl2p0         ;
; ============================ PIPE LOOP KERNEL ==============================
LOOP_Y:
        ADD     .S1     A_p2r,      A_p3r,      A_y_l1_0        ;[25,1]
||      ADDAH   .D2     B_y_h2_0,   B_p01r,     B_y_h2_0        ;[25,1]
||      MPYHIR  .M1X    A_si10,     B_yt1,      A_p1r           ;[15,2]
||      MPYHIR  .M2     B_co10,     B_xt1,      B_p0r           ;[15,2]
||      PACKH2  .L1     A_yt0,      A_xt0,      A_yt0xt0        ;[15,2]
||      PACK2   .L2     B_si10,     B_co10,     B_si10co10      ;[15,2]
||      LDDW    .D1T2   *A_w2[A_j], B_co30:B_si30               ;[ 5,3]
||      MV      .S2X    A_j,        B_j                         ;[ 5,3]

  [!B_pro]STDW  .D2T2   B_y_l2_1:B_y_l2_0,      *B_x__[B_l2]    ;[26,1]
||      ADDAH   .D1     A_y_l1_1,   A_p23c,     A_y_l1_1        ;[26,1]
||      SUB     .S2X    B_p0c,      A_p1c,      B_y_h2_1        ;[26,1]
||      SHR     .S1     A_y_h1_0,   1,          A_y_h1_0        ;[16,2]
||      MPYHIR  .M2     B_co30,     B_xt2,      B_p4r           ;[16,2]
||      MPYHIR  .M1     A_co20,     A_yt0,      A_p2c           ;[16,2]
||      PACK2   .L2     B_co30,     B_si30,     B_co30si30      ;[16,2]
||      SUB     .L1X    B_fft_jmp,  A_j,        A_ifj           ;[ 6,3]

        ADDAH   .D2     B_y_h2_1,   B_p01c,     B_y_h2_1        ;[27,1]
||[!A_pro]STDW  .D1T1   A_y_h1_1:A_y_h1_0,      *A_x_1[0]       ;[17,2]
||      DOTPNRSU2.M2    B_yt2xt2,   B_co30si30, B_p45c          ;[17,2]
||      MPYHIR  .M1     A_si20,     A_yt0,      A_p3r           ;[17,2]
||      PACK2   .L1     A_co20,     A_si20,     A_co20si20      ;[17,2]
||      PACK2   .S2     B_co10,     B_si10,     B_co10si10      ;[17,2]
||      SUB     .L2X    B_xp1,      A_xl1p1,    B_xl1           ;[ 7,3]
||      ADD     .S1X    B_xp1,      A_xl1p1,    A_xh1           ;[ 7,3]

        SUB     .L2     B_p4c,      B_p5c,      B_y_l2_1        ;[18,2]
||      DOTPNRSU2.M2    B_yt1xt1,   B_co10si10, B_p01c          ;[18,2]
||[!A_ifj]ADD   .S1     A_x,        A_fft_jmp,  A_x             ;[ 8,3]
||      MVD     .M1     A_x,        A_x_1                       ;[ 8,3]
||      LDDW    .D2T1   *B_w1[B_j], A_co20:A_si20               ;[ 8,3]
||      LDDW    .D1T2   *A_w0[A_j], B_co10:B_si10               ;[ 8,3]
||      SUB     .S2X    B_xp0,      A_xl1p0,    B_xl0           ;[ 8,3]
||      ADD     .L1X    B_xp0,      A_xl1p0,    A_xh0           ;[ 8,3]

        BDEC    .S2     LOOP_Y,     B_i                         ;[29,1]
||[!B_pro]STDW  .D2T2   B_y_h2_1:B_y_h2_0,      *B_x__[B_h2]    ;[29,1]
||      ADDAH   .D1     A_y_l1_0,   A_p23r,     A_y_l1_0        ;[29,1]
||      MPYHIR  .M1     A_si20,     A_xt0,      A_p3c           ;[19,2]
||      DOTPRSU2.M2     B_yt1xt1,   B_si10co10, B_p01r          ;[19,2]
||      ADD     .S1     A_x,        8,          A_x             ;[ 9,3]
||      SUB     .L2X    B_xh2p0,    A_xl2p0,    B_xl20          ;[ 9,3]
||      ADD     .L1X    B_xh2p0,    A_xl2p0,    A_xh20          ;[ 9,3]

  [!B_pro]STDW  .D2T1   A_y_l1_1:A_y_l1_0,      *B_x__[B_l1]    ;[30,1]
||      MPYHIR  .M1     A_co20,     A_xt0,      A_p2r           ;[20,2]
||      MPYHIR  .M2     B_co10,     B_yt1,      B_p0c           ;[20,2]
||      PACK2   .S1     A_si20,     A_co20,     A_si20co20      ;[20,2]
||      ADD     .S2     B_xl20,     B_xl1,      B_yt2           ;[10,3]
||      ADD     .L1     A_xh20,     A_xh0,      A_y_h1_0        ;[10,3]
||      SUB     .L2X    B_xh2p1,    A_xl2p1,    B_xl21          ;[10,3]
||      ADD     .D1X    B_xh2p1,    A_xl2p1,    A_xh21          ;[10,3]

        MV      .D2X    A_x_1,      B_x__                       ;[21,2]
||      ADD     .S2     B_p4r,      B_p5r,      B_y_l2_0        ;[21,2]
||      ADD     .L1     A_j,        3,          A_j             ;[11,3]
||      MPYHIR  .M2     B_co30,     B_yt2,      B_p4c           ;[11,3]
||      SUB     .L2     B_xl0,      B_xl21,     B_xt2           ;[11,3]
||      ADD     .S1     A_xh21,     A_xh1,      A_y_h1_1        ;[11,3]
||      LDDW    .D1T1   *A_x[A_l1], A_xl1p1:A_xl1p0             ;[ 1,4]
||      MPYSU   .M1     0,          A_pro,      A_pro           ;

        ADDAH   .D2     B_y_l2_0,   B_p45r,     B_y_l2_0        ;[22,2]
||      DOTPNRSU2.M1    A_yt0xt0,   A_co20si20, A_p23c          ;[22,2]
||[!A_ifj]ZERO  .L1     A_j                                     ;[12,3]
||      SHR     .S1     A_y_h1_1,   1,          A_y_h1_1        ;[12,3]
||      MPYHIR  .M2     B_si30,     B_yt2,      B_p5r           ;[12,3]
||      PACKH2  .S2     B_yt2,      B_xt2,      B_yt2xt2        ;[12,3]
||      ADD     .L2     B_xl21,     B_xl0,      B_xt1           ;[12,3]
||      LDDW    .D1T2   *A_x[0],    B_xp1:B_xp0                 ;[ 2,4]

        ADDAH   .D2     B_y_l2_1,   B_p45c,     B_y_l2_1        ;[23,2]
||      SUB     .L1     A_p2c,      A_p3c,      A_y_l1_1        ;[23,2]
||      DOTPRSU2.M1     A_yt0xt0,   A_si20co20, A_p23r          ;[23,2]
||      MPYHIR  .M2     B_si30,     B_xt2,      B_p5c           ;[13,3]
||      MV      .S1X    B_si10,     A_si10                      ;[13,3]
||      PACK2   .L2     B_si30,     B_co30,     B_si30co30      ;[13,3]
||      SUB     .S2     B_xl1,      B_xl20,     B_yt1           ;[13,3]
||      LDDW    .D1T2   *A_x[A_h2], B_xh2p1:B_xh2p0             ;[ 3,4]

        ADD     .L2     B_pro,      B_pro,      B_pro           ;[34,1]
||      ADD     .D2X    B_p0r,      A_p1r,      B_y_h2_0        ;[24,2]
||      DOTPRSU2.M2     B_yt2xt2,   B_si30co30, B_p45r          ;[14,3]
||      MPYHIR  .M1X    A_si10,     B_xt1,      A_p1c           ;[14,3]
||      PACKH2  .S2     B_yt1,      B_xt1,      B_yt1xt1        ;[14,3]
||      SUB     .L1     A_xh1,      A_xh21,     A_yt0           ;[14,3]
||      SUB     .S1     A_xh0,      A_xh20,     A_xt0           ;[14,3]
||      LDDW    .D1T1   *A_x[A_l2], A_xl2p1:A_xl2p0             ;[ 4,4]

; ============================ PIPE LOOP EPILOG ==============================
        ADD     .S1     A_p2r,      A_p3r,      A_y_l1_0        ;
||      ADDAH   .D2     B_y_h2_0,   B_p01r,     B_y_h2_0        ;[25,4]
||      CMPGTU  .L1     A_stride,   A_radix,    A_whl           ;

        STDW    .D2T2   B_y_l2_1:B_y_l2_0,      *B_x__[B_l2]    ;[26,4]
||      ADDAH   .D1     A_y_l1_1,   A_p23c,     A_y_l1_1        ;[26,4]
||      SUB     .S2X    B_p0c,      A_p1c,      B_y_h2_1        ;
||[A_whl]B      .S1     LOOP_WHILE                              ;} end while

        ADDAH   .D2     B_y_h2_1,   B_p01c,     B_y_h2_1        ;[27,4]
||      ADDAH   .D1     A_ptr_w,    A_tw_offset,A_w0            ;
||      SHRU    .S1     A_stride,   2,          A_h2            ;[ 6,0]

        NOP             1
||      ADDAH   .D1     A_h2,       A_h2,       A_l2            ;[ 7,0]
||      MVK     .L1     1,          A_pro                       ;
||      MVK     .L2     1,          B_pro                       ;[11,0]

        STDW    .D2T2   B_y_h2_1:B_y_h2_0,      *B_x__[B_h2]    ;[29,4]
||      ADDAH   .D1     A_y_l1_0,   A_p23r,     A_y_l1_0        ;[29,4]
||      ADD     .L2X    A_w0,       8,          B_w1            ;[ 8,0]
||      MPYSU   .M1     6,          A_stride,   A_fft_jmp       ;
||      SHRU    .S1     A_stride,   1,          A_l1            ;[10,0]

        STDW    .D2T1   A_y_l1_1:A_y_l1_0,      *B_x__[B_l1]    ;[30,4]

        NOP             1
||      MV      .L2X    A_l2,       B_l2                        ;[ 9,0]
||      SHL     .S2     B_pro,      30,         B_pro           ;[11,0]
||      LDDW    .D1T1   *A_ptr_x[A_l1], A_xl1p1:A_xl1p0         ;

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A14,        A_radix
        .asg            A6,         A_ptr_x
        .asg            B6,         B_ptr_y
        .asg            B4,         B_n
        .asg            A0,         A_r2
        .asg            A20,        A_p_x0
        .asg            B8,         B_p_x0
        .asg            B21,        B_p_y0
        .asg            B22,        B_p_y2
        .asg            B23,        B_p_y1
        .asg            B3,         B_p_y3
        .asg            B20,        B_l1
        .asg            B19,        B_j0
        .asg            A18,        A_i
        .asg            B9,         B_j
        .asg            A1,         A_pro                       ;
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B9,         B_j
        .asg            A18,        A_i
        .asg            B19,        B_j0
        .asg            B20,        B_l1
        .asg            B21,        B_p_y0
        .asg            B23,        B_p_y1
        .asg            B22,        B_p_y2
        .asg            B3,         B_p_y3
        .asg            A20,        A_p_x0
        .asg            B8,         B_p_x0
        .asg            A0,         A_r2
        .asg            B25,        B_h0
        .asg            B7,         B_h1
        .asg            B7,         B_h2
        .asg            B5,         B_h3
        .asg            B16,        B_h4
        .asg            A7,         A_x1
        .asg            A6,         A_x0
        .asg            B29,        B_x3
        .asg            B28,        B_x2
        .asg            A5,         A_x5
        .asg            A4,         A_x4
        .asg            B5,         B_x7
        .asg            B4,         B_x6
        .asg            A21,        A_xh0_0
        .asg            A3,         A_xh1_0
        .asg            B24,        B_xh0_1
        .asg            B26,        B_xh1_1
        .asg            B24,        B_y0
        .asg            B25,        B_y1
        .asg            B6,         B_y4
        .asg            B7,         B_y5
        .asg            A16,        A_xl0_0
        .asg            A19,        A_xl1_0
        .asg            B18,        B_xl0_1
        .asg            B17,        B_xl1_1
        .asg            A16,        A_y2
        .asg            A17,        A_y3
        .asg            A8,         A_y6
        .asg            A9,         A_y7
        .asg            A22,        A_temp
; ============================ PIPE LOOP PROLOG ==============================
        NORM    .L2     B_n,        B_l1                        ;[ 2,0]
||      MV      .D2     B_ptr_y,    B_p_y0                      ;[ 2,0]
||      MVK     .L1     1,          A_pro                       ;

        ZERO    .L2     B_j                                     ;[ 3,0]
||      SUB     .D1     A_radix,    2,          A_r2            ;[ 3,0]
||      ADD     .S2     B_l1,       2,          B_l1            ;[ 3,0]
||      ADDAW   .D2     B_p_y0,     B_n,        B_p_y2          ;[ 3,0]

        MVK     .S2     4,          B_j0                        ;[ 4,0]
||[!A_r2]NORM   .L2     B_n,        B_l1                        ;[ 4,0]
||      ADDAH   .D2     B_p_y2,     B_n,        B_p_y3          ;[ 4,0]
||      SHL     .S1     A_pro,      15,         A_pro           ;

        SHRU    .S1X    B_n,        2,          A_i             ;[ 5,0]
||[!A_r2]MVK    .S2     8,          B_j0                        ;[ 5,0]
||[!A_r2]ADD    .L2     B_l1,       1,          B_l1            ;[ 5,0]
||      ADDAH   .D2     B_p_y0,     B_n,        B_p_y1          ;[ 5,0]

  [!A_r2]ADD    .S2     B_p_y2,     B_n,        B_p_y3          ;[ 6,0]
||[!A_r2]ADD    .L2     B_p_y0,     B_n,        B_p_y1          ;[ 6,0]
||      ADD     .D2X    A_ptr_x,    8,          B_p_x0          ;[ 6,0]
||      MV      .L1     A_ptr_x,    A_p_x0                      ;[ 6,0]
; ============================ PIPE LOOP KERNEL ==============================
LOOP_Z:
  [!A_r2]ROTL   .M1     A_x4,       0,          A_xl0_0         ;[13,1]
||      SUB     .L1X    A_xl1_0,    B_xl0_1,    A_y3            ;[13,1]
||      ADD     .S2X    A_xh1_0,    B_xh1_1,    B_y1            ;[13,1]
||      BDEC    .S1     LOOP_Z,     A_i                         ;[13,1]
||      ADD     .L2     B_j,        B_j0,       B_j             ;[ 1,3]
||      LDDW    .D2T2   *B_p_x0++[2],           B_x3:B_x2       ;[ 1,3]
||      LDDW    .D1T1   *A_p_x0++[2],           A_x1:A_x0       ;[ 1,3]
||      DEAL    .M2     B_j,        B_h0                        ;[ 1,3]

 [!A_pro]STDW   .D2T2   B_y1:B_y0,  *B_p_y0[B_h4]               ;[14,1]
||      MV      .S1     A_y3,       A_temp                      ;[14,1]
||      ADD     .L1X    A_xl1_0,    B_xl0_1,    A_y7            ;[14,1]
||      SUB     .L2     B_x2,       B_x6,       B_xl0_1         ;[ 8,2]
||      ADD     .S2     B_x6,       B_x2,       B_xh0_1         ;[ 8,2]
||      ADD     .D1     A_x4,       A_x0,       A_xh0_0         ;[ 8,2]
||[!A_r2]ROTL   .M1     A_x0,       0,          A_xh0_0         ;[ 8,2]
||[!A_r2]ROTL   .M2     B_x2,       0,          B_xh0_1         ;[ 8,2]

        SUB     .L1X    A_xl0_0,    B_xl1_1,    A_y6            ;[15,1]
||      SUB     .L2X    A_xh1_0,    B_xh1_1,    B_y5            ;[15,1]
||      ADD     .S1     A_x5,       A_x1,       A_xh1_0         ;[ 9,2]
||[!A_r2]ROTL   .M1     A_x1,       0,          A_xh1_0         ;[ 9,2]
||[!A_r2]MV     .S2     B_x7,       B_xl0_1                     ;[ 9,2]
||      SHFL    .M2     B_h2,       B_h3                        ;[ 9,2]
||      LDDW    .D1T1   *A_p_x0++[2],           A_x5:A_x4       ;[ 3,3]
||      LDDW    .D2T2   *B_p_x0++[2],           B_x7:B_x6       ;[ 3,3]

        ADD     .S1X    A_xl0_0,    B_xl1_1,    A_y2            ;[16,1]
||[!A_r2]MV     .D1     A_y7,       A_y3                        ;[16,1]
||[!A_pro]STDW  .D2T2   B_y5:B_y4,  *B_p_y2[B_h4]               ;[16,1]
||      SUB     .L1     A_x1,       A_x5,       A_xl1_0         ;[10,2]
||[!A_r2]ROTL   .M1     A_x5,       0,          A_xl1_0         ;[10,2]
||      ADD     .S2     B_x7,       B_x3,       B_xh1_1         ;[10,2]
||      SUB     .L2     B_x3,       B_x7,       B_xl1_1         ;[10,2]
||      BITR    .M2     B_h0,       B_h1                        ;[ 4,3]

  [!A_r2]MV     .L1     A_temp,     A_y7                        ;[17,1]
||[!A_pro]STDW  .D2T1   A_y3:A_y2,  *B_p_y1[B_h4]               ;[17,1]
||      SUB     .D1     A_x0,       A_x4,       A_xl0_0         ;[11,2]
||      ADD     .L2X    A_xh0_0,    B_xh0_1,    B_y0            ;[11,2]
||      SUB     .S2X    A_xh0_0,    B_xh0_1,    B_y4            ;[11,2]
||[!A_r2]ROTL   .M2     B_x3,       0,          B_xh1_1         ;[11,2]

 [!A_pro]STDW   .D2T1   A_y7:A_y6,  *B_p_y3[B_h4]               ;[18,1]
||      SHRU    .S2     B_h3,       B_l1,       B_h4            ;[12,2]
||[!A_r2]MV     .L2     B_x6,       B_xl1_1                     ;[12,2]
||      ROTL    .M2     B_h1,       16,         B_h2            ;[ 6,3]
||      MPYSU   .M1     2,          A_pro,      A_pro           ;10000
||      MV      .S1X    B_SP,       A_SP        ; Twin Stack Pointer
; ============================ PIPE LOOP EPILOG ==============================
        LDW     .D1T2   *+A_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr       ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10         ; Restore A10

        LDW     .D1T2   *+A_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11         ; Restore A11

        LDW     .D1T2   *+A_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12         ; Restore A12

        LDW     .D1T2   *+A_SP[ 9], B13         ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13         ; Restore A13

        LDW     .D1T2   *+A_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14         ; Restore A14

        LDW     .D2T1   *++B_SP[14],A15         ; Restore A15
||      BNOP    .S2     B_ret, 4                ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
*====== Interruptibility state restored
;====== Branch Occurs =====

*==============================================================================*
*=  End of file:  dsp_fft32x32s.asm                                           =*
*==============================================================================*
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*==============================================================================*
fir_cplx.asm/   1061588610  0     0     0       21477     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.10    Sun Mar 10 01:00:59 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_fir_cplx -- Hand-Coded Assembly code for                        *
*       Complex Filter.                                                     *
*                                                                           *
*   REVISION DATE                                                           *
*       06-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fir_cplx                                                   *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short       *restrict r,                                        *
*           short                 nh,                                       *
*           short                 nr                                        *
*      )                                                                    *
*                                                                           *
*      x[2*(nr+nh-1)] : Complex input data. x must point to x[2*(nh-1)].    *
*      h[2*nh]        : Complex coefficients (in normal order).             *
*      r[2*nr]        : Complex output data.                                *
*      nh             : Number of complex coefficients.                     *
*                       Must be multiple of 2.                              *
*      nr             : Number of complex output samples.                   *
*                       Must be multiple of 4.                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This complex FIR computes nr complex output samples using nh        *
*       complex coefficients. It operates on 16-bit data with a 32-bit      *
*       accumulate. Each array consists of an even and odd term with even   *
*       terms representing the real part of the element and the odd terms   *
*       the imaginary part. The pointer to input array x must point to the  *
*       (nh)th complex sample, i.e. element 2*(nh-1), upon entry to the     *
*       function. The coefficients are expected in normal order.            *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_fir_cplx                                                   *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short *restrict r,                                              *
*           short nh,                                                       *
*           short nr                                                        *
*       )                                                                   *
*       {                                                                   *
*           short i,j;                                                      *
*           int imag, real;                                                 *
*                                                                           *
*           for (i = 0; i < 2*nr; i += 2)                                   *
*           {                                                               *
*               imag = 0;                                                   *
*               real = 0;                                                   *
*               for (j = 0; j < 2*nh; j += 2)                               *
*               {                                                           *
*                   real += h[j] * x[i-j]   - h[j+1] * x[i+1-j];            *
*                   imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];              *
*               }                                                           *
*               r[i]   = (real >> 15);                                      *
*               r[i+1] = (imag >> 15);                                      *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Outer loop is unrolled 4 times while inner loop is not unrolled.    *
*       Both inner and outer loops are collapsed into one loop.             *
*       ADDAH and SUBAH are used alongwith PACKH2 to perform accumulation,  *
*       shift and data packing.                                             *
*       Collpsed one stage of epilog and prolog each.                       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nr must be a multiple of 4 and >= 4.                                *
*       nh must be a multiple of 2 and >= 2.                                *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No memory bank hits under any conditions.                           *
*                                                                           *
*   NOTE                                                                    *
*       This function is little Endian.                                     *
*       This function is interrupt-tolerant but not interruptible.          *
*                                                                           *
*   CYCLES                                                                  *
*       nh * nr + 24                                                        *
*                                                                           *
*       For nh = 24, nr = 40, 984 cycles                                    *
*                                                                           *
*   CODESIZE                                                                *
*      432 bytes                                                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_fir_cplx
_DSP_fir_cplx:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            B0,         B_i
        .asg            B1,         B_c
        .asg            B4,         B_tapadd
        .asg            A8,         A_nx
        .asg            A20,        A_tapadd
        .asg            B16,        B_inadd
        .asg            A4,         A_inadd
        .asg            A19,        A_niter
        .asg            A17,        A_savetapadd
        .asg            A21,        A_temp
        .asg            A6,         A_outadd
        .asg            B18,        B_outadd
        .asg            A31,        A_imag0
        .asg            A30,        A_real0
        .asg            A29,        A_imag1
        .asg            A28,        A_real1
        .asg            B6,         B_nh
        .asg            A25,        A_h1
        .asg            A24,        A_h0
        .asg            B27,        B_h1
        .asg            B26,        B_h0
        .asg            A22,        A_xn_1
        .asg            B25,        B_xn3
        .asg            B24,        B_xn2
        .asg            A27,        A_xn1
        .asg            A26,        A_xn0
        .asg            B19,        B_st_
        .asg            B2,         B_s
        .asg            A18,        A_0h
        .asg            A25,        A_1h
        .asg            B23,        B_0h
        .asg            B17,        B_1h
        .asg            A23,        A_tempr0
        .asg            A9,         A_tempr1
        .asg            B24,        B_tempr2
        .asg            B27,        B_tempr3
        .asg            A16,        A_rtemp0
        .asg            A27,        A_rtemp1
        .asg            B20,        B_rtemp2
        .asg            B21,        B_rtemp3
        .asg            A9,         A_tempi0
        .asg            A26,        A_tempi1
        .asg            B25,        B_tempi2
        .asg            B22,        B_tempi3
        .asg            A23,        A_itemp0
        .asg            A7,         A_itemp1
        .asg            B9,         B_itemp2
        .asg            B20,        B_itemp3
        .asg            A16,        A_real0x
        .asg            A27,        A_real1x
        .asg            B24,        B_real2x
        .asg            B27,        B_real3x
        .asg            A27,        A_imag0x
        .asg            A18,        A_imag1x
        .asg            B9,         B_imag2x
        .asg            B22,        B_imag3x
        .asg            B28,        B_real2
        .asg            B30,        B_real3
        .asg            B29,        B_imag2
        .asg            B31,        B_imag3
        .asg            A22,        A_stor0
        .asg            A23,        A_stor1
        .asg            B22,        B_stor2
        .asg            B23,        B_stor3
        .asg            B3,         B_ret
        .asg            B5,         B_csr
        .asg            B7,         B_no_gie

* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        LDNDW   .D2T1   *B_tapadd,       A_h1:A_h0                    ;[ 1,1]
||      SHR     .S2     B_nh,            1,            B_nh           ;
||      SHR     .S1     A_nx,            2,            A_nx           ;

        LDNW    .D1T1   *-A_inadd[1],    A_xn_1                       ;[ 2,1]
||      SUB     .L2     B_nh,            1,            B_i            ;
||      MV      .S1X    B_tapadd,        A_tapadd                     ;
||      ADD     .D2X    A_outadd,        8,            B_outadd       ;
||      ZERO    .L1     A_imag1:A_real1                               ;
||      MVC     .S2     CSR,             B_csr                        ;

        LDNDW   .D1T1   *A_inadd--,      A_xn1:A_xn0                  ;[ 3,1]
||      MV      .D2X    A_inadd,         B_inadd                      ;
||      AND     .L2     B_csr,           -2,           B_no_gie       ;
||      MPY     .M1X    A_nx,            B_nh,         A_niter        ;
||      SHL     .S1X    B_nh,            3,            A_temp         ;

        MV      .D1     A_tapadd,        A_savetapadd                 ;
||      MVC     .S2     B_no_gie,        CSR                          ;Mask int.

        LDNDW   .D1T2   *A_tapadd++,     B_h1:B_h0                    ;[ 5,1]
        SUB     .L1     A_niter,         2,            A_niter        ;
||      ADDK    .S1     16,              A_temp                       ;
||      ZERO    .L2     B_imag2:B_real2                               ;

        ZERO    .L2     B_imag3:B_real3                               ;

        DOTPN2  .M1     A_h1,            A_xn_1,       A_rtemp0       ;[ 7,1]
||[!B_i]ADD     .D1     A_inadd,         A_temp,       A_inadd        ;[ 7,1]
||      ZERO    .L1     A_imag0:A_real0
||      LDNDW   .D2T2   *+B_inadd[1],    B_xn3:B_xn2                  ;[ 7,1]

        DOTPN2  .M1     A_h0,            A_xn1,        A_tempr1       ;[ 8,1]
||[!B_i]MV      .L1     A_savetapadd,    A_tapadd                     ;[ 8,1]
||      MVK     .S2     1,               B_c                          ;pred.


* =========================== PIPE LOOP KERNEL ============================ *
out_loop:
  [!B_c]DOTPN2  .M2     B_h0,            B_xn3,         B_tempr3      ;[17,1]
||      OR      .L2     B_st_,           B_c,           B_s           ;[17,1]
||      DOTPN2  .M1     A_h1,            A_xn0,         A_rtemp1      ;[ 9,2]
||      SWAP2   .L1     A_h1,            A_1h                         ;[ 9,2]
||      SWAP2   .S1     A_h0,            A_0h                         ;[ 9,2]
||      MV      .S2X    A_inadd,         B_inadd                      ;[ 9,2]
||      MV      .D2     B_i,             B_st_                        ;[ 9,2]
||      LDNDW   .D1T1   *A_tapadd,       A_h1:A_h0                    ;[ 1,3]

  [!B_c]SUBAH   .D1     A_real0,         A_real0x,      A_real0       ;[18,1]
||[!B_c]ADD     .L2     B_tempr2,        B_rtemp2,      B_real2x      ;[18,1]
||      DOTP2   .M1     A_1h,            A_xn0,         A_itemp1      ;[10,2]
||      DOTPN2  .M2X    B_h1,            A_xn1,         B_rtemp2      ;[10,2]
||      SWAP2   .S2     B_h1,            B_1h                         ;[10,2]
||      LDNW    .D2T1   *-B_inadd[1],    A_xn_1                       ;[ 2,3]

        BDEC    .S1     out_loop,        A_niter                      ;[19,1]
||[!B_c]SUBAH   .D2     B_real2,         B_real2x,      B_real2       ;[19,1]
||[!B_c]ADD     .S2     B_tempi2,        B_itemp2,      B_imag2x      ;[19,1]
||[!B_c]ADD     .L1     A_tempi0,        A_itemp0,      A_imag0x      ;[19,1]
||      DOTP2   .M2X    B_1h,            A_xn1,         B_itemp2      ;[11,2]
||      DOTP2   .M1     A_0h,            A_xn1,         A_tempi1      ;[11,2]
||      SWAP2   .L2     B_h0,            B_0h                         ;[11,2]
||      LDNDW   .D1T1   *A_inadd--,      A_xn1:A_xn0                  ;[ 3,3]

  [!B_c]PACKH2  .L1     A_imag1,         A_real1,       A_stor1       ;[20,1]
||[!B_c]ADDAH   .D2     B_imag2,         B_imag2x,      B_imag2       ;[20,1]
||[!B_c]ADDAH   .D1     A_imag0,         A_imag0x,      A_imag0       ;[20,1]
||[!B_c]ADD     .S2     B_tempi3,        B_itemp3,      B_imag3x      ;[20,1]
||      DOTPN2  .M2     B_h1,            B_xn2,         B_rtemp3      ;[12,2]
||      DOTPN2  .M1     A_h0,            A_xn0,         A_tempr0      ;[12,2]
||[!B_i]MV      .L2     B_nh,            B_i                          ;[12,2]

  [!B_s]ZERO    .L1     A_imag0:A_real0                               ;[21,1]
||[!B_c]PACKH2  .S2     B_imag2,         B_real2,       B_stor2       ;[21,1]
||[!B_c]PACKH2  .S1     A_imag0,         A_real0,       A_stor0       ;[21,1]
||[!B_c]ADDAH   .D2     B_imag3,         B_imag3x,      B_imag3       ;[21,1]
||[!B_c]ADD     .L2     B_tempr3,        B_rtemp3,      B_real3x      ;[21,1]
||      DOTP2   .M1     A_1h,            A_xn_1,        A_itemp0      ;[13,2]
||      DOTPN2  .M2     B_h0,            B_xn2,         B_tempr2      ;[13,2]
||      LDNDW   .D1T2   *A_tapadd++,     B_h1:B_h0                    ;[ 5,3]

  [!B_s]ZERO    .L2     B_imag2:B_real2                               ;[22,1]
||[!B_s]ZERO    .L1     A_imag1:A_real1                               ;[22,1]
||[!B_s]STNDW   .D1T1   A_stor1:A_stor0, *A_outadd++[2]               ;[22,1]
||[!B_c]SUBAH   .D2     B_real3,         B_real3x,      B_real3       ;[22,1]
||      ADD     .S1     A_tempr1,        A_rtemp1,      A_real1x      ;[14,2]
||      DOTP2   .M2     B_0h,            B_xn2,         B_tempi2      ;[14,2]
||      DOTP2   .M1     A_0h,            A_xn0,         A_tempi0      ;[14,2]
||      SUB     .S2     B_i,             1,             B_i           ;[ 6,3]

  [!B_s]ZERO    .L2     B_imag3:B_real3                               ;[23,1]
||[!B_c]PACKH2  .S2     B_imag3,         B_real3,       B_stor3       ;[23,1]
||      SUBAH   .D1     A_real1,         A_real1x,      A_real1       ;[15,2]
||      ADD     .S1     A_tempi1,        A_itemp1,      A_imag1x      ;[15,2]
||      DOTP2   .M2     B_0h,            B_xn3,         B_tempi3      ;[15,2]
||      DOTPN2  .M1     A_h1,            A_xn_1,        A_rtemp0      ;[ 7,3]
||[!B_i]ADD     .L1     A_inadd,         A_temp,        A_inadd       ;[ 7,3]
||      LDNDW   .D2T2   *+B_inadd[1],    B_xn3:B_xn2                  ;[ 7,3]

  [!B_s]STNDW   .D2T2   B_stor3:B_stor2, *B_outadd++[2]               ;[24,1]
||      ADDAH   .D1     A_imag1,         A_imag1x,      A_imag1       ;[16,2]
||      ADD     .S1     A_tempr0,        A_rtemp0,      A_real0x      ;[16,2]
||      DOTP2   .M2     B_1h,            B_xn2,         B_itemp3      ;[16,2]
||      DOTPN2  .M1     A_h0,            A_xn1,         A_tempr1      ;[ 8,3]
||[!B_i]MV      .L1     A_savetapadd,    A_tapadd                     ;[ 8,3]
||      ZERO    .L2     B_c
* =========================== PIPE LOOP EPILOG ============================ *
        DOTPN2  .M2     B_h0,            B_xn3,         B_tempr3      ;[17,3]

        SUBAH   .D1     A_real0,         A_real0x,      A_real0       ;[18,3]
||      ADD     .L2     B_tempr2,        B_rtemp2,      B_real2x      ;[18,3]

        B       .S2     B_ret
||      SUBAH   .D2     B_real2,         B_real2x,      B_real2       ;[19,3]
||      ADD     .L2     B_tempi2,        B_itemp2,      B_imag2x      ;[19,3]
||      ADD     .L1     A_tempi0,        A_itemp0,      A_imag0x      ;[19,3]

        PACKH2  .L1     A_imag1,         A_real1,       A_stor1       ;[20,3]
||      ADDAH   .D2     B_imag2,         B_imag2x,      B_imag2       ;[20,3]
||      ADDAH   .D1     A_imag0,         A_imag0x,      A_imag0       ;[20,3]
||      ADD     .S2     B_tempi3,        B_itemp3,      B_imag3x      ;[20,3]

        PACKH2  .S2     B_imag2,         B_real2,       B_stor2       ;[21,3]
||      PACKH2  .S1     A_imag0,         A_real0,       A_stor0       ;[21,3]
||      ADDAH   .D2     B_imag3,         B_imag3x,      B_imag3       ;[21,3]
||      ADD     .L2     B_tempr3,        B_rtemp3,      B_real3x      ;[21,3]

        STNDW   .D1T1   A_stor1:A_stor0, *A_outadd                    ;[22,3]
||      SUBAH   .D2     B_real3,         B_real3x,      B_real3       ;[22,3]
||      MVC     .S2     B_csr,           CSR                          ;Int.
        PACKH2  .S2     B_imag3,         B_real3,       B_stor3       ;[23,3]

        STNDW   .D2T2   B_stor3:B_stor2, *B_outadd                    ;[24,3]

* ========================================================================= *
*   End of file:  dsp_fir_cplx.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

fir_gen.asm/    1061588650  0     0     0       26264     `
;12-Jun-2003 Fixed GIE bug

;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.03                                        *;
;*      CVS Revision:   1.5     Sun Sep 29 03:26:45 2002 (UTC)              *;
;*      Snapshot date:  28-Oct-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       fir_gen: FIR Filter (general purpose)                               *
*                                                                           *
*   USAGE                                                                   * 
*       This routine is C-callable and can be called as:                    * 
*                                                                           * 
*       void fir_gen                                                        * 
*       (                                                                   * 
*           const short *restrict x,  /* Input ('nr + nh - 1' samples) */   * 
*           const short *restrict h,  /* Filter coefficients (nh taps) */   * 
*           short       *restrict r,  /* Output array ('nr' samples)   */   * 
*           int                   nh, /* Length of filter (nh >= 5)    */   * 
*           int                   nr  /* Length of output (nr >= 1)    */   * 
*       );                                                                  * 
*                                                                           * 
*   C CODE                                                                  * 
*                                                                           * 
*       This is the C equivalent of the assembly code. Note that the        * 
*       assembly code is hand optimized and restrictions may apply.         * 
*                                                                           * 
*       void fir_gen                                                        * 
*       (                                                                   * 
*           const short *restrict x,  /* Input ('nr + nh - 1' samples) */   * 
*           const short *restrict h,  /* Filter coefficients (nh taps) */   * 
*           short       *restrict r,  /* Output array ('nr' samples)   */   * 
*           int                   nh, /* Length of filter (nh >= 5)    */   * 
*           int                   nr  /* Length of output (nr >= 1)    */   * 
*       )                                                                   * 
*       {                                                                   * 
*           int i, j, sum;                                                  * 
*                                                                           * 
*           for (j = 0; j < nr; j++)                                        * 
*           {                                                               * 
*               sum = 0;                                                    * 
*               for (i = 0; i < nh; i++)                                    * 
*                   sum += x[i + j] * h[i];                                 * 
*                                                                           * 
*               r[j] = sum >> 15;                                           * 
*           }                                                               * 
*       }                                                                   * 
*                                                                           * 
*   DESCRIPTION                                                             * 
*       Computes a real FIR filter (direct-form) using coefficients         * 
*       stored in vector h. The real data input is stored in vector x.      * 
*       The filter output result is stored in vector r. This FIR            * 
*       assumes the number of filter coefficients is greater than or        * 
*       equal to 5. It operates on 16-bit data with a 32-bit                * 
*       accumulate. This routine has no memory hits regardless of where     * 
*       x, h, and r arrays are located in memory. The filter is nr          * 
*       output samples and nh coefficients. The assembly routine            * 
*       performs 4 output samples at a time.                                * 
*                                                                           * 
*   TECHNIQUES                                                              * 
*       1. Load double word instruction is used to simultaneously load      * 
*          four values in a single clock cycle.                             * 
*                                                                           * 
*       2. The inner loop is unrolled four times and will always            * 
*          compute a multiple of 4 of nh and nr. If nh % 4 != 0, the        * 
*          code will fill in 0s to make nh a multiple of 4. If nr % 4       * 
*          != 0, the code will still perform a mutiple of 4 outputs.        * 
*                                                                           * 
*       3. Both the inner and outer loops are software pipelined.           * 
*                                                                           * 
*       4. This code yields best performance when ratio of outer            * 
*          loop to inner loop is less than or equal to 4.                   * 
*                                                                           * 
*   ASSUMPTIONS                                                             * 
*       1. Little Endian is assumed for LDNDW.                              * 
*       2. nh >= 5.                                                         * 
*       3. nr multiple of 4.                                                * 
*       4. Output array r[] must be word-aligned                            * 
*                                                                           * 
*   MEMORY NOTE                                                             * 
*       No memory bank hits under any conditions.                           * 
*       Little Endian operation is assumed.                                 * 
*                                                                           * 
*   CYCLES                                                                  * 
*       [11 + 4 * ceil(nh/4)] * nr/4 + 15                                   * 
*                                                                           * 
*   CODESIZE                                                                * 
*       544  bytes                                                          * 
*                                                                           * 
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_fir_gen
_DSP_fir_gen:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS =====================*
        .asg            A4,         A_x        ; Input data pointer
        .asg            A27,        A_xptr     ; Input load pointer
        .asg            B4,         B_hptr     ; Filter pointer
        .asg            A6,         A_rptr     ; Output pointer
        .asg            B6,         B_nh       ; # Filter taps
        .asg            A8,         A_nr       ; # Output samples
        .asg            A7,         A_ptr_x    ; Input read pointer
        .asg            A22,        A_h10      ; Packed coefficient h10
        .asg            A23,        A_h32      ; Packed coefficient h32
        .asg            B22,        B_h10      ; Packed coefficient h10
        .asg            B23,        B_h32      ; Packed coefficient h32
        .asg            A4,         A_sum0     ; Accum. for sample# 0
        .asg            A5,         A_sum1     ; Accum. for sample# 1
        .asg            B8,         B_sum2     ; Accum. for sample# 2
        .asg            B9,         B_sum3     ; Accum. for sample# 3
        .asg            B6,         B_x54      ; Input samples x54
        .asg            B7,         B_x76      ; Input samples x76
        .asg            A3,         A_hptr     ; Filter pointer
        .asg            A0,         A_i        ; Index variable i
        .asg            B24,        B_h32_n    ; Special filter
        .asg            B25,        B_h10_n    ; words h32, h10
        .asg            B26,        B_optr     ; Output twin pointers
        .asg            A26,        A_optr     ; Output twin pointers
        .asg            B27,        B_ptr      ; 
        .asg            A28,        A_ofs      ; 
        .asg            B28,        B_nh_l     ; 
        .asg            B0,         B_j        ; Outer loop trip cnt.
;---------------------------------------------------------------------------
        .asg            B1,         B_m        ;
        .asg            B2,         B_3        ;
        .asg            B0,         B_2        ;
        .asg            B1,         B_1        ;
        .asg            B5,         B_ofs      ;
        .asg            A16,        A_nr_l     ;
        .asg            A9,         A_it_i     ;
        .asg            A29,        A_nh_l     ;
        .asg            B30,        B_csr      ; CSR
        .asg            B31,        B_no_gie   ; NO GIE
* ========================================================================= *

        AND     .D2     3,          B_nh,       B_m       ; mask = nh & 3
||      MV      .L1     A_x,        A_xptr                ; xptr = x
||      MVC     .S2     CSR,        B_csr                 ; CSR

  [!B_m]MVK     .L2     4,          B_m                   ; mask = 4
     
        SUB     .S2     B_nh,       B_m,        B_ofs     ; ofs = nh - m
||      AND     .L2     B_csr,      -2,         B_no_gie  ; NO GIE

        ADDAH   .D2     B_hptr,     B_ofs,      B_ptr     ; ptr = &h[ofs]
||      MVC     .S2     B_no_gie,   CSR                   ; Interr. masked

;-- Interrupts masked here

        LDNDW   .D2T2   *B_ptr--,   B_h32:B_h10           ; Load h32:h10
||      ADD     .L1     A_nr,       3,          A_nr_l    ; nr + 3
||      ADD     .S2     B_nh,       3,          B_nh_l    ; nh + 3

        SHRU    .S1     A_nr_l,     2,          A_nr_l    ; nr_l >> 2
||      CMPEQ   .L2     3,          B_m,        B_3       ; m == 3
||      SHRU    .S2     B_nh_l,     2,          B_nh_l    ; nr_h >> 2

        ADD     .D2X    A_rptr,     4,          B_optr    ; optr = &r[4]
||      MV      .L1X    B_nh_l,     A_nh_l                ; copy.
||      CMPEQ   .L2     1,          B_m,        B_1       ; m == 1

        ADD     .D1X    B_ofs,      4,          A_ofs     ; ofs + 4

        ADD     .S1     A_ofs,      A_ofs,      A_ofs     ; ADDAH
                                                                
        ADD     .L1     A_xptr,     A_ofs,      A_ptr_x   ; xptr + ofs
||      CMPEQ   .L2     2,          B_m,        B_2       ; m == 2
||[ B_3]CLR     .S2     B_h32,      16, 31,     B_h32     ; h32 = 00XX

        LDNDW   .D1T2   *A_ptr_x--, B_x76:B_x54           ; x76:x54
||      ADD     .L1     A_rptr,     0,          A_optr    ; optr= r
||[ B_1]CLR     .S2     B_h10,      16, 31,     B_h10     ; h10 = 00XX
||[ B_1]ZERO    .L2     B_h32                             ; h32 = 0
||[ B_2]ZERO    .D2     B_h32                             ; h32 = 0


* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A7,         A_ptr_x             ; Input data ptr
        .asg            A22,        A_h10               ; Packed h10
        .asg            A23,        A_h32               ; Packed h32
        .asg            B22,        B_h10               ; Packed h10
        .asg            B23,        B_h32               ; Packed h32
        .asg            A4,         A_sum0              ; Accumulators
        .asg            A5,         A_sum1              ; for 4 o/p
        .asg            B8,         B_sum2              ; samples
        .asg            B9,         B_sum3              ; 
        .asg            B6,         B_x54               ; 
        .asg            B7,         B_x76               ; 
        .asg            A3,         A_hptr              ; Filter ptr
        .asg            A0,         A_i                 ;
        .asg            B17,        B_r32               ;
        .asg            A20,        A_sum0_s            ;
        .asg            A17,        A_sum1_s            ;
        .asg            A21,        A_x32               ;
        .asg            A20,        A_x10               ;
        .asg            A19,        A_x21               ;
        .asg            B17,        B_x43               ;
        .asg            B5,         B_x65               ;
        .asg            A17,        A_prod0_10          ;
        .asg            A16,        A_prod0_32          ;
        .asg            A16,        A_prod2_10          ;
        .asg            A9,         A_prod2_32          ;
        .asg            B16,        B_prod1_10          ;
        .asg            B20,        B_prod1_32          ;
        .asg            B20,        B_prod3_10          ;
        .asg            B19,        B_prod3_32          ;
        .asg            A19,        A_sum0_0            ;
        .asg            A18,        A_sum2_0            ;
        .asg            B16,        B_sum1_0            ;
        .asg            B18,        B_sum3_0            ;
        .asg            B18,        B_sum2_s            ;
        .asg            B19,        B_sum3_s            ;
        .asg            A18,        A_r10               ;
        .asg            B3,         B_return            ; Return address
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        LDNDW   .D1T1   *A_ptr_x--, A_x32:A_x10                 ;[ 1,1] 
||      MV      .L1X    B_ptr,      A_hptr                      ;[20,0] 
||      MV      .S1     A_nh_l,     A_i                         ;[19,0] 
||      MV      .L2     B_h10,      B_h10_n                     ;[15,0] 
||      MV      .S2     B_h32,      B_h32_n                     ;[15,0] 

        SUB     .S1     A_i,        1,          A_i             ;[21,0] 
||      MV      .D1X    B_h32_n,    A_h32                       ;[21,0] 
||      ZERO    .L1     A_prod0_10                              ;[P ,0]
||      SUB     .D2X    A_nr_l,     0,          B_j             ;[13,0] 

        MPY     .M2     B_sum3_0,   0,          B_sum3_0        ;[P, 0]
||      ZERO    .S2     B_prod3_32                              ;[P, 0]
||      ZERO    .D2     B_sum1_0                                ;[P, 0]
||      ZERO    .L1     A_prod0_32                              ;[P, 0]
||      MPY     .M1     A_sum2_0,   0,          A_sum2_0        ;[13,3] 
||      MV      .S1X    B_h10_n,    A_h10                       ;[22,0] 
||      MV      .L2     B_h10_n,    B_h10                       ;[22,0] 
||      ADD     .D1     A_ofs,      8,          A_ofs           ;[22,0] 

LOOPJ:
   [B_j]LDNDW   .D1T1   *A_hptr,    A_h32:A_h10                 ;[ 4,1] 
|| [B_j]ZERO    .S2     B_prod3_10,                             ;[13,3] 
|| [B_j]MPY     .M2     B_prod1_10, 0,          B_prod1_10      ;[ P,0]
|| [B_j]ADD     .S1     A_sum0,     A_prod0_10, A_sum0_0        ;[12,3] 
|| [B_j]MPY     .M1     A_prod0_10, 0,          A_prod0_10      ;[ P,0]
|| [B_j]MV      .D2     B_h32_n,    B_h32                       ;[22,0] 
|| [B_j]ZERO    .L1     A_sum1:A_sum0                           ;[22,0] 
|| [B_j]ZERO    .L2     B_sum3:B_sum2                           ;[22,0] 

 [A_i]  BDEC    .S1     LOOPI,      A_i                         ;[17,1]
||      DOTP2   .M1X    B_x54,      A_h32,      A_prod2_32      ;[ 5,1] 
||      LDNDW   .D1T1   *A_ptr_x--, A_x32:A_x10                 ;[ 1,2] 
||      ZERO    .L1     A_prod2_10                              ;[ P,0]

        MV      .D2X    A_x32,      B_x76                       ;[ 6,1] 
||      LDNDW   .D1T2   *A_hptr--,  B_h32:B_h10                 ;[ 6,1] 
||      DOTP2   .M1     A_x10,      A_h10,      A_prod0_10      ;[ 6,1] 
||      PACKLH2 .S2     B_x76,      B_x54,      B_x65           ;[ 6,1] 
||      PACKLH2 .L2X    B_x54,      A_x32,      B_x43           ;[ 6,1] 
||      PACKLH2 .S1     A_x32,      A_x10,      A_x21           ;[ 6,1] 
||      ZERO    .L1     A_prod2_32                              ;[11,3] 

;
* =========================== PIPE LOOP KERNEL ============================ *
LOOPI:
        SHR     .S2     B_sum2,     15,         B_sum2_s        ;[15,2] 
||      SHR     .S1     A_sum0,     15,         A_sum0_s        ;[15,2] 
||      ADD     .L2     B_sum3_0,   B_prod3_32, B_sum3          ;[15,2] 
||      ADD     .D1X    A_sum1,     B_sum1_0,   A_sum1          ;[15,2] 
||      ADD     .L1     A_prod2_10, A_prod2_32, A_sum2_0        ;[11,3] 
||      MV      .D2X    A_x10,      B_x54                       ;[ 7,4] 
||      DOTP2   .M2     B_x43,      B_h32,      B_prod1_32      ;[ 7,4] 
||      DOTP2   .M1     A_x32,      A_h10,      A_prod2_10      ;[ 7,4] 

        SHR     .S2     B_sum3,     15,         B_sum3_s        ;[16,2] 
||      SHR     .S1     A_sum1,     15,         A_sum1_s        ;[16,2] 
||      ADD     .D2     B_prod1_10, B_prod1_32, B_sum1_0        ;[12,3] 
||      ADD     .L1     A_sum0,     A_prod0_10, A_sum0_0        ;[12,3] 
||      DOTP2   .M2X    A_x21,      B_h10,      B_prod1_10      ;[ 8,4] 
||      DOTP2   .M1     A_x32,      A_h32,      A_prod0_32      ;[ 8,4] 
||      LDNDW   .D1T1   *A_hptr,    A_h32:A_h10                 ;[ 4,5] 

  [ A_i]BDEC    .S1     LOOPI,      A_i                         ;[17,2] 
||      PACK2   .L1     A_sum1_s,   A_sum0_s,   A_r10           ;[17,2] 
||      PACK2   .L2     B_sum3_s,   B_sum2_s,   B_r32           ;[17,2] 
||      ADD     .S2     B_sum3,     B_prod3_10, B_sum3_0        ;[13,3] 
||      ADD     .D2X    B_sum2,     A_sum2_0,   B_sum2          ;[13,3] 
||      DOTP2   .M2     B_x43,      B_h10,      B_prod3_10      ;[ 9,4] 
||      DOTP2   .M1X    B_x54,      A_h32,      A_prod2_32      ;[ 5,5] 
||      LDNDW   .D1T1   *A_ptr_x--, A_x32:A_x10                 ;[ 1,6] 

        ADD     .L1     A_sum0_0,   A_prod0_32, A_sum0          ;[14,3] 
||      DOTP2   .M2     B_x65,      B_h32,      B_prod3_32      ;[10,4] 
||      MV      .D2X    A_x32,      B_x76                       ;[ 6,5] 
||      LDNDW   .D1T2   *A_hptr--,  B_h32:B_h10                 ;[ 6,5] 
||      DOTP2   .M1     A_x10,      A_h10,      A_prod0_10      ;[ 6,5] 
||      PACKLH2 .S2     B_x76,      B_x54,      B_x65           ;[ 6,5] 
||      PACKLH2 .L2X    B_x54,      A_x32,      B_x43           ;[ 6,5] 
||      PACKLH2 .S1     A_x32,      A_x10,      A_x21           ;[ 6,5] 

* =========================== PIPE LOOP EPILOG ============================ *

        SHR     .S2     B_sum2,     15,         B_sum2_s        ;[15,5] 
||      SHR     .S1     A_sum0,     15,         A_sum0_s        ;[15,5] 
||      ADD     .L2     B_sum3_0,   B_prod3_32, B_sum3          ;[15,5] 
||      ADD     .D1X    A_sum1,     B_sum1_0,   A_sum1          ;[15,5] 
||      ADD     .L1     A_prod2_10, A_prod2_32, A_sum2_0        ;[11,6] 

        SHR     .S2     B_sum3,     15,         B_sum3_s        ;[16,5] 
||      SHR     .S1     A_sum1,     15,         A_sum1_s        ;[16,5] 
||      ADD     .D2     B_prod1_10, B_prod1_32, B_sum1_0        ;[12,6] 
||      ADD     .L1     A_sum0,     A_prod0_10, A_sum0_0        ;[12,6] 

        PACK2   .L1     A_sum1_s,   A_sum0_s,   A_r10           ;[17,5] 
||      PACK2   .L2     B_sum3_s,   B_sum2_s,   B_r32           ;[17,5] 
||      ADD     .D2X    B_sum2,     A_sum2_0,   B_sum2          ;[13,6] 
||[B_j] BDEC    .S2     LOOPJ,      B_j                         ;[ 3,0] 
||      ADD     .D1     A_xptr,     A_ofs,      A_ptr_x         ;[17,0] 
||      MV      .S1X    B_h10_n,    A_h10                       ;[22,0]

        ADD     .L1     A_sum0_0,   A_prod0_32, A_sum0          ;[14,6] 
||      ADD     .D2     B_sum3,     B_prod3_10, B_sum3_0        ;[13,6] 
||      LDNDW   .D1T2   *A_ptr_x--, B_x76:B_x54                 ;[18,0] 
||      MV      .S1X    B_h32_n,    A_h32                       ;[21,0] 
||[!B_j]RET     .S2     B_return

        SHR     .S2     B_sum2,     15,         B_sum2_s        ;[15,6] 
||      SHR     .S1     A_sum0,     15,         A_sum0_s        ;[15,6] 
||      ADD     .L2     B_sum3_0,   B_prod3_32, B_sum3          ;[15,6] 
||      ADD     .D1X    A_sum1,     B_sum1_0,   A_sum1          ;[15,6] 
||      SUB     .L1     A_nh_l,     1,          A_i             ;[19,0] 

        SHR     .S2     B_sum3,     15,         B_sum3_s        ;[16,6] 
||      SHR     .S1     A_sum1,     15,         A_sum1_s        ;[16,6] 
||[B_j] LDNDW   .D1T1   *A_ptr_x--, A_x32:A_x10                 ;[ 1,1] 
||      MV      .L1X    B_ptr,      A_hptr                      ;[20,0] 
||      MV      .L2     B_h10_n,    B_h10                       ;[22,0]
||      MPY     .M1     A_prod0_32, 0,          A_prod0_32      ;

        PACK2   .L1     A_sum1_s,   A_sum0_s,   A_r10           ;[17,6] 
||      PACK2   .L2     B_sum3_s,   B_sum2_s,   B_r32           ;[17,6] 
||      ZERO    .S1     A_prod0_10                              ;[ P,0]
||      MPY     .M2     B_sum3_0,   0,          B_sum3_0        ;[ P,0]
||      ZERO    .S2     B_prod3_32                              ;[ P,0]
||      ZERO    .D2     B_sum1_0                                ;[ P,0]
||      MPY     .M1     A_sum2_0,   0,          A_sum2_0        ;[13,3]
||      ADD     .D1     A_ofs,      8,          A_ofs           ;[22,0]

        STW     .D2T2   B_r32,      *B_optr++[2]                ;[ 8,0] 
||      STW     .D1T1   A_r10,      *A_optr++[2]                ;[ 8,0] 
||[!B_j]MVC     .S2     B_csr,      CSR                         ;[ E,0]

        ;==== Branch occurs                                     

* ========================================================================= *
*   End of file:  dsp_fir_gen.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
fir_r4.asm/     1061588610  0     0     0       18108     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.6     Thu Sep  6 18:22:36 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_fir_r4: FIR Filter (radix 4)                                    *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fir_r4                                                     *
*       (                                                                   *
*           const short *restrict x,  /* Input array [nr+nh-1 elements] */  *
*           const short *restrict h,  /* Coeff array [nh elements]      */  *
*           short       *restrict r,  /* Output array [nr elements]     */  *
*           int nh,                   /* Number of coefficients.        */  *
*           int nr                    /* Number of output samples.      */  *
*       )                                                                   *
*                                                                           *
*   ARGUMENTS PASSED                                                        *
*       *x    ->      A4                                                    *
*       *h    ->      B4                                                    *
*       *r    ->      A6                                                    *
*       nh    ->      B6                                                    *
*       nr    ->      A8                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Computes a real FIR filter (direct-form) using coefficients         *
*       stored in vector h.  The real data input is stored in vector x.     *
*       The filter output result is stored in vector r.  Input data and     *
*       filter taps are 16-bit, with intermediate values kept at 32-bit     *
*       precision.  Filter taps are expected in Q15 format.                 *
*                                                                           *
*       The following is a natural C implementation with no restrictions.   *
*       This version has restrictions as noted in the ASSUMPTIONS below.    *
*                                                                           *
*       void DSP_fir_r4                                                     *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short       *restrict r,                                        *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*       {                                                                   *
*           int i, j, sum;                                                  *
*                                                                           *
*           for (j = 0; j < nr; j++)                                        *
*           {                                                               *
*               sum = 0;                                                    *
*               for (i = 0; i < nh; i++)                                    *
*                   sum += x[i + j] * h[i];                                 *
*               r[j] = sum >> 15;                                           *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Number of taps:    'nh' >= 8, multiple of 4                         *
*       Number of samples: 'nr' >= 4, multiple of 4                         *
*                                                                           *
*   NOTES                                                                   *
*       This function blocks interrupts for its entire duration.  It is     *
*       interrupt tolerant, but not interruptible.                          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No memory bank hits under any conditions.                           *
*       This code is a LITTLE ENDIAN implementation                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       1.  Load double word instruction is used to simultaneously          *
*           load four values in a single clock cycle.                       *
*       2.  The inner loop is unrolled four times                           *
*                                                                           *
*   CYCLES                                                                  *
*       (8 + nh) * nr/4 + 9                                                 *
*                                                                           *
*       For nh = 12 and nr = 12, cycles = 69                                *
*                                                                           *
*   CODESIZE                                                                *
*       308 bytes.                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



; ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== ;
        .asg   A0,      A_s        ; flag for sum0a,1a,2a,3a: = 1
        .asg   A1,      A_i        ; inner loop count = 2
        .asg   A2,      A_rj       ; outer loop cont j_cnt = (nr+3)>>2
        .asg   A4,      A_x_ptr    ; input array pointer
        .asg   A6,      A_r_ptr    ; output array pointer
        .asg   A7,      A_nh_x     ; = (nh+3)>>2+1
        .asg   A8,      A_nr       ; = (nr+3)
        .asg   A16,     A_h10      ; coef: h[1:0]
        .asg   A17,     A_h32      ; coef: h[3:2]
        .asg   A18,     A_x10      ; input: x[1:0]
        .asg   A19,     A_x32      ; input: x[3:2]
        .asg   A20,     A_x21      ; input: x[2:1]
        .asg   A21,     A_prod00_11; = x[0]*h[0] + x[1]*h[1]
        .asg   A22,     A_prod22_33; = x[2]*h[2] + x[3]*h[3]
        .asg   A23,     A_prod32_43; = x[3]*h[2] + x[4]*h[3]
        .asg   A24,     A_prod10_21; = x[1]*h[0] + x[2]*h[1]
        .asg   A26,     A_sum0a    ; = sum0b + x[2]*h[2] + x[3]*h[3]
        .asg   A26,     A_sum0b    ; = sum0a + x[0]*h[0] + x[1]*h[1]
        .asg   A27,     A_sum1a    ; = sum1b + x[1]*h[0] + x[2]*h[1]
        .asg   A27,     A_sum1b    ; = sum1a + x[3]*h[2] + x[4]*h[3]
        .asg   A25,     A_sum0     ; = sum0a >>15 for r[0]
        .asg   A28,     A_sum1     ; = sum1a >>15 for r[1]
        .asg   B0,      B_j        ; outer loop flag; if 0,branch to iloop
        .asg   B4,      B_h_ptr    ; coef array pointer
        .asg   B5,      B_iloop    ; iloop label address
        .asg   B6,      B_nh       ; initial value for B_j, if A_rj != 0
        .asg   B7,      B_nh_h     ; addr offset for h_ptr: = (nh+3)>>2+1
        .asg   B8,      B_h_ptr1   ; temp coef array ptr: point to h[nh]
        .asg   B8,      B_r10      ; output: r[1:0]
        .asg   B9,      B_r32      ; output: r[3:2]
        .asg   B9,      B_x32      ; input: x[3:2]
        .asg   B16,     B_h10      ; coef: h[1:0]
        .asg   B17,     B_h32      ; coef: h[3:2]
        .asg   B18,     B_x54      ; input: x[5:4]
        .asg   B19,     B_x76      ; input: x[7:6]
        .asg   B20,     B_x43      ; input: x[4:3]
        .asg   B21,     B_x65      ; input: x[6:5]
        .asg   B22,     B_prod42_53; = x[4]*h[2] + x[5]*h[3]
        .asg   B23,     B_prod20_31; = x[2]*h[0] + x[3]*h[1]
        .asg   B24,     B_prod30_41; = x[3]*h[0] + x[4]*h[1]
        .asg   B25,     B_prod52_63; = x[5]*h[2] + x[6]*h[3]
        .asg   B26,     B_sum2a    ; = sum2b + x[2]*h[0] + x[3]*h[1]
        .asg   B26,     B_sum2b    ; = sum2a + x[4]*h[2] + x[5]*h[3]
        .asg   B27,     B_sum3a    ; = sum3b + x[3]*h[0] + x[4]*h[1]
        .asg   B27,     B_sum3b    ; = sum3a + x[5]*h[2] + x[6]*h[3]
        .asg   B28,     B_sum0     ; = A_sum0
        .asg   B29,     B_sum1     ; = A_sum1
        .asg   B30,     B_sum2     ; = sum2a >>15 for r[2]
        .asg   B31,     B_sum3     ; = sum3a >>15 for r[3]

        .text
        .global _DSP_fir_r4
_DSP_fir_r4:
; ======================= SETUP / LOOP PIPE-UP CODE ======================= ;
        LDNDW   .D1T2   *++A_x_ptr,B_x76:B_x54    ; load B_x76:x54
||      ADD     .L1     3,A_nr,A_nr               ; nr + 3
||      SHR     .S2     B_nh,2,B_nh               ; i_cnt = nh>>2
||      B       .S1     dint0                     ; protect setup code

        LDNDW   .D1T1   *-A_x_ptr[1],A_x32:A_x10  ; load A_x32:x10
||      SHR     .S1     A_nr,2,A_rj               ; j_cnt = (nr+3)>>2

        LDNDW   .D2T1   *B_h_ptr,A_h32:A_h10      ; load A_h32:h10
||      SUB     .L1     A_rj,1,A_rj               ; j_cnt -= 1

        LDNDW   .D2T2   *B_h_ptr++,B_h32:B_h10    ; load B_h32:h10
||[A_rj]MV      .S2     B_nh,B_j                  ; jloop cnt
||      MV      .S1X    B_nh,A_i                  ; i_cnt = nh>>2
||      SUB     .L2     -2,B_nh,B_nh_h            ; addr offset for h_ptr

        LDNDW   .D1T2   *++A_x_ptr,B_x76:B_x54    ; load B_x1110:x98
||      MVK     .S1     1,A_s                     ; sync for sum0a,1a,2a,3a
||      ADDKPC  .S2     iloop,B_iloop,0           ; store iloop addr to reg
||      SUB     .L1X    -1,B_nh,A_nh_x            ; addr offset for x_ptr

        LDNDW   .D1T1   *-A_x_ptr[1],A_x32:A_x10  ; load A_x76:x54
||      B       .S1     iloop                     ;
||      ZERO    .L2     B_sum3a:B_sum2a

dint0:  LDNDW   .D2T1   *B_h_ptr,A_h32:A_h10      ; load A_h76:h54
||      PACKLH2 .S2X    B_x54,A_x32,B_x43         ; @ input: x[4:3]
||      ZERO    .L1     A_sum1a:A_sum0a
||[!A_rj]ADD    .L2     5,B_nh,B_j                ; if last jloop, will not

; ========================== "ILOOP" LOOP KERNEL ========================== ;
iloop:
        DOTP2   .M1     A_x10,A_h10,A_prod00_11     ; @ x[0]*h[0] + x[1]*h[1]
||[!A_s]ADD     .S1     A_sum0a,A_prod00_11,A_sum0b ; x[0]*h[0] + x[1]*h[1]
||      DOTP2   .M2X    B_x54,A_h32,B_prod42_53     ; @ x[4]*h[2] + x[5]*h[3]
||[!A_s]ADD     .L2     B_sum2a,B_prod42_53,B_sum2b ; x[4]*h[2] + x[5]*h[3]
||      PACKLH2 .S2     B_x76,B_x54,B_x65           ; @ input: x[6:5]
||      LDNDW   .D2T2   *B_h_ptr++,B_h32:B_h10      ; load coef: h32:h10
||      PACKLH2 .L1     A_x32,A_x10,A_x21           ; input: x[2:1]
||[!B_j]ADDAD   .D1     A_x_ptr,A_nh_x,A_x_ptr      ; reset the input pointer

        DOTP2   .M1     A_x32,A_h32,A_prod22_33     ; x[2]*h[2] + x[3]*h[3]
||[!A_s]ADD     .L1     A_sum0b,A_prod22_33,A_sum0a ; x[2]*h[2] + x[3]*h[3]
||      DOTP2   .M2     B_x65,B_h32,B_prod52_63     ; x[5]*h[2] + x[6]*h[3]
||[!A_s]ADD     .S2     B_sum3a,B_prod52_63,B_sum3b ; x[5]*h[2] + x[6]*h[3]
||      LDNDW   .D1T2   *++A_x_ptr,B_x76:B_x54      ; load intput: x76:x54
||[!B_j]ADDAD   .D2     B_h_ptr,B_nh_h,B_h_ptr      ; reset the coef pointer
||[ A_i]SUB     .S1     A_i,1,A_i                   ; @
||      MV      .L2X    A_x32,B_x32                 ;

        DOTP2   .M2     B_x32,B_h10,B_prod20_31     ; x[2]*h[0] + x[3]*h[1]
||[!A_s]ADD     .L2     B_sum2b,B_prod20_31, B_sum2a; x[2]*h[0] + x[3]*h[1]
||      DOTP2   .M1X    B_x43,A_h32,A_prod32_43     ; x[3]*h[2] + x[4]*h[3]
||[!A_s]ADD     .L1     A_sum1a,A_prod32_43,A_sum1b ; x[3]*h[2] + x[4]*h[3]
||[ A_i]B       .S1     iloop                       ; inner loop brach
||[!B_j]B       .S2     B_iloop                     ; outer loop brach
||      LDNDW   .D1T1   *-A_x_ptr[1],A_x32:A_x10    ; load input: x[32]:x[10]
||      SUB     .D2     B_j,1,B_j                   ; count for outer loop

        DOTP2   .M1X    A_x21,B_h10,A_prod10_21     ; x[1]*h[0] + x[2]*h[1]
||[!A_s]ADD     .D1     A_sum1b,A_prod10_21,A_sum1a ; x[1]*h[0] + x[2]*h[1]
||      DOTP2   .M2     B_x43,B_h10,B_prod30_41     ; x[3]*h[0] + x[4]*h[1]
||[!A_s]ADD     .L2     B_sum3b,B_prod30_41,B_sum3a ; x[3]*h[0] + x[4]*h[1]
||      LDNDW   .D2T1   *B_h_ptr,A_h32:A_h10        ; load coef: h32:h10
||[ A_s]ZERO    .L1     A_s                         ; @flag for sum0a,1a,2a,3a
||      PACKLH2 .S2X    B_x54,A_x32,B_x43           ; @ input: x[4:3]
; ========================= END OF "ILOOP" KERNEL ========================= ;

        SHR     .S1     A_sum0a,15,A_sum0        ; = sum0a >>15 for r[0]
||      ADD     .L2     B_sum2a,B_sum2a,B_sum2   ; = sum2a <<1 for r[2]
||[A_rj]LDNDW   .D2T2   *B_h_ptr++,B_h32:B_h10   ; p load intput: x[3:2]:x[1:0]
||[!A_rj]B      .S2     B3

  [A_rj]LDNDW   .D1T2   *++A_x_ptr,B_x76:B_x54   ; p load intput: x[7:6]:x[5:4]
||      SHR     .S2X    A_sum1a,15,B_sum1        ; = sum1a >>15 for r[1]
||      ADD     .D2     B_sum3a,B_sum3a,B_sum3   ; = sum3a <<1 for r[3]
||      MV      .S1X    B_nh,A_i                 ; initialize inner loop count
||      ZERO    .L2     B_sum3a:B_sum2a          ; p initialize B_sum3a,2a

        PACK2   .L2X    B_sum1,A_sum0,B_r10      ; r[1:0]
||      PACKH2  .S2     B_sum3,B_sum2,B_r32      ; r[3:2]
||[A_rj]LDNDW   .D2T1   *B_h_ptr,A_h32:A_h10     ; p load coef: h[3:2]:h[1:0]
||      MVD     .M1X    B_x76,A_x32              ; p load intput: x[3:2]
||      MVK     .D1     1,A_s                    ; p flag for accum sum0a..3a
||[A_rj]B       .S1     iloop                    ; p branch to outer loop
||[A_rj]SUB     .L1     A_rj,1,A_rj              ; count down for outer loop

        STNDW   .D1     B_r32:B_r10,*A_r_ptr++   ; p store output r[3:2]:r[1:0]
||      MVD     .M1X    B_x54,A_x10              ; p load intput: x[1:0]
||[A_rj]MV      .S2     B_nh,B_j                 ; initialize outer loop count
||[!A_rj]ADD    .D2     5,B_nh,B_j               ; initialize outer loop count
||      ZERO    .L1     A_sum1a:A_sum0a          ; p initialize B_sum1a,0a
||      PACKLH2 .L2X    B_x54,A_x32,B_x43        ; @ input: x[4:3]
; ============================ END OF "JLOOP" ============================= ;
        NOP             2
; ============================= BRANCH OCCURS ============================= ;

* ========================================================================= *
*   End of file:  dsp_fir_r4.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
fir_r8.asm/     1061588610  0     0     0       19259     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Thu Sep  6 18:22:36 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_fir_r8: FIR Filter (radix 8)                                    *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fir_r8                                                     *
*       (                                                                   *
*           const short *restrict x,  /* Input array [nr+nh-1 elements] */  *
*           const short *restrict h,  /* Coeff array [nh elements]      */  *
*           short       *restrict r,  /* Output array [nr elements]     */  *
*           int nh,                   /* Number of coefficients.        */  *
*           int nr                    /* Number of output samples.      */  *
*       )                                                                   *
*                                                                           *
*   ARGUMENTS PASSED                                                        *
*       *x    ->      A4                                                    *
*       *h    ->      B4                                                    *
*       *r    ->      A6                                                    *
*       nh    ->      B6                                                    *
*       nr    ->      A8                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Computes a real FIR filter (direct-form) using coefficients         *
*       stored in vector h.  The real data input is stored in vector x.     *
*       The filter output result is stored in vector r.  Input data and     *
*       filter taps are 16-bit, with intermediate values kept at 32-bit     *
*       precision.  Filter taps are expected in Q15 format.                 *
*                                                                           *
*       The following is a natural C implementation with no restrictions.   *
*       This version has restrictions as noted in the ASSUMPTIONS below.    *
*                                                                           *
*       void DSP_fir_r8                                                     *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short       *restrict r,                                        *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*       {                                                                   *
*           int i, j, sum;                                                  *
*                                                                           *
*           for (j = 0; j < nr; j++)                                        *
*           {                                                               *
*               sum = 0;                                                    *
*               for (i = 0; i < nh; i++)                                    *
*                   sum += x[i + j] * h[i];                                 *
*               r[j] = sum >> 15;                                           *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Number of taps:    'nh' >= 8, multiple of 8                         *
*       Number of samples: 'nr' >= 4, multiple of 4                         *
*       Array 'r' is word aligned.                                          *
*                                                                           *
*   NOTES                                                                   *
*       This function blocks interrupts for its entire duration.  It is     *
*       interrupt tolerant, but not interruptible.                          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No memory bank hits under any conditions.                           *
*       This code is a LITTLE ENDIAN implementation.                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       1.  Load double word instruction is used to simultaneously load     *
*           four values in a single clock cycle.                            *
*                                                                           *
*       2.  The inner loop is unrolled four times and will always           *
*           compute a multiple of 4 of nr.                                  *
*                                                                           *
*       3.  The outer loop is conditionally exected in parallel with the    *
*           inner loop.  This allows for a zero overhead outer loop.        *
*                                                                           *
*   CYCLES                                                                  *
*       nh * nr/4 + 17                                                      *
*                                                                           *
*       For nh = 32 and nr = 36, cycles = 305.                              *
*                                                                           *
*   CODESIZE                                                                *
*       336 bytes.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

; ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== ;
        .asg   A0,      A_i        ; inner loop flag;when = 0,branch to iloop
        .asg   A1,      A_i1       ; delayed i_cnt
        .asg   A2,      A_s        ; flag for adding 1st sum
        .asg   A4,      A_x_ptr    ; input array pointer
        .asg   A5,      A_r2       ; output: r[2]
        .asg   A6,      A_r_ptr    ; output ptr that init. point to r[0]
        .asg   A8,      A_nr       ; number of output samples
        .asg   A9,      A_x_offset ; offset to reset input ptr for next loop
        .asg   A16,     A_x54      ; input: x[5:4]
        .asg   A17,     A_x76      ; input: x[7:6]
        .asg   A20,     A_h10      ; input: h[1:0]
        .asg   A21,     A_h32      ; input: h[3:2]
        .asg   A22,     A_h54      ; input: h[5:4]
        .asg   A23,     A_h76      ; input: h[7:6]
        .asg   A24,     A_sum0     ; sum0
        .asg   A25,     A_sum2     ; sum2
        .asg   A26,     A_prod0_32 ; = x[3]*h[3] + x[2]*h[2]
        .asg   A26,     A_prod0_54 ; = x[5]*h[5] + x[4]*h[4]
        .asg   A26,     A_prod0_76 ; = x[7]*h[7] + x[6]*h[6]
        .asg   A27,     A_prod2_32 ; = x[5]*h[3] + x[4]*h[2]
        .asg   A27,     A_prod2_54 ; = x[7]*h[5] + x[6]*h[4]
        .asg   A27,     A_prod2_76 ; = x[9]*h[7] + x[8]*h[6]
        .asg   A28,     A_prod0_10 ; = x[1]*h[1] + x[0]*h[0]
        .asg   A29,     A_prod2_10 ; = x[3]*h[1] + x[2]*h[0]
        .asg   A28,     A_sum0a    ; sum0
        .asg   A29,     A_sum2a    ; sum2
        .asg   A30,     A_r0       ; output: r[0]
        .asg   A31,     A_r1       ; output: r[1]
        .asg   A31,     A_r10      ; output: r[1:0]
        .asg   B0,      B_j        ; outer loop count
        .asg   B1,      B_i2       ; 2nd delayed i_cnt
        .asg   B4,      B_h_ptr    ; coef array pointer
        .asg   B5,      B_x18      ; input: x[1:8]
        .asg   B6,      B_nh       ; number of coefficients
        .asg   B7,      B_r_ptr    ; output ptr that init. point to r[2]
        .asg   B8,      B_x3a      ; input: x[3:10]
        .asg   B9,      B_h_offset ; offset to reset coef ptr for next loop
        .asg   B16,     B_x10      ; input: x[1:0]
        .asg   B17,     B_x32      ; input: x[3:2]
        .asg   B18,     B_x98      ; input: x[9:8]
        .asg   B19,     B_xba      ; input: x[11:10]
        .asg   B20,     B_h0X      ; coef: h[0:-1]
        .asg   B21,     B_h21      ; coef: h[2:1]
        .asg   B22,     B_h43      ; coef: h[4:3]
        .asg   B23,     B_h65      ; coef: h[6:5]
        .asg   B24,     B_sum1     ; sum1
        .asg   B25,     B_sum3     ; sum3
        .asg   B26,     B_prod1_21 ; = x[3]*h[2] + x[2]*h[1]
        .asg   B26,     B_prod1_65 ; = x[7]*h[6] + x[6]*h[5]
        .asg   B26,     B_prod1_07 ; = x[1]*h[0] + x[8]*h[7]
        .asg   B27,     B_prod3_21 ; = x[5]*h[2] + x[4]*h[1]
        .asg   B27,     B_prod3_65 ; = x[9]*h[6] + x[8]*h[5]
        .asg   B27,     B_prod3_07 ; = x[3]*h[0] + x[a]*h[7]
        .asg   B28,     B_prod1_43 ; = x[5]*h[4] + x[4]*h[3]
        .asg   B28,     B_sum1a    ; sum1
        .asg   B29,     B_prod3_43 ; = x[7]*h[4] + x[6]*h[3]
        .asg   B29,     B_sum3a    ; sum3
        .asg   B30,     B_h07      ; input: h[0:7]
        .asg   B31,     B_r3       ; output: r[3]
        .asg   B31,     B_r32      ; output: r[3:2]

        .text
        .global _DSP_fir_r8
_DSP_fir_r8:

; ======================= SETUP / LOOP PIPE-UP CODE ======================= ;
        LDNDW   .D1T2 *A_x_ptr++,B_x32:B_x10     ; load input: x[3:2]:x[1:0]
||      ADD     .L1   3,A_nr,A_nr                ; nr + 3

        LDNDW   .D2T1 *B_h_ptr++,A_h32:A_h10     ; load coef: h[3:2]:h[1:0]

        LDNDW   .D2T2 *-B_h_ptr(10),B_h21:B_h0X  ; load coef: h[2:1]:h[0:-1]
||      SHR     .S2X  A_nr,2,B_j                 ; j_cnt = (nr+3)>>2

        LDNDW   .D1T1 *A_x_ptr++,A_x76:A_x54     ; load input: x[7:6]:x[5:4]
||      MPY     .M2   B_j,B_nh,B_j
||      ADD     .L1X  -4,B_nh,A_x_offset         ; twin reg for h pointer

        LDNDW   .D2T2 *-B_h_ptr(2),B_h65:B_h43   ; load coef: h[6:5]:h[4:3]
||      ADD     .S1X  -8,B_nh,A_i                ; j_cnt = (nh>>3)
||      ZERO    .L1   A_sum2:A_sum0
||      MVK     .D1   1,A_s                      ; flag for adding 1st sum

        LDNDW   .D1T2 *A_x_ptr,B_xba:B_x98       ; load input: x[11:10]:x[9:8]
||      MV      .L2   B_nh,B_h_offset            ; twin reg for h pointer
||      SHR     .S2   B_j,3,B_j                  ; j_cnt = (nh>>3)
||      B       .S1   dint0

        LDNDW   .D2T1 *B_h_ptr++,A_h76:A_h54     ; load coef: h[7:6]:h[5:4]
||[!A_i]SUBAH   .D1   A_x_ptr,A_x_offset,A_x_ptr ; reset x_ptr
||      ZERO    .L2   B_sum3:B_sum1

        ADD     .L2X  4,A_r_ptr,B_r_ptr          ; nr + 3
||      MVK     .S1   1,A_i1                     ; twin reg for h pointer


; ========================== "JLOOP" LOOP KERNEL ========================== ;
jloop:
        LDNDW   .D1T2 *A_x_ptr++,B_x32:B_x10     ; load input: x[3:2]:x[1:0]
||[!A_i]SUBAH   .D2   B_h_ptr,B_h_offset,B_h_ptr ; reset h_ptr
||      DOTP2   .M1X  A_h32,B_x32,A_prod0_32     ; x[3]*h[3] + x[2]*h[2]
||      DOTP2   .M2X  B_h21,A_x54,B_prod3_21     ; x[5]*h[2] + x[4]*h[1]
||[!A_s]ADD     .L1   A_sum0,A_prod0_54,A_sum0   ; sum0 += A_prod0_54
||[!A_s]ADD     .L2   B_sum1,B_prod1_65,B_sum1   ; sum1 += B_prod1_65
||[!A_s]ADD     .S1   A_sum2,A_sum2a,A_sum2      ; sum2 += A_prod2_32,2_10
||[!A_s]ADD     .S2   B_sum3,B_sum3a,B_sum3      ; sum3 += B_prod3_43,3_21

        LDNDW   .D2T1 *B_h_ptr++,A_h32:A_h10     ; load coef: h[3:2]:h[1:0]
||      DOTP2   .M1   A_x54,A_h32,A_prod2_32     ; x[5]*h[3] + x[4]*h[2]
||      DOTP2   .M2   B_x32,B_h21,B_prod1_21     ; x[3]*h[2] + x[2]*h[1]
||[!A_s]ADD     .L1   A_sum2,A_prod2_54,A_sum2   ; sum2 += A_prod2_54
||[!A_s]ADD     .L2   B_sum3,B_prod3_65,B_sum3   ; sum3 += B_prod3_65
||[!A_i]MV      .S1X  B_nh,A_i                   ; j_cnt = nh
||      MV      .D1   A_i,A_i1                   ; delayed i_cnt
||      MV      .S2X  A_i1,B_i2                  ; 2nd delayed i_cnt

        LDNDW   .D2T2 *-B_h_ptr(10),B_h21:B_h0X  ; load coef: h[2:1]:h[0:-1]
||      DOTP2   .M1X  A_h10,B_x10,A_prod0_10     ; x[1]*h[1] + x[0]*h[0]
||      DOTP2   .M2X  B_h43,A_x54,B_prod1_43     ; x[5]*h[4] + x[4]*h[3]
||[!A_s]ADD     .L1   A_sum0,A_prod0_76,A_sum0   ; sum0 += A_prod0_76
||[!A_s]ADD     .L2   B_sum1,B_prod1_07,B_sum1   ; sum1 += B_prod1_07
||      SUB     .D1   A_i,8,A_i                  ; i_cnt -=8
||[ B_j]B       .S1   jloop                      ; outer loop branch
||[!B_j]B       .S2   B3                         ; return to calling program

dint0:  DOTP2   .M1X  A_h10,B_x32,A_prod2_10     ; x[3]*h[1] + x[2]*h[0]
||      DOTP2   .M2X  B_h43,A_x76,B_prod3_43     ; x[7]*h[4] + x[6]*h[3]
||[ B_j]LDNDW   .D1T1 *A_x_ptr++,A_x76:A_x54     ; load input: x[7:6]:x[5:4]
||[!A_s]ADD     .L1   A_sum2,A_prod2_76,A_sum2   ; sum2 += A_prod2_76
||[!A_s]ADD     .D2   B_sum3,B_prod3_07,B_sum3   ; sum3 += B_prod3_07
||      SHR     .S1   A_sum0,15,A_r0             ; r[0] = sum0 >>15
||      PACKHL2 .L2   B_x32,B_xba,B_x3a          ; input: x[4:3]
||      PACKHL2 .S2   B_x10,B_x98,B_x18          ; input: x[6:5]

  [ B_j]LDNDW   .D2T2 *-B_h_ptr(2),B_h65:B_h43   ; load coef: h[6:5]:h[4:3]
||      DOTP2   .M1   A_x54,A_h54,A_prod0_54     ; x[5]*h[5] + x[4]*h[4]
||      DOTP2   .M2X  B_h65,A_x76,B_prod1_65     ; x[7]*h[6] + x[6]*h[5]
||      SHR     .S1X  B_sum1,15,A_r1             ; r[1] = sum1 >>15
||      ADD     .L1   A_sum2,A_sum2,A_r2         ; r[2] = sum2 >>15
||      ADD     .S2   B_sum3,B_sum3,B_r3         ; r[3] = sum3 >>15
||[ A_s]ZERO    .D1   A_s                        ; start to add the sum
||[!B_i2]ZERO   .L2   B_sum3:B_sum1

  [ B_j]LDNDW   .D1T2 *A_x_ptr,B_xba:B_x98       ; load input: x[11:10]:x[9:8]
||      DOTP2   .M1   A_x76,A_h54,A_prod2_54     ; x[7]*h[5] + x[6]*h[4]
||      DOTP2   .M2   B_x98,B_h65,B_prod3_65     ; x[9]*h[6] + x[8]*h[5]
||[!B_i2]ZERO   .L1   A_sum2:A_sum0
||      PACKH2  .L2X  B_h0X,A_h76,B_h07          ; coef: h[0:7]
||[ B_j]SUB     .D2   B_j,1,B_j                  ; j_cnt -=1
||[ A_s]B       .S2   dint0

  [ B_j]LDNDW   .D2T1 *B_h_ptr++,A_h76:A_h54     ; load coef: h[7:6]:h[5:4]
||      DOTP2   .M1   A_x76,A_h76,A_prod0_76     ; x[7]*h[7] + x[6]*h[6]
||      DOTP2   .M2   B_x18,B_h07,B_prod1_07     ; x[1]*h[0] + x[8]*h[7]
||      ADD     .L1   A_prod0_10,A_prod0_32,A_sum0a   ; sum0a = A_prod0_10+0_32
||      ADD     .L2   B_prod1_21,B_prod1_43,B_sum1a   ; sum1a = B_prod1_21+1_43
||[!A_i]SUBAH   .D1   A_x_ptr,A_x_offset,A_x_ptr
||      PACK2   .S1   A_r1,A_r0,A_r10            ; r[1:0]
||      PACKH2  .S2X  B_r3,A_r2,B_r32            ; r[3:2]

  [!B_i2]STW    .D1T1 A_r10,*A_r_ptr++[2]        ; store output r[1:0]
||[!B_i2]STW    .D2T2 B_r32,*B_r_ptr++[2]        ; store output r[3:2]
||      DOTP2   .M1X  A_h76,B_x98,A_prod2_76     ; x[9]*h[7] + x[8]*h[6]
||      DOTP2   .M2   B_x3a,B_h07,B_prod3_07     ; x[3]*h[0] + x[10]*h[7]
||      ADD     .L1   A_prod2_10,A_prod2_32,A_sum2a   ; sum2a = A_prod2_10+2_32
||      ADD     .L2   B_prod3_21,B_prod3_43,B_sum3a   ; sum3a = B_prod3_21+3_43
||      ADD     .S1   A_sum0,A_sum0a,A_sum0      ; sum0 += A_prod0_10,0_32
||      ADD     .S2   B_sum1,B_sum1a,B_sum1      ; sum1 += B_prod1_21,1_43

; ============================ END OF "JLOOP" ============================= ;
; ============================= BRANCH OCCURS ============================= ;

* ========================================================================= *
*   End of file:  dsp_fir_r8.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

fir_sym.asm/    1061588610  0     0     0       32280     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.6     Tue Mar 12 01:04:57 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_fir_sym -- Symmetric FIR                                        *
*                                                                           *
*   REVISION DATE                                                           *
*       11-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This function is C callable, and may be called as follows:          *
*                                                                           *
*       void DSP_fir_sym                                                    *
*       (                                                                   *
*           const short * x,      /* Input samples                   */     *
*           const short * h ,     /* Filter taps                     */     *
*           short * restrict r,   /* Output samples                  */     *
*           int nh,               /* Number of symmetric filter taps */     *
*           int nr,               /* Number of output samples        */     *
*           int s                 /* Final output shift.             */     *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function applies a symmetric filter to the input samples.      *
*       The filter tap array h[] provides 'nh + 1' total filter taps.       *
*       The filter tap at h[nh] forms the center point of the filter.       *
*       The taps at h[nh - 1] through h[0] form a symmetric filter          *
*       about this central tap.  The effective filter length is thus        *
*       2*nh + 1 taps.                                                      *
*                                                                           *
*       The filter is performed on 16-bit data with 16-bit coefficients,    *
*       accumulating intermediate results to 40-bit precision.  The         *
*       accumulator is rounded and truncated according to the value         *
*       provided in 's'.  This allows a variety of Q-points to be used.     *
*                                                                           *
*       Note that samples are added together before multiplication, and     *
*       so overflow *may* result for large-scale values, despite the        *
*       40-bit accumulation.                                                *
*                                                                           *
*   C CODE                                                                  *
*       Below is a C code implementation without restrictions.  The         *
*       optimized implementations have restrictions, as noted under         *
*       "ASSUMPTIONS" and "MEMORY NOTE" below.                              *
*                                                                           *
*       void DSP_fir_sym                                                    *
*       (                                                                   *
*           const short * x,      /* Input samples                   */     *
*           const short * h ,     /* Filter taps                     */     *
*           short * restrict r,   /* Output samples                  */     *
*           int nh,               /* Number of symmetric filter taps */     *
*           int nr,               /* Number of output samples        */     *
*           int s                 /* Final output shift.             */     *
*       )                                                                   *
*       {                                                                   *
*           int  i, j;                                                      *
*           long y0, round = (long) 1 << (s - 1);                           *
*                                                                           *
*           for (j = 0; j < nr; j++)                                        *
*           {                                                               *
*               y0 = round;                                                 *
*                                                                           *
*               for (i = 0; i < nh; i++)                                    *
*                   y0 += ((short) (x[j + i] + x[j + 2 * nh - i])) * h[i];  *
*                                                                           *
*               y0 += x[j + nh] * h[nh];                                    *
*                                                                           *
*               r[j] = (int) (y0 >> s);                                     *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The optimized versions of this kernel may assume that nr is         *
*       a multiple of 4 and nh is a multiple of 8.                          *
*                                                                           *
*   MEMORY NOTE.                                                            *
*       The code assumes that 'x' and 'h' are double-word aligned, and      *
*       that 'r' is word alignend.                                          *
*                                                                           *
*       The code expects the device to be in LITTLE ENDIAN mode.            *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = (10 * nh/8 + 15) * nr/4 + 26                               *
*                                                                           *
*   CODESIZE                                                                *
*       664 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

*===================== SYMBOLIC REGISTER ASSIGNMENTS ========================*
        .asg            A0,         A_round     ; round = 1 << (s - 1)
        .asg            A1,         A_o         ; flag for load, mpy for lp
        .asg            A2,         A_i         ; inner loop count
        .asg            A3,         A_s         ; = s
        .asg            A4,         A_xf_ptr    ; input forward pointer
        .asg            A5,         A_h_ptr     ; coeff pointer
        .asg            A6,         A_r_ptr     ; output pointer
        .asg            A6,         A_nhi       ; initial inner loop count
        .asg            A7,         A_h_offset  ; offset to h[0]
        .asg            A8,         A_nr        ; no. of output
        .asg            A8,         A_nr3       ; = nr + 3
        .asg            A8,         A_xs2_32    ; (xf5+xr4)<<16 | (xf4+xr3) for r[2]
        .asg            A8,         A_xs2_54    ; (xf5+xr4)<<16 | (xf4+xr3) for r[2]
        .asg            A8,         A_y0_8      ; = x[nh]*h[nh] for r[0]
        .asg            A9,         A_y1_8      ; = x[nh+1]*h[nh] for r[1]
        .asg            A9,         A_y2_8      ; = x[nh+2]*h[nh] for r[2]
        .asg            A9,         A_y0_32     ; = xs0_32 * h32 for r[0]
        .asg            A9,         A_y0_54     ; = xs0_54 * h54 for r[0]
        .asg            A9,         A_y0_76     ; = xs0_76 * h76 for r[0]
        .asg            A9,         A_y2_10     ; = xs2_10 * h10 for r[2]
        .asg            A9,         A_y2_32     ; = xs2_32 * h32 for r[2]
        .asg            A9,         A_y2_54     ; = xs2_54 * h54 for r[2]
        .asg            A9,         A_y2_76     ; = xs2_76 * h76 for r[2]
        .asg            A16,        A_xs2_10    ; point 2: xs2_3:xs2_2
        .asg            A16,        A_xr87      ; = x[nh*2-5,nh*2-4]
        .asg            A16,        A_r_ptr1    ; output pointer
        .asg            A17,        A_xr65      ; = x[nh*2-3,nh*2-2]
        .asg            A17,        A_r32       ; = r[3,2]
        .asg            A17,        A_y3l       ; = y3 (lower reg)
        .asg            A18,        A_h_10      ; = h[1,0]
        .asg            A18,        A_xs0_32    ; point 0: xs0_3:xs0_2
        .asg            A18,        A_xs0_54    ; point 0: xs0_5:xs0_4
        .asg            A18,        A_xs0_76    ; point 0: xs0_7:xs0_6
        .asg            A19,        A_h_32      ; = h[3,2]
        .asg            A19,        A_xs2_76    ; point 2: xs2_7:xs2_6
        .asg            A20,        A_h_54      ; = h[5,4]
        .asg            A20,        A_xr43      ; = x[nh*2-1,nh*2]
        .asg            A20,        A_xf_offset ; offset to x[4*i]
        .asg            A21,        A_h_76      ; = h[7,6]
        .asg            A22,        A_xf10      ; = x[1,0]
        .asg            A22,        A_xrA9      ; = x[nh*2-7,nh*2-6]
        .asg            A23,        A_xf32      ; = x[3,2]
        .asg            A23,        A_y0_10     ; = xs0_10 * h10 for r[0]
        .asg            A24,        A_xr67      ; = x[nh*2-3,nh*2-4]
        .asg            A25,        A_xr45      ; = x[nh*2-1,nh*2-2]
        .asg            A25,        A_xs0_10    ; point 0: xs2_3:xs2_2
        .asg            A26,        A_xrAB      ; = x[nh*2-7,nh*2-8]
        .asg            A27,        A_xr89      ; = x[nh*2-5,nh*2-6]
        .asg            A28,        A_y0l       ; = y0 (lower reg)
        .asg            A29,        A_y0h       ; = y0 (higher reg)
        .asg            A30,        A_y2l       ; = y2 (lower reg)
        .asg            A31,        A_y2h       ; = y2 (higher reg)

        .asg            B0,         B_round     ; round = 1 << (s - 1)
        .asg            B1,         B_one       ; B_one = 1
        .asg            B1,         B_p         ; flag for add = 1
        .asg            B2,         B_j         ; output loop count
        .asg            B4,         B_h_ptr     ; coeff pointer
        .asg            B4,         B_xr_offset ; offset to x[nh*2+4]
        .asg            B5,         B_xr_ptr    ; input reverse pointer
        .asg            B6,         B_nh        ; = nh
        .asg            B6,         B_xf_ptr    ; input forword pointer
        .asg            B7,         B_nh1       ; B_nh1 = B_nh >>1
        .asg            B7,         B_r_ptr     ; output pointer
        .asg            B8,         B_s         ; = s
        .asg            B8,         B_s1        ; = s - 1
        .asg            B8,         B_y2_8      ; = x[nh+2]*h[nh] for r[2]
        .asg            B8,         B_y1_8      ; = x[nh+1]*h[nh] for r[1]
        .asg            B8,         B_xr07      ; = x[nh*2+3,nh*2-4]
        .asg            B8,         B_xs3_65    ; point 3: xs3_6:xs3_5
        .asg            B9,         B_y3_8      ; = x[nh+3]*h[nh] for r[3]
        .asg            B9,         B_y1_07     ; = xs1_07 * h07 for r[1]
        .asg            B9,         B_y1_21     ; = xs1_21 * h21 for r[1]
        .asg            B9,         B_y1_43     ; = xs1_43 * h43 for r[1]
        .asg            B9,         B_y1_65     ; = xs1_65 * h65 for r[1]
        .asg            B9,         B_y3_07     ; = xs3_07 * h07 for r[3]
        .asg            B9,         B_y3_43     ; = xs3_43 * h43 for r[3]
        .asg            B9,         B_y3_65     ; = xs3_65 * h65 for r[3]
        .asg            B16,        B_h_43      ; = h[4,3]
        .asg            B16,        B_xr21      ; = x[nh*2+1,nh*2+2]
        .asg            B16,        B_xs3_21    ; point 3: xs3_2:xs3_1
        .asg            B16,        B_y3_21     ; = xs3_21 * h21 for r[3]
        .asg            B16,        B_r10       ; = r[1,0]
        .asg            B17,        B_h_65      ; = x[6,5]
        .asg            B17,        B_xs1_21    ; point 1: xs1_2:xs1_1
        .asg            B17,        B_r32       ; = r[3,2]
        .asg            B18,        B_h_0X      ; = h[0,-1]
        .asg            B18,        B_h_07      ; = h[0,7]
        .asg            B18,        B_ss        ; = s
        .asg            B19,        B_h_21      ; = h[2,1]
        .asg            B19,        B_xr29      ; = x[nh*2+1,nh*2-6]
        .asg            B19,        B_xs3_07    ; point 3: xs3_0:xs3_7
        .asg            B19,        B_xs1_65    ; point 1: xs1_6:xs1_5
        .asg            B19,        B_xf_offset ; offset to x[4*i]
        .asg            B20,        B_xf54      ; = x[9,8]
        .asg            B20,        B_xs1_43    ; point 1: xs1_4:xs1_3
        .asg            B20,        B_xf3A      ; = x[9,8]
        .asg            B10,        B_h_nh10    ; = h[nh]>>16 | h[nh]
        .asg            A10,        A_h_nh10    ; = h[nh]>>16 | h[nh]
        .asg            B20,        B_y0l       ; = y0 (lower reg)
        .asg            B21,        B_xf76      ; = x[9,8]
        .asg            B11,        B_h_nh32    ; = h[nh]>>16 | h[nh]
        .asg            B22,        B_xf10      ; = x[1,0]
        .asg            B22,        B_xf18      ; = x[1,8]
        .asg            B22,        B_nh2       ; = nh/4
        .asg            B23,        B_xf32      ; = x[3,2]
        .asg            B24,        B_xf98      ; = x[9,8]
        .asg            B25,        B_xfBA      ; = x[11,10]
        .asg            B25,        B_xs1_07    ; point 1: xs1_0:xs1_7
        .asg            B26,        B_xr23      ; = x[nh*2+1,nh*2]
        .asg            B27,        B_xr01      ; = x[nh*2+3,nh*2+2]
        .asg            B27,        B_xs3_43    ; point 3: xs3_4:xs3_3
        .asg            B28,        B_y1l       ; = y1 (lower reg)
        .asg            B29,        B_y1h       ; = y1 (higher reg)
        .asg            B30,        B_y3l       ; = y3 (lower reg)
        .asg            B31,        B_y3h       ; = y3 (highr reg)
; ============================================================================
; START:
; ============================ PIPE LOOP PROLOG ==============================


        .text
        .global _DSP_fir_sym
_DSP_fir_sym:

; ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A1,         A_SP        ; Stack pointer, A datapath
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            B3,         B_ret       ; Return address
        .asg            B2,         B_csr       ; CSR's value
; ========================================================================= ;
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T2   B14,        *B_SP--[14]             ; Save B14, get stk
||      MV              B_SP,       A_SP                    ; Twin Stack Ptr

        STDW    .D1T1   A15:A14,    *-A_SP[1]               ; Save A15, A14
||      STDW    .D2T2   B13:B12,    *+B_SP[5]               ; Save B13, B12
||      MVC     .S2     CSR,        B_csr                   ; Remember CSR

        STDW    .D1T1   A13:A12,    *-A_SP[3]               ; Save A13, A12
||      STDW    .D2T2   B11:B10,    *+B_SP[3]               ; Save B11, B10
||      AND             B_csr,      -2,         B_no_gie    ; Clear GIE
;-
        STDW    .D1T1   A11:A10,    *-A_SP[5]               ; Save A11, A10
||      STDW    .D2T2   B_ret:B_csr,*+B_SP[1]               ; Save Return, CSR
||      MVC     .S2     B_no_gie,   CSR                     ; Disable ints


*** BEGIN Benchmark Timing ***
B_START
        SHR     .S2     B_nh,1,B_nh1                 ; B_nh1 = B_nh >>1
||      LDH     .D2T1   *B_h_ptr[B_nh],A_h_nh10      ; h[nh]

        SUB     .S2     B_s,1,B_s1                   ; = s - 1
||      MV      .L2X    A_xf_ptr,B_xr_ptr            ; B_xr_ptr = &x[0]
||      MV      .S1X    B_h_ptr,A_h_ptr              ; A_h_ptr = &h[0]

        LDDW    .D2T2   *++B_xr_ptr[B_nh1],B_xr01:B_xr23 ;p xr01 = x[nh*2+3,nh*2+2]
||      ADD     .D1     A_nr,3,A_nr3                 ; nr+3
||      MVK     .S2     1,B_one                      ; B_one (B_p) = 1

        SHL     .S2     B_one,B_s1,B_y1h:B_y1l       ; y0 = round = 1 << (s - 1)
||      LDDW    .D2T1   *--B_xr_ptr[2],A_xr89:A_xrAB ;p xr89 = x[2*nh-5,2*nh-6]
||      MV      .L2X    A_r_ptr,B_r_ptr              ; output twin reg
||      SHR     .S1X    B_nh,3,A_nhi                 ; = init. inner lp cnt

        SHR     .S2     B_nh,2,B_nh2                 ; B_nh = addr offset
||      LDDW    .D2T1   *++B_xr_ptr[1],A_xr45:A_xr67 ;p xr45 = x[2*nh-1,2*nh-2]
||      LDDW    .D1T2   *A_xf_ptr,B_xf32:B_xf10      ;p xf32 = x[3,2]
||      MV      .L2X    A_xf_ptr,B_xf_ptr            ; B_xf_ptr = &x[0]
||      MV      .L1X    B_y1l,A_y0l                  ; y1 (lower reg) = round

        LDDW    .D2T2   *++B_xf_ptr[1],B_xf76:B_xf54 ;p xf76 = x[7,6]
||      LDDW    .D1T1   *A_xf_ptr,A_xf32:A_xf10      ;p xf32 = x[3,2]
||      MV      .S1     A_nhi,A_i                    ; set inner lp cnt
||      PACK2   .L1     A_h_nh10,A_h_nh10,A_h_nh10   ; = h[nh]<<16 | h[nh]
||      SHR     .S2X    A_nr3,2,B_j                  ; = outer loop count
||      MPY     .M1     A_y0h,0,A_y0h                ; Initialize B_y1h

        ADD     .L1     A_nr,1,A_o                   ; A_o != 0
||      LDDW    .D1T2   *++A_xf_ptr[2],B_xfBA:B_xf98 ;p xfba = x[11,10]
||      ADD     .S1X    B_nh2,1,A_h_offset           ; = nh/4 + 1
||      MVD     .M1     A_y0l,A_round                ; y0 (lower reg) = round
||      MV      .L2     B_y1h:B_y1l,B_y3h:B_y3l      ; y3 = round

        ADD     .S2     B_nh2,3,B_xr_offset          ; = nh/4 + 3
||      MV      .L1     A_y0h:A_y0l,A_y2h:A_y2l      ; y2 = round
||      SUB     .L2     B_j,2,B_j                    ; decrement outer lp cnt
||      MVD     .M2     B_y1l,B_round                ; store round value
||      MPY     .M1     8,A_h_offset,A_h_offset      ; = 8*(nh/4+1) bytes
||      ADD     .S1X    B_s1,1,A_s                   ; = s
;=============================== PIPE LOOP KERNEL ==============================
            ; point 0:   add xs0_0 = xf0 + xr3
            ;            add xs0_1 = xf1 + xr4
            ;            add xs0_2 = xf2 + xr5
            ;            add xs0_3 = xf3 + xr6
            ;            add xs0_4 = xf4 + xr7
            ;            add xs0_5 = xf5 + xr8
            ;            add xs0_6 = xf6 + xr9
            ;            add xs0_7 = xf7 + xrA

            ; point 1:   add xs1_0 = xf1 + xr2
            ;            add xs1_1 = xf2 + xr3
            ;            add xs1_2 = xf3 + xr4
            ;            add xs1_3 = xf4 + xr5
            ;            add xs1_4 = xf5 + xr6
            ;            add xs1_5 = xf6 + xr7
            ;            add xs1_6 = xf7 + xr8
            ;            add xs1_7 = xf8 + xr9

            ; point 2:   add xs2_0 = xf2 + xr1
            ;            add xs2_1 = xf3 + xr2
            ;            add xs2_2 = xf4 + xr3
            ;            add xs2_3 = xf5 + xr4
            ;            add xs2_4 = xf6 + xr5
            ;            add xs2_5 = xf7 + xr6
            ;            add xs2_6 = xf8 + xr7
            ;            add xs2_7 = xf9 + xr8

            ; point 3:   add xs3_0 = xf3 + xr0
            ;            add xs3_1 = xf4 + xr1
            ;            add xs3_2 = xf5 + xr2
            ;            add xs3_3 = xf6 + xr3
            ;            add xs3_4 = xf7 + xr4
            ;            add xs3_5 = xf8 + xr5
            ;            add xs3_6 = xf9 + xr6
            ;            add xs3_7 = xfA + xr7

iloop:

        DOTP2   .M1     A_xs0_54,   A_h_54,     A_y0_54    ; = xs0_5*h5+xs0_4*h4
||      DOTP2   .M2     B_xs1_43,   B_h_43,     B_y1_43    ; = xs1_4*h4+xs1_3*h3
||      ADD2    .L1     A_xf32,     A_xr65,     A_xs0_32   ;
||      ADD2    .L2X    B_xf76,     A_xr87,     B_xs1_65   ;
||      ADD2    .S1X    B_xf76,     A_xr65,     A_xs2_54   ;
||      ADD2    .D2     B_xf18,     B_xr29,     B_xs1_07   ;
||      PACKHL2 .S2     B_xf32,     B_xfBA,     B_xf3A     ;
||      LDDW    .D1T1   *A_h_ptr++,A_h_32:A_h_10           ; @

  [!B_p]ADD     .L1     A_y2_10,    A_y2h:A_y2l,A_y2h:A_y2l;
||[!B_p]ADD     .L2     B_y1_21,    B_y1h:B_y1l,B_y1h:B_y1l;
||      DOTP2   .M1     A_xs0_32,   A_h_32,     A_y0_32    ; = xs0_3*h3+xs0_2*h2
||      DOTP2   .M2     B_xs1_65,   B_h_65,     B_y1_65    ; = xs1_6*h6+xs1_5*h5
||      ADD2    .S1X    B_xf76,     A_xrA9,     A_xs0_76   ;
||      ADD2    .D2     B_xf3A,     B_xr07,     B_xs3_07   ;
||      PACKH2  .S2X    B_h_0X,     A_h_76,     B_h_07     ;
||[ A_o]LDNDW   .D1     *-A_h_ptr(10),B_h_21:B_h_0X        ; @

  [!B_p]ADD     .L1     A_y0_10,    A_y0h:A_y0l,A_y0h:A_y0l;
||[!B_p]ADD     .L2     B_y3_21,    B_y3h:B_y3l,B_y3h:B_y3l;
||      DOTP2   .M1     A_xs2_54,   A_h_54,     A_y2_54    ; = xs2_5*h5+xs2_4*h4
||      DOTP2   .M2     B_xs1_07,   B_h_07,     B_y1_07    ; = xs1_0*h0+xs1_7*h7
||      PACKHL2 .S1X    A_xr45,     B_xr23,     A_xr43     ;
||      ADD2    .D2X    B_xf98,     A_xr65,     B_xs3_65   ;
||      PACKHL2 .S2     B_xr23,     B_xr01,     B_xr21     ;
||[ A_o]LDDW    .D1T1   *A_h_ptr++,A_h_76:A_h_54           ; @

  [!B_p]ADD     .L1     A_y2_32,    A_y2h:A_y2l,A_y2h:A_y2l;
||[!B_p]ADD     .L2     B_y3_43,    B_y3h:B_y3l,B_y3h:B_y3l;
||      DOTP2   .M1     A_xs0_76,   A_h_76,     A_y0_76    ; = xs0_7*h7+xs0_6*h6
||      DOTP2   .M2     B_xs3_65,   B_h_65,     B_y3_65    ; = xs3_6*h6+xs3_5*h5
||      PACKHL2 .S2X    B_xr01,     A_xr67,     B_xr07     ;
||      ADD2    .S1X    B_xf98,     A_xr87,     A_xs2_76   ;
||[!A_o]ADDAD   .D2     B_xr_ptr,B_xr_offset,B_xr_ptr      ;
||[ A_o]LDNDW   .D1     *-A_h_ptr(10),B_h_65:B_h_43        ; @

  [!B_p]ADD     .L1     A_y0_54,    A_y0h:A_y0l,A_y0h:A_y0l;
||[!B_p]ADD     .L2     B_y1_43,    B_y1h:B_y1l,B_y1h:B_y1l;
||      DOTP2   .M1     A_xs2_76,   A_h_76,     A_y2_76    ; = xs2_7*h7+xs2_6*h6
||      DOTP2   .M2     B_xs3_07,   B_h_07,     B_y3_07    ; = xs3_0*h0+xs3_7*h7
||      ADD2    .D1X    A_xf32,     B_xr21,     A_xs2_10   ; @
||      ADD2    .D2X    B_xf32,     A_xr43,     B_xs1_21   ; @
||      ADD2    .S2     B_xf54,     B_xr21,     B_xs3_21   ; @
||[ A_i]BDEC    .S1     iloop,      A_i                    ; @

  [!B_p]ADD     .L1     A_y0_32,    A_y0h:A_y0l,A_y0h:A_y0l;
||[!B_p]ADD     .L2     B_y1_65,    B_y1h:B_y1l,B_y1h:B_y1l;
||      ADD2    .D1     A_xf10,     A_xr43,     A_xs0_10   ; @
||      PACKHL2 .S2     B_xf10,     B_xf98,     B_xf18     ; @
||      PACKHL2 .S1     A_xr67,     A_xr45,     A_xr65     ; @
||      LDDW    .D2T2   *--B_xr_ptr[1],B_xr01:B_xr23       ; @@
||[!A_o]MPY2    .M2X    B_xf32,   A_h_nh10,   B_y3_8:B_y2_8;x[nh+3]*h[nh]:x[nh+2]*h[nh]
||[!A_o]MPY2    .M1X    B_xf10,   A_h_nh10,   A_y1_8:A_y0_8;x[nh+1]*h[nh]:x[nh]*h[nh]

  [!B_p]ADD     .L1     A_y2_54,    A_y2h:A_y2l,A_y2h:A_y2l;
||[!B_p]ADD     .L2     B_y1_07,    B_y1h:B_y1l,B_y1h:B_y1l;
||[ A_o]DOTP2   .M1     A_xs2_10,   A_h_10,     A_y2_10    ; @ = xs2_1*h1+xs2_0*h0
||[ A_o]DOTP2   .M2     B_xs1_21,   B_h_21,     B_y1_21    ; @ = xs1_2*h2+xs1_1*h1
||      ADD2    .S2X    B_xf76,     A_xr43,     B_xs3_43   ; @
||      ADD2    .D1X    B_xf54,     A_xr43,     A_xs2_32   ; @
||      PACKHL2 .S1     A_xrAB,     A_xr89,     A_xrA9     ; @
||      LDDW    .D2T1   *--B_xr_ptr[2],A_xr89:A_xrAB       ; @@

  [!B_p]ADD     .L1     A_y0_76,    A_y0h:A_y0l,A_y0h:A_y0l;
||[!B_p]ADD     .L2     B_y3_65,    B_y3h:B_y3l,B_y3h:B_y3l;
||[ A_o]DOTP2   .M1     A_xs0_10,   A_h_10,     A_y0_10    ; @ = xs0_1*h1+xs0_0*h0
||[ A_o]DOTP2   .M2     B_xs3_21,   B_h_21,     B_y3_21    ; @ = xs3_2*h2+xs3_1*h1
||      PACKHL2 .S1     A_xr89,     A_xr67,     A_xr87     ; @
||      PACKHL2 .S2X    B_xr23,     A_xr89,     B_xr29     ; @
||[ A_o]LDDW    .D1T2   *A_xf_ptr,B_xf32:B_xf10            ; @@
||      LDDW    .D2T1   *++B_xr_ptr[1],A_xr45:A_xr67       ; @@

  [!B_p]ADD     .L1     A_y2_76,    A_y2h:A_y2l,A_y2h:A_y2l;
||[!B_p]ADD     .L2     B_y3_07,    B_y3h:B_y3l,B_y3h:B_y3l;
||[ A_o]DOTP2   .M1     A_xs2_32,   A_h_32,     A_y2_32    ; @ = xs2_3*h3+xs2_2*h2
||[ A_o]DOTP2   .M2     B_xs3_43,   B_h_43,     B_y3_43    ; @ = xs3_4*h4+xs3_3*h3
||      ADD2    .S1X    B_xf54,     A_xr87,     A_xs0_54   ; @
||      ADD2    .S2X    B_xf54,     A_xr65,     B_xs1_43   ; @
||[ A_o]LDDW    .D1T1   *A_xf_ptr,A_xf32:A_xf10            ; @@
||[ A_o]LDDW    .D2T2   *++B_xf_ptr[2],B_xf76:B_xf54       ; @@

  [ A_o]LDDW    .D1T2   *++A_xf_ptr[2],B_xfBA:B_xf98       ; @@
||[!A_o]ADD     .L1     A_y0_8,    A_y0h:A_y0l,A_y0h:A_y0l ;o last add for y0
||[!A_o]ADD     .L2     B_y3_8,    B_y3h:B_y3l,B_y3h:B_y3l ;o last add for y3
||[!A_i]MPY     .M1     A_o,0,A_o                          ;o
||[ B_p]MPY     .M2     B_p,0,B_p                          ; @ start add after
||[!A_o]MV      .D2X    A_s,B_ss                           ; twin reg for s
||[!A_o]ADD     .S1X    B_xr_offset,-2,A_xf_offset         ; = nh/4 + 1
||[!A_o]BDEC    .S2     iloop,      B_j                    ;o
; ============================ PIPE LOOP EPILOG ==============================

        SHR     .S1     A_y0h:A_y0l,A_s,A_y0h:A_y0l        ; = y0 >> s
||      SHR     .S2     B_y3h:B_y3l,B_ss,B_y3h:B_y3l       ; = y3 >> s
||      MV      .L1X    B_y2_8,A_y2_8                      ;o
||      MV      .L2X    A_y1_8,B_y1_8                      ;o
||      MVD     .M1     A_round,A_y0l                      ;p y0 (lower reg) = round
||      MVD     .M2     B_round,B_y3l                      ;p y3 (lower reg) = round
||      ADD     .D2     B_xr_offset,-4,B_xf_offset         ; = nh/4 - 1
||      SUB     .D1     A_h_ptr,A_h_offset,A_h_ptr         ;p return to h[0]

        LDDW    .D1T2   *--A_xf_ptr[A_xf_offset],B_xf32:B_xf10  ;p
||      ADD     .L1     A_y2_8,    A_y2h:A_y2l,A_y2h:A_y2l ; last add for y2
||      ADD     .L2     B_y1_8,    B_y1h:B_y1l,B_y1h:B_y1l ; last add for y1
||      MV      .S1     A_nhi,A_i                          ;p initialize inner lp cnt
||      ADD     .D2     B_p,1,B_p                          ;p set flag for add intr
||      MPY     .M1     A_y0h,0,A_y0h                      ;p clear y0 (higher reg)
||      MPY     .M2     B_y3h,0,B_y3h                      ;p clear y3 (higher reg)

        LDDW    .D1T1   *A_xf_ptr,A_xf32:A_xf10            ;p
||      LDDW    .D2T2   *--B_xf_ptr[B_xf_offset],B_xf76:B_xf54  ;p
||      SHR     .S1     A_y2h:A_y2l,A_s,A_y2h:A_y2l        ; = y2 >> s
||      SHR     .S2     B_y1h:B_y1l,B_ss,B_y1h:B_y1l       ; = y1 >> s
||      MV      .L2X    A_y0l,B_y0l
||      MV      .L1X    B_y3l,A_y3l
||      MPY     .M1     A_nhi,1,A_o                        ;p

        LDDW    .D1T2   *++A_xf_ptr[2],B_xfBA:B_xf98       ;p
||      PACK2   .L2     B_y1l,     B_y0l,    B_r10         ; r[1,0]
||      PACK2   .S1     A_y3l,     A_y2l,    A_r32         ; r[3,2]
||      MV      .L1X    B_r_ptr,A_r_ptr1

        STW     .D2T2   B_r10,*B_r_ptr++[2]                ; store r[1,0]
||      STW     .D1T1   A_r32,*+A_r_ptr1[1]                ; store r[3,2]
||      MV      .L1     A_y0h:A_y0l,A_y2h:A_y2l            ;p y2 = round
||      MV      .L2     B_y3h:B_y3l,B_y1h:B_y1l            ;p y1 = round

; ============================================================================

; ================ SYMBOLIC REGISTER ASSIGNMENTS: CLEANUP ================= ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A3,         A_SP        ; Stack pointer, A datapath
        .asg            B3,         B_ret       ; Return address
        .asg            B2,         B_csr       ; CSR value to restore
; ========================================================================= ;

        LDDW    .D2T2   *+B_SP[1],  B_ret:B_csr             ; Get rtn, CSR
||      MV              B_SP,       A_SP                    ; Twin Stack Ptr

        LDDW    .D1T1   *+A_SP[2],  A11:A10                 ; Restore A11, A10
||      LDDW    .D2T2   *+B_SP[3],  B11:B10                 ; Restore B11, B10

        LDDW    .D1T1   *+A_SP[4],  A13:A12                 ; Restore A13, A12
||      LDDW    .D2T2   *+B_SP[5],  B13:B12                 ; Restore B13, B12

        LDDW    .D1T1   *+A_SP[6],  A15:A14                 ; Restore A15, A14
||      B       .S2     B_ret                               ;

        LDW     .D2T2   *++B_SP[14],B14                     ; Restore B14, ...

        MVC     .S2     B_csr,      CSR                     ; Restore CSR

        NOP              3

; ===== Branch Occurs =====
; ===== Interruptibility state restored here =====

* ========================================================================= *
*   End of file:  dsp_fir_sym.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
firlms2.asm/    1061588610  0     0     0       12775     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.8     Sun Mar 17 11:19:34 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ======================================================================== *
*  NAME                                                                    *
*      DSP_firlms2 -- Least Mean Square Adaptive Filter                    *
*                 Hand Coded Assembly Implementation                       *
*                                                                          *
*  REVISION DATE                                                           *
*      13-Mar-2002                                                         *
*                                                                          *
*  USAGE                                                                   *
*                                                                          *
*      This routine has the following C prototype:                         *
*                                                                          *
*          long DSP_firlms2                                                *
*          (                                                               *
*              short       *restrict h,  // Filter Coefficients            *
*              const short *restrict x,  // Input Data                     *
*              short                 b,  // Error from previous FIR        *
*              int                   nh  // Number of Coefficients         *
*          )                                                               *
*                                                                          *
*      The DSP_firlms2 routine accepts a list of 'nh' input data and 'nh'  *
*      adaptive filter coefficients and updates the coefficients by        *
*      adding weighted error times the inputs to the original              *
*      coefficients. This assumes single sample input followed by the      *
*      last nh-1 inputs and nh coefficients.                               *
*                                                                          *
*  DESCRIPTION                                                             *
*                                                                          *
*      The algorithm is simple and Natural C implementation is as follows: *
*                                                                          *
*          long DSP_firlms2                                                *
*          (                                                               *
*              short       *restrict h,  // Filter Coefficients            *
*              const short *restrict x,  // Input Data                     *
*              short                 b,  // Error from previous FIR        *
*              int                   nh  // Number of Coefficients         *
*          )                                                               *
*          {                                                               *
*              int  i;                                                     *
*              long r=0;                                                   *
*                                                                          *
*              for(i = 0; i < nh; i++)                                     *
*              {                                                           *
*                * Update the filter coefficients *                        *
*                                                                          *
*                  h[i] += (x[i] * b) >> 15;                               *
*                                                                          *
*                * Calculate the filter output    *                        *
*                                                                          *
*                  r    += x[i + 1] * h[i];                                *
*              }                                                           *
*              return r;                                                   *
*          }                                                               *
*                                                                          *
*  TECHNIQUES                                                              *
*      - The loop is unrolled 4 times                                      *
*      - MPY2, PACKH2 and ADD2 are used to update the filter coefficients  *
*      - DOTP2 is used to calculate filter output                          *
*                                                                          *
*  ASSUMPTIONS                                                             *
*      - Assumes 16-bit input data, error and filter coefficients.         *
*      - nh > = 4 and is a multiple of 4                                   *
*                                                                          *
*   MEMORY NOTE                                                            *
*                                                                          *
*   NOTES                                                                  *
*      - Little Endian                                                     *
*      - No Bank Conflict                                                  *
*      - interrupt tolerant but not interruptible                          *
*                                                                          *
*   CYCLES                                                                 *
*       3 * nh/4 + 17                                                      *
*                                                                          *
*   CODESIZE                                                               *
*       144 bytes                                                          *
*                                                                          *
* ------------------------------------------------------------------------ *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ======================================================================== *


        .text
        .global _DSP_firlms2
_DSP_firlms2:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ==================== *
        .asg            A4,         A_hadd
        .asg            B5,         B_hadd
        .asg            B4,         B_inadd
        .asg            A5,         A_inadd
        .asg            A6,         A_err
        .asg            B31,        B_err
        .asg            B6,         B_nh_
        .asg            B0,         B_nh
        .asg            A9,         A_h32
        .asg            A8,         A_h10
        .asg            B17,        B_x32
        .asg            B16,        B_x10
        .asg            A31,        A_x43
        .asg            A30,        A_x21
        .asg            B17,        B_xb32H
        .asg            B16,        B_xb32L
        .asg            A9,         A_xb10H
        .asg            A8,         A_xb10L
        .asg            B7,         B_xb32
        .asg            A30,        A_xb10
        .asg            B29,        B_h3h2
        .asg            A3,         A_h1h0
        .asg            A31,        A_r1_
        .asg            B16,        B_r2_
        .asg            B9,         B_rH
        .asg            B8,         B_rL
        .asg            A25,        A_rH
        .asg            A24,        A_rL
        .asg            B28,        B_h1h0
        .asg            B3,         B_ret
        .asg            A7,         A_temp
        .asg            A1,         A_ec
        .asg            B2,         B_pc
        .asg            A5,         A_retH
        .asg            A4,         A_retL
* ======================================================================== *
* =========================== PIPE LOOP PROLOG =========================== *
         LDNDW   .D      *B_inadd++, B_x32:B_x10                 ;[ 1,1]
||       SHR     .S2     B_nh_,      2,          B_nh
||       PACK2   .L1     A_err,      A_err,      A_err


         MVK     .S1     6,          A_temp

         SUB     .L1X    B_inadd,    A_temp,     A_inadd
||       MV      .L2X    A_err,      B_err
||       B       .S2     loop                                    ;[12,1]

         LDNDW   .D      *B_inadd++, B_x32:B_x10                 ;[ 1,2]
||       MVK     .S2     3,          B_pc
||       MV      .L2X    A_hadd,     B_hadd

         ZERO    .L2     B_rH:B_rL
||       ZERO    .L1     A_rH:A_rL

* =========================== PIPE LOOP KERNEL =========================== *
loop:
  [!B_pc]STDW    .D2T2   B_h3h2:B_h1h0,          *B_hadd++       ;[15,1]
||[ B_nh]BDEC    .S2     loop,       B_nh                        ;[12,2]
||       ADD2    .L2X    B_xb32,     A_h32,      B_h3h2          ;[12,2]
||       SMPY2   .M1X    A_err,      B_x10,      A_xb10H:A_xb10L ;[ 6,4]
||       SMPY2   .M2     B_err,      B_x32,      B_xb32H:B_xb32L ;[ 6,4]
||       LDDW    .D1T1   *A_hadd++,  A_h32:A_h10                 ;[ 6,4]

         DOTP2   .M2X    A_x43,      B_h3h2,     B_r2_           ;[13,2]
||       DOTP2   .M1     A_x21,      A_h1h0,     A_r1_           ;[13,2]
||       PACKH2  .S1     A_xb10H,    A_xb10L,    A_xb10          ;[10,3]
||       PACKH2  .L2     B_xb32H,    B_xb32L,    B_xb32          ;[10,3]
||       LDNDW   .D      *B_inadd++, B_x32:B_x10                 ;[ 1,6]

  [!B_pc]ADD     .L1     A_r1_,      A_rH:A_rL,  A_rH:A_rL       ;[17,1]
||[!B_pc]ADD     .L2     B_r2_,      B_rH:B_rL,  B_rH:B_rL       ;[17,1]
||       MV      .S2X    A_h1h0,     B_h1h0                      ;[14,2]
||       ADD2    .S1     A_xb10,     A_h10,      A_h1h0          ;[11,3]
||       LDNDW   .D      *A_inadd++, A_x43:A_x21                 ;[ 8,4]
||[ B_pc]SUB     .D2     B_pc,       1,          B_pc

* =========================== PIPE LOOP EPILOG =========================== *

         B       .S2     B_ret

         STDW    .D2T2   B_h3h2:B_h1h0,          *B_hadd         ;[15,6]

         ADD     .L1     A_r1_,      A_rH:A_rL,  A_rH:A_rL       ;[17,6]
||       ADD     .L2     B_r2_,      B_rH:B_rL,  B_rH:B_rL       ;[17,6]

         NOP             1

         ADDU    .L1X    B_rL,       A_rH:A_rL,  A_retH:A_retL

         ADD     .L1X    B_rH,       A_retH,     A_retH


*========================================================================= *
*   End of file:  dsp_firlms2.asm                                          *
*------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*========================================================================= *

fltoq15.asm/    1061588610  0     0     0       13469     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.7     Sun Mar 17 11:19:38 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*     TEXAS INSTRUMENTS, INC.                                               *
*                                                                           *
*     NAME                                                                  *
*           DSP_fltoq15                                                     *
*                                                                           *
*     REVISION DATE                                                         *
*         27-Jul-2001                                                       *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fltoq15(float x[], short r[], short nx)                    *
*                                                                           *
*       x[nx] : Pointer to values of type float                             *
*       r[nx] : Contains Q15 values from x[nx]                              *
*       nx    : Number of elements in arrays                                *
*                                                                           *
*   DESCRIPTION                                                             *
*       Convert the IEEE floating point numbers stored in vector x[] into   *
*       Q.15 format numbers stored in vector r[]. Results are truncated     *
*       towards zero. Values that exceed the size limit will be saturated   *
*       to 0x7fff if value is positive and 0x8000 if value is negative.     *
*       All values too small to be correctly represented will be truncated  *
*       to 0.                                                               *
*                                                                           *
*       The 16-bit Q.15 format is defined as follows:                       *
*                                                                           *
*           1 11111                                                         *
*           5 432109876543210                                               *
*           S.XXXXXXXXXXXXXXX                                               *
*                                                                           *
*           range: 1.000000000000000 = -1.0               <-> -32768        *
*                  0.111111111111111 =  0.999969482421875 <->  32767        *
*                                                                           *
*       IEEE floating point format is defined as follows:                   *
*                                                                           *
*           31 30....23  22.....0                                           *
*            S EXPONENT  MANTISSA                                           *
*                                                                           *
*       The value is obtained as: (-1)^S * 1.MANTISSA * 2^(EXPONENT-127)    *
*                                                                           *
*     C CODE                                                                *
*         void DSP_fltoq15(float x[], short r[], short nx)                  *
*         {                                                                 *
*             int i, a;                                                     *
*                                                                           *
*             for(i = 0; i < nx; i++)                                       *
*             {                                                             *
*                 a = 32768 * x[i];                                         *
*                                                                           *
*                 // saturate to 16-bit //                                  *
*                 if (a>32767)  a =  32767;                                 *
*                 if (a<-32768) a = -32768;                                 *
*                                                                           *
*                 r[i] = (short) a;                                         *
*             }                                                             *
*         }                                                                 *
*                                                                           *
*     ASSUMPTIONS                                                           *
*         1.  nx >= 2                                                       *
*         2.  nx is a multiple of 2                                         *
*                                                                           *
*     NOTES                                                                 *
*         This code is interrupt-tolerant but not interruptible.            *
*         This implementation is ENDIAN NEUTRAL.                            *
*                                                                           *
*     TECHNIQUE                                                             *
*         Loop is unrolled twice.                                           *
*                                                                           *
*     CYCLES                                                                *
*         3 * nx/2 + 14                                                     *
*                                                                           *
*     CODESIZE                                                              *
*         224 bytes                                                         *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_fltoq15
_DSP_fltoq15:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x_ptr
        .asg            B4,         B_r_ptr
        .asg            A6,         A_nx
        .asg            A8,         A_bit23
        .asg            B16,        B_offset
        .asg            B9,         B_ma_mask
        .asg            A7,         A_c31
        .asg            B8,         B_bit23
        .asg            A5,         A_offset
        .asg            A3,         A_ma_mask
        .asg            B5,         B_c31
        .asg            B7,         B_fl_val_1
        .asg            B6,         B_fl_val
        .asg            B7,         B_mant
        .asg            B7,         B_exp
        .asg            B0,         B_sign
        .asg            B19,        B_manti
        .asg            B18,        B_shift
        .asg            B17,        B_fract
        .asg            A18,        A_fl_val_1
        .asg            A17,        A_mant_1
        .asg            A16,        A_exp_1
        .asg            A0,         A_sign_1
        .asg            A17,        A_manti_1
        .asg            A16,        A_shift_1
        .asg            A9,         A_fract_1
        .asg            A18,        A_fracts_1
        .asg            B1,         B_p
* ========================================================================= *

* =========================== PIPE LOOP PROLOG ============================ *
        LDNDW   .D1T2   *A_x_ptr++, B_fl_val_1:B_fl_val         ;[ 1,1]
||      MVKL    .S1     0x7FFFFF,   A_ma_mask                   ;setup

        SHR     .S1     A_nx,       1,        A_nx              ;setup
||      MVK     .S2     31,         B_c31                       ;setup
||      ZERO    .L1     A_bit23                                 ;setup

        B       .S2     loop                                    ;[12,1]
||      SET     .S1     A_bit23,    23, 23,   A_bit23           ;setup

        LDNDW   .D1T2   *A_x_ptr++, B_fl_val_1:B_fl_val         ;[ 1,2]
||      MVKH    .S1     0x7FFFFF,   A_ma_mask                   ;setup
||      MVK     .S2     135,        B_offset                    ;setup
||      MV      .L1X    B_c31,      A_c31                       ;setup
||      MV      .L2X    A_bit23,    B_bit23                     ;setup

        MVK     .S2     3,          B_p                         ;setup
||      MV      .L2X    A_ma_mask,  B_ma_mask                   ;setup
||      MV      .L1X    B_offset,   A_offset                    ;setup
||      SUB     .D1     A_nx,       2,        A_nx              ;setup

* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!B_p]STW     .D2T1   A_fracts_1, *B_r_ptr++                  ;[15,1]
||      BDEC    .S1     loop,       A_nx                        ;[12,2]
||[ A_sign_1]NEG.L1     A_fract_1,  A_fract_1                   ;[12,2]
||[ B_sign]NEG  .L2     B_fract,    B_fract                     ;[12,2]
||      MV      .D1X    B_fl_val_1, A_fl_val_1                  ;[ 6,4]
||      EXTU    .S2     B_fl_val,   1,  24,     B_exp           ;[ 6,4]

        SSHVR   .M1     A_manti_1,  A_shift_1,  A_fract_1       ;[10,3]
||      SSHVR   .M2     B_manti,    B_shift,    B_fract         ;[10,3]
||      EXTU    .S1     A_fl_val_1, 1,  24,     A_exp_1         ;[ 7,4]
||      AND     .L1     A_fl_val_1, A_ma_mask,  A_mant_1        ;[ 7,4]
||      SUB     .D2     B_offset,   B_exp,      B_shift         ;[ 7,4]
||      AND     .S2     B_fl_val,   B_ma_mask,  B_mant          ;[ 7,4]
||      LDNDW   .D1T2   *A_x_ptr++, B_fl_val_1:B_fl_val         ;[ 1,6]
|| [B_p]SUB     .L2     B_p,        1,          B_p             ;prolog coll

        SPACK2  .S1X    A_fract_1,  B_fract,    A_fracts_1      ;[14,2]
||      SUB     .L1     A_offset,   A_exp_1,    A_shift_1       ;[ 8,4]
||      ADD     .D1     A_mant_1,   A_bit23,    A_manti_1       ;[ 8,4]
||      SSHVR   .M1     A_fl_val_1, A_c31,      A_sign_1        ;[ 8,4]
||      ADD     .D2     B_mant,     B_bit23,    B_manti         ;[ 8,4]
||      SSHVR   .M2     B_fl_val,   B_c31,      B_sign          ;[ 8,4]

* =========================== PIPE LOOP EPILOG ============================ *
  [!B_p]  STW   .D2T1   A_fracts_1, *B_r_ptr++                  ;[15,5]
||[ A_sign_1]NEG.L1     A_fract_1,  A_fract_1                   ;[12,6]
||[ B_sign]NEG  .L2     B_fract,    B_fract                     ;[12,6]
||      B       .S2     B3

        NOP             1

        SPACK2  .S1X    A_fract_1,  B_fract,    A_fracts_1      ;[14,6]

        STW     .D2T1   A_fracts_1, *B_r_ptr++                  ;[15,6]

        NOP             2

* ========================================================================= *
*   End of file:  dsp_fltoq15.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


ifft16x32.asm/  1061588610  0     0     0       57438     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.3     Thu Sep  6 18:22:41 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


*========================================================================== *
*      TEXAS INSTRUMENTS, INC.                                              *
*                                                                           *
*      NAME                                                                 *
*            DSP_ifft16x32                                                  *
*                                                                           *
*      USAGE                                                                *
*            This routine is C-callable and can be called as:               *
*                                                                           *
*           void DSP_ifft16x32(const short * ptr_w, int  npoints,           *
*                            int   * ptr_x, int  *ptr_y ) ;                 *
*                                                                           *
*             ptr_w   =  input twiddle factors                              *
*             npoints =  number of points                                   *
*             ptr_x   =  transformed data reversed                          *
*             ptr_y   =  linear transformed data                            *
*                                                                           *
*            (See the C compiler reference guide.)                          *
*                                                                           *
*      In reality one can re-use fft16x32 to perform IFFT, by first         *
*      conjugating the input, performing the FFT, conjugating again.        *
*      This allows fft16x32 to perform the IFFT as well. However if         *
*      the double conjugation needs to be avoided then this routine         *
*      uses the same twiddle factors as the FFT and performs an IFFT.       *
*      The change in the sign of the twiddle factors is adjusted for        *
*      software. Hence this routine uses the same twiddle factors as        *
*      the FFT routine.                                                     *
*                                                                           *
*   DESCRIPTION                                                             *
*       The following code performs a mixed radix IFFT for "npoints" which  *
*       is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  *
*       transform and performs either a radix2 or radix4 transform on the   *
*       last stage depending on "npoints". If "npoints" is a multiple of 4, *
*       then this last stage is also a radix4 transform, otherwise it is a  *
*       radix2 transform. This program is available as a C compilable file  *
*       to automatically generate the twiddle factors "twiddle_split.c"     *
*                                                                           *
*         int i, j, k, n = N;                                               *
*         double theta1, theta2, theta3, x_t, y_t;                          *
*         const double M = 32768.0, PI = 3  41592654;                       *
*                                                                           *
*         for (j=1, k=0; j < n>>2; j = j<<2)                                *
*         {                                                                 *
*             for (i=0; i < n>>2; i += j<<1)                                *
*             {                                                             *
*                 theta1 = 2*PI*i/n;                                        *
*                 x_t = M*cos(theta1);                                      *
*                 y_t = M*sin(theta1);                                      *
*                 w[k+1] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+1] = 0x7fff;                            *
*                 w[k+0] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+0] = 0x7fff;                            *
*                                                                           *
*                 theta1 = 2*PI*(i+j)/n;                                    *
*                 x_t = M*cos(theta1);                                      *
*                 y_t = M*sin(theta1);                                      *
*                 w[k+7] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+3] = 0x7fff;                            *
*                 w[k+6] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+2] = 0x7fff;                            *
*                                                                           *
*                 theta2 = 4*PI*i/n;                                        *
*                 x_t = M*cos(theta2);                                      *
*                 y_t = M*sin(theta2);                                      *
*                 w[k+3] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+5] = 0x7fff;                            *
*                 w[k+2] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+4] = 0x7fff;                            *
*                                                                           *
*                 theta2 = 4*PI*(i+j)/n;                                    *
*                 x_t = M*cos(theta2);                                      *
*                 y_t = M*sin(theta2);                                      *
*                 w[k+9] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+7] = 0x7fff;                            *
*                 w[k+8] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+6] = 0x7fff;                            *
*                                                                           *
*                 theta3 = 6*PI*i/n;                                        *
*                 x_t = M*cos(theta3);                                      *
*                 y_t = M*sin(theta3);                                      *
*                 w[k+5] = (short) x_t;                                     *
*                 if (x_t >= M) w[k+9] = 0x7fff;                            *
*                 w[k+4] = (short) y_t;                                     *
*                 if (y_t >= M) w[k+8] = 0x7fff;                            *
*                                                                           *
*                 theta3 = 6*PI*(i+j)/n;                                    *
*                 x_t = M*cos(theta3);                                      *
*                 y_t = M*sin(theta3);                                      *
*                 w[k+11] = (short) x_t;                                    *
*                 if (x_t >= M) w[k+11] = 0x7fff;                           *
*                 w[k+10] = (short) y_t;                                    *
*                 if (y_t >= M) w[k+10] = 0x7fff;                           *
*                                                                           *
*                 k += 12;                                                  *
*             }                                                             *
*         }                                                                 *
*         w[2*n-1] = w[2*n-3] = w[2*n-5] = 0x7fff;                          *
*         w[2*n-2] = w[2*n-4] = w[2*n-6] = 0x0000;                          *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This code works for  both "npoints" a multiple of 2 or 4.           *
*       The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         *
*       double-word boundary for the "optimized" implementations.           *
*                                                                           *
*       The input and output data are complex, with the real/imaginary      *
*       components stored in adjacent locations in the array.  The real     *
*       components are stored at even array indices, and the imaginary      *
*       components are stored at odd array indices.                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF IFFT. It accepts the inputs in normal order and   *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in nor-    *
*       mal order and produces the outputs in normal order.                 *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 - xl21;                                 *
*                        yt2  = xl1 - xl20;                                 *
*                        xt2  = xl0 + xl21;                                 *
*                        yt1  = xl1 + xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 - yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 + xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 - yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 + xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 - yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 + xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*-------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*-------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*-------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 .  . Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order.                            *
*                                                                           *
*       The fft() code shown here performs the bulk of the computation      *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part os the         *
*       complex multiply is implemented using _dotp2. The imaginary         *
*       part of the complex multiply is implemented using the 16x32         *
*       multiply instruction "mpylir" or "mpyhir".                          *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The optimized implementations are written for LITTLE ENDIAN.        *
*                                                                           *
*   INTERRUPTS                                                              *
*       This code is interrupt tolerant but not interruptible. It masks out *
*       interrupts for the entire duration of the code.                     *
*                                                                           *
*   CYCLES                                                                  *
*       (13 * N/8 + 25) * ceil(log4(N) - 1) + (N + 8) * 1.5 + 30            *
*                                                                           *
*       N = 512, (13 * 64 + 25) * 4 + 520 * 1.5 + 30 = 4238 cycles          *
*                                                                           *
*   CODESIZE                                                                *
*       1064 bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


*============================================================================*
        .text
        .global _DSP_ifft16x32
_DSP_ifft16x32: 
*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ====================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A31,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
; ====================== SYMBOLIC REGISTER ASSIGNMENTS ======================*
        .asg            A0,         A_whl
*============================================================================*
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T1   A15,        *B_SP--[14] ; Reserve stack, Save A15

        MV      .S1X    B_SP,       A_SP        ; Twin Stack Pointer

        STW     .D1T1   A14,        *+A_SP[12]  ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]  ; Save B14
||      MVC     .S2     CSR,        B_csr       ; Capture CSR's state

        STW     .D1T1   A13,        *+A_SP[10]  ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]  ; Save B13
||      AND     .L2     B_csr,      -2, B_no_gie; Clear GIE
;-
        STW     .D1T1   A12,        *+A_SP[ 8]  ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]  ; Save B12

        STW     .D1T1   A11,        *+A_SP[ 6]  ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]  ; Save B11
||      MV      .L1X    B_csr,      A_csr       ; Partitioning MV

        STW     .D1T1   A10,        *+A_SP[ 4]  ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]  ; Save B10
||      MVC     .S2     B_no_gie,   CSR         ; Disable interrupts
; ===== Interrupts masked here =====

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_ptr_w
        .asg            B4,         B_n
        .asg            A6,         A_ptr_x
        .asg            B6,         B_ptr_y
        .asg            B14,        B_radix
        .asg            B0,         B_radix2
        .asg            B18,        B_h2
        .asg            B13,        B_tw_offset
        .asg            B0,         B_stride
        .asg            B1,         B_j
        .asg            B19,        B_fft_jmp
        .asg            A19,        A_fft_jmp
        .asg            B16,        B_l1
        .asg            B17,        B_l2
        .asg            A16,        A_l1
        .asg            A18,        A_h2
        .asg            A17,        A_l2
        .asg            B0,         B_x
        .asg            A15,        A_w0
        .asg            B0,         B_fft_jmp_1
        .asg            A14,        A_i
        .asg            B2,         B_pro
        .asg            A15,        A_w0
        .asg            B1,         B_j
        .asg            B0,         B_x
        .asg            B16,        B_l1
        .asg            B17,        B_l2
        .asg            B18,        B_h2
        .asg            A16,        A_l1
        .asg            A17,        A_l2
        .asg            A18,        A_h2
        .asg            A19,        A_fft_jmp
        .asg            B19,        B_fft_jmp
        .asg            A14,        A_i
        .asg            A5,         A_j
        .asg            B5,         B_w1
        .asg            A8,         A_w2
        .asg            B29,        B_co20_si20
        .asg            B28,        B_co10_si10
        .asg            A25,        A_co11_si11
        .asg            A24,        A_co30_si30
        .asg            A31,        A_co31_si31
        .asg            A30,        A_co21_si21
        .asg            B31,        B_x_1
        .asg            B30,        B_x_0
        .asg            B25,        B_xl1_1i
        .asg            B24,        B_xl1_0i
        .asg            B27,        B_xl2_1i
        .asg            B26,        B_xl2_0i
        .asg            B21,        B_xh2_1i
        .asg            B20,        B_xh2_0i
        .asg            A10,        A_x
        .asg            A27,        A_x_3
        .asg            A26,        A_x_2
        .asg            A25,        A_xl1_3i
        .asg            A24,        A_xl1_2i
        .asg            A25,        A_xl2_3i
        .asg            A24,        A_xl2_2i
        .asg            A23,        A_xh2_3i
        .asg            A22,        A_xh2_2i
        .asg            B31,        B_xh1_0
        .asg            B7,         B_xh0_0
        .asg            A29,        A_xh1_1
        .asg            A0,         A_xh0_1
        .asg            B25,        B_xl1_0
        .asg            B3,         B_xl0_0
        .asg            A20,        A_xl1_1
        .asg            A1,         A_xl0_1
        .asg            B20,        B_xh21_0
        .asg            B12,        B_xh20_0
        .asg            A11,        A_xh21_1
        .asg            A8,         A_xh20_1
        .asg            B28,        B_xl21_0
        .asg            B26,        B_xl20_0
        .asg            A7,         A_xl21_1
        .asg            A5,         A_xl20_1
        .asg            A13,        A_x_
        .asg            B11,        B_x__
        .asg            A2,         A_ifj
        .asg            B25,        B_x_1o
        .asg            B24,        B_x_0o
        .asg            A29,        A_x_3o
        .asg            A28,        A_x_2o
        .asg            B3,         B_yt0_0
        .asg            B7,         B_xt0_0
        .asg            A9,         A_yt0_1
        .asg            A3,         A_xt0_1
        .asg            B9,         B_yt1_0
        .asg            B7,         B_xt1_0
        .asg            A3,         A_yt2_1
        .asg            A22,        A_xt1_1
        .asg            B23,        B_yt2_0
        .asg            B10,        B_xt2_0
        .asg            A20,        A_yt1_1
        .asg            A28,        A_xt2_1
        .asg            B5,         B_p0
        .asg            B8,         B_p1
        .asg            B22,        B_xh2_0o
        .asg            B14,        B_p2
        .asg            B8,         B_p3
        .asg            B23,        B_xh2_1o
        .asg            A8,         A_p4
        .asg            A23,        A_p5
        .asg            A22,        A_xh2_2o
        .asg            A9,         A_p6
        .asg            A23,        A_p7
        .asg            A23,        A_xh2_3o
        .asg            B21,        B_p8
        .asg            B8,         B_p9
        .asg            B26,        B_xl1_0o
        .asg            B27,        B_pa
        .asg            B9,         B_pb
        .asg            B27,        B_xl1_1o
        .asg            A27,        A_pc
        .asg            A26,        A_pd
        .asg            A26,        A_xl1_2o
        .asg            A21,        A_pe
        .asg            A23,        A_pf
        .asg            A27,        A_xl1_3o
        .asg            B29,        B_co30_si30
        .asg            B5,         B_p10
        .asg            B8,         B_p11
        .asg            B30,        B_xl2_0o
        .asg            B5,         B_p12
        .asg            B8,         B_p13
        .asg            B31,        B_xl2_1o
        .asg            A24,        A_p14
        .asg            A7,         A_p15
        .asg            A20,        A_xl2_2o
        .asg            A23,        A_p16
        .asg            A21,        A_p17
        .asg            A21,        A_xl2_3o
        .asg            A12,        A_x__
; ============================================================================
        ZERO    .L2     B_tw_offset                             ;tw_offset = 0;
||      MV      .S2     B_n,        B_h2                        ;stride=n
||      STW     .D1T1   A_csr,      *+A_SP[ 2]  ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]  ; Remember return address

; ============================ PIPE LOOP PROLOG ==============================

        SHRU    .S2     B_h2,       2,          B_h2            ;[ 7,0]

        ADDAH   .D2     B_h2,       B_h2,       B_l2            ;[ 8,0]


        SHRU    .S1X    B_n,        3,          A_i             ;[ 9,0] n>>3

        MV      .L1X    B_l2,       A_l2                        ;[10,0]
||      SHL     .S2     B_h2,       1,          B_l1            ;[10,0]
||      MPYSU   .M2     8,          B_l2,       B_fft_jmp       ;1.5*stride

        MV      .D1X    B_h2,       A_h2                        ;[11,0]

LOOP_WHILE_N:

        MV      .L1X    B_l1,       A_l1                        ;[12,0]
||      LDDW    .D1T2   *A_ptr_x[A_h2], B_xh2_1i:B_xh2_0i       ;[ 1,1]

        SHRU    .S1X    B_fft_jmp,  4,          A_fft_jmp       ;[13,0]
||      MVK     .L2     1,          B_pro                       ;
||      ADD     .L1     A_ptr_x,    8,          A_x             ;[ 2,1]

        ADD     .D1X    A_ptr_w,    B_tw_offset,A_w0            ;[14,0]
||      SHRU    .S2     B_fft_jmp,  2,          B_fft_jmp_1     ;[14,0]
||      MPYSU   .M2     0,          B_j,        B_j             ;[14,0] j = 0

        MV      .L2X    A_ptr_x,    B_x                         ;[15,0]ptr_x
||      SUB     .D1     A_fft_jmp,  3,          A_fft_jmp       ;[15,0]
||      ADD     .L1X    A_w0,       B_tw_offset,A_w0            ;[15,0]tw_offset
||      ADD     .D2     B_tw_offset,B_fft_jmp_1,B_tw_offset     ;[15,0]fft_jmp

        MVD     .M1X    B_x,        A_x_                        ;[ 5,1]
||      LDDW    .D2T2   *B_x[B_l2], B_xl2_1i:B_xl2_0i           ;[ 5,1]
||      BDEC    .S1     LOOP_Y8 + 20, A_i

        SUB     .S1     A_fft_jmp,  0,          A_ifj           ;[ 6,1]
||      LDDW    .D1T1   *A_x[0],    A_x_3:A_x_2                 ;[ 6,1]
||      LDDW    .D2T2   *B_x[0],    B_x_1:B_x_0                 ;[ 6,1]
||      B       .S2     LOOP_Y9 + 16

  [!A_ifj]ADD   .S2     B_x,        B_fft_jmp,  B_x             ;[ 7,1]
||      LDDW    .D2T2   *B_x[B_l1], B_xl1_1i:B_xl1_0i           ;[ 7,1]
||      MV      .L1X    B_j,        A_j                         ;[ 7,1]
||      BDEC    .S1     LOOP_Y10 + 16, A_i

        LDDW    .D1T1   *A_x[A_h2], A_xh2_3i:A_xh2_2i           ;[ 8,1]
||      B       .S1     LOOP_Y11 + 12

        LDDW    .D1T1   *A_x[A_l2], A_xl2_3i:A_xl2_2i           ;[ 9,1]
||      ADD     .L2X    A_w0,       8,          B_w1            ;[ 9,1]
||      B       .S1     LOOP_Y12 + 16

        SUB     .L2     B_xh2_0i,   B_xl2_0i,   B_xl20_0        ;[10,1]
||      ADD     .S2     B_xl2_0i,   B_xh2_0i,   B_xh20_0        ;[10,1]
||      ADD     .D2     B_xl2_1i,   B_xh2_1i,   B_xh21_0        ;[10,1]
||      B       .S1     LOOP_Y
; ============================ PIPE LOOP KERNEL ==============================
LOOP_Y:
  [!B_pro]STDW  .D1T1   A_xl2_3o:A_xl2_2o,      *A_x__[A_l2]    ;[29,1]
||[!B_pro]STDW  .D2T2   B_xh2_1o:B_xh2_0o,      *B_x__[B_h2]    ;[29,1]
||      MPYHIR  .M2     B_co30_si30,B_xt2_0,    B_p11           ;[29,1]
||      MPYHIR  .M1     A_co21_si21,A_xt0_1,    A_pd            ;[29,1]
||      ADD     .L2     B_xl0_0,    B_xl21_0,   B_xt2_0         ;[16,2]conj
||[!A_ifj]ZERO  .S2     B_j                                     ;[16,2]
||      SUB     .L1     A_x_2,      A_xl1_2i,   A_xl0_1         ;[16,2]
||      SUB     .S1     A_x_3,      A_xl1_3i,   A_xl1_1         ;[16,2]

  [!B_pro]STDW  .D1T1   A_x_3o:A_x_2o,          *A_x__[0]       ;[30,1]
||      MPYLIR  .M1     A_co21_si21,A_xt0_1,    A_pf            ;[30,1]
||      SUB     .D2     B_p9,       B_p8,       B_xl1_0o        ;[30,1]conj
||      MPYLIR  .M2     B_co10_si10,B_yt1_0,    B_p0            ;[17,2]
||      ADD     .S1     A_xl0_1,    A_xl21_1,   A_xt2_1         ;[17,2]conj
||      SUB     .L2     B_xl1_0,    B_xl20_0,   B_yt2_0         ;[17,2]conj
||      SUB     .L1     A_xl1_1,    A_xl20_1,   A_yt2_1         ;[17,2]conj
||      SUB     .S2     B_xh1_0,    B_xh21_0,   B_yt0_0         ;[17,2]

        ADD     .S2     B_p12,      B_p13,      B_xl2_1o        ;[31,1]conj
||      ADD     .S1     A_p6,       A_p7,       A_xh2_3o        ;[31,1]conj
||      MPYHIR  .M2     B_co10_si10,B_xt1_0,    B_p1            ;[18,2]
||      ADD     .L2     B_xh21_0,   B_xh1_0,    B_x_1o          ;[18,2]
||      ADD     .D1     A_xl1_2i,   A_x_2,      A_xh0_1         ;[18,2]
||      ADD     .L1     A_xl1_3i,   A_x_3,      A_xh1_1         ;[18,2]
||      MVD     .M1X    B_x,        A_x_                        ;[ 5,3]
||      LDDW    .D2T2   *B_x[B_l2], B_xl2_1i:B_xl2_0i           ;[ 5,3]

        MPYHIR  .M1     A_co31_si31,A_xt2_1,    A_p15           ;[19,2]
||      MPYLIR  .M2     B_co10_si10,B_xt1_0,    B_p3            ;[19,2]
||      ADD     .L1     A_xl1_1,    A_xl20_1,   A_yt1_1         ;[19,2]conj
||      ADD     .S2     B_xl1_0i,   B_x_0,      B_xh0_0         ;[19,2]
||      SUB     .S1X    A_fft_jmp,  B_j,        A_ifj           ;[ 6,3]
||      LDDW    .D1T1   *A_x[0],    A_x_3:A_x_2                 ;[ 6,3]
||      LDDW    .D2T2   *B_x[0],    B_x_1:B_x_0                 ;[ 6,3]

  [!B_pro]STDW  .D1T1   A_xh2_3o:A_xh2_2o,      *A_x__[A_h2]    ;[33,1]
||      SUB     .L2     B_p11,      B_p10,      B_xl2_0o        ;[33,1]conj
||      MPYLIR  .M1     A_co31_si31,A_xt2_1,    A_p17           ;[20,2]
||      SUB     .S1     A_xh1_1,    A_xh21_1,   A_yt0_1         ;[20,2]
||      MVD     .M2X    A_x_,       B_x__                       ;[20,2]
||[!A_ifj]ADD   .S2     B_x,        B_fft_jmp,  B_x             ;[ 7,3]
||      LDDW    .D2T2   *B_x[B_l1], B_xl1_1i:B_xl1_0i           ;[ 7,3]
||      MV      .L1X    B_j,        A_j                         ;[ 7,3]

  [!B_pro]STDW  .D2T2   B_xl2_1o:B_xl2_0o,      *B_x__[B_l2]    ;[34,1]
||      MPYHIR  .M1     A_co31_si31,A_yt2_1,    A_p16           ;[21,2]
||      MPYHIR  .M2     B_co20_si20,B_yt0_0,    B_pa            ;[21,2]
||      SUB     .S1     A_xl0_1,    A_xl21_1,   A_xt1_1         ;[21,2]conj
||      SUB     .L2     B_xh0_0,    B_xh20_0,   B_xt0_0         ;[21,2]
||      ADD     .L1     A_xh20_1,   A_xh0_1,    A_x_2o          ;[21,2]
||      ADD     .S2     B_xh20_0,   B_xh0_0,    B_x_0o          ;[21,2]
||      LDDW    .D1T1   *A_x[A_h2], A_xh2_3i:A_xh2_2i           ;[ 8,3]

  [!B_pro]STDW  .D2T2   B_xl1_1o:B_xl1_0o,      *B_x__[B_l1]    ;[35,1]
||      ADD     .L1     A_pe,       A_pf,       A_xl1_3o        ;[35,1]conj
||      SUB     .S1     A_pd,       A_pc,       A_xl1_2o        ;[35,1]conj
||      MPYLIR  .M1     A_co31_si31,A_yt2_1,    A_p14           ;[22,2]
||      MPYLIR  .M2     B_co20_si20,B_yt0_0,    B_p8            ;[22,2]
||      SUB     .S2     B_p1,       B_p0,       B_xh2_0o        ;[22,2]conj
||      LDDW    .D1T1   *A_x[A_l2], A_xl2_3i:A_xl2_2i           ;[ 9,3]
||      ADD     .L2X    A_w0,       8,          B_w1            ;[ 9,3]

        BDEC    .S1     LOOP_Y,     A_i                         ;} end for
||[!B_pro]STDW  .D1T1   A_xl1_3o:A_xl1_2o,      *A_x__[A_l1]    ;[36,1]
||      MPYLIR  .M2     B_co20_si20,B_xt0_0,    B_pb            ;[23,2]
||      MPYLIR  .M1     A_co11_si11,A_yt1_1,    A_p4            ;[23,2]
||      SUB     .L1     A_xh0_1,    A_xh20_1,   A_xt0_1         ;[23,2]
||      SUB     .L2     B_xh2_0i,   B_xl2_0i,   B_xl20_0        ;[10,3]
||      ADD     .S2     B_xl2_0i,   B_xh2_0i,   B_xh20_0        ;[10,3]
||      ADD     .D2     B_xl2_1i,   B_xh2_1i,   B_xh21_0        ;[10,3]
LOOP_Y8:
        ZERO    .S2     B_pro                                   ;
||      STDW    .D2T2   B_x_1o:B_x_0o,          *B_x__[0]       ;[24,2]
||      MPYHIR  .M1     A_co11_si11,A_xt1_1,    A_p5            ;[24,2]
||      MPYHIR  .M2     B_co10_si10,B_yt1_0,    B_p2            ;[24,2]
||      ADD     .S1     A_xh21_1,   A_xh1_1,    A_x_3o          ;[24,2]
||      SUB     .L2     B_xh2_1i,   B_xl2_1i,   B_xl21_0        ;[11,3]
||      LDDW    .D1T1   *A_x[A_l1], A_xl1_3i:A_xl1_2i           ;[11,3]
||      ADD     .L1X    B_w1,       8,          A_w2            ;[11,3]
LOOP_Y9:
        ADD     .S1     A_p16,      A_p17,      A_xl2_3o        ;[25,2]conj
||      MV      .S2X    A_co30_si30,B_co30_si30                 ;[25,2]
||      MPYHIR  .M2     B_co20_si20,B_xt0_0,    B_p9            ;[25,2]
||      MPYLIR  .M1     A_co11_si11,A_xt1_1,    A_p7            ;[25,2]
||      ADD     .D2     B_x,        16,         B_x             ;[12,3]
||      SUB     .L2     B_x_0,      B_xl1_0i,   B_xl0_0         ;[12,3]
||      LDDW    .D1T2   *A_w0[A_j], B_co20_si20:B_co10_si10     ;[12,3]
LOOP_Y10:
        ADD     .S1X    B_x__,      8,          A_x__           ;[26,2]
||      SUB     .L1     A_p15,      A_p14,      A_xl2_2o        ;[26,2]conj
||      MPYHIR  .M2     B_co30_si30,B_yt2_0,    B_p12           ;[26,2]
||      MPYHIR  .M1     A_co11_si11,A_yt1_1,    A_p6            ;[26,2]
||      SUB     .S2     B_xl0_0,    B_xl21_0,   B_xt1_0         ;[13,3]conj
||      SUB     .L2     B_x_1,      B_xl1_1i,   B_xl1_0         ;[13,3]
||      ADD     .D2     B_xl1_1i,   B_x_1,      B_xh1_0         ;[13,3]
||      LDDW    .D1T1   *A_w2[A_j], A_co31_si31:A_co21_si21     ;[13,3]
LOOP_Y11:
        MPYLIR  .M2     B_co30_si30,B_xt2_0,    B_p13           ;[27,2]
||      MPYHIR  .M1     A_co21_si21,A_yt0_1,    A_pe            ;[27,2]
||      ADD     .S2     B_pa,       B_pb,       B_xl1_1o        ;[27,2]conj
||      ADD     .L2     B_xl1_0,    B_xl20_0,   B_yt1_0         ;[14,3]conj
||      SUB     .S1     A_xh2_2i,   A_xl2_2i,   A_xl20_1        ;[14,3]
||      SUB     .D1     A_xh2_3i,   A_xl2_3i,   A_xl21_1        ;[14,3]
||      ADD     .L1     A_xl2_3i,   A_xh2_3i,   A_xh21_1        ;[14,3]
||      LDDW    .D2T2   *B_x[B_h2], B_xh2_1i:B_xh2_0i           ;[ 1,4]
LOOP_Y12:
        MPYLIR  .M2     B_co30_si30,B_yt2_0,    B_p10           ;[28,2]
||      MPYLIR  .M1     A_co21_si21,A_yt0_1,    A_pc            ;[28,2]
||      SUB     .L1     A_p5,       A_p4,       A_xh2_2o        ;[28,2]
||      ADD     .S2     B_p2,       B_p3,       B_xh2_1o        ;[28,2]
||      ADD     .L2     B_j,        3,          B_j             ;[15,3]
||      ADD     .S1     A_xl2_2i,   A_xh2_2i,   A_xh20_1        ;[15,3]
||      LDDW    .D2T1   *B_w1[B_j], A_co11_si11:A_co30_si30     ;[15,3]
||      ADD     .D1X    B_x,        8,          A_x             ;[ 2,4]
; ============================ PIPE LOOP EPILOG ==============================
        STDW    .D1T1   A_xl2_3o:A_xl2_2o,      *A_x__[A_l2]    ;[29,4]
||      STDW    .D2T2   B_xh2_1o:B_xh2_0o,      *B_x__[B_h2]    ;[29,4]
||      MPYHIR  .M2     B_co30_si30,B_xt2_0,    B_p11           ;[29,4]
||      MPYHIR  .M1     A_co21_si21,A_xt0_1,    A_pd            ;[29,4]
||      NORM    .L2     B_n,        B_radix2                    ;[ 2,0]

        STDW    .D1T1   A_x_3o:A_x_2o,          *A_x__[0]       ;[30,4]
||      MPYLIR  .M1     A_co21_si21,A_xt0_1,    A_pf            ;[30,4]
||      SUB     .D2     B_p9,       B_p8,       B_xl1_0o        ;[30,4]
||      AND     .S2     B_radix2,   1,          B_radix2        ;norm(npoints)&1
||      MVK     .L2     4,          B_radix                     ; radix = 4?

        ADD     .L2     B_p12,      B_p13,      B_xl2_1o        ;[31,4]
||      ADD     .L1     A_p6,       A_p7,       A_xh2_3o        ;[31,4]
||[B_radix2]MVK .D2     2,          B_radix                     ;radix = 2

        CMPGTU  .L1X    A_h2,       B_radix,    A_whl           ;while

        STDW    .D1T1   A_xh2_3o:A_xh2_2o,      *A_x__[A_h2]    ;[33,4]
||      SUB     .L2     B_p11,      B_p10,      B_xl2_0o        ;[33,4]
||[A_whl]B      .S1     LOOP_WHILE_N                            ;} end while

        STDW    .D2T2   B_xl2_1o:B_xl2_0o,      *B_x__[B_l2]    ;[34,4]
||      SHRU    .S2     B_h2,       2,          B_h2            ;[ 7,0]

        STDW    .D2T2   B_xl1_1o:B_xl1_0o,      *B_x__[B_l1]    ;[35,4]
||      ADD     .L1     A_pe,       A_pf,       A_xl1_3o        ;[35,4]
||      SUB     .S1     A_pd,       A_pc,       A_xl1_2o        ;[35,4]

        STDW    .D1T1   A_xl1_3o:A_xl1_2o,      *A_x__[A_l1]    ;[36,4]
||      SHRU    .S1X    B_n,        3,          A_i             ;[ 9,0] n>>3
||      ADDAH   .D2     B_h2,       B_h2,       B_l2            ;[ 8,0]

        MV      .L1X    B_l2,       A_l2                        ;[10,0]
||      SHL     .S2     B_h2,       1,          B_l1            ;[10,0]
||      MPYSU   .M2     8,          B_l2,       B_fft_jmp       ;1.5*stride

        MV      .D1X    B_h2,       A_h2                        ;[11,0]

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            B14,        B_radix
        .asg            A6,         A_ptr_x
        .asg            B6,         B_ptr_y
        .asg            B4,         B_n
        .asg            A0,         A_r2
        .asg            A20,        A_p_x0
        .asg            B8,         B_p_x0
        .asg            B22,        B_p_y2
        .asg            B23,        B_p_y1
        .asg            B3,         B_p_y3
        .asg            B20,        B_l1
        .asg            B19,        B_j0
        .asg            A18,        A_i
        .asg            B9,         B_j
        .asg            A1,         A_pro
        .asg            B9,         B_j
        .asg            A18,        A_i
        .asg            B19,        B_j0
        .asg            B20,        B_l1
        .asg            B23,        B_p_y1
        .asg            B22,        B_p_y2
        .asg            B3,         B_p_y3
        .asg            A20,        A_p_x0
        .asg            B8,         B_p_x0
        .asg            A0,         A_r2
        .asg            B25,        B_h0
        .asg            B7,         B_h1
        .asg            B7,         B_h2
        .asg            B5,         B_h3
        .asg            B16,        B_h4
        .asg            A27,        A_x1
        .asg            A26,        A_x0
        .asg            B29,        B_x3
        .asg            B28,        B_x2
        .asg            A5,         A_x5
        .asg            A4,         A_x4
        .asg            B5,         B_x7
        .asg            B4,         B_x6
        .asg            A21,        A_xh0_0
        .asg            A3,         A_xh1_0
        .asg            B24,        B_xh0_1
        .asg            B26,        B_xh1_1
        .asg            B24,        B_y0
        .asg            B25,        B_y1
        .asg            B31,        B_y5
        .asg            B30,        B_y4
        .asg            A16,        A_xl0_0
        .asg            A19,        A_xl1_0
        .asg            B18,        B_xl0_1
        .asg            B17,        B_xl1_1
        .asg            A16,        A_y2
        .asg            A17,        A_y3
        .asg            A8,         A_y6
        .asg            A9,         A_y7
        .asg            A22,        A_temp
        .asg            B13,        B_zero
; ============================ PIPE LOOP PROLOG ==============================
        NORM    .L2     B_n,        B_l1                        ;_norm(n)+2
||      MVK     .L1     1,          A_pro                       ;
||      ZERO    .S2     B_zero                                  ;

        ZERO    .L2     B_j                                     ;[ 3,0]
||      SUB     .D1X    B_radix,    2,          A_r2            ;[ 3,0]
||      ADD     .S2     B_l1,       2,          B_l1            ;[ 3,0]
||      ADDAW   .D2     B_ptr_y,    B_n,        B_p_y2          ;[ 3,0]

        MVK     .S2     4,          B_j0                        ;[ 4,0] j0 = 4
||      ADDAH   .D2     B_p_y2,     B_n,        B_p_y3          ;[ 4,0]
||      SHL     .S1     A_pro,      15,         A_pro           ;

        SHRU    .S1X    B_n,        2,          A_i             ;[ 5,0]
||[!A_r2]MVK    .S2     8,          B_j0                        ;[ 5,0] j0 = 8
||[!A_r2]SUB    .L2     B_l1,       1,          B_l1            ;[ 5,0]
||      ADDAH   .D2     B_ptr_y,    B_n,        B_p_y1          ;[ 5,0]

  [!A_r2]ADD    .S2     B_p_y2,     B_n,        B_p_y3          ;[ 6,0]
||[!A_r2]ADD    .L2     B_ptr_y,    B_n,        B_p_y1          ;[ 6,0]
||      ADD     .D2X    A_ptr_x,    8,          B_p_x0          ; ptr_x
; ============================ PIPE LOOP KERNEL ==============================
LOOP_Z:
  [!A_r2]ROTL   .M1     A_x4,       0,          A_xl0_0         ;[13,1]
||      ADD     .L1X    A_xl1_0,    B_xl0_1,    A_y3            ;[13,1]conj
||      ADD     .S2X    A_xh1_0,    B_xh1_1,    B_y1            ;[13,1]
||      BDEC    .S1     LOOP_Z,     A_i                         ;[13,1] }end for
||      ADD     .L2     B_j,        B_j0,       B_j             ;j  += j0;
||      LDDW    .D2T2   *B_p_x0++[2],           B_x3:B_x2       ;[ 1,3]
||      LDDW    .D1T1   *A_ptr_x++[2],          A_x1:A_x0       ;[ 1,3]
||      DEAL    .M2     B_j,        B_h0                        ;h2=_deal(j);

 [!A_pro]STDW   .D2T2   B_y1:B_y0,  *B_ptr_y[B_h4]              ;[14,1]
||      MV      .S1     A_y3,       A_temp                      ;[14,1]
||      SUB     .L1X    A_xl1_0,    B_xl0_1,    A_y7            ;[14,1]conj
||      SUB     .L2     B_x2,       B_x6,       B_xl0_1         ;[ 8,2]
||      ADD     .S2     B_x6,       B_x2,       B_xh0_1         ;[ 8,2]
||      ADD     .D1     A_x4,       A_x0,       A_xh0_0         ;[ 8,2]
||[!A_r2]ROTL   .M1     A_x0,       0,          A_xh0_0         ;[ 8,2]
||[!A_r2]ROTL   .M2     B_x2,       0,          B_xh0_1         ;[ 8,2]

        ADD     .L1X    A_xl0_0,    B_xl1_1,    A_y6            ;[15,1]conj
||      SUB     .L2X    A_xh1_0,    B_xh1_1,    B_y5            ;[15,1]
||      ADD     .S1     A_x5,       A_x1,       A_xh1_0         ;[ 9,2]
||[!A_r2]ROTL   .M1     A_x1,       0,          A_xh1_0         ;[ 9,2]
||[!A_r2]SUB    .S2     B_zero,     B_x7,       B_xl0_1         ;[ 9,2]-1
||      SHFL    .M2     B_h2,       B_h3                        ; _shfl(h2);
||      LDDW    .D1T1   *A_ptr_x++[2],          A_x5:A_x4       ;[ 3,3]
||      LDDW    .D2T2   *B_p_x0++[2],           B_x7:B_x6       ;[ 3,3]

        SUB     .S1X    A_xl0_0,    B_xl1_1,    A_y2            ;[16,1]conj
||[!A_r2]MV     .D1     A_y7,       A_y3                        ;[16,1]
||[!A_pro]STDW  .D2T2   B_y5:B_y4,  *B_p_y2[B_h4]               ;[16,1]
||      SUB     .L1     A_x1,       A_x5,       A_xl1_0         ;[10,2]
||[!A_r2]ROTL   .M1     A_x5,       0,          A_xl1_0         ;[10,2]
||      ADD     .S2     B_x7,       B_x3,       B_xh1_1         ;[10,2]
||      SUB     .L2     B_x3,       B_x7,       B_xl1_1         ;[10,2]
||      BITR    .M2     B_h0,       B_h1                        ;_bitr(h2);

  [!A_r2]MV     .L1     A_temp,     A_y7                        ;[17,1]
||[!A_pro]STDW  .D2T1   A_y3:A_y2,  *B_p_y1[B_h4]               ;[17,1]
||      SUB     .D1     A_x0,       A_x4,       A_xl0_0         ;[11,2]
||      ADD     .L2X    A_xh0_0,    B_xh0_1,    B_y0            ;[11,2]
||      SUB     .S2X    A_xh0_0,    B_xh0_1,    B_y4            ;[11,2]
||[!A_r2]ROTL   .M2     B_x3,       0,          B_xh1_1         ;[11,2]

 [!A_pro]STDW   .D2T1   A_y7:A_y6,  *B_p_y3[B_h4]               ;[18,1]
||      SHRU    .S2     B_h3,       B_l1,       B_h4            ;h2 >>= l1;
||[!A_r2]SUB    .L2     0,          B_x6,       B_xl1_1         ;[12,2]-1
||      ROTL    .M2     B_h1,       16,         B_h2            ;h2=_rotl(h2,16)
||      MPYSU   .M1     2,          A_pro,      A_pro           ;10000
||      MV      .S1X    B_SP,       A_SP                        ;Twin Stack Pntr
; ============================ PIPE LOOP EPILOG ==============================
        LDW     .D1T2   *+A_SP[ 1], B_ret                       ;Get ret address
||      LDW     .D2T1   *+B_SP[ 2], A_csr                       ;Get CSR's value

        LDW     .D1T2   *+A_SP[ 3], B10                         ;Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10                         ;Restore A10

        LDW     .D1T2   *+A_SP[ 5], B11                         ;Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11                         ;Restore A11

        LDW     .D1T2   *+A_SP[ 7], B12                         ;Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12                         ;Restore A12

        LDW     .D1T2   *+A_SP[ 9], B13                         ;Restore B13
||      LDW     .D2T1   *+B_SP[10], A13                         ;Restore A13

        LDW     .D1T2   *+A_SP[11], B14                         ;Restore B14
||      LDW     .D2T1   *+B_SP[12], A14                         ;Restore A14

        LDW     .D2T1   *++B_SP[14],A15                         ;Restore A15
||      BNOP    .S2     B_ret, 4                                ;Ret to caller

        MVC     .S2X    A_csr,      CSR                         ;Restore CSR
        ;Interruptibility state restored
        ;Branch Occurs
*============================================================================*
*=  End of file:  ifft32x16_h.asm                                           =*
*============================================================================*
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*============================================================================*
ifft32x32.asm/  1061588610  0     0     0       51491     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Thu Sep  6 18:22:42 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


*========================================================================== *
*      TEXAS INSTRUMENTS, INC.                                              *
*                                                                           *
*      NAME                                                                 *
*            DSP_ifft32x32: Double Precision FFT                            *
*                                                                           *
*      USAGE                                                                *
*            This routine is C-callable and can be called as:               *
*                                                                           *
*           void DSP_ifft32x32(const int  * ptr_w, int  npoints,            *
*                            int   * ptr_x, int  * ptr_y ) ;                *
*                                                                           *
*             ptr_w   =  input twiddle factors                              *
*             npoints =  number of points                                   *
*             ptr_x   =  transformed data reversed                          *
*             ptr_y   =  linear transformed data                            *
*                                                                           *
*            (See the C compiler reference guide.)                          *
*                                                                           *
*       In reality one can re-use fft32x32 to perform IFFT, by first        *
*       conjugating the input, performing the FFT, conjugating again.       *
*       This allows fft32x32 to perform the IFFT as well. However if        *
*       the double conjugation needs to be avoided then this routine        *
*       uses the same twiddle factors as the FFT and performs an IFFT.      *
*       The change in the sign of the twiddle factors is adjusted for       *
*       software. Hence this routine uses the same twiddle factors as       *
*       the FFT routine.                                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       The following code performs a mixed radix IFFT for "npoints" which  *
*       is either a multiple of 4 or 2. It uses logN4 - 1 stages of radix4  *
*       transform and performs either a radix2 or radix4 transform on the   *
*       last stage depending on "npoints". If "npoints" is a multiple of 4, *
*       then this last stage is also a radix4 transform, otherwise it is a  *
*       radix2 transform. This program is available as a C compilable file  *
*       to automatically generate the twiddle factors "twiddle_split.c"     *
*                                                                           *
*       Generate special vector of twiddle factors                          *
*                                                                           *
*       for (j=1, k=0; j < npoints>>2; j = j <<2 )                          *
*       {                                                                   *
*           for (i=0; i < npoints>>2; i += j)                               *
*           {                                                               *
*               theta1 = 2*PI*i/npoints;                                    *
*               x_t = M*cos(theta1);                                        *
*               y_t = M*sin(theta1);                                        *
*               ptr_w[k+1] = (int) x_t;                                     *
*               if (x_t >= M) ptr_w[k+1] = 0x7fffffff;                      *
*               ptr_w[k+0] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+0] = 0x7fffffff;                      *
*                                                                           *
*               theta2 = 4*PI*i/npoints;                                    *
*               x_t = M*cos(theta2);                                        *
*               y_t = M*sin(theta2);                                        *
*               ptr_w[k+3] = (int) x_t;                                     *
*                                                                           *
*               if (x_t >= M) ptr_w[k+3] = 0x7fffffff;                      *
*               ptr_w[k+2] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+2] = 0x7fffffff;                      *
*                                                                           *
*               theta3 = 6*PI*i/npoints;                                    *
*               x_t = M*cos(theta3);                                        *
*               y_t = M*sin(theta3);                                        *
*               ptr_w[k+5] = (int) x_t;                                     *
*               if (x_t >= M) ptr_w[k+5] = 0x7fffffff;                      *
*               ptr_w[k+4] = (int) y_t;                                     *
*               if (y_t >= M) ptr_w[k+4] = 0x7fffffff;                      *
*               k += 6;                                                     *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This code works for  both "npoints" a multiple of 2 or 4.           *
*       The arrays 'x[]', 'y[]', and 'w[]' all must be aligned on a         *
*       double-word boundary for the "optimized" implementations.           *
*       The input and output data are complex, with the real/imaginary      *
*       components stored in adjacent locations in the array.  The real     *
*       components are stored at even array indices, and the imaginary      *
*       components are stored at odd array indices. The input, twiddle      *
*       factors are in 32 bit precision. The 32 by 32 multiplies are        *
*       done with a 1.5 bit loss in accuracy. This comes about because      *
*       the contribution of the low sixteen bits to the 32 bit result       *
*       is not computed. In addition the contribution of the low * high     *
*       term is shifted by 16 as opposed to 15, for a loss 0f 0.5 bits      *
*       after rounding. To illustrate real part of complex multiply of:     *
*       (X + jY) ( C + jS) =                                                *
*                                                                           *
*       _mpyhir(co10 , xt1_0)  - _mpyhir(si10 , yt1_0) +                    *
*                        (((MPYLUHS(co10,xt1_0) - MPYLUHS(si10, yt1_0)      *
*                                               + 0x8000)  >> 16) << 1)     *
*                                                                           *
*       The intrinsic C version of this code performs this function as:     *
*                                                                           *
*       _mpyhir(co10 , xt1_0)  - _mpyhir(co10 , xt1_0) +                    *
*                        (_dotpnrsu2(xt1_0yt1_0, co10si10) << 1);           *
*                                                                           *
*                                                                           *
*       where the functions _mpyhir, MPYLUHS are as follows:                *
*                                                                           *
*   #define _mpyhir(x,y) \                                                  *
*   (((int)((short)(x>>16)*(unsigned short)(y&0x0000FFFF)+0x4000) >> 15)    *
*    + \ ((int)((short)(x >> 16) * (short)((y) >> 16)) << 1))               *
*                                                                           *
*   #define MPYLUHS(x,y)   \                                                *
*       ( (int) ((unsigned short)(x & 0x0000FFFF) * (short) (y >> 16)) )    *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The following C code represents an implementation of the Cooley     *
*       Tukey radix 4 DIF FFT. It accepts the inputs in normal order and    *
*       produces the outputs in digit reversed order. The natural C code    *
*       shown in this file on the other hand, accepts the inputs in nor-    *
*       mal order and produces the outputs in normal order.                 *
*                                                                           *
*       Several transformations have been applied to the original Cooley    *
*       Tukey code to produce the natural C code description shown here.    *
*       In order to understand these it would first be educational to       *
*       understand some of the issues involved in the conventional Cooley   *
*       Tukey FFT code.                                                     *
*                                                                           *
*       void radix4(int n, short x[], short wn[])                           *
*       {                                                                   *
*           int    n1,  n2,  ie,   ia1,  ia2, ia3;                          *
*           int    i0,  i1,  i2,    i3,    i, j,     k;                     *
*           short  co1, co2, co3,  si1,  si2, si3;                          *
*           short  xt0, yt0, xt1,  yt1,  xt2, yt2;                          *
*           short  xh0, xh1, xh20, xh21, xl0, xl1,xl20,xl21;                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k = n; k > 1; k >>= 2)                                     *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 >>= 2;                                                   *
*               ia1 = 0;                                                    *
*                                                                           *
*               for (j = 0; j < n2; j++)                                    *
*               {                                                           *
*                    ia2 = ia1 + ia1;                                       *
*                    ia3 = ia2 + ia1;                                       *
*                                                                           *
*                    co1 = wn[2 * ia1    ];                                 *
*                    si1 = wn[2 * ia1 + 1];                                 *
*                    co2 = wn[2 * ia2    ];                                 *
*                    si2 = wn[2 * ia2 + 1];                                 *
*                    co3 = wn[2 * ia3    ];                                 *
*                    si3 = wn[2 * ia3 + 1];                                 *
*                    ia1 = ia1 + ie;                                        *
*                                                                           *
*                    for (i0 = j; i0< n; i0 += n1)                          *
*                    {                                                      *
*                        i1 = i0 + n2;                                      *
*                        i2 = i1 + n2;                                      *
*                        i3 = i2 + n2;                                      *
*                                                                           *
*                                                                           *
*                        xh0  = x[2 * i0    ] + x[2 * i2    ];              *
*                        xh1  = x[2 * i0 + 1] + x[2 * i2 + 1];              *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                                                                           *
*                        xh20 = x[2 * i1    ] + x[2 * i3    ];              *
*                        xh21 = x[2 * i1 + 1] + x[2 * i3 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        x[2 * i0    ] = xh0 + xh20;                        *
*                        x[2 * i0 + 1] = xh1 + xh21;                        *
*                                                                           *
*                        xt0  = xh0 - xh20;                                 *
*                        yt0  = xh1 - xh21;                                 *
*                        xt1  = xl0 - xl21;                                 *
*                        yt2  = xl1 - xl20;                                 *
*                        xt2  = xl0 + xl21;                                 *
*                        yt1  = xl1 + xl20;                                 *
*                                                                           *
*                        x[2 * i1    ] = (xt1 * co1 - yt1 * si1) >> 15;     *
*                        x[2 * i1 + 1] = (yt1 * co1 + xt1 * si1) >> 15;     *
*                        x[2 * i2    ] = (xt0 * co2 - yt0 * si2) >> 15;     *
*                        x[2 * i2 + 1] = (yt0 * co2 + xt0 * si2) >> 15;     *
*                        x[2 * i3    ] = (xt2 * co3 - yt2 * si3) >> 15;     *
*                        x[2 * i3 + 1] = (yt2 * co3 + xt2 * si3) >> 15;     *
*                    }                                                      *
*              }                                                            *
*                                                                           *
*              ie <<= 2;                                                    *
*          }                                                                *
*      }                                                                    *
*                                                                           *
*       The conventional Cooley Tukey FFT, is written using three loops.    *
*       The outermost loop "k" cycles through the stages. There are log     *
*       N to the base 4 stages in all. The loop "j" cycles through the      *
*       groups of butterflies with different twiddle factors, loop "i"      *
*       reuses the twiddle factors for the different butterflies within     *
*       a stage. It is interesting to note the following:                   *
*                                                                           *
*-------------------------------------------------------------------------- *
*       Stage#     #Groups     # Butterflies with common     #Groups*Bflys  *
*                                twiddle factors                            *
*-------------------------------------------------------------------------- *
*        1         N/4          1                            N/4            *
*        2         N/16         4                            N/4            *
*        ..                                                                 *
*        logN      1            N/4                          N/4            *
*-------------------------------------------------------------------------- *
*                                                                           *
*       The following statements can be made based on above observations:   *
*                                                                           *
*       a) Inner loop "i0" iterates a veriable number of times. In          *
*       particular the number of iterations quadruples every time from      *
*       1..N/4. Hence software pipelining a loop that iterates a vraiable   *
*       number of times is not profitable.                                  *
*                                                                           *
*       b) Outer loop "j" iterates a variable number of times as well.      *
*       However the number of iterations is quartered every time from       *
*       N/4 ..1. Hence the behaviour in (a) and (b) are exactly opposite    *
*       to each other.                                                      *
*                                                                           *
*       c) If the two loops "i" and "j" are colaesced together then they    *
*       will iterate for a fixed number of times namely N/4. This allows    *
*       us to combine the "i" and "j" loops into 1 loop. Optimized impl-    *
*       ementations will make use of this fact.                             *
*                                                                           *
*       In addition the Cooley Tukey FFT accesses three twiddle factors     *
*       per iteration of the inner loop, as the butterflies that re-use     *
*       twiddle factors are lumped together. This leads to accessing the    *
*       twiddle factor array at three points each sepearted by "ie". Note   *
*       that "ie" is initially 1, and is quadrupled with every iteration.   *
*       Therfore these three twiddle factors are not even contiguous in     *
*       the array.                                                          *
*                                                                           *
*       In order to vectorize the FFT, it is desirable to access twiddle    *
*       factor array using double word wide loads and fetch the twiddle     *
*       factors needed. In order to do this a modified twiddle factor       *
*       array is created, in which the factors WN/4, WN/2, W3N/4 are        *
*       arranged to be contiguous. This eliminates the seperation between   *
*       twiddle factors within a butterfly. However this implies that as    *
*       the loop is traversed from one stage to another, that we maintain   *
*       a redundant version of the twiddle factor array. Hence the size     *
*       of the twiddle factor array increases as compared to the normal     *
*       Cooley Tukey FFT.  The modified twiddle factor array is of size     *
*       "2 * N" where the conventional Cooley Tukey FFT is of size"3N/4"    *
*       where N is the number of complex points to be transformed. The      *
*       routine that generates the modified twiddle factor array was        *
*       presented earlier. With the above transformation of the FFT,        *
*       both the input data and the twiddle factor array can be accessed    *
*       using double-word wide loads to enable packed data processing.      *
*                                                                           *
*       The final stage is optimised to remove the multiplication as        *
*       w0 = 1.  This stage also performs digit reversal on the data,       *
*       so the final output is in natural order.                            *
*                                                                           *
*       The fft() code shown here performs the bulk of the computation      *
*       in place. However, because digit-reversal cannot be performed       *
*       in-place, the final result is written to a separate array, y[].     *
*                                                                           *
*       There is one slight break in the flow of packed processing that     *
*       needs to be comprehended. The real part of the complex number is    *
*       in the lower half, and the imaginary part is in the upper half.     *
*       The flow breaks in case of "xl0" and "xl1" because in this case     *
*       the real part needs to be combined with the imaginary part because  *
*       of the multiplication by "j". This requires a packed quantity like  *
*       "xl21xl20" to be rotated as "xl20xl21" so that it can be combined   *
*        using add2's and sub2's. Hence the natural version of C code       *
*       shown below is transformed using packed data processing as shown:   *
*                                                                           *
*                        xl0  = x[2 * i0    ] - x[2 * i2    ];              *
*                        xl1  = x[2 * i0 + 1] - x[2 * i2 + 1];              *
*                        xl20 = x[2 * i1    ] - x[2 * i3    ];              *
*                        xl21 = x[2 * i1 + 1] - x[2 * i3 + 1];              *
*                                                                           *
*                        xt1  = xl0 + xl21;                                 *
*                        yt2  = xl1 + xl20;                                 *
*                        xt2  = xl0 - xl21;                                 *
*                        yt1  = xl1 - xl20;                                 *
*                                                                           *
*                        xl1_xl0   = _sub2(x21_x20, x21_x20)                *
*                        xl21_xl20 = _sub2(x32_x22, x23_x22)                *
*                        xl20_xl21 = _rotl(xl21_xl20, 16)                   *
*                                                                           *
*                        yt2_xt1   = _add2(xl1_xl0, xl20_xl21)              *
*                        yt1_xt2   = _sub2(xl1_xl0, xl20_xl21)              *
*                                                                           *
*       Also notice that xt1, yt1 endup on seperate words, these need to    *
*       be packed together to take advantage of the packed twiddle fact     *
*       ors that have been loaded. In order for this to be achieved they    *
*       are re-aligned as follows:                                          *
*                                                                           *
*       yt1_xt1 = _packhl2(yt1_xt2, yt2_xt1)                                *
*       yt2_xt2 = _packhl2(yt2_xt1, yt1_xt2)                                *
*                                                                           *
*       In the folllowing code since all data elements are 32 bits, add2    *
*       sub2 are replaced with normal 32 bit add's and subtracts.           *
*       The packed words "yt1_xt1" allows the loaded"sc" twiddle factor     *
*       to be used for the complex multiplies. The real part of the         *
*       multiply and the imaginary part of the multiply are performed       *
*       as 16x32 multiplies using MPYLIR and MPYHIR                         *
*                                                                           *
*       (X + jY) ( C + j S) = (XC + YS) + j (YC - XS).                      *
*                                                                           *
*       The actual twiddle factors for the FFT are cosine, - sine. The      *
*       twiddle factors stored in the table are csine and sine, hence       *
*       the sign of the "sine" term is comprehended during multipli-        *
*       cation as shown above.                                              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The optimized implementations are written for LITTLE ENDIAN.        *
*                                                                           *
*   CYCLES                                                                  *
*       [(N/4 + 1) * 10 + 10] * ceil(log4(N) - 1) + 6 * (N/4 + 2) + 27      *
*                                                                           *
*       N = 512, [1290 + 10] * 4 + 6 * 130 + 27 = 6007 cycles               *
*                                                                           *
*   CODESIZE                                                                *
*       932 bytes of codesize                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

*==============================================================================*
        .text
        .global _DSP_ifft32x32
_DSP_ifft32x32: 
*================== SYMBOLIC REGISTER ASSIGNMENTS: SETUP ======================*
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A31,        A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
        .asg            A0,         A_whl
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A4,         A_ptr_w
        .asg            B4,         B_n
        .asg            A6,         A_ptr_x
        .asg            B6,         B_ptr_y
        .asg            A15,        A_stride
        .asg            A13,        A_tw_offset
        .asg            A14,        A_radix
        .asg            B0,         B_radix2
        .asg            A17,        A_j
        .asg            A23,        A_fft_jmp
        .asg            B20,        B_fft_jmp
        .asg            A19,        A_h2
        .asg            A18,        A_l1
        .asg            A20,        A_l2
        .asg            B21,        B_l1
        .asg            B22,        B_h2
        .asg            B23,        B_l2
        .asg            A10,        A_x
        .asg            A21,        A_w0
        .asg            B19,        B_w1
        .asg            A22,        A_w2
        .asg            A3,         A_fft_jmp_1
        .asg            A2,         A_i
        .asg            A1,         A_pro
        .asg            B2,         B_pro2
        .asg            B25,        B_xp1
        .asg            B24,        B_xp0
        .asg            A25,        A_xl1p1
        .asg            A24,        A_xl1p0
        .asg            B29,        B_xh2p1
        .asg            B28,        B_xh2p0
        .asg            A27,        A_xl2p1
        .asg            A26,        A_xl2p0
        .asg            A9,         A_xh0
        .asg            A24,        A_xh1
        .asg            B30,        B_xl0
        .asg            B27,        B_xl1
        .asg            A8,         A_xh20
        .asg            A29,        A_xh21
        .asg            B5,         B_xl20
        .asg            B7,         B_xl21
        .asg            A26,        A_y_h1_0
        .asg            A27,        A_y_h1_1
        .asg            B26,        B_j
        .asg            B29,        B_co10
        .asg            B28,        B_si10
        .asg            A31,        A_co20
        .asg            A30,        A_si20
        .asg            B27,        B_co30
        .asg            B26,        B_si30
        .asg            A5,         A_xt0
        .asg            A7,         A_yt0
        .asg            B8,         B_xt1
        .asg            B0,         B_yt2
        .asg            B9,         B_xt2
        .asg            B3,         B_yt1
        .asg            B8,         B_co10si10
        .asg            B5,         B_si10co10
        .asg            A8,         A_co20si20
        .asg            A5,         A_si20co20
        .asg            B5,         B_co30si30
        .asg            B3,         B_si30co30
        .asg            A7,         A_xt0yt0
        .asg            B16,        B_xt1yt1
        .asg            B9,         B_xt2yt2
        .asg            A5,         A_si10
        .asg            B18,        B_p0r
        .asg            A11,        A_p1r
        .asg            B30,        B_y_h2_0
        .asg            B3,         B_p01r
        .asg            B7,         B_p0c
        .asg            A3,         A_p1c
        .asg            B31,        B_y_h2_1
        .asg            B9,         B_p01c
        .asg            A27,        A_p2r
        .asg            A3,         A_p3r
        .asg            A28,        A_y_l1_0
        .asg            A24,        A_p23r
        .asg            A25,        A_p2c
        .asg            A3,         A_p3c
        .asg            A29,        A_y_l1_1
        .asg            A3,         A_p23c
        .asg            B7,         B_p4r
        .asg            B26,        B_p5r
        .asg            B24,        B_y_l2_0
        .asg            B8,         B_p45r
        .asg            B25,        B_p4c
        .asg            B24,        B_p5c
        .asg            B25,        B_y_l2_1
        .asg            B5,         B_p45c
        .asg            A16,        A_x_1
        .asg            B17,        B_x__
        .asg            A0,         A_ifj
        .asg            A0,         A_whl
; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        STW     .D2T1   A15,        *B_SP--[14] ; Reserve stack, Save A15

        MV      .S1X    B_SP,       A_SP        ; Twin Stack Pointer

        STW     .D1T1   A14,        *+A_SP[12]  ; Save A14
||      STW     .D2T2   B14,        *+B_SP[11]  ; Save B14
||      MVC     .S2     CSR,        B_csr       ; Capture CSR's state

        STW     .D1T1   A13,        *+A_SP[10]  ; Save A13
||      STW     .D2T2   B13,        *+B_SP[ 9]  ; Save B13
||      AND     .L2     B_csr, -2,  B_no_gie    ; Clear GIE
;-
        STW     .D1T1   A12,        *+A_SP[ 8]  ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 7]  ; Save B12

        STW     .D1T1   A11,        *+A_SP[ 6]  ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 5]  ; Save B11
||      MV      .L1X    B_csr,      A_csr       ; Partitioning MV

        STW     .D1T1   A10,        *+A_SP[ 4]  ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 3]  ; Save B10
||      MVC     .S2     B_no_gie,   CSR         ; Disable interrupts
; ===== Interrupts masked here =====
        STW     .D1T1   A_csr,      *+A_SP[ 2]  ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 1]  ; Remember return address
||      NORM    .L2     B_n,        B_radix2              ;[ 2,0]

        AND     .L2     B_radix2,   1,          B_radix2  ;[3,0]_norm(npoints)&1
||      MVK     .D1     4,          A_radix               ;[ 3,0] radix = 4?

  [ B_radix2]MVK.D1     2,          A_radix               ;[ 4,0] radix = 2
||      ZERO    .L1     A_tw_offset                       ;[ 4,0] tw_offset = 0;
||      MV      .S1X    B_n,        A_stride              ;[ 4,0] stride=n
; ============================ PIPE LOOP PROLOG ==============================
        ADDAH   .D1     A_ptr_w,    A_tw_offset,A_w0      ;[ 6,0]
||      SHRU    .S1     A_stride,   2,          A_h2      ;[ 6,0]
||      MVK     .L1     1,          A_pro                 ;[11,0]


        ADDAH   .D1     A_h2,       A_h2,       A_l2      ;[ 7,0]
||      MVK     .L2     1,          B_pro2                ;
||      SHL     .S1     A_pro,      29,         A_pro     ;

        ADD     .L2X    A_w0,       8,          B_w1      ;[ 8,0]
||      MPYSU   .M1     6,          A_stride,   A_fft_jmp ;fft_jmp=1.5*stride

        SHRU    .S1X    B_n,        2,          A_i       ;[ 9,0] n>>3
||      MV      .D2X    A_l2,       B_l2                  ;[ 9,0]

        MV      .L2X    A_h2,       B_h2                  ;[10,0]
||      SHRU    .S1     A_stride,   1,          A_l1      ;[10,0]
||      ROTL    .M1     A_ptr_x,    0,          A_x       ;x = ptr_x
||      ADD     .D1X    B_w1,       8,          A_w2      ;[12,0]

LOOP_WHILE:

        SUB     .L1     A_i,        1,          A_i       ;[11,0]
||      SHRU    .S2X    A_fft_jmp,  3,          B_fft_jmp ;[11,0]
||      SHRU    .S1     A_fft_jmp,  1,        A_fft_jmp_1 ;[11,0]
||      MPYSU   .M1     0,          A_j,        A_j       ;[11,0] j = 0
||      LDDW    .D1T2   *A_ptr_x[0],B_xp1:B_xp0           ;x[0]  (0)

        MV      .S2X    A_l1,       B_l1                  ;[12,0]
||      ADD     .L1     A_tw_offset,A_fft_jmp_1,A_tw_offset;[12,0]tw_offset+=
||      SUB     .L2     B_fft_jmp,  3,          B_fft_jmp ;[12,0]       fft_jmp
||      SHRU    .S1     A_stride,   2,          A_stride  ;[12,0]stride >>= 2
||      LDDW    .D1T1   *A_ptr_x[A_l1],   A_xl1p1:A_xl1p0 ;x[l1] (N/2)
; ============================ PIPE LOOP KERNEL ==============================
LOOP_Y:
        SUB     .S1     A_p2r,      A_p3r,      A_y_l1_0  ;[23,2]*y[l1]=
||      ADDAH   .D2     B_y_h2_1,   B_p01c,     B_y_h2_1  ;[23,2](si20*yt0+
||      MPYHIR  .M2     B_co10,     B_xt1,      B_p0r     ;[13,3] co20*xt0)>>15
||      PACKH2  .S2     B_xt1,      B_yt1,      B_xt1yt1  ;[13,3]*
||      SUB     .L2     B_xl1,      B_xl20,     B_yt2     ;[13,3]*yt2=xl1+xl20
||      SUB     .L1     A_xh1,      A_xh21,     A_yt0     ;[13,3] yt0=xh1-xh21
||      LDDW    .D1T1   *A_x[A_l2], A_xl2p1:A_xl2p0       ;[ 3,4] x[l2] (3N/4)

        ADD     .L1     A_pro,      A_pro,      A_pro     ;[34,1]
||      ADDAH   .D2     B_y_l2_1,   B_p45c,     B_y_l2_1  ;[24,2]
||      MPYHIR  .M2     B_si30,     B_yt2,      B_p5r     ;[14,3]
||      MPYHIR  .M1X    A_si10,     B_yt1,      A_p1r     ;[14,3]
||      PACK2   .S2     B_co30,     B_si30,     B_co30si30;[14,3]*()>>16
||      ADD     .L2     B_xl0,      B_xl21,     B_xt2     ;[14,3]*xt2=xl0-xl21
||      ADD     .S1     A_xh21,     A_xh1,      A_y_h1_1  ;[14,3] y[1]=xh1+xh21
||      LDDW    .D1T2   *A_x[A_h2], B_xh2p1:B_xh2p0       ;[ 4,4] x[h2] (N/4)

  [!A_pro]STDW  .D2T2   B_y_l2_1:B_y_l2_0,  *B_x__[B_l2]  ;[25,2]
||      ADD     .L1     A_p2c,      A_p3c,      A_y_l1_1  ;[25,2]*y[l1+1]=(
||      ADDAH   .D1     A_y_l1_0,   A_p23r,     A_y_l1_0  ;[25,2] co20*yt0-
||      MPYHIR  .M2     B_co30,     B_yt2,      B_p4c     ;[15,3] si20*xt0)>>15
||      SUB     .L2X    B_p0r,      A_p1r,      B_y_h2_0  ;[25,2]*y[h2]=(
||      MPYHIR  .M1X    A_si10,     B_xt1,      A_p1c     ;[15,3] si10*yt1+
||      PACK2   .S2     B_co10,     B_si10,     B_co10si10;[15,3]*co10*xt1)>>15
||      SUB     .S1     A_xh0,      A_xh20,     A_xt0     ;[15,3] xt0=xh0-xh20

        ADDAH   .D2     B_y_h2_0,   B_p01r,     B_y_h2_0  ;[26,2]
||[!B_pro2]STDW .D1T1   A_y_h1_1:A_y_h1_0,      *A_x_1[0] ;[16,3]
||      MPYHIR  .M2     B_si30,     B_xt2,      B_p5c     ;[16,3]
||      MPYHIR  .M1     A_co20,     A_yt0,      A_p2c     ;[16,3]
||      PACK2   .S1     A_co20,     A_si20,     A_co20si20;[16,3]*()>>16
||      PACK2   .L2     B_si30,     B_co30,     B_si30co30;[16,3]*()>>16
||      SUB     .L1X    B_fft_jmp,  A_j,        A_ifj     ;[6,4]ifj=(j-fft_jmp)
||      MV      .S2X    A_j,        B_j                   ;[ 6,4]

        BDEC    .S1     LOOP_Y,     A_i                   ;[37,1]
||      MPYHIR  .M2     B_co30,     B_xt2,      B_p4r     ;[17,3]
||      MPYHIR  .M1     A_si20,     A_yt0,      A_p3r     ;[17,3]
||      PACKH2  .S2     B_xt2,      B_yt2,      B_xt2yt2  ;[17,3]*
||      LDDW    .D2T1   *B_w1[B_j], A_co20:A_si20         ;[ 7,4]
||      LDDW    .D1T2   *A_w0[A_j], B_co10:B_si10         ;[ 7,4]
||      SUB     .L2X    B_xp1,      A_xl1p1,    B_xl1     ;[7,4]xl1=x[1]-x[l1p1]
||      ADD     .L1X    B_xp0,      A_xl1p0,    A_xh0     ;[7,4]xh0=x[0]+x[l1]

  [!A_pro]STDW  .D2T2   B_y_h2_1:B_y_h2_0,  *B_x__[B_h2]  ;[28,2]
||      ADDAH   .D1     A_y_l1_1,   A_p23c,     A_y_l1_1  ;[28,2]
||      DOTPNRSU2.M2    B_xt2yt2,   B_co30si30, B_p45r    ;[18,3]*
||      MPYHIR  .M1     A_co20,     A_xt0,      A_p2r     ;[18,3]
||      PACKH2  .L1     A_xt0,      A_yt0,      A_xt0yt0  ;[18,3]
||      PACK2   .S2     B_si10,     B_co10,     B_si10co10;[18,3]*()>>16
||      SUB     .L2X    B_xp0,      A_xl1p0,    B_xl0     ;[8,4]xl0=x[0]-x[l1]
||      ADD     .S1X    B_xp1,      A_xl1p1,    A_xh1     ;[8,4]xh1=x[1]+x[l1p1]

        DOTPRSU2.M2     B_xt1yt1,   B_si10co10, B_p01c    ;[19,3] *
||[!A_ifj]ADD   .L1     A_x,        A_fft_jmp,  A_x       ;[9,4]if(!predj)
||      MVD     .M1     A_x,        A_x_1                 ;[9,4]      x+=fft_jmp
||      ADD     .S1     A_j,        3,          A_j       ;[9,4] j += 1
||      LDDW    .D1T2   *A_w2[A_j], B_co30:B_si30         ;[9,4]
||      SUB     .D2X    B_xh2p0,    A_xl2p0,    B_xl20    ;[9,4]xl20=x[h2]-x[l2]
||      ZERO    .L2     B_pro2

  [!A_pro]STDW  .D2T1   A_y_l1_1:A_y_l1_0, *B_x__[B_l1]   ;[30,2]
||      ADD     .S1X    B_xh2p1,    A_xl2p1,    A_xh21    ;[10,4]xh21=x[h2p1]+
||      DOTPRSU2.M2     B_xt2yt2,   B_si30co30, B_p45c    ;[20,3]*    x[l2p1]
||      ADD     .S2X    B_p0c,      A_p1c,      B_y_h2_1  ;[20,3]*y[h2+1]=(
||      MPYHIR  .M1     A_si20,     A_xt0,      A_p3c     ;[20,3] co10*yt1-
||      ADD     .L1     A_x,        8,          A_x       ;[10,4] si10*xt1)>>15
||[!A_ifj]ZERO  .D1     A_j                               ;[10,4]if(!predj)j=0
||      ADD     .L2     B_xl1,      B_xl20,     B_yt1     ;[10,4]*yt1=xl1-xl20

        ADD     .S2     B_p4c,      B_p5c,      B_y_l2_1  ;[21,3]*y[l2+1]=(
||      DOTPNRSU2.M1    A_xt0yt0,   A_co20si20, A_p23r    ;*[21,3]si30*yt2-
||      DOTPNRSU2.M2    B_xt1yt1,   B_co10si10, B_p01r    ;*[21,3] co30*xt2)>>15
||      SUB     .L2     B_p4r,      B_p5r,      B_y_l2_0  ;[21,3]*y[l2]=
||      PACK2   .L1     A_si20,     A_co20,     A_si20co20;*co30*yt2+si30*xt2
||      SUB     .D2X    B_xh2p1,    A_xl2p1,    B_xl21    ;xl21=x[h2p1]-x[l2p1]
||      ADD     .S1X    B_xh2p0,    A_xl2p0,    A_xh20    ;xh20=x[h2]+x[l2]
||      LDDW    .D1T2   *A_x[0],    B_xp1:B_xp0           ;x[0]  (0)

        MV      .S2X    A_x_1,      B_x__                 ;[22,3]
||      ADDAH   .D2     B_y_l2_0,   B_p45r,     B_y_l2_0  ;[22,3]
||      DOTPRSU2.M1     A_xt0yt0,   A_si20co20, A_p23c    ;[22,3]*
||      MPYHIR  .M2     B_co10,     B_yt1,      B_p0c     ;[12,4]
||      MV      .L1X    B_si10,     A_si10                ;[12,4]
||      SUB     .L2     B_xl0,      B_xl21,     B_xt1     ;*xt1=xl0-xl21
||      ADD     .S1     A_xh20,     A_xh0,      A_y_h1_0  ;y[0]=xh0+xh20
||      LDDW    .D1T1   *A_x[A_l1], A_xl1p1:A_xl1p0       ;x[l1] (N/2)
; ============================ PIPE LOOP EPILOG ==============================
        SUB     .S1     A_p2r,      A_p3r,      A_y_l1_0  ;[23,5]*y[l1]=(
||      ADDAH   .D2     B_y_h2_1,   B_p01c,     B_y_h2_1  ;[23,5] si20*yt0+

        ADDAH   .D2     B_y_l2_1,   B_p45c,     B_y_l2_1  ;[24,5] co20*xt0)>>15
||      CMPGTU  .L1     A_stride,   A_radix,    A_whl     ;while(stride>radix)do

        STDW    .D2T2   B_y_l2_1:B_y_l2_0,      *B_x__[B_l2];[25,5]
||      ADD     .L1     A_p2c,      A_p3c,      A_y_l1_1  ;[25,5]*y[l1+1]=
||      ADDAH   .D1     A_y_l1_0,   A_p23r,     A_y_l1_0  ;[25,5]c2*yt0-s2*xt0
||[A_whl]B      .S1     LOOP_WHILE                        ;} end while
||      SUB     .L2X    B_p0r,      A_p1r,      B_y_h2_0  ;[25,5]*y[h2]=(
                                                          ;s1*y1+c1*x1)>>15
        ADDAH   .D2     B_y_h2_0,   B_p01r,     B_y_h2_0  ;[26,5]
||      ADDAH   .D1     A_ptr_w,    A_tw_offset,A_w0      ;[ 6,0]
||      SHRU    .S1     A_stride,   2,          A_h2      ;[ 6,0]
||      MVK     .L1     1,          A_pro                 ;[11,0]

        NOP             1
||      ADDAH   .D1     A_h2,       A_h2,       A_l2      ;[ 7,0]
||      MVK     .L2     1,          B_pro2                ;
||      SHL     .S1     A_pro,      29,         A_pro     ;

        STDW    .D2T2   B_y_h2_1:B_y_h2_0,      *B_x__[B_h2];[28,5]
||      ADDAH   .D1     A_y_l1_1,   A_p23c,     A_y_l1_1  ;[28,5]
||      ADD     .L2X    A_w0,       8,          B_w1      ;[ 8,0]
||      MPYSU   .M1     6,          A_stride,   A_fft_jmp ;fft_jmp=1.5*stride

        NOP             1
||      SHRU    .S1X    B_n,        2,          A_i       ;[ 9,0] n>>3
||      MV      .D2X    A_l2,       B_l2                  ;[ 9,0]

        STDW    .D2T1   A_y_l1_1:A_y_l1_0,      *B_x__[B_l1];[30,5]
||      MV      .L2X    A_h2,       B_h2                  ;[10,0]
||      SHRU    .S1     A_stride,   1,          A_l1      ;[10,0]
||      ROTL    .M1     A_ptr_x,    0,          A_x       ;x = ptr_x
||      ADD     .D1X    B_w1,       8,          A_w2      ;[12,0]

; ====================== SYMBOLIC REGISTER ASSIGNMENTS =======================
        .asg            A14,        A_radix
        .asg            A6,         A_ptr_x
        .asg            B6,         B_ptr_y
        .asg            B4,         B_n
        .asg            A0,         A_r2
        .asg            A20,        A_p_x0
        .asg            B8,         B_p_x0
        .asg            B21,        B_p_y0
        .asg            B22,        B_p_y2
        .asg            B23,        B_p_y1
        .asg            B3,         B_p_y3
        .asg            B20,        B_l1
        .asg            B19,        B_j0
        .asg            A18,        A_i
        .asg            B9,         B_j
        .asg            A1,         A_pro
        .asg            B25,        B_h0
        .asg            B7,         B_h1
        .asg            B7,         B_h2
        .asg            B5,         B_h3
        .asg            B16,        B_h4
        .asg            A7,         A_x1
        .asg            A6,         A_x0
        .asg            B29,        B_x3
        .asg            B28,        B_x2
        .asg            A5,         A_x5
        .asg            A4,         A_x4
        .asg            B5,         B_x7
        .asg            B4,         B_x6
        .asg            A21,        A_xh0_0
        .asg            A3,         A_xh1_0
        .asg            B24,        B_xh0_1
        .asg            B26,        B_xh1_1
        .asg            B24,        B_y0
        .asg            B25,        B_y1
        .asg            B6,         B_y4
        .asg            B7,         B_y5
        .asg            A16,        A_xl0_0
        .asg            A19,        A_xl1_0
        .asg            B18,        B_xl0_1
        .asg            B17,        B_xl1_1
        .asg            A16,        A_y2
        .asg            A17,        A_y3
        .asg            A8,         A_y6
        .asg            A9,         A_y7
        .asg            A22,        A_temp
; ============================ PIPE LOOP PROLOG ==============================
        NORM    .L2     B_n,        B_l1               ;[ 2,0] l1 = _norm(n) + 2;
||      MV      .D2     B_ptr_y,    B_p_y0             ;[ 2,0]
||      MVK     .L1     1,          A_pro              ;

        ZERO    .L2     B_j                            ;[ 3,0]
||      SUB     .D1     A_radix,    2,          A_r2   ;[ 3,0]
||      ADD     .S2     B_l1,       2,          B_l1   ;[ 3,0]
||      ADDAW   .D2     B_p_y0,     B_n,        B_p_y2 ;[ 3,0]

        MVK     .S2     4,          B_j0               ;[ 4,0] j0 = 4
||[!A_r2]NORM   .L2     B_n,        B_l1               ;[ 4,0] l1 = _norm(n) + 1;
||      ADDAH   .D2     B_p_y2,     B_n,        B_p_y3 ;[ 4,0]
||      SHL     .S1     A_pro,      15,         A_pro  ;

        SHRU    .S1X    B_n,        2,          A_i    ;[ 5,0]
||[!A_r2]MVK    .S2     8,          B_j0               ;[ 5,0] j0 = 8
||[!A_r2]ADD    .L2     B_l1,       1,          B_l1   ;[ 5,0]
||      ADDAH   .D2     B_p_y0,     B_n,        B_p_y1 ;[ 5,0]

  [!A_r2]ADD    .S2     B_p_y2,     B_n,        B_p_y3 ;[ 6,0]
||[!A_r2]ADD    .L2     B_p_y0,     B_n,        B_p_y1 ;[ 6,0]
||      ADD     .D2X    A_ptr_x,    8,          B_p_x0 ;[ 6,0] x = ptr_x
||      MV      .L1     A_ptr_x,    A_p_x0             ;[ 6,0]
; ============================ PIPE LOOP KERNEL ==============================
LOOP_Z:
  [!A_r2]ROTL   .M1     A_x4,       0,          A_xl0_0;[13,1]
||      ADD     .L1X    A_xl1_0,    B_xl0_1,    A_y3   ;[13,1]*
||      ADD     .S2X    A_xh1_0,    B_xh1_1,    B_y1   ;[13,1]
||      BDEC    .S1     LOOP_Z,     A_i                ;[13,1] }end for
||      ADD     .L2     B_j,        B_j0,       B_j    ;[ 1,3]j += j0;
||      LDDW    .D2T2   *B_p_x0++[2],         B_x3:B_x2;[ 1,3]
||      LDDW    .D1T1   *A_p_x0++[2],         A_x1:A_x0;[ 1,3]
||      DEAL    .M2     B_j,        B_h0               ;[ 1,3] h2 = _deal(j);

 [!A_pro]STDW   .D2T2   B_y1:B_y0,  *B_p_y0[B_h4]      ;[14,1]
||      MV      .S1     A_y3,       A_temp             ;[14,1]
||      SUB     .L1X    A_xl1_0,    B_xl0_1,    A_y7   ;[14,1]*
||      SUB     .L2     B_x2,       B_x6,       B_xl0_1;[ 8,2]
||      ADD     .S2     B_x6,       B_x2,       B_xh0_1;[ 8,2]
||      ADD     .D1     A_x4,       A_x0,       A_xh0_0;[ 8,2]
||[!A_r2]ROTL   .M1     A_x0,       0,          A_xh0_0;[ 8,2]
||[!A_r2]ROTL   .M2     B_x2,       0,          B_xh0_1;[ 8,2]

        ADD     .L1X    A_xl0_0,    B_xl1_1,    A_y6   ;[15,1]*
||      SUB     .S2X    A_xh1_0,    B_xh1_1,    B_y5   ;[15,1]
||      ADD     .S1     A_x5,       A_x1,       A_xh1_0;[ 9,2]
||[!A_r2]ROTL   .M1     A_x1,       0,          A_xh1_0;[ 9,2]
||[!A_r2]SUB    .L2     0,          B_x7,       B_xl0_1;[ 9,2]*
||      SHFL    .M2     B_h2,       B_h3               ;[ 9,2] h2 = _shfl(h2);
||      LDDW    .D1T1   *A_p_x0++[2],         A_x5:A_x4;[ 3,3]
||      LDDW    .D2T2   *B_p_x0++[2],         B_x7:B_x6;[ 3,3]

        SUB     .S1X    A_xl0_0,    B_xl1_1,    A_y2   ;[16,1]*
||[!A_r2]MV     .D1     A_y7,       A_y3               ;[16,1]
||[!A_pro]STDW  .D2T2   B_y5:B_y4,  *B_p_y2[B_h4]      ;[16,1]
||      SUB     .L1     A_x1,       A_x5,       A_xl1_0;[10,2]
||[!A_r2]ROTL   .M1     A_x5,       0,          A_xl1_0;[10,2]
||      ADD     .S2     B_x7,       B_x3,       B_xh1_1;[10,2]
||      SUB     .L2     B_x3,       B_x7,       B_xl1_1;[10,2]
||      BITR    .M2     B_h0,       B_h1               ;[ 4,3] h2 = _bitr(h2);

  [!A_r2]MV     .L1     A_temp,     A_y7               ;[17,1]
||[!A_pro]STDW  .D2T1   A_y3:A_y2,  *B_p_y1[B_h4]      ;[17,1]
||      SUB     .D1     A_x0,       A_x4,       A_xl0_0;[11,2]
||      ADD     .L2X    A_xh0_0,    B_xh0_1,    B_y0   ;[11,2]
||      SUB     .S2X    A_xh0_0,    B_xh0_1,    B_y4   ;[11,2]
||[!A_r2]ROTL   .M2     B_x3,       0,          B_xh1_1;[11,2]

 [!A_pro]STDW   .D2T1   A_y7:A_y6,  *B_p_y3[B_h4]      ;[18,1]
||      SHRU    .S2     B_h3,       B_l1,       B_h4   ;[12,2] h2 >>= l1;
||[!A_r2]SUB    .L2     0,          B_x6,       B_xl1_1;[12,2]*
||      ROTL    .M2     B_h1,       16,         B_h2   ;[ 6,3]h2=_rotl(h2, 16);
||      MPYSU   .M1     2,          A_pro,      A_pro  ;10000
||      MV      .S1X    B_SP,       A_SP        ; Twin Stack Pointer
; ============================ PIPE LOOP EPILOG ==============================
        LDW     .D1T2   *+A_SP[ 1], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 2], A_csr       ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 3], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 4], A10         ; Restore A10

        LDW     .D1T2   *+A_SP[ 5], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 6], A11         ; Restore A11

        LDW     .D1T2   *+A_SP[ 7], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[ 8], A12         ; Restore A12

        LDW     .D1T2   *+A_SP[ 9], B13         ; Restore B13
||      LDW     .D2T1   *+B_SP[10], A13         ; Restore A13

        LDW     .D1T2   *+A_SP[11], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[12], A14         ; Restore A14

        LDW     .D2T1   *++B_SP[14],A15         ; Restore A15
||      BNOP    .S2     B_ret, 4                ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
*====== Interruptibility state restored
;====== Branch Occurs =====

*==============================================================================*
*=  End of file:  dsp_ifft32x32.asm                                           =*
*==============================================================================*
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
*==============================================================================*

iir.asm/        1061588610  0     0     0       16734     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.6     Fri Mar 29 15:42:31 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       iir -- Infinite Impulse Response Filter/ ARMA filter, Hand ASM      *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           void DSP_iir                                                    *
*           (                                                               *
*               short *restrict r1,      /* Output array (used)      */     *
*               const short     *x,      /* Input array              */     *
*               short *restrict r2,      /* Output array (stored)    */     *
*               const short     *h2,     /* Filter Coeffs. AR part   */     *
*               const short     *h1,     /* Filter Coeffs. FIR part  */     *
*               int             nr       /* Number of output samples */     *
*           );                                                              *
*                                                                           *
*       The iir routine performs an impulse response filter computation     *
*       on the input data in "x" and the past outputs in "r1".  It          *
*       stores the output for "nr" output samples in "r2".                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       The IIR performs an auto regressive moving average (ARMA)           *
*       filter with 4 auto-regressive coefficients in "h2" and 5 moving     *
*       average filter coefficients FIR in "h1" for "nr" output             *
*       samples.  The output vector is stored in two locations. This        *
*       routine is used as a high pass filter in the VSELP vocoder.         *
*       All data is assumed to be 16 bit.                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Reads to the output array to get the previous output samples        *
*       for AR filtering are avoided by maintaining copies of the           *
*       samples in the register file.  The accumulator for the "AR"         *
*       part and the "FIR" part are de-coupled to break data                *
*       dependencies.  Inner loop that iterates through the filter          *
*       coefficients is completely unrolled.                                *
*                                                                           *
*       C64x multiply instructions such as DOTP2 are used for the FIR       *
*       portion of the computation, and the lower latency MPY               *
*       instructions are used for the IIR portion.                          *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       "nr" is greater than or equal to 8.                                 *
*                                                                           *
*       Input data array "x" contains "nr + 4" input samples to produce     *
*       "nr" output samples.                                                *
*                                                                           *
*       Output array "r1" contains "nr + 4" locations, "r2" contains        *
*       "nr" locations for storing "nr" output samples. The output          *
*       samples are stored with an offset of 4 into the "r1" array.         *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 4 * nr + 21                                                *
*                                                                           *
*   CODESIZE                                                                *
*       268 bytes                                                           *
*                                                                           *
*   SOURCE                                                                  *
*       DSPLIB for C62x                                                     *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_iir
_DSP_iir:


* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_r1              ;
        .asg            B4,         B_x               ;
        .asg            A6,         A_r2              ;
        .asg            B6,         B_h2              ;
        .asg            A8,         A_h1              ;
        .asg            B8,         B_nr              ;
        .asg            A9,         A_x               ;
        .asg            A7,         A_h23_h24         ;
        .asg            B16,        B_h21_h22         ;
        .asg            B9,         B_h20             ;
        .asg            B7,         B_h11             ;
        .asg            B5,         B_h12             ;
        .asg            A5,         A_h13             ;
        .asg            A3,         A_h14             ;
        .asg            B25,        B_sum0_s          ;
        .asg            B21,        B_sum1_s          ;
        .asg            A19,        A_sum2_s          ;
        .asg            A20,        A_sum3_s          ;
        .asg            A0,         A_i               ;
        .asg            B20,        B_r1_ptr          ;
        .asg            B19,        B_r2_ptr          ;
        .asg            B31,        B_h24_h23         ;
        .asg            B30,        B_h22_h21         ;
        .asg            A6,         A_h24_h23         ;
        .asg            B1,         B_h1              ;
        .asg            A30,        A_h12             ;
        .asg            B29,        B_h14             ;
        .asg            B26,        B_zero            ;
        .asg            A2,         A_zero            ;
        .asg            B5,         B_r1              ;
        .asg            B18,        B_x4              ;
        .asg            A17,        A_x32             ;
        .asg            A16,        A_x10             ;
        .asg            B28,        B_csr             ;
        .asg            B27,        B_no_gie          ;
        .asg            A1,         A_p               ;
        .asg            B0,         B_p               ;
* ========================================================================= *

        ADD     .L1     A_h1,       2,          A_h1            ;[ 3,0]
||      LDH     .D2T2   *+B_x[4],   B_x4                        ;[ 1,1]

        LDNDW   .D      *B_x,       A_x32:A_x10                 ;[ 2,1]
||      SUB     .L1X    B_nr,       1,          A_i             ;[10,0]
||      MVC     .S2     CSR,        B_csr
||      ADD     .L2X    A_h1,       2,          B_h1            ;[ 3,0]

        LDNDW   .D      *+B_h2(2),  B_h24_h23:B_h22_h21         ;[ 5,0]
||      AND     .L2     B_csr,      -2,       B_no_gie          ;
||      ADD     .S1X    B_x,        2,        A_x               ;[13,0]

        LDH     .D1T2   *A_h1++[2], B_h11                       ;[ 4,0]
||      LDH     .D2T1   *B_h1++[2], A_h12                       ;[ 4,0]
||      MVC     .S2     B_no_gie,   CSR

        MV      .L2X    A_r1,       B_r1                        ;[ 6,0]
||      LDH     .D2T2   *B_h1++[2], B_h14                       ;[ 6,0]
||      LDH     .D1T1   *A_h1++[2], A_h13                       ;[ 6,0]

        LDH     .D2T1   *B_r1[0],   A_sum3_s                    ;[ 7,0]
||      LDH     .D1T2   *A_r1[2],   B_sum1_s                    ;[ 7,0]

        LDH     .D2T1   *B_r1[1],   A_sum2_s                    ;[ 8,0]
||      LDH     .D1T2   *A_r1[3],   B_sum0_s                    ;[ 8,0]

        LDH     .D2T2   *B_h2[0],   B_h20                       ;[ 9,0]
||      MV      .S1X    B_h24_h23,  A_h24_h23                   ;[11,0]
||      MV      .L2X    A_r2,       B_r2_ptr                    ;[11,0]

        ADD     .S2X    A_r1,       8,          B_r1_ptr        ;[12,0]
||      MVK     .S1     2,          A_p                         ;
||      MVK     .D2     1,          B_p                         ;

        SUBAH   .D1     A_h13,      A_h13,      A_h13           ;[13,0] NEG
||      NEG     .L2X    A_h12,                  B_h12           ;[13,0]
||      SUBAH   .D2     B_h11,      B_h11,      B_h11           ;[13,0] NEG
||      PACKLH2 .S2     B_h22_h21,  B_h22_h21,  B_h21_h22       ;[13,0]
||      PACKLH2 .L1     A_h24_h23,  A_h24_h23,  A_h23_h24       ;[13,0]
||      NEG     .S1X    B_h14,                  A_h14           ;[12,0]

        ;==== Branch occurs

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A9,         A_x
        .asg            A7,         A_h23_h24
        .asg            B16,        B_h21_h22
        .asg            B9,         B_h20
        .asg            B7,         B_h11
        .asg            B5,         B_h12
        .asg            A5,         A_h13
        .asg            A3,         A_h14
        .asg            B25,        B_sum0_s
        .asg            B21,        B_sum1_s
        .asg            A19,        A_sum2_s
        .asg            A20,        A_sum3_s
        .asg            A0,         A_i                         ;
        .asg            B20,        B_r1_ptr
        .asg            B19,        B_r2_ptr
        .asg            B18,        B_x4
        .asg            A17,        A_x32
        .asg            A16,        A_x10
        .asg            A19,        A_prod0
        .asg            B23,        B_prod1
        .asg            B17,        B_prod2
        .asg            B21,        B_prod3
        .asg            B23,        B_sum0
        .asg            B22,        B_mpy0
        .asg            B22,        B_mpy1
        .asg            A16,        A_mpy2
        .asg            A18,        A_mpy3
        .asg            A16,        A_add1
        .asg            B22,        B_sumA
        .asg            B24,        B_sumB
        .asg            B24,        B_sumC
        .asg            B3,         B_return
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *

        LDH     .D1T2   *+A_x[4],   B_x4                        ;[ 1,2]

        LDNDW   .D      *A_x++(2),  A_x32:A_x10                 ;[ 2,2]

        DOTP2   .M1     A_x10,      A_h23_h24,  A_prod0         ;[ 7,1]

        MPY     .M1     A_sum3_s,   A_h14,      A_mpy3          ;[ 8,1]
||      DOTP2   .M2X    A_x32,      B_h21_h22,  B_prod1         ;[ 8,1]
||      B       .S2     LOOP                                    ;

        MPY     .M2     B_x4,       B_h20,      B_prod2         ;[ 9,1]
||      LDH     .D1T2   *+A_x[4],   B_x4                        ;[ 1,3]
;--

* =========================== PIPE LOOP KERNEL ============================ *
LOOP:
  [!B_p]MV      .L2     B_sum0_s,   B_sum1_s                    ;[14,2]
||[!B_p]ADD     .S2X    B_mpy1,     A_add1,     B_sumA          ;[14,2]
||[!B_p]MPY     .M2     B_sum0_s,   B_h11,      B_mpy0          ;[14,2]
||[!B_p]ADD     .D2     B_prod3,    B_prod2,    B_sum0          ;[14,2]
||      MV      .L1     A_sum2_s,   A_sum3_s                    ;[10,3]
||      MPY     .M1     A_sum2_s,   A_h13,      A_mpy2          ;[10,3]
||[A_i] LDNDW   .D      *A_x++(2),  A_x32:A_x10                 ;[ 2,5]

  [!A_p]STH     .D2T2   B_sum0_s,   *B_r2_ptr++                 ;[19,1]
||[!B_p]ADD     .L2     B_sumA,     B_sum0,     B_sumB          ;[15,2]
||      MPY     .M2     B_sum1_s,   B_h12,      B_mpy1          ;[11,3]
||      DOTP2   .M1     A_x10,      A_h23_h24,  A_prod0         ;[ 7,4]

  [!A_p]STH     .D2T2   B_sum0_s,   *B_r1_ptr++                 ;[20,1]
||[ A_i]BDEC    .S1     LOOP,       A_i                         ;[16,2]
||[!B_p]ADD     .L2     B_sumB,     B_mpy0,     B_sumC          ;[16,2]
||      ADD     .D1     A_mpy2,     A_mpy3,     A_add1          ;[12,3]
||      MPY     .M1     A_sum3_s,   A_h14,      A_mpy3          ;[ 8,4]
||      DOTP2   .M2X    A_x32,      B_h21_h22,  B_prod1         ;[ 8,4]

  [!B_p]EXT     .S2     B_sumC,     1,  16,     B_sum0_s        ;[17,2]
||      MV      .L1X    B_sum1_s,   A_sum2_s                    ;[13,3]
||      ADD     .L2X    B_prod1,    A_prod0,    B_prod3         ;[13,3]
||      MPY     .M2     B_x4,       B_h20,      B_prod2         ;[ 9,4]
||      LDH     .D1T2   *+A_x[4],   B_x4                        ;[ 1,6]
||[A_p] SUB     .S1     A_p,        1,          A_p             ;
||[B_p] SUB     .D2     B_p,        1,          B_p             ;

* =========================== PIPE LOOP EPILOG ============================ *

        BNOP    .S2     B_return,   3                           ;

        STH     .D2T2   B_sum0_s,   *B_r2_ptr++                 ;[19,6]
||      MVC     .S2     B_no_gie,   CSR                         ;

        STH     .D2T2   B_sum0_s,   *B_r1_ptr++                 ;[20,6]

* ========================================================================= *
*   End of file:  dsp_iir.asm                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
iirlat.asm/     1061588610  0     0     0       18616     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.2     Wed Apr 17 16:06:59 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_iirlat                                                          *
*                                                                           *
*   REVISION DATE                                                           *
*       15-Apr-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       void DSP_iirlat                                                     *
*       (                                                                   *
*           short       *x,                                                 *
*           int          nx,                                                *
*           const short *restrict k,                                        *
*           int          nk,                                                *
*           int         *restrict b,                                        *
*           short       *r                                                  *
*       );                                                                  *
*                                                                           *
*       x[nx]   : Input vector (16-bit)                                     *
*       nx      : Length of input vector.                                   *
*       k[nk]   : Reflection coefficients in Q.15 format                    *
*       nk      : Number of reflection coefficients/lattice stages          *
*                 Must be multiple of 2 and >=10.                           *
*       b[nk+1] : Delay line elements from previous call. Should be         *
*                 initialized to all zeros prior to the first call.         *
*       r[nx]   : Output vector (16-bit)                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine implements a real all-pole IIR filter in lattice       *
*       structure (AR lattice). The filter consists of nk lattice stages.   *
*       Each stage requires one reflection coefficient k and one delay      *
*       element b. The routine takes an input vector x[] and returns the    *
*       filter output in r[]. Prior to the first call of the routine the    *
*       delay elements in b[] should be set to zero. The input data may     *
*       have to be pre-scaled to avoid overflow or achieve better SNR. The  *
*       reflections coefficients lie in the range -1.0 < k < 1.0. The       *
*       order of the coefficients is such that k[nk-1] corresponds to the   *
*       first lattice stage after the input and k[0] corresponds to the     *
*       last stage.                                                         *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_iirlat                                                     *
*       (                                                                   *
*           short       *x,                                                 *
*           int         nx,                                                 *
*           const short *restrict k,                                        *
*           int         nk,                                                 *
*           int         *restrict b,                                        *
*           short       *r                                                  *
*       )                                                                   *
*       {                                                                   *
*           int rt;     /* output       */                                  *
*           int i, j;                                                       *
*                                                                           *
*           for (j=0; j<nx; j++)                                            *
*           {                                                               *
*               rt = x[j] << 15;                                            *
*                                                                           *
*               for (i = nk - 1; i >= 0; i--)                               *
*               {                                                           *
*                   rt       = rt   - (short)(b[i] >> 15) * k[i];           *
*                   b[i + 1] = b[i] + (short)(rt   >> 15) * k[i];           *
*               }                                                           *
*                                                                           *
*               b[0] = rt;                                                  *
*                                                                           *
*               r[j] = rt >> 15;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Prolog and epilog of the inner loop are partially collapsed         *
*       and overlapped to reduce outer loop overhead.                       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       - nk must be a multiple of 2 and >= 10.                             *
*       - no special alignment requirements                                 *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt-tolerant but not interruptible.              *
*       This code is ENDIAN NEUTRAL                                         *
*                                                                           *
*   CYCLES                                                                  *
*       (2 * nk + 7) * nx + 9                                               *
*                                                                           *
*   CODESIZE                                                                *
*       360 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_iirlat
_DSP_iirlat:         ; A_xp, B_nx, A_kp, B_nk, A_bp, B_rp
                     ; A4,   B4,   A6,   B6,   A8,   B8

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_j
        .asg            A16,        A_b1x
        .asg            A17,        A_bk1
        .asg            A17,        A_rt1
        .asg            A18,        A_b1xx
        .asg            A18,        A_k1k2
        .asg            A19,        A_r
        .asg            A20,        A_rtk1
        .asg            A20,        A_rtk2
        .asg            A21,        A_bp_rst
        .asg            A21,        A_nk
        .asg            A22,        A_x
        .asg            A23,        A_rt
        .asg            A3,         A_bpn
        .asg            A4,         A_xp
        .asg            A5,         A_k1k2x
        .asg            A6,         A_kp
        .asg            A7,         A_b1
        .asg            A8,         A_bp
        .asg            A9,         A_b0n
        .asg            B1,         B_i
        .asg            B16,        B_bp
        .asg            B17,        B_b1n
        .asg            B18,        B_b2x
        .asg            B19,        B_i_rst
        .asg            B19,        B_nk2
        .asg            B2,         B_p
        .asg            B20,        B_bk2
        .asg            B21,        B_bp_rst
        .asg            B22,        B_csr
        .asg            B23,        B_nogie
        .asg            B4,         B_bpn
        .asg            B4,         B_nx
        .asg            B5,         B_b2
        .asg            B6,         B_nk
        .asg            B8,         B_rp
        .asg            B9,         B_kp

* ========================================================================= *

        MV      .L1X    B_nk,       A_nk
||      MVC     .S2     CSR,        B_csr

        ADDAW   .D1     A_bp,       A_nk,       A_bp
||      MV      .S2X    A_bp,       B_bp
||      AND     .L2     B_csr,      -2,         B_nogie
||      B       .S1     loop_j                         ; no ints

        LDW     .D1T1   *--A_bp[1], A_b1               ;[ 1,1] b[nk-1]
||      MV      .L2X    A_kp,       B_kp
||      MV      .S1     A_bp,       A_bp_rst
||      ADDAW   .D2     B_bp,       B_nk,       B_bp
||      MVC     .S2     B_nogie,    CSR                ; disable ints

        ADDAH   .D2     B_kp,       B_nk,       B_kp   ; &k[nk]
||      LDH     .D1T1   *A_xp++,    A_x                ; x[j]
||      MV      .S2     B_bp,       B_bp_rst

        LDW     .D2T1   *--B_kp,    A_k1k2             ;[ 4,1] k[nk-1],k[nk-2]

        LDW     .D2T2   *--B_bp[2], B_b2               ;[ 5,1] b[nk-2]
||      LDW     .D1T1   *--A_bp[2], A_b1               ;[ 1,2] b[nk-1]
||      SHR     .S2     B_nk,       1,          B_nk2
||      ZERO    .L2     B_p
||      B       .S1     loop_i+4                       ; prolog coll

        SUB     .S2     B_nk2,      4,          B_i_rst; -4 for 5 overlaps
||      SUB     .L1X    B_nx,       1,          A_j

loop_j:
* =========================== PIPE LOOP PROLOG ============================ *

        MVD     .M1     A_b1,       A_b1x              ;[ 7,1]split live2long
||      LDW     .D2T1   *B_kp,      A_k1k2x            ;[ 7,1]split live2long

        LDW     .D2T1   *--B_kp,    A_k1k2             ;[ 4,2]k[nk-1],k[nk-2]
||      B       .S1     plk3                           ; prolog coll

        SMPYH   .M1     A_b1,       A_k1k2,     A_bk1  ;[ 9,1]b[nk-1]*k[nk-1]
||      LDW     .D2T2   *--B_bp[2], B_b2               ;[ 5,2]b[nk-2]
||      LDW     .D1T1   *--A_bp[2], A_b1               ;[ 1,3]b[nk-1]

        SMPYHL  .M2X    B_b2,       A_k1k2,     B_bk2  ;[10,1]b[nk-2]*k[nk-2]
||      SHL     .S1     A_x,        16,         A_rt   ; rt=x[j]<<16
|| [B_p]STH     .D2T1   A_r,        *B_rp++            ; r[j]=r
||      MV      .L2     B_i_rst,    B_i                ; i=nk/2-2

;kernel cycle 0, 1, 2

plk3:
        MV      .S1     A_b1x,      A_b1xx             ;[14,1]split live2long
||      MVK     .S2     1,          B_p
||      SMPYHL  .M1     A_rt,       A_k1k2x,    A_rtk2 ;[14,1]rtk2=rt *k[nk-2]
||      SMPYHL  .M2X    B_b2,       A_k1k2,     B_bk2  ;[10,2]b[nk-2]*k[nk-2]
||      SUB     .L1     A_bp_rst,   0,          A_bpn  ; store new b
||      SUB     .L2     B_bp_rst,   4,          B_bpn  ; store new b
||[B_p] STW     .D2T2   B_b1n,      *B_bpn             ;[18,5]b[nk-1]=b1n
||[B_p] STW     .D1T1   A_b0n,      *A_bpn             ;[18,5]b[nk]=b0n

* =========================== PIPE LOOP KERNEL ============================ *
loop_i:
        ADD     .L1     A_b1xx,     A_rtk1,     A_b0n  ;[15,1]b0n=b[nk-1]+rtk1
||      MVD     .M2     B_b2,       B_b2x              ;[11,2]split live2long
||      SUB     .D1     A_rt,       A_bk1,      A_rt1  ;[11,2]rt1=rt-bk1
||      MVD     .M1     A_b1,       A_b1x              ;[ 7,3]split live2long
||      LDW     .D2T1   *B_kp,      A_k1k2x            ;[ 7,3]split live2long

        SMPYH   .M1     A_rt1,      A_k1k2x,    A_rtk1 ;[12,2]rtk1=rt1*k[nk-1]
||      LDW     .D2T1   *--B_kp,    A_k1k2             ;[ 4,4]k[nk-1],k[nk-2]

        ADD     .L2X    B_b2x,      A_rtk2,     B_b1n  ;[17,1]b1n=b[nk-2]+rtk2
||      BDEC    .S2     loop_i,     B_i                ;[13,2]
||      SUB     .S1X    A_rt1,      B_bk2,      A_rt   ;[13,2]rt=rt1-bk2
||      SMPYH   .M1     A_b1,       A_k1k2,     A_bk1  ;[ 9,3]b[nk-1]*k[nk-1]
||      LDW     .D2T2   *--B_bp[2], B_b2               ;[ 5,4]b[nk-2]
||      LDW     .D1T1   *--A_bp[2], A_b1               ;[ 1,5]b[nk-1]

        STW     .D2T2   B_b1n,      *B_bpn--[2]        ;[18,1]b[nk-1]=b1n
||      STW     .D1T1   A_b0n,      *A_bpn--[2]        ;[18,1]b[nk]=b0n
||      MV      .S1     A_b1x,      A_b1xx             ;[14,2]split live2long
||      SMPYHL  .M1     A_rt,       A_k1k2x,    A_rtk2 ;[14,2]rtk2=rt *k[nk-2]
||      SMPYHL  .M2X    B_b2,       A_k1k2,     B_bk2  ;[10,3]b[nk-2]*k[nk-2]

* =========================== PIPE LOOP EPILOG ============================ *
        ADD     .L1     A_b1xx,     A_rtk1,     A_b0n  ;[15,4]b0n=b[nk-1]+rtk1
||      MVD     .M2     B_b2,       B_b2x              ;[11,5]split live2long
||      SUB     .D1     A_rt,       A_bk1,      A_rt1  ;[11,5]rt1=rt-bk1
||      ADD     .S1     A_bp_rst,   4,          A_bp   ; &b[nk+1] (load)
||      MV      .L2X    A_kp,       B_kp

        SMPYH   .M1     A_rt1,      A_k1k2x,    A_rtk1 ;[12,5]rtk1=rt1*k[nk-1]
||      LDW     .D1T1   *--A_bp[2], A_b1               ;[ 1,1]b[nk-1]
||      ADDAH   .D2     B_kp,       B_nk,       B_kp   ; &k[nk]
||      SUB     .L2     B_bp_rst,   0,          B_bp   ; &b[nk] (load)
||[A_j] B       .S1     loop_j

        ADD     .L2X    B_b2x,      A_rtk2,     B_b1n  ;[17,4]b1n=b[nk-2]+rtk2
||      SUB     .L1X    A_rt1,      B_bk2,      A_rt   ;[13,5]rt=rt1-bk2
||      LDH     .D1T1   *A_xp++,    A_x                ; x[j]

        STW     .D2T2   B_b1n,      *B_bpn--[2]        ;[18,4]b[nk-1]=b1n
||      STW     .D1T1   A_b0n,      *A_bpn--[2]        ;[18,4]b[nk]=b0n
||      MV      .L1     A_b1x,      A_b1xx             ;[14,5]split live2long
||      SMPYHL  .M1     A_rt,       A_k1k2x,    A_rtk2 ;[14,5]rtk2=rt *k[nk-2]
||[!A_j]B       .S2     B3                             ; return to caller

        ADD     .L1     A_b1xx,     A_rtk1,     A_b0n  ;[15,5]b0n=b[nk-1]+rtk1
||      SHR     .S1     A_rt,       16,         A_r    ; r=rt>>16
||      LDW     .D2T1   *--B_kp,    A_k1k2             ;[ 4,1]k[nk-1],k[nk-2]

        LDW     .D2T2   *--B_bp[2], B_b2               ;[ 5,1]b[nk-2]
||      LDW     .D1T1   *--A_bp[2], A_b1               ;[ 1,2]b[nk-1]
||[A_j] B       .S1     loop_i+4                       ; prolog coll

        ADD     .L2X    B_b2x,      A_rtk2,     B_b1n  ;[17,5]b1n=b[nk-2]+rtk2
||      STW     .D1T1   A_rt,       *-A_bpn[2]         ; b[0]=rt
||[A_j] SUB     .S1     A_j,        1,          A_j
; end of loop

        STH     .D2T1   A_r,        *B_rp++            ; r[j]=r
||      MVC     .S2     B_csr,      CSR                ; enable ints

        STW     .D2T2   B_b1n,      *B_bpn--[2]        ;[18,5]b[nk-1]=b1n
||      STW     .D1T1   A_b0n,      *A_bpn--[2]        ;[18,5]b[nk]=b0n

* ========================================================================= *
*   End of file:  dsp_iirlat.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mat_mul.asm/    1061588610  0     0     0       24648     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.3     Sun Mar 10 21:45:23 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_mat_mul -- Matrix Multiply, Little Endian                       *
*                                                                           *
*    REVISION DATE                                                          *
*        10-Feb-2002                                                        *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSP_mat_mul                                                *
*           (                                                               *
*               const short *restrict x, int r1, int c1,                    *
*               const short *restrict y,         int c2,                    *
*               short       *restrict r,                                    *
*               int                   qs                                    *
*           );                                                              *
*                                                                           *
*       x  == Pointer to r1 by c1 input matrix.                             *
*       y  == Pointer to c1 by c2 input matrix.                             *
*       r  == Pointer to r1 by c2 output matrix.                            *
*                                                                           *
*       r1 == Number of rows in x.                                          *
*       c1 == Number of columns in x.  Also number of rows in y.            *
*       c2 == Number of columns in y.                                       *
*                                                                           *
*       qs == Final right-shift to apply to the result.                     *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function computes the expression "r = x * y" for the matrices  *
*       x and y.  The columnar dimension of x must match the row dimension  *
*       of y.  The resulting matrix has the same number of rows as x and    *
*       the same number of columns as y.                                    *
*                                                                           *
*       The values stored in the matrices are assumed to be fixed-point     *
*       or integer values.  All intermediate sums are retained to 32-bit    *
*       precision.  No rounding or overflow checking is performed.  The     *
*       results are right-shifted by the user-specified amount, and then    *
*       truncated to 16 bits.                                               *
*                                                                           *
*       This code is suitable for dense matrices.  No optimizations are     *
*       made for sparse matrices.                                           *
*                                                                           *
*       The following is a C description of the algorithm.  The assembly    *
*       code may place restrictions on the inputs that the C code version   *
*       does not.  These restrictions are noted under ASSUMPTIONS below.    *
*                                                                           *
*       void DSP_mat_mul                                                    *
*       (                                                                   *
*           const short *restrict x, int r1, int c1,                        *
*           const short *restrict y,         int c2,                        *
*           short       *restrict r,                                        *
*           int                   qs                                        *
*       )                                                                   *
*       {                                                                   *
*           int i, j, k;                                                    *
*           int sum;                                                        *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Multiply each row in x by each column in y.  The    */      *
*           /*  product of row m in x and column n in y is placed   */      *
*           /*  in position (m,n) in the result.                    */      *
*           /* ---------------------------------------------------- */      *
*           for (i = 0; i < r1; i++)                                        *
*               for (j = 0; j < c2; j++)                                    *
*               {                                                           *
*                   sum = 0;                                                *
*                                                                           *
*                   for (k = 0; k < c1; k++)                                *
*                       sum += x[k + i*c1] * y[j + k*c2];                   *
*                                                                           *
*                   r[j + i*c2] = sum >> qs;                                *
*               }                                                           *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The arrays 'x', 'y', and 'r' are stored in distinct arrays.  That   *
*       is, in-place processing is not allowed.                             *
*                                                                           *
*       The input matrices have minimum dimensions of at least 1 row and    *
*       1 column, and maximum dimensions of 32767 rows and 32767 columns.   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The 'i' loop and 'k' loops are unrolled 2x.  The 'j' loop is        *
*       unrolled 4x.  For dimensions that are not multiples of the          *
*       various loops' unroll factors, this code calculates extra results   *
*       beyond the edges of the matrix.  These extra results are            *
*       ultimately discarded.  This allows the loops to be unrolled for     *
*       efficient operation on large matrices while not losing              *
*       flexibility.                                                        *
*                                                                           *
*       The outer two levels of loop nest are collapsed, further reducing   *
*       the overhead of the looping structure.                              *
*                                                                           *
*   NOTES                                                                   *
*       This code blocks interrupts during its innermost loop.  Interrupts  *
*       are not blocked otherwise.  As a result, interrupts can be blocked  *
*       for up to 0.25*c1' + 16 cycles at a time.                           *
*                                                                           *
*       When calculating the loop trip counts, the values of r1 and c1      *
*       are rounded up to the next even value.  The value of c2 is          *
*       rounded up to the next multiple of 4.  This does not affect         *
*       the memory layout of the input or output matrices.                  *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The load instructions in the inner loop are predicated to avoid     *
*       significant over-fetching on the matrices.  However, since the      *
*       outer loops are unrolled, this code may fetch approximately one     *
*       full row beyond the end of the 'x' matrix and approximately one     *
*       double-word beyond the end of the 'y' matrix.  The values read      *
*       are discarded and do not affect the results of the computation.     *
*                                                                           *
*       This code has no memory alignment requirements, as non-aligned      *
*       loads are used for accessing the inputs, and individual STHs are    *
*       used for writing the results.                                       *
*                                                                           *
*       This is a LITTLE ENDIAN implementation.                             *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 0.25 * (r1'*c2'*c1') + 2.25 * (r1'*c2') + 11, where:       *
*                                                                           *
*           r1' = 2 * ceil(r1/2.0)   // r1 rounded up to next even          *
*           c1' = 2 * ceil(c1/2.0)   // c1 rounded up to next even          *
*           c2' = 4 * ceil(c2/4.0);  // c2 rounded up to next mult of 4     *
*                                                                           *
*       For r1= 1, c1= 1, c2= 1,  cycles =    33.                           *
*       For r1= 8, c1=20, c2= 8,  cycles =   475.                           *
*       For r1=12, c1=14, c2=18,  cycles =  1391.                           *
*       For r1=32, c1=32, c2=32,  cycles = 10507.                           *
*                                                                           *
*       The cycle count includes 6 cycles of function call overhead.  The   *
*       exact overhead seen by a given application will depend on the       *
*       compiler options used.                                              *
*                                                                           *
*   CODESIZE                                                                *
*       416 bytes.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_mat_mul
_DSP_mat_mul:
*           void DSP_mat_mul                                                *
*           (                                                               *
*               const short *restrict x, int r1, int c1,                    *
*               const short *restrict y,         int c2,                    *
*               short       *restrict r,                                    *
*               int                   qs                                    *
*           );                                                              *
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
          .asg          A4,         A_x         ; const short *restrict x
          .asg          B4,         B_r1        ; int r1
          .asg          A6,         A_c1        ; int c1
          .asg          B6,         B_y         ; const short *restrict y
          .asg          A8,         A_c2        ; int c2
          .asg          B8,         B_r         ; short       *restrict r
          .asg          A10,        A_qs        ; int qs

          .asg          B1,         B_i         ; I loop counter
          .asg          A0,         A_j         ; J loop counter
          .asg          A7,         A_k         ; K loop counter

          .asg          A27,        A_kc        ; K loop counter reload

          .asg          B22,        B_ic_       ; temp value
          .asg          A26,        A_kc_       ; temp value

          .asg          A1,         A_lj        ; Flag: "Last J iteration"
          .asg          B2,         B_lr        ; Flag: "Last row of output"
          .asg          A2,         A_c1o       ; Flag: "c1 is odd"
          .asg          B27,        B_r1o       ; Flag: "r1 is odd"
          .asg          B0,         B_p         ; Prolog collapse predicate
          .asg          A1,         A_e         ; Epilog collapse predicate

          .asg          A5,         A_c1_2      ; c1 * 2
          .asg          B26,        B_c2        ; c2 (twin copy)
          .asg          B7,         B_c2_2      ; c2 * 2
          .asg          B9,         B_qs        ; qs (twin copy)

          .asg          B5,         B_na        ; unused value

          .asg          A28,        A_x_sv      ; Saved copy of x (i-loop)
          .asg          A29,        A_y_sv      ; Saved copy of y (j-loop)
          .asg          B29,        B_y_sv2     ; Saved copy of y (i-loop)
          .asg          B30,        B_r_sv      ; Saved copy of r (i-loop)

          .asg          A9,         A_x00
          .asg          A16,        A_y10
          .asg          A17,        A_y32
          .asg          A18,        A_s00
          .asg          A18,        A_t00
          .asg          A19,        A_s01
          .asg          A19,        A_t01
          .asg          A20,        A_s02
          .asg          A20,        A_t02
          .asg          A21,        A_s03
          .asg          A21,        A_t03
          .asg          A22,        A_p00
          .asg          A22,        A_p01
          .asg          A22,        A_p02
          .asg          A22,        A_p03

          .asg          B4,         B_x11
          .asg          B5,         B_y00
          .asg          B16,        B_y10
          .asg          B17,        B_y32
          .asg          B18,        B_s10
          .asg          B18,        B_t10
          .asg          B19,        B_s11
          .asg          B19,        B_t11
          .asg          B20,        B_s12
          .asg          B20,        B_t12
          .asg          B21,        B_s13
          .asg          B21,        B_t13
          .asg          B22,        B_p10
          .asg          B22,        B_p11
          .asg          B22,        B_y33
          .asg          B23,        B_y22
          .asg          B24,        B_p13
          .asg          B24,        B_y11
          .asg          B25,        B_p12

* ========================================================================= *
          AND   .S1     A_c1,       1,          A_c1o           ;[ 1,0]

          MV    .L2X    A_c2,       B_c2                        ;[ 2,0]
||        ADD   .L1     A_c1o,      A_c1,       A_kc_           ;[ 2,0]
||        AND   .D2     B_r1,       1,          B_r1o           ;[ 2,0]
||        SHL   .S2X    A_c2,       1,          B_c2_2          ;[ 3,0]

          MV    .L2     B_r,        B_r_sv                      ;[ 3,0]
||[ A_c1o]SUB   .S2     B_y,        B_c2_2,     B_y             ;[ 4,0]
||        SUBAH .D1     A_x,        A_c1o,      A_x             ;[ 3,0]
||        SHRU  .S1     A_kc_,      1,          A_kc            ;[ 3,0]
||        ADD   .D2     B_r1o,      B_r1,       B_ic_           ;[ 3,0]

          ROTL  .M2X    A_qs,       0,          B_qs            ;[ 4,0]
||        MV    .D1     A_c2,       A_j                         ;[ 4,0]
||        SHL   .S1     A_c1,       1,          A_c1_2          ;[ 4,0]
||[!A_c1o]LDNDW .D2T1   *B_y,                   A_y32:A_y10

          ROTL  .M2     B_y,        0,          B_y_sv2         ;[ 5,0]
||        ADD   .L2     B_y,        B_c2_2,     B_y
||        MV    .L1     A_x,        A_x_sv                      ;[ 5,0]
||        SHRU  .S2     B_ic_,      1,          B_i             ;[ 5,0]
||        MV    .S1X    B_y,        A_y_sv                      ;[ 5,0]
* =========================== PIPE LOOP PROLOG ============================ *
loop_ij:
          LDNDW .D2T2   *B_y++(B_c2_2),         B_y32:B_y10     ;[ 1,1]
||        SUB   .S1     A_kc,       2,          A_k
||        ZERO  .L2     B_s13:B_s12
||        ZERO  .L1     A_s03:A_s02

          LDNDW .D1T2   *A_x(A_c1_2),           B_na:B_x11      ;[ 2,1]
||        B     .S1     loop_k
||        ZERO  .L2     B_s11:B_s10
||[ A_c1o]ZERO  .L1     A_y32:A_y10

          CMPGT .L1     A_k,        -1,         A_e             ;[ 3,1]
||        LDNW  .D1T1   *A_x++[1], A_x00                        ;[ 3,1]
||        SHR   .S1     A_s03:A_s02, 0,         A_s01:A_s00
||        MVK           2,          B_p
; ===== 2 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop_k:
  [!B_p ] ADD   .D1     A_p03,      A_s03,      A_s03           ;[12,1]
||[!B_p ] ADD   .L2     B_p13,      B_s13,      B_s13           ;[12,1]
||        DOTP2 .M1X    A_x00,      B_y33,      A_p03           ;[ 8,2]
||        DOTP2 .M2     B_x11,      B_y33,      B_p13           ;[ 8,2]
||        PACKH2.S2X    B_y10,      A_y10,      B_y11           ;[ 8,2]
||[ A_e ] LDNDW .D2T1   *B_y++(B_c2_2),         A_y32:A_y10     ;[ 4,3]

  [!B_p ] ADD   .S1     A_p02,      A_s02,      A_s02           ;[13,1]
||[!B_p ] ADD   .S2     B_p10,      B_s10,      B_s10           ;[13,1]
||[!B_p ] ADD   .L2     B_p12,      B_s12,      B_s12           ;[13,1]
||        DOTP2 .M1X    A_x00,      B_y22,      A_p02           ;[ 9,2]
||        DOTP2 .M2     B_x11,      B_y00,      B_p10           ;[ 9,2]
||[ A_e ] LDNDW .D2T2   *B_y++(B_c2_2),         B_y32:B_y10     ;[ 1,4]
loop_k2:
  [!B_p ] ADD   .L1     A_p00,      A_s00,      A_s00           ;[14,1]
||[!B_p ] ADD   .D2     B_p11,      B_s11,      B_s11           ;[14,1]
||        BDEC  .S1     loop_k,     A_k                         ;[10,2]
||        DOTP2 .M1X    A_x00,      B_y00,      A_p00           ;[10,2]
||        DOTP2 .M2     B_x11,      B_y11,      B_p11           ;[10,2]
||        PACK2 .L2X    B_y32,      A_y32,      B_y22           ;[ 6,3]
||        PACKH2.S2X    B_y32,      A_y32,      B_y33           ;[ 6,3]
||[ A_e ] LDNDW .D1T2   *A_x(A_c1_2),           B_na:B_x11      ;[ 2,4]
loop_k3:
  [ B_p ] SUB   .L2     B_p,        1,          B_p             ;[15,1]
||[!B_p ] ADD   .S1     A_p01,      A_s01,      A_s01           ;[15,1]
||        DOTP2 .M1X    A_x00,      B_y11,      A_p01           ;[11,2]
||        DOTP2 .M2     B_x11,      B_y22,      B_p12           ;[ 7,3]
||        PACK2 .S2X    B_y10,      A_y10,      B_y00           ;[ 7,3]
||        CMPGT .L1     A_k,        -1,         A_e             ;[ 3,4]
||[ A_e ] LDNW  .D1T1   *A_x++[1], A_x00                        ;[ 3,4]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 2 epilog stages collapsed
          ADD   .D1     A_p03,      A_s03,      A_s03           ;[12,4]
||        ADD   .D2     B_p13,      B_s13,      B_s13           ;[12,4]
||        CMPGT .L2     B_i,        B_r1o,      B_lr
||        CMPLT .L1     A_j,        5,          A_lj
||        ADD   .S1     A_y_sv,     8,          A_y_sv  ; Adv. y 4 cols.

          ADD   .L1     A_p02,      A_s02,      A_s02           ;[13,4]
||        ADD   .S2     B_p10,      B_s10,      B_s10           ;[13,4]
||        ADD   .D2     B_p12,      B_s12,      B_s12           ;[13,4]
||[ A_lj] MV    .D1X    B_y_sv2,    A_y_sv              ; Rewind y
||[ A_lj] SUB   .L2     B_i,        1,          B_i

          ADD   .L1     A_p00,      A_s00,      A_s00           ;[14,4]
||        ADD   .L2     B_p11,      B_s11,      B_s11           ;[14,4]
||        SHR   .S1     A_s02,      A_qs,       A_t02
||        SHR   .S2     B_s10,      B_qs,       B_t10
||[!A_c1o]LDNDW .D1T1   *A_y_sv,                A_y32:A_y10
||[ A_lj] ADDAH .D2     B_r_sv,     B_c2_2,     B_r_sv  ; Adv. r 2 rows

          ADD   .L1     A_p01,      A_s01,      A_s01           ;[15,4]
||        SHR   .S1     A_s00,      A_qs,       A_t00
||        SHR   .S2     B_s13,      B_qs,       B_t13
||[ B_lr] STH   .D2T2   B_t10,      *B_r  [B_c2]
||[ A_j ] SUB   .D1     A_j,        1,          A_j

          SHR   .S1     A_s03,      A_qs,       A_t03
||        SHR   .S2     B_s11,      B_qs,       B_t11
||        STH   .D2T1   A_t00,      *B_r++[1]
||[!A_j ] ZERO  .L2     B_lr
||        SSHVR .M1     A_s01,      A_qs,       A_t01

  [ B_lr] STH   .D2T2   B_t11,      *B_r  [B_c2]
||[ B_i ] B     .S1     loop_ij
||[!B_i ] B     .S2     B3

  [ A_j ] STH   .D2T1   A_t01,      *B_r++[1]
||[ A_j ] SUB   .D1     A_j,        1,          A_j
||[ B_lr] CMPGT .L2X    A_j,        1,          B_lr
||        SHR   .S2     B_s12,      B_qs,       B_t12

  [ B_lr] STH   .D2T2   B_t12,      *B_r  [B_c2]

  [ A_j ] STH   .D2T1   A_t02,      *B_r++[1]
||[ A_j ] SUB   .D1     A_j,        1,          A_j
||[ B_lr] CMPGT .L2X    A_j,        1,          B_lr

  [ B_lr] STH   .D2T2   B_t13,      *B_r  [B_c2]
||[ A_lj] ADDAH .D1     A_x_sv,     A_c1_2,     A_x_sv  ; Adv. x 2 rows
||[ A_j ] ADD   .L2     B_r,        2,          B_r

  [ A_j ] STH   .D2T1   A_t03,      *-B_r[1]
||[!A_lj] SUB   .L1     A_j,        1,          A_j
||[ A_lj] MV    .S2     B_r_sv,     B_r                 ; Adv. r 2 rows
||[ A_lj] MV    .D1     A_c2,       A_j
||[ B_i]  MV    .S1     A_x_sv,                 A_x
||[ B_i]  ADD   .L2X    A_y_sv,     B_c2_2,     B_y

* ========================================================================= *
*   End of file:  dsp_mat_mul.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
mat_trans.asm/  1061588610  0     0     0       14853     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.7     Mon Feb 18 00:59:02 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*     TEXAS INSTRUMENTS, INC.                                               *
*                                                                           *
*     NAME                                                                  *
*           DSP_mat_trans                                                   *
*                                                                           *
*     REVISION DATE                                                         *
*         17-Feb-2002                                                       *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_mat_trans(const short *x, short rows, short columns, short *r) *
*                                                                           *
*       x       : Pointer to input matrix containing 16-bit elements        *
*       rows    : Number of rows in matrix                                  *
*       columns : Number of columnss in matrix                              *
*       r       : Pointer to output matrix (transpose of input matrix)      *
*                                                                           *
*   DESCRIPTION                                                             *
*       The program transposes a matrix of 16-bit values and user-          *
*       determined dimensions. The result of a matrix transpose is a        *
*       matrix with the number of rows = number of columns of input matrix  *
*       and number of columns = number of rows of input matrix The value    *
*       of an elements of the output matrix is equal to the value of the    *
*       element from the input matrix with switched coordinates (rows,      *
*       columns).                                                           *
*                                                                           *
*     C CODE                                                                *
*         void DSP_mat_trans(short *x, short rows, short columns, short *r) *
*         {                                                                 *
*             short i,j;                                                    *
*             for(i=0; i<columns; i++)                                      *
*                 for(j=0; j<rows; j++)                                     *
*                     *(r+i*rows+j)=*(x+i+columns*j);                       *
*         }                                                                 *
*                                                                           *
*     TECHNIQUES                                                            *
*         Data from four adjacent rows, spaced columns apart are read, and  *
*         local 4x4 transpose is performed in the register file. This leads *
*         to four double words, that are "rows" apart. These loads and      *
*         stores can cause bank conflicts, hence non-aligned loads and      *
*         stores are used.                                                  *
*                                                                           *
*     ASSUMPTIONS                                                           *
*         rows and columns must be a multiple of 4                          *
*                                                                           *
*     NOTES                                                                 *
*         LITTLE ENDIAN Configuration used.                                 *
*                                                                           *
*         This code is interruptible throughout as it is single register    *
*         assignment code.                                                  *
*                                                                           *
*     CYCLES                                                                *
*         (0.5 * rows + 2.0) * cols + 11                                    *
*                                                                           *
*         rows = 20, cols = 12, cycles = 153                                *
*                                                                           *
*         This includes 6 cycles function call overhead.  This may vary     *
*         depending on compiler options.                                    *
*                                                                           *
*     CODESIZE                                                              *
*         224 bytes                                                         *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_mat_trans
_DSP_mat_trans:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x                         ;
        .asg            B4,         B_rows                      ;
        .asg            A6,         A_columns                   ;
        .asg            B6,         B_r                         ;
        .asg            A19,        A_of_0                      ;
        .asg            A18,        A_of_1                      ;
        .asg            A5,         A_of_2                      ;
        .asg            B21,        B_of_0                      ;
        .asg            B20,        B_of_1                      ;
        .asg            B7,         B_of_2                      ;
        .asg            A3,         A_of_3                      ;
        .asg            B22,        B_i                         ;
        .asg            A0,         A_it_c                      ;
        .asg            A25,        A_xold                      ;
        .asg            B24,        B_it_r                      ;
        .asg            A26,        A_zero                      ;
        .asg            B26,        B_zero                      ;
        .asg            A1,         A_p                         ;
* ========================================================================= *
        ZERO    .L1     A_zero                                  ;[ 1,0]
||      SHRU    .S2     B_rows,     2,          B_it_r          ;[ 3,0]
||      MVK     .S1     1,          A_p                         ;

        ADDAW   .D1     A_zero,     A_columns,  A_of_1          ;[ 2,0]
||      ADD     .S1     A_columns,  A_columns,  A_of_0          ;[ 2,0]
||      ZERO    .L2     B_zero                                  ;[ 2,0]
||      MPY     .M2     B_rows,     6,          B_of_2          ;[ 2,0]
||      MPY     .M1     A_columns,  8,          A_of_3          ;[ 2,0]

        MV      .L1     A_x,        A_xold                      ;[ 3,0]
||      ADDAW   .D2     B_zero,     B_rows,     B_of_1          ;[ 3,0]
||      ADD     .L2     B_rows,     B_rows,     B_of_0          ;[ 3,0]
||      ADD     .D1     A_of_0,     A_of_1,     A_of_2          ;[ 3,0]
||      SHRU    .S1     A_columns,  2,          A_it_c          ;[ 3,0]
||      SUB     .S2     B_it_r,     2,          B_i             ;[ 5,0]

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x                         ;
        .asg            B6,         B_r                         ;
        .asg            A19,        A_of_0
        .asg            A18,        A_of_1
        .asg            A5,         A_of_2
        .asg            B21,        B_of_0
        .asg            B20,        B_of_1
        .asg            B7,         B_of_2
        .asg            B31,        B_of_2_8
        .asg            A3,         A_of_3
        .asg            B22,        B_i
        .asg            A7,         A_a1z1
        .asg            A6,         A_y1x1
        .asg            B9,         B_a2z2
        .asg            B8,         B_y2x2
        .asg            B19,        B_a3z3
        .asg            B18,        B_y3x3
        .asg            A9,         A_a0z0
        .asg            A8,         A_y0x0
        .asg            A16,        A_x1x0
        .asg            B4,         B_x3x2
        .asg            A20,        A_y1y0
        .asg            B17,        B_y3y2
        .asg            A17,        A_x3x2
        .asg            B16,        B_y1y0
        .asg            A16,        A_z1z0
        .asg            B9,         B_z3z2
        .asg            A20,        A_a1a0
        .asg            B5,         B_a3a2
        .asg            A17,        A_z3z2
        .asg            B4,         B_a1a0
        .asg            B3,         B_return                    ;
* =========================== PIPE LOOP KERNEL ============================ *
LOOP_2:
  [!A_p]MV      .S1X    B_z3z2,     A_z3z2                      ;[ 9,1]
||      LDNDW   .D      *+A_x(A_of_1),          B_a2z2:B_y2x2   ;[ 1,2]
||      ADD             B_of_2,     8,          B_of_2_8

  [!A_p]PACK2   .L1     A_a1z1,     A_a0z0,     A_z1z0          ;[10,1]
||[!A_p]PACKH2  .S1     A_y1x1,     A_y0x0,     A_y1y0          ;[10,1]
||      LDNDW   .D      *+A_x(A_of_2),          B_a3z3:B_y3x3   ;[ 2,2]

        BDEC    .S2     LOOP_2,     B_i                         ;[11,1]
||[!A_p]STNDW   .D      A_z3z2:A_z1z0,          *+B_r(B_of_1)   ;[11,1]
||[!A_p]MV      .S1X    B_x3x2,     A_x3x2                      ;[11,1]
||[!A_p]PACK2   .L1     A_y1x1,     A_y0x0,     A_x1x0          ;[11,1]

  [!A_p]PACKH2  .L1     A_a1z1,     A_a0z0,     A_a1a0          ;[12,1]
||[!A_p]MV      .D2X    A_y1y0,     B_y1y0                      ;[12,1]
||      LDNDW   .D      *+A_x(A_of_0),          A_a1z1:A_y1x1   ;[ 4,2]

        LDNDW   .D      *A_x++(A_of_3),         A_a0z0:A_y0x0   ;[ 5,2]

  [!A_p]STNDW   .D      B_y3y2:B_y1y0,          *+B_r(B_of_0)   ;[14,1]
||[!A_p]MV      .L2X    A_a1a0,     B_a1a0                      ;[14,1]

  [!A_p]STNDW   .D      B_a3a2:B_a1a0,          *+B_r(B_of_2)   ;[15,1]
||      PACKH2  .S2     B_a3z3,     B_a2z2,     B_a3a2          ;[ 7,2]
||      PACK2   .L2     B_a3z3,     B_a2z2,     B_z3z2          ;[ 7,2]
||[A_p] MPY     .M1     A_p,        0,          A_p             ;

  [!A_p]STNDW   .D      A_x3x2:A_x1x0,          *B_r++(8)       ;[16,1]
||      PACKH2  .S2     B_y3x3,     B_y2x2,     B_y3y2          ;[ 8,2]
||      PACK2   .L2     B_y3x3,     B_y2x2,     B_x3x2          ;[ 8,2]

* =========================== PIPE LOOP EPILOG ============================ *
        MV      .S1X    B_z3z2,     A_z3z2                      ;[ 9,2]
||[ A_it_c]SUB  .D1     A_it_c,     1,          A_it_c          ;[ 4,0]

        PACK2   .L1     A_a1z1,     A_a0z0,     A_z1z0          ;[10,2]
||      PACKH2  .S1     A_y1x1,     A_y0x0,     A_y1y0          ;[10,2]

        STNDW   .D      A_z3z2:A_z1z0,          *+B_r(B_of_1)   ;[11,2]
||      MV      .D1X    B_x3x2,     A_x3x2                      ;[11,2]
||      PACK2   .L1     A_y1x1,     A_y0x0,     A_x1x0          ;[11,2]
||[ A_it_c]B    .S1     LOOP_2                                  ;[ 5,0]
||[!A_it_c]B    .S2     B_return                                ;

        PACKH2  .L1     A_a1z1,     A_a0z0,     A_a1a0          ;[12,2]
||      MV      .D2X    A_y1y0,     B_y1y0                      ;[12,2]

        MVK     .S1     1,          A_p                         ;

        STNDW   .D      B_y3y2:B_y1y0,          *+B_r(B_of_0)   ;[14,2]
||      MV      .L2X    A_a1a0,     B_a1a0                      ;[14,2]
||      ADD     .L1     A_xold,     8,          A_xold          ;[ 9,0]

        STNDW   .D      B_a3a2:B_a1a0,          *+B_r(B_of_2)   ;[15,2]
||      MV      .D1     A_xold,     A_x                         ;[10,0]

        STNDW   .D      A_x3x2:A_x1x0,          *B_r++(B_of_2_8);[16,2]
||      SUB     .S2     B_it_r,     2,          B_i             ;[ 5,0]

* ========================================================================= *
*   End of file:  dsp_mat_trans.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

maxidx.asm/     1061588650  0     0     0       21972     `
;
; 7/17/03: Fixed a bug that returns a wrong index when the index is in 
;          the range of 16 to 31.
;
; 7/22/03: Fixed a bug that searches the maximum beyond the temporary area
;          allocated in the stack.


;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.03                                        *;
;*      CVS Revision:   1.5     Sun Sep 29 03:26:45 2002 (UTC)              *;
;*      Snapshot date:  28-Oct-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_maxidx                                                          *
*                                                                           *
*   REVISION DATE                                                           *
*       17-Feb-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           int DSP_maxidx(const short *x, int nx);                         *
*                                                                           *
*           x       = pointer to input data                                 *
*           nx      = number of samples                                     *
*           return  = max index                                             *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine finds the maximum value of the vector x[ ] and         *
*       returns the index of that value.                                    *
*                                                                           *
*       The input array is treated as 16 separate "columns" that are        *
*       interleaved throughout the array.  If values in different           *
*       columns are equal to the maximum value, then the element in         *
*       the leftmost column is returned.  If two values within a            *
*       column are equal to the maximum, then the one with the lower        *
*       index is returned.                                                  *
*                                                                           *
*       Column takes precedence over index.                                 *
*                                                                           *
*           int DSP_maxidx(const short *x, int nx)                          *
*           {                                                               *
*               int col, idx;                                               *
*               short max_val;                                              *
*               int   max_idx;                                              *
*                                                                           *
*               max_val = x[0];                                             *
*               max_idx = 0;                                                *
*                                                                           *
*               for (col = 0; col < 16; col++)                              *
*                   for (idx = col; idx < nx; idx += 16)                    *
*                       if (x[idx] > max_val)                               *
*                       {                                                   *
*                           max_val = x[idx];                               *
*                           max_idx = idx;                                  *
*                       }                                                   *
*                                                                           *
*               return max_idx;                                             *
*           }                                                               *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code has some restrictions, as          *
*       noted below.                                                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       The code is unrolled 16 times to enable the full bandwidth of       *
*       LDDW and MAX2 instructions to be utilized.  This splits the         *
*       search into 16 subranges.  The global maximum is then found         *
*       from the list of maximums of the subsranges.                        *
*                                                                           *
*       Then using this offset from the subranges, the global maximum       *
*       and the index of it are found using a simple match.                 *
*                                                                           *
*       For common maximums in multiple ranges, the index will be           *
*       different to the above C code.                                      *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input data are stored on double-word aligned boundaries.        *
*       nx must be a multiple of 16 and >= 48                               *
*                                                                           *
*   MEMORY NOTE                                                             *
*       There are no bank conflicts in this code.                           *
*                                                                           *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       This code requires 40 bytes of stack space for a temporary          *
*       buffer.                                                             *
*                                                                           *
*   NOTES                                                                   *
*       Interupts are disabled for the duration of this function.           *
*                                                                           *
*   CYCLES                                                                  *
*       5/16 * nx + 42                                                      *
*       For nx = 128, cycles = 82.                                          *
*                                                                           *
*   CODESIZE                                                                *
*       384 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_maxidx
_DSP_maxidx:
*====================== SYMBOLIC REGISTER ASSIGNMENTS ========================*
        .asg            A4,         A_Input       ;ptr to input data
        .asg            B4,         B_nInputs     ;number of elements
        .asg            A6,         A_MaxBuf      ;pointer to output data
        .asg            B28,        B_MaxBuf      ;copy of results
        .asg            B25,        B_Input       ;copy of input pntr
        .asg            B29,        B_j           ;1st max loop counter
        .asg            A31,        A_m3m2        ;maxes 3,2
        .asg            A30,        A_m1m0        ;maxes 1,0
        .asg            B27,        B_m7m6        ;maxes 7,6
        .asg            B26,        B_m5m4        ;maxes 5,4
        .asg            A27,        A_mbma        ;maxes 11,10
        .asg            A26,        A_m9m8        ;maxes 9,8 copy
        .asg            B19,        B_mbma        ;maxes 11,10 copy
        .asg            B18,        B_m9m8        ;maxes 9,8
        .asg            B23,        B_mfme        ;maxes 15,14
        .asg            B22,        B_mdmc        ;maxes 12,13
        .asg            A9,         A_GMax        ;pnt to local maximums
        .asg            B30,        B_argmax      ;position of global max
        .asg            B31,        B_i           ;index of global maxes
        .asg            B24,        B_k           ;loop counter
        .asg            A29,        A_d3d2        ;elements 0 to 15
        .asg            A28,        A_d1d0        ;elements 0 to 15
        .asg            B21,        B_d7d6        ;elements 0 to 15
        .asg            B20,        B_d5d4        ;elements 0 to 15
        .asg            A29,        A_dbda        ;elements 0 to 15
        .asg            A28,        A_d9d8        ;elements 0 to 15
        .asg            B21,        B_dfde        ;elements 0 to 15
        .asg            B20,        B_dddc        ;elements 0 to 15
        .asg            B5,         B_16          ;cnst = 16
        .asg            A2,         A_pr          ;prologue collapse
        .asg            A7,         A_max         ;global max
        .asg            A25,        A_mi          ;local data
        .asg            A1,         A_d0          ;local data
        .asg            B0,         B_n           ;loop counter
        .asg            A24,        A_n           ;loop counter
        .asg            A0,         A_c0          ;decision for euqal to max
        .asg            B9,         B_csr         ;copy of CRS register
        .asg            B29,        B_no_gie      ;CSR with interupts off
*============================ PIPE LOOP PROLOG 1 =============================*
        B     .S1   NO_INTS                           ;kill interupts 5 cycles
||      MVC   .S2   CSR,      B_csr                   ;copy CSR reg

        ADD   .L2X  A_Input,  8,        B_Input       ;make odd copy of inbuf
||      AND   .D2   B_csr,    -2,       B_no_gie      ;clear interupt bit
||      ADDK        -40,      B15                     ;reserve stack frame

        LDDW  .D2T2 *B_Input++[2],      B_m7m6:B_m5m4 ;load d[7..4]
||      LDDW  .D1T1 *A_Input++[2],      A_m3m2:A_m1m0 ;load d[3..0]
||      MVC   .S2   B_no_gie, CSR                     ;prevent interupts
||      ADD         B15,      8,        A_MaxBuf      ;alloc temp buf on stack

        LDDW  .D2T2 *B_Input++[2],      B_mfme:B_mdmc ;load 1st 4 data 15:12
||      LDDW  .D1T1 *A_Input++[2],      A_mbma:A_m9m8 ;load 1st 4 data 11:8

        LDDW  .D2T2 *B_Input++[2],      B_d7d6:B_d5d4 ;load 2nd d[7..4]
||      LDDW  .D1T1 *A_Input++[2],      A_d3d2:A_d1d0 ;load 2nd d[3..40
||      SHRU  .S2   B_nInputs,4,        B_j           ;i+=16

        BDEC  .S2   LOOPJ,    B_j                     ;for (i=16; i < nInputs
||      MVK   .L1   1,        A_pr                    ;setup prolog collapser
NO_INTS:
        LDDW  .D2T2 *B_Input++[2],      B_dfde:B_dddc ;load 2nd d[15..12]
||      LDDW  .D1T1 *A_Input++[2],      A_dbda:A_d9d8 ;load 2nd d[11..8]
||      SUB   .L2   B_j,      3,        B_j           ;correct for loop
*============================ PIPE LOOP KERNEL 1 =============================*
LOOPJ:
  [!A_pr]MAX2 .L2   B_dddc,   B_mdmc,   B_mdmc        ;find max 12 & 13
||[!A_pr]MAX2 .L1   A_dbda,   A_mbma,   A_mbma        ;find max 10 & 11
||      ADD   .S1   A_MaxBuf, 2,        A_GMax        ;GMAX = MAxbuf
||      MVK   .S2   16,       B_16                    ;const 16
;-
  [!A_pr]MAX2 .L2   B_dfde,   B_mfme,   B_mfme        ;find max 14 & 15
||[!A_pr]MAX2 .L1   A_d9d8,   A_m9m8,   A_m9m8        ;find max 8 & 9
||      MVK   .S2   15-2,       B_k                     ;k = 15
||      MPY   .M2   0,        B_i,      B_i           ;clear i next loop
||      LDDW  .D2T2 *B_Input++[2],      B_d7d6:B_d5d4 ;load jth d[7..4]
||      LDDW  .D1T1 *A_Input++[2],      A_d3d2:A_d1d0 ;load jth d[3..0]
;-
        BDEC  .S2   LOOPJ,    B_j                     ;for j = 16; j < nInputs
||      MAX2  .L2   B_d7d6,   B_m7m6,   B_m7m6        ;find max 6 & 7
||      MAX2  .L1   A_d3d2,   A_m3m2,   A_m3m2        ;find max 2 & 3
||      MPY   .M2   0,        B_argmax, B_argmax      ;clear argmax next loop
||      MPY   .M1   0,        A_pr,     A_pr          ;clear prolog collapse
;-
        MV    .S2X  A_MaxBuf, B_MaxBuf                ;use outbuf as tempstore
||      MAX2  .L2   B_d5d4,   B_m5m4,   B_m5m4        ;find max 4 & 5
||      MAX2  .L1   A_d1d0,   A_m1m0,   A_m1m0        ;find max 0 & 1
||      LDDW  .D2T2 *B_Input++[2],      B_dfde:B_dddc ;load jth d[15..12]
||      LDDW  .D1T1 *A_Input++[2],      A_dbda:A_d9d8 ;load jth d[11..8]
*============================ PIPE LOOP EPILOG 1==============================*
        STDW  .D2T2 B_m7m6:B_m5m4,      *B_MaxBuf[1]  ;store max 7 to 4
||      STDW  .D1T1 A_m3m2:A_m1m0,      *A_MaxBuf[0]  ;store max 3 to 0
||      MAX2  .L2   B_dddc,   B_mdmc,   B_mdmc        ;find max 12 and 13
||      MAX2  .L1   A_dbda,   A_mbma,   A_mbma        ;find max 11 and 10
||      EXT   .S1   A_m1m0,   16, 16,   A_max         ;set global max to max[0]
*============================ PIPE LOOP PROLOG 2==============================*
        LDH   .D1T1 *A_GMax++[1],       A_mi          ;load 1st local maxima
||      BDEC  .S2   LOOPG,    B_k                     ;pipe loop
||      MAX2  .L2   B_dfde,   B_mfme,   B_mfme        ;find maxes 14, 15
||      MAX2  .L1   A_d9d8,   A_m9m8,   A_m9m8        ;find maxes 8 , 9 j loop

        LDH   .D1T1 *A_GMax++[1],       A_mi          ;load 2nd local maxima
||      BDEC  .S2   LOOPG,    B_k                     ;pipe up 3rd loop
||      MV    .L2X  A_mbma,   B_mbma                  ;copy max 10, 11 j loop
||      SUBAW .D2   B_Input,  26,       B_Input       ;adjust pointer to input
;-
        LDH   .D1T1 *A_GMax++[1],       A_mi          ;load 3rd local maxima
||      BDEC  .S2   LOOPG,    B_k                     ;pipe up 3rd loop
||      MV    .L2X  A_m9m8,   B_m9m8                  ;copy max 8,9
||      STDW  .D2T2 B_mfme:B_mdmc,      *B_MaxBuf[3]  ;store final maxes 12-15

        BDEC  .S2   LOOPG,    B_k                     ;pipe up 3rd loop
||      LDH   .D1T1 *A_GMax++[1],       A_mi          ;load 4th local maxima
||      ZERO  .L1   A_d0                              ;zero find predicate
||      STDW  .D2T2 B_mbma:B_m9m8,      *B_MaxBuf[2]  ;store final max 8-11
;-
        BDEC  .S2   LOOPG,    B_k                     ;pipe up 3rd loop
||      LDH   .D1T1 *A_GMax++[1],       A_mi          ;load 5th local maximum
*============================ PIPE LOOP KERNEL 2==============================*
LOOPG:
  [ A_d0]MV   .D2   B_i,      B_argmax                ;update new arg max
||      CMPGT2.S1   A_mi,     A_max,    A_d0          ;see if next max is bigger
||      MAX2  .L1   A_mi,     A_max,    A_max         ;take next biggest max
||      ADD   .L2   B_i,      1,        B_i           ;increment possible index
||      BDEC  .S2   LOOPG,    B_k                     ;loop k
||      LDH   .D1T1 *A_GMax++[1],       A_mi          ;load kth maximum
*============================ PIPE LOOP EPILOG 2==============================*
  [ A_d0]MV   .L2   B_i,      B_argmax                ;update next argmax
*============================ PIPE LOOP PROLOG 3==============================*
        ADDAH .D2   B_Input,  B_argmax, B_Input       ;offset into subrange

        LDH   .D2T1 *B_Input--[16],     A_d0          ;load 1st value
||      B     .S1   LOOPS                             ;pipe up loop
||      SUB   .L2   B_nInputs, B_16,    B_i           ;setup loop count

        LDH   .D2T1 *B_Input--[16],     A_d0          ;load 2nd value
||      B     .S1   LOOPS                             ;pipe up loop
;-
        LDH   .D2T1 *B_Input--[16],     A_d0          ;load 3rd data point
||      B     .S1   LOOPS                             ;pipe up loop
||      ADD   .L2   B_i,      B_argmax, B_i           ;adjust argument
||      SHRU  .S2   B_nInputs,4,        B_n           ;correct loop count

        LDH   .D2T1 *B_Input--[16],     A_d0          ;load 4th data pt
||      B     .S1   LOOPS                             ;pipe up loop
||      MV    .L2   B_i,      B_argmax                ;argmax = i
||      MVK   .L1   1,        A_c0                    ;assume not found
;-
        LDH   .D2T1 *B_Input--[16],     A_d0          ;load 6tt element
||      B     .S1   LOOPS                             ;pipe up loop
||      SUB   .L1X  B_n,      9,        A_n           ;correct loop count
*============================= PIPE LOOP KERNEL 3=============================*
LOOPS:
 [!A_c0]MV    .S2   B_i,      B_argmax                ;set new argmax
||      SUB   .D1   A_d0,     A_max,    A_c0          ;test if global max found
||      SUB   .L2   B_i,      B_16,     B_i           ;i += 16
||      BDEC  .S1   LOOPS,    A_n                     ;for (i=1; i < nInputs;
||      LDH   .D2T1 *B_Input--[16],     A_d0          ;load next point from max
*============================= PIPE LOOP EPILOG 3=============================*
 [!A_c0]MV    .D2   B_i,      B_argmax                ;set new argmax
||      SUB   .D1   A_d0,     A_max,    A_c0          ;test if global max found
||      RETNOP.S2   B3,       3                       ;branch to caller

 [!A_c0]SUB   .L2   B_i,      B_16,     B_argmax      ;correct final argmax
||      ADDK        40,       B15                     ;release temp buffer

        MV    .S1X  B_argmax, A4                      ;return final global arg
||      MVC   .S2   B_csr,    CSR                     ;restore interupts

* ========================================================================= *
*   End of file:  dsp_maxidx.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
maxval.asm/     1061588650  0     0     0       10617     `
;
; 7/22/03: Fixed a bug that returns a wrong maximum value when the index of
;          the maximum is in the range of 4 to 7.

;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.03                                        *;
;*      CVS Revision:   1.5     Sun Sep 29 03:26:45 2002 (UTC)              *;
;*      Snapshot date:  28-Oct-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


;* ======================================================================== *;
;*  Assembler compatibility shim for assembling 4.30 and later code on      *;
;*  tools prior to 4.30.                                                    *;
;* ======================================================================== *;

        .if $isdefed(".ASSEMBLER_VERSION")
        .asg    .ASSEMBLER_VERSION, $asmver
        .else
        .asg    0,    $asmver
        .endif

        .if ($asmver < 430)

        .asg    B,    CALL     ; Function Call
        .asg    B,    RET      ; Return from a Function
        .asg    B,    CALLRET  ; Function call with Call / Ret chaining.

        .if .TMS320C6400
        .asg    BNOP, CALLNOP  ; C64x BNOP as a Fn. Call
        .asg    BNOP, RETNOP   ; C64x BNOP as a Fn. Return
        .asg    BNOP, CRNOP    ; C64x Fn call w/, Call/Ret chaining via BNOP.
        .endif

        .asg    , .asmfunc     ; .func equivalent for hand-assembly code
        .asg    , .endasmfunc  ; .endfunc equivalent for hand-assembly code

        .endif

;* ======================================================================== *;
;*  End of assembler compatibility shim.                                    *;
;* ======================================================================== *;

* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_maxval                                                          *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           short maxval(const short *x, int nx);                           *
*                                                                           *
*           x  = address to array of values                                 *
*           nx = number of values in array                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine finds the maximum value of a vector and returns        *
*       the value.                                                          *
*                                                                           *
*           short maxval(const short *x, int nx)                            *
*           {                                                               *
*               int  i, max;                                                *
*               max = -32768;                                               *
*               for (i = 0; i < nx; i++)                                    *
*                   if (x[i] > max)                                         *
*                        max = x[i];                                        *
*               return max;                                                 *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Nx is a multiple of 8.                                              *
*       Nx is greater than or equal to 32.                                  *
*                                                                           *  
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt tolerant but not interruptible.              *
*                                                                           *
*   CODESIZE                                                                *
*       112 bytes                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       nx / 4 + 10                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2001 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_maxval
_DSP_maxval:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            B4,         B_nx
        .asg            A4,         A_x
        .asg            A7,         A_x_hi
        .asg            A6,         A_x_lo
        .asg            A2,         A_maxA
        .asg            B5,         B_maxB
        .asg            B0,         B_i  
        .asg            B1,         B_x
        .asg            B3,         B_return
        .asg            A4,         A_maxAc
        .asg            A5,         A_compareA
        .asg            B7,         B_compareB
* =========================== PIPE LOOP PROLOG ============================ *

        LDNDW   .D1T1   *A_x++,     A_x_hi:A_x_lo          ;[ 1,1] Load 4 elem
;||      B       .S1     LOOP + 8                           ;[ 2,2] Loop 
||      B       .S1     LOOP                            ;[ 2,2] Loop 
||      SHR     .S2     B_nx,       2,            B_i      ;[ 3,0] nx/4

        LDNDW   .D1T1   *A_x++,     A_x_hi:A_x_lo          ;[ 1,2] Load 4 elem
||      B       .S2     LOOP                               ;[ 2,2] Loop 
||      SUB     .L2     B_i,        4,            B_i      ;[ 4,0] BDEC at 0
||      MVKL    .S1     0x80008000, A_maxA

  [ B_i]BDEC    .S2     LOOP,       B_i                    ;[ 2,2] Loop 
||      LDNDW   .D1T1   *A_x++,     A_x_hi:A_x_lo          ;[ 1,3] Load 4 elem
||      MVKH    .S1     0x80008000, A_maxA

  [ B_i]BDEC    .S2     LOOP,       B_i                    ;[ 2,3] Loop 
||      LDNDW   .D1T1   *A_x++,     A_x_hi:A_x_lo          ;[ 1,4] Load 4 elem

  [ B_i]BDEC    .S2     LOOP,       B_i                    ;[ 2,4] Loop 
||      LDNDW   .D1T1   *A_x++,     A_x_hi:A_x_lo          ;[ 1,5] Load 4 elem
||      MV      .L2X    A_maxA,     B_maxB                 ;[ 4,0] Part. copy

* =========================== PIPE LOOP KERNEL ============================ *
LOOP:
        MAX2    .L1     A_x_hi,     A_maxA,       A_maxA   ;[ 6,2] update max 
||      MAX2    .L2X    A_x_lo,     B_maxB,       B_maxB   ;[ 6,2] update max 
||[ B_i]BDEC    .S2     LOOP,       B_i                    ;[ 2,6] Loop 
||      LDNDW   .D1T1   *A_x++,     A_x_hi:A_x_lo          ;[ 1,7] Load 4 elem

* =========================== PIPE LOOP EPILOG ============================ *
        MAX2    .L1     A_x_hi,     A_maxA,       A_maxA   ;[ 6,6] update max 
||      MAX2    .L2X    A_x_lo,     B_maxB,       B_maxB   ;[ 6,6] update max 
||      RET     .S2     B_return                           ;

        SWAP2   .L2     B_maxB,     B_compareB             ;[ 2,0] 
||      SWAP2   .S1     A_maxA,     A_compareA             ;[ 3,0] 

        MAX2    .L2     B_maxB,     B_compareB,   B_maxB   ;[ 3,0] update max

        MAX2    .L1     A_maxA,     A_compareA,   A_maxA   ;[ 4,0] update max

        MAX2    .L1X    A_maxA,     B_maxB,       A_maxA   ;[ 5,0] final max

        EXT     .S1     A_maxA,     16, 16,       A_maxAc  ;[ 6,0] 

        ;==== Branch occurs  

* ========================================================================= *
*   End of file:  maxval_h.asm                                              *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2001 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

minerror.asm/   1061588610  0     0     0       21902     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.7     Mon Mar 11 23:38:08 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_minerror -- Minimum Energy Error Search                         *
*                                                                           *
*   REVISION DATE                                                           *
*       11-Feb-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       int DSP_minerror                                                    *
*       (                                                                   *
*           const short *restrict GSP0_TABLE,                               *
*           const short *restrict errCoefs,                                 *
*           int         *restrict max_index                                 *
*       );                                                                  *
*                                                                           *
*       GSP0_TABLE[256*9] :  Pointer to GSP0 terms array.                   *
*                            Must be double-word aligned.                   *
*       errCoefs[9]       :  Array of error coefficients.                   *
*       max_index         :  Index to GSP0_TABLE[max_index], the first      *
*                            element of the 9-element vector that resulted  *
*                            in the maximum dot product.                    *
*       return int        :  Maximum dot product result.                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Performs a dot product on 256 pairs of 9 element vectors and        *
*       searches for the pair of vectors which produces the maximum dot     *
*       product result. This is a large part of the VSELP vocoder codebook  *
*       search.                                                             *
*                                                                           *
*   C CODE                                                                  *
*       This is the C equivalent of the assembly code without restrictions  *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       int DSP_minerror                                                    *
*       (                                                                   *
*           const short *restrict GSP0_TABLE,                               *
*           const short *restrict errCoefs,                                 *
*           int         *restrict max_index                                 *
*       )                                                                   *
*       {                                                                   *
*           int val, maxVal = -50;                                          *
*           int i, j;                                                       *
*                                                                           *
*           for (i = 0; i < GSP0_NUM; i++)                                  *
*           {                                                               *
*               for (val = 0, j = 0; j < GSP0_TERMS; j++)                   *
*                   val += GSP0_TABLE[i*GSP0_TERMS+j] * errCoefs[j];        *
*                                                                           *
*               if (val > maxVal)                                           *
*               {                                                           *
*                   maxVal = val;                                           *
*                   *max_index = i*GSP0_TERMS;                              *
*               }                                                           *
*           }                                                               *
*                                                                           *
*           return (maxVal);                                                *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Load double word instruction is used to simultaneously              *
*       load four values in a single clock cycle.                           *
*       The jloop is totally unrolled                                       *
*       The iloop is unrolled 4 times                                       *
*       A flag is used to set the exit program location                     *
*       The MV is used to move the data                                     *
*       The loop is software pipelined.                                     *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Array GSP0_TABLE[] must be double-word aligned.                     *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No memory bank hits under any conditions.                           *
*                                                                           *
*   NOTES                                                                   *
*       This code is LITTLE ENDIAN.                                         *
*       This code is interrupt-tolerant but not interruptible.              *
*                                                                           *
*   CYCLES                                                                  *
*      256/4 * 9 + 17 = 593                                                 *
*                                                                           *
*   CODESIZE                                                                *
*       352 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

*===================== SYMBOLIC REGISTER ASSIGNMENTS ========================*
        .asg            A0,         A_i         ; loop count
        .asg            A1,         A_c         ; flat for updating maxVal
                                                ; & savePtr
        .asg            A4,         A_TB_ptr1   ; GSP0_TABLE pointer
        .asg            A4,         A_max       ; return int
        .asg            A5,         A_TB_ptr    ; GSP0_TABLE pointer
        .asg            A6,         A_save_ptr_ret ; savePtr_ret pointer
        .asg            A7,         A_v0        ; point0: sum of dot prod
        .asg            A7,         A_v1        ; point1: sum of dot prod
        .asg            A8,         A_v2        ; point2: sum of dot prod
        .asg            A9,         A_v3        ; point3: sum of dot prod
        .asg            A16,        A_c10       ; = coef[1,0]
        .asg            A17,        A_c32       ; = coef[3,2]
        .asg            A18,        A_c54       ; = coef[5,4]
        .asg            A19,        A_c76       ; = coef[7,6]
        .asg            A20,        A_tb0_10    ; = table[4i][1,0]
        .asg            A20,        A_tb0_54    ; = table[4i][5,4]
        .asg            A20,        A_tb2_32    ; = table[4i+2][3,2]
        .asg            A20,        A_tb2_76    ; = table[4i+2][7,6]
        .asg            A20,        A_tb2_10    ; = table[4i+2][1,0]
        .asg            A21,        A_tb0_32    ; = table[4i][3,2]
        .asg            A21,        A_tb0_76    ; = table[4i][7,6]
        .asg            A21,        A_tb2_54    ; = table[4i+2][5,4]
        .asg            A21,        A_tb32_08   ; = table[4i+3][0],[4i+2][8]
        .asg            A22,        A_tc0_10    ; = tc0_1 | tc0_0
        .asg            A22,        A_tc2_10    ; = tc2_1 | tc2_0
        .asg            A23,        A_tc0_32    ; = tc0_3 | tc0_2
        .asg            A23,        A_tc0_54    ; = tc0_5 | tc0_4
        .asg            A23,        A_tc0_76    ; = tc0_7 | tc0_6
        .asg            A23,        A_tc2_32    ; = tc2_3 | tc2_2
        .asg            A23,        A_tc2_54    ; = tc2_5 | tc2_4
        .asg            A23,        A_tc2_76    ; = tc2_7 | tc2_6
        .asg            A24,        A_tc2_8     ; = tc2_8
        .asg            A25,        A_tc3_0     ; = tc3_0

        .asg            B0,         B_p         ; flag to activate the compare
        .asg            B4,         B_coef_ptr  ; errCoefs pointer
        .asg            B5,         B_TB_ptr    ; GSP0_TABLE pointer
        .asg            B6,         B_dist      ; = GSP0_TABLE[i+1]-[i] in bytes
        .asg            B7,         B_cnt       ; = GSP0_TABLE[i+1]-[0] in bytes
        .asg            B8,         B_c10       ; = coef[1,0]
        .asg            B8,         B_save      ; = B_cnt which gives max dotprod
        .asg            B9,         B_c08       ; = coef[0,8]
        .asg            B16,        B_c21       ; = coef[2,1]
        .asg            B17,        B_c43       ; = coef[4,3]
        .asg            B18,        B_c65       ; = coef[6,5]
        .asg            B19,        B_c87       ; = coef[8,7]
        .asg            B20,        B_tb1_43    ; = table[4i+1][4,3]
        .asg            B20,        B_tb10_08   ; = table[4i+1][0],[4i][8]
        .asg            B20,        B_tb3_65    ; = table[4i+3][6,5]
        .asg            B20,        B_tb3_21    ; = table[4i+3][2,1]
        .asg            B20,        B_tb1_87    ; = table[4i+1][8,7]
        .asg            B21,        B_tb1_65    ; = table[4i+1][6,5]
        .asg            B21,        B_tb1_21    ; = table[4i+1][2,1]
        .asg            B21,        B_tb3_87    ; = table[4i+3][8,7]
        .asg            B21,        B_tb3_43    ; = table[4i+3][4,3]
        .asg            B22,        B_tc1_43    ; = tc1_4 | tc1_3
        .asg            B22,        B_tc1_21    ; = tc1_2 | tc1_1
        .asg            B22,        B_tc1_87    ; = tc1_8 | tc1_7
        .asg            B23,        B_tc1_65    ; = tc1_6 | tc1_5
        .asg            B23,        B_v1        ; point1: sum of dot prod
        .asg            B24,        B_tc0_8     ; = tc0_8
        .asg            B24,        B_tc3_65    ; = tc3_6 | tc0_5
        .asg            B24,        B_tc3_21    ; = tc3_2 | tc0_1
        .asg            B24,        B_tc3_43    ; = tc3_4 | tc0_3
        .asg            B25,        B_tc1_0     ; = tc1_0
        .asg            B25,        B_tc3_87    ; = tc3_8 | tc0_7
        .asg            B25,        B_v3        ; point3: sum of dot prod
; ============================ PIPE LOOP PROLOG ==============================

        .asg      9,    GSP0_TERMS
        .asg    256,    GSP0_NUM


        .text
        .global _DSP_minerror
_DSP_minerror:

        LDNDW   .D2T1   *B_coef_ptr,A_c32:A_c10            ;
||      MV      .L1     A_TB_ptr1,  A_TB_ptr               ; twin reg for *TABLE
||      MVK     .S2     GSP0_TERMS, B_dist                 ; = 9

        LDNDW   .D2T2   *+B_coef_ptr(10),B_c87:B_c65       ;
||      MV      .L2X    A_TB_ptr1,  B_TB_ptr               ; twin reg for *TABLE
||      MVK     .S2     -GSP0_TERMS, B_cnt                 ; init cnt = -9

        LDNDW   .D2T2   *+B_coef_ptr(2),B_c43:B_c21        ;

        MVK     .S1     GSP0_NUM,   A_i                    ; loop count = 256
||      LDDW    .D1T1   *A_TB_ptr++,A_tb0_32:A_tb0_10      ; @
||      LDDW    .D2T2   *++B_TB_ptr[3],B_tb1_65:B_tb1_43   ; @

        LDNDW   .D2T1   *+B_coef_ptr[1],A_c76:A_c54        ;
||      SHR     .S1     A_i,        2,         A_i         ; loop count = 64
||      ZERO    .D1     A_c                                ; clear count flag

        LDDW    .D1T1   *A_TB_ptr++[4],A_tb0_76:A_tb0_54   ; @
||      LDDW    .D2T2   *-B_TB_ptr[1],B_tb1_21:B_tb10_08   ; @

        MV      .L2X    A_c10,      B_c10                  ; twin reg
||      MVK     .S2     1,          B_p                    ; set compare flag
||      MVK     .S1     -50,        A_max                  ; int maxVal = -50

        PACKLH2 .L2     B_c10,      B_c87,     B_c08       ;
||      LDW     .D1T1   *-A_TB_ptr[1],A_tb2_10             ; @
||      LDW     .D2T2   *++B_TB_ptr[2],B_tb1_87            ; @


iloop:
            ; point 0:    tc0_0 = tb0_0 * c0
            ;             tc0_1 = tb0_1 * c1
            ;             tc0_2 = tb0_2 * c2
            ;             tc0_3 = tb0_3 * c3
            ;             tc0_4 = tb0_4 * c4
            ;             tc0_5 = tb0_5 * c5
            ;             tc0_6 = tb0_6 * c6
            ;             tc0_7 = tb0_7 * c7
            ;             tc0_8 = tb0_8 * c8
            ; sum of tc0_0,1,2,...,8 = v0

            ; point 1:    tc1_0 = tb1_0 * c0
            ;             tc1_1 = tb1_1 * c1
            ;             tc1_2 = tb1_2 * c2
            ;             tc1_3 = tb1_3 * c3
            ;             tc1_4 = tb1_4 * c4
            ;             tc1_5 = tb1_5 * c5
            ;             tc1_6 = tb1_6 * c6
            ;             tc1_7 = tb1_7 * c7
            ;             tc1_8 = tb1_8 * c8
            ; sum of tc0_0,1,2,...,8 = v1

            ; point 2:    tc2_0 = tb2_0 * c0
            ;             tc2_1 = tb2_1 * c1
            ;             tc2_2 = tb2_2 * c2
            ;             tc2_3 = tb2_3 * c3
            ;             tc2_4 = tb2_4 * c4
            ;             tc2_5 = tb2_5 * c5
            ;             tc2_6 = tb2_6 * c6
            ;             tc2_7 = tb2_7 * c7
            ;             tc2_8 = tb2_8 * c8
            ; sum of tc0_0,1,2,...,8 = v2

            ; point 3:    tc3_0 = tb3_0 * c0
            ;             tc3_1 = tb3_1 * c1
            ;             tc3_2 = tb3_2 * c2
            ;             tc3_3 = tb3_3 * c3
            ;             tc3_4 = tb3_4 * c4
            ;             tc3_5 = tb3_5 * c5
            ;             tc3_6 = tb3_6 * c6
            ;             tc3_7 = tb3_7 * c7
            ;             tc3_8 = tb3_8 * c8
            ; sum of tc0_0,1,2,...,8 = v3

        DOTP2   .M1     A_tb0_10,   A_c10,      A_tc0_10   ; @
||      DOTP2   .M2     B_tb1_43,   B_c43,      B_tc1_43   ; @
||      ADD     .S1     A_tc2_10,   A_tc2_32,   A_v2       ;
||[!B_p]CMPGT   .L1     A_v0,       A_max,      A_c        ;
||[!B_p]ADD     .L2     B_cnt,      B_dist,     B_cnt      ;
||      LDDW    .D1T1   *A_TB_ptr++,A_tb2_54:A_tb2_32      ; @
||      LDDW    .D2T2   *++B_TB_ptr[4],B_tb3_87:B_tb3_65   ; @

        DOTP2   .M1     A_tb0_32,   A_c32,      A_tc0_32   ; @
||      DOTP2   .M2     B_tb1_65,   B_c65,      B_tc1_65   ; @
||      ADD     .S1     A_v2,       A_tc2_54,   A_v2       ;
||      ADD     .S2     B_tc3_65,   B_tc3_87,   B_v3       ;
||[ A_c]MV      .L1     A_v0,       A_max                  ;
||[ A_c]MV      .L2     B_cnt,      B_save                 ;
||      MV      .D1X    B_v1,       A_v1                   ;

        DOTP2   .M1     A_tb0_54,   A_c54,      A_tc0_54   ; @
||      MPY2    .M2     B_tb10_08,  B_c08,      B_tc1_0:B_tc0_8; @
||      ADD     .S1     A_v2,       A_tc2_76,   A_v2       ;
||      ADD     .S2     B_v3,       B_tc3_21,   B_v3       ;
||[!B_p]CMPGT   .L1     A_v1,       A_max,      A_c        ;
||[!B_p]ADD     .L2     B_cnt,      B_dist,     B_cnt      ;
||      LDDW    .D1T1   *A_TB_ptr++[3],A_tb32_08:A_tb2_76  ; @
||      LDDW    .D2T2   *-B_TB_ptr[1],B_tb3_43:B_tb3_21    ; @

        DOTP2   .M1     A_tb0_76,   A_c76,      A_tc0_76   ; @
||      DOTP2   .M2     B_tb1_21,   B_c21,      B_tc1_21   ; @
||      ADD     .D1     A_v2,       A_tc2_8,    A_v2       ;
||      ADD     .D2     B_v3,       B_tc3_43,   B_v3       ;
||[ A_c]MV      .L1     A_v1,       A_max                  ;
||[ A_c]MV      .L2     B_cnt,      B_save                 ;
||[ A_i]B       .S1     iloop                              ;
||[!A_i]B       .S2     B3                                 ; return to calling program

  [ A_i]DOTP2   .M1     A_tb2_10,   A_c10,      A_tc2_10   ; @
||[ A_i]DOTP2   .M2     B_tb1_87,   B_c87,      B_tc1_87   ; @
||[!B_p]CMPGT   .L1     A_v2,       A_max,      A_c        ;
||[!B_p]ADD     .L2     B_cnt,      B_dist,     B_cnt      ;
||[ A_i]LDDW    .D1T1   *A_TB_ptr++,A_tb0_32:A_tb0_10      ; @@
||[ A_i]LDDW    .D2T2   *++B_TB_ptr[4],B_tb1_65:B_tb1_43   ; @@

  [ A_i]DOTP2   .M1     A_tb2_32,   A_c32,      A_tc2_32   ; @
||[ A_i]DOTP2   .M2     B_tb3_65,   B_c65,      B_tc3_65   ; @
||      ADD     .S1     A_tc0_10,   A_tc0_32,   A_v0       ; @
||      ADD     .S2     B_tc1_43,   B_tc1_65,   B_v1       ; @
||      ADD     .D1X    B_v3,       A_tc3_0,    A_v3       ;
||[ A_c]MV      .L1     A_v2,       A_max                  ;
||[ A_c]MV      .L2     B_cnt,      B_save                 ;

  [ A_i]DOTP2   .M1     A_tb2_54,   A_c54,      A_tc2_54   ; @
||[ A_i]DOTP2   .M2     B_tb3_87,   B_c87,      B_tc3_87   ; @
||      ADD     .S1     A_v0,       A_tc0_54,   A_v0       ; @
||      ADD     .S2     B_v1,       B_tc1_0,    B_v1       ; @
||[!B_p]CMPGT   .L1     A_v3,       A_max,      A_c        ;
||[!B_p]ADD     .L2     B_cnt,      B_dist,     B_cnt      ;
||[ A_i]LDDW    .D1T1   *A_TB_ptr++[4],A_tb0_76:A_tb0_54   ; @@
||[ A_i]LDDW    .D2T2   *-B_TB_ptr[1],B_tb1_21:B_tb10_08   ; @@

  [ A_i]DOTP2   .M1     A_tb2_76,   A_c76,      A_tc2_76   ; @
||[ A_i]DOTP2   .M2     B_tb3_21,   B_c21,      B_tc3_21   ; @
||      ADD     .S1X    A_v0,       B_tc0_8,    A_v0       ; @
||      ADD     .S2     B_v1,       B_tc1_21,   B_v1       ; @
||[ A_c]MV      .L1     A_v3,       A_max                  ;
||[ A_c]MV      .L2     B_cnt,      B_save                 ;
||[ A_i]LDW     .D1T1   *-A_TB_ptr[1],A_tb2_10             ; @@
||[ A_i]LDW     .D2T2   *++B_TB_ptr[2],B_tb1_87            ; @@

  [ A_i]MPY2    .M1X    A_tb32_08,  B_c08,      A_tc3_0:A_tc2_8; @
||[ A_i]DOTP2   .M2     B_tb3_43,   B_c43,      B_tc3_43   ; @
||      ADD     .S1     A_v0,       A_tc0_76,   A_v0       ; @
||      ADD     .S2     B_v1,       B_tc1_87,   B_v1       ; @
||      ZERO    .D2     B_p                                ;
||[ A_i]SUB     .L1     A_i,        1,          A_i        ;
||[!A_i]STW     .D1T2   B_save,     *A_save_ptr_ret        ;
;       end of iloop

* ============================================================================ *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ============================================================================ *
minval.asm/     1061588610  0     0     0       9449      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.6     Fri Mar 29 20:27:51 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_minval                                                          *
*                                                                           *
*   REVISION DATE                                                           *
*       07-May-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           short DSP_minval(const short *x, int nx);                       *
*                                                                           *
*           x  = address to array of values                                 *
*           nx = number of values in array                                  *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine finds the minimum value of a vector and returns        *
*       the value.                                                          *
*                                                                           *
*           short DSP_minval(const short *x, int nx)                        *
*           {                                                               *
*               int  i, min;                                                *
*               min = 32767;                                                *
*               for (i = 0; i < nx; i++)                                    *
*                   if (x[i] < min)                                         *
*                        min = x[i];                                        *
*               return min;                                                 *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Nx is a multiple of 4.                                              *
*       Nx is greater than or equal to 20.                                  *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt tolerant but not interruptible.              *
*                                                                           *
*   CODESIZE                                                                *
*       112 bytes                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       nx / 4 + 10                                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_minval
_DSP_minval:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            B4,         B_nx
        .asg            A4,         A_x
        .asg            A7,         A_x_hi
        .asg            A6,         A_x_lo
        .asg            A2,         A_minA
        .asg            B5,         B_minB
        .asg            B0,         B_i
        .asg            B1,         B_x
        .asg            B3,         B_return
        .asg            A4,         A_minAc
        .asg            A5,         A_compareA
        .asg            B7,         B_compareB
* =========================== PIPE LOOP PROLOG ============================ *

        LDNDW   .D1T1   *A_x++,     A_x_hi:A_x_lo          ;[ 1,1] Load 4 elem
||      B       .S1     LOOP + 8                           ;[ 2,2] Loop
||      SHR     .S2     B_nx,       2,            B_i      ;[ 3,0] nx/4

        LDNDW   .D1T1   *A_x++,     A_x_hi:A_x_lo          ;[ 1,2] Load 4 elem
||      B       .S2     LOOP                               ;[ 2,2] Loop
||      SUB     .L2     B_i,        4,            B_i      ;[ 4,0] BDEC at 0
||      MVKL    .S1     0x7FFF7FFF, A_minA

  [ B_i]BDEC    .S2     LOOP,       B_i                    ;[ 2,2] Loop
||      LDNDW   .D1T1   *A_x++,     A_x_hi:A_x_lo          ;[ 1,3] Load 4 elem
||      MVKH    .S1     0x7FFF7FFF, A_minA

  [ B_i]BDEC    .S2     LOOP,       B_i                    ;[ 2,3] Loop
||      LDNDW   .D1T1   *A_x++,     A_x_hi:A_x_lo          ;[ 1,4] Load 4 elem

  [ B_i]BDEC    .S2     LOOP,       B_i                    ;[ 2,4] Loop
||      LDNDW   .D1T1   *A_x++,     A_x_hi:A_x_lo          ;[ 1,5] Load 4 elem
||      MV      .L2X    A_minA,     B_minB                 ;[ 4,0] Part. copy

* =========================== PIPE LOOP KERNEL ============================ *
LOOP:
        MIN2    .L1     A_x_hi,     A_minA,       A_minA   ;[ 6,2] update min
||      MIN2    .L2X    A_x_lo,     B_minB,       B_minB   ;[ 6,2] update min
||[ B_i]BDEC    .S2     LOOP,       B_i                    ;[ 2,6] Loop
||      LDNDW   .D1T1   *A_x++,     A_x_hi:A_x_lo          ;[ 1,7] Load 4 elem

* =========================== PIPE LOOP EPILOG ============================ *
        MIN2    .L1     A_x_hi,     A_minA,       A_minA   ;[ 6,6] update min
||      MIN2    .L2X    A_x_lo,     B_minB,       B_minB   ;[ 6,6] update min
||      B       .S2     B_return                           ;

        SWAP2   .L2     B_minB,     B_compareB             ;[ 2,0]
||      SWAP2   .S1     A_minA,     A_compareA             ;[ 3,0]

        MIN2    .L2     B_minB,     B_compareB,   B_minB   ;[ 3,0] update min

        MIN2    .L1     A_minA,     A_compareA,   A_minA   ;[ 4,0] update min

        MIN2    .L1X    A_minA,     B_minB,       A_minA   ;[ 5,0] final min

        EXT     .S1     A_minA,     16, 16,       A_minAc  ;[ 6,0]

        ;==== Branch occurs

* ========================================================================= *
*   End of file:  dsp_minval.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mul32.asm/      1061588610  0     0     0       26426     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.8     Fri Mar 29 19:29:52 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   NAME                                                                    *
*       DSP_mul32                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       14-May-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSP_mul32                                                  *
*           (                                                               *
*               const int    *x,   /* Input array of length nx  */          *
*               const int    *y,   /* Input array of length nx  */          *
*               int *restrict r,   /* Output array of length nx */          *
*               int           nx   /* Number of elements.       */          *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine performs a 32-bit by 32-bit multiply, returning the    *
*       upper 32 bits of the 64-bit result.  This is equivalent to a        *
*       Q31 x Q31 multiply, yielding a Q30 result.                          *
*                                                                           *
*       The 32 x 32 multiply is constructed from 16 x 16 multiplies.        *
*       For efficiency reasons, the 'lo * lo' term of the 32 x 32           *
*       multiply is omitted, as it has minimal impact on the final          *
*       result.  This is due to the fact that the 'lo * lo' term            *
*       primarily affects the lower 32 bits of the result, and these        *
*       are not returned.  Due to this omission, the results of this        *
*       function differ from the exact results of a 32 x 32 multiply by     *
*       at most 1.                                                          *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C code description of the algorithm without      *
*       restrictions.  This implementation may have restrictions,           *
*       as noted under "ASSUMPTIONS" below.                                 *
*                                                                           *
*       void DSP_mul32                                                      *
*       (                                                                   *
*           const int    *x,   /* Input array of length nx  */              *
*           const int    *y,   /* Input array of length nx  */              *
*           int *restrict r,   /* Output array of length nx */              *
*           int           nx   /* Number of elements.       */              *
*       )                                                                   *
*       {                                                                   *
*           int i;                                                          *
*                                                                           *
*           for (i = 0; i < nx; i++)                                        *
*           {                                                               *
*               short           a_hi, b_hi;                                 *
*               unsigned short  a_lo, b_lo;                                 *
*               int             hihi, lohi, hilo, hllh;                     *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  A full 32x32 multiply can be constructed from   */      *
*               /*  four 16x16 multiplies.  If you divide the two   */      *
*               /*  32-bit multiplicands into hi and lo halves,     */      *
*               /*  then the 32x32 product is constructed from the  */      *
*               /*  sum of 'hi * hi', 'hi * lo', 'lo * hi', and     */      *
*               /*  'lo * lo', each shifted appropriately.  The     */      *
*               /*  'hi' terms are signed terms, and the 'lo'       */      *
*               /*  terms are unsigned.                             */      *
*               /* ------------------------------------------------ */      *
*               a_hi = (short)(x[i] >> 16);                                 *
*               b_hi = (short)(y[i] >> 16);                                 *
*               a_lo = (unsigned short)x[i];                                *
*               b_lo = (unsigned short)y[i];                                *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  For our result alignment, the 'hi * hi' term    */      *
*               /*  requires no shift.                              */      *
*               /* ------------------------------------------------ */      *
*               hihi = a_hi * b_hi;                                         *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  The 'lo * hi' and the 'hi * lo' terms will      */      *
*               /*  both be shifted right by 16.  Therefore, we     */      *
*               /*  will compute them, then add them together.      */      *
*               /*  Note that this sum can be 33 bits long, and we  */      *
*               /*  need the upper 17 bits of that 33-bit sum.      */      *
*               /*  Hence, we use longs.                            */      *
*               /* ------------------------------------------------ */      *
*               hilo = a_hi * b_lo;                                         *
*               lohi = a_lo * b_hi;                                         *
*               hllh = (hilo + (long)lohi) >> 16;                           *
*                                                                           *
*               /* ------------------------------------------------ */      *
*               /*  Merge the middle and upper sums to form the     */      *
*               /*  final result.                                   */      *
*               /* ------------------------------------------------ */      *
*               r[i] = hihi + hllh;                                         *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The MPYHI instruction is used to perform a 16 by 32 multiply        *
*       to form a 48 bit result.  This reduces the number of multiplies     *
*       required by the algorithm from 3 to 2.                              *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       "nx" is a multiple of 8.                                            *
*       "nx" is greater than or equal to 16, multiple of 8.                 *
*       input and output vectors are double word aligned.                   *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This function is ENDIAN NEUTRAL.                                    *
*                                                                           *
*   NOTES                                                                   *
*       The 32x32 multiply is an approximation, as described above.         *
*                                                                           *
*       This code is interrupt tolerant but not interruptible.              *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 9 * (nx/8) + 18                                            *
*       For nx = 256, cycles = 306 cycles.                                  *
*                                                                           *
*   CODESIZE                                                                *
*       508 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_mul32
_DSP_mul32:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x
        .asg            B4,         B_y
        .asg            A6,         A_r
        .asg            B6,         B_nx
        .asg            B6,         B_x
        .asg            A8,         A_y
        .asg            B7,         B_r
        .asg            A9,         A_i
        .asg            B3,         B_return                    ;
        .asg            A2,         A_ret                       ;
        .asg            B1,         B_csr                       ;
        .asg            B30,        B_no_gie                    ;
        .asg            A4,         A_x
        .asg            B6,         B_x
        .asg            B4,         B_y
        .asg            A8,         A_y
        .asg            A6,         A_r
        .asg            B7,         B_r
        .asg            A9,         A_i
        .asg            A25,        A_x1
        .asg            A24,        A_x0
        .asg            B25,        B_x3
        .asg            B24,        B_x2
        .asg            A17,        A_y1
        .asg            A16,        A_y0
        .asg            B9,         B_y3
        .asg            B8,         B_y2
        .asg            A29,        A_x5
        .asg            A28,        A_x4
        .asg            B29,        B_x7
        .asg            B28,        B_x6
        .asg            A17,        A_y5
        .asg            A16,        A_y4
        .asg            B23,        B_y7
        .asg            B22,        B_y6
        .asg            A19,        A_xh0
        .asg            A18,        A_xl0
        .asg            A22,        A_xlow0
        .asg            A0,         A_c0
        .asg            A31,        A_p1
        .asg            A30,        A_p0
        .asg            A31,        A_xhigh0
        .asg            A5,         A_xhi0
        .asg            A24,        A_s0
        .asg            A27,        A_xh1
        .asg            A26,        A_xl1
        .asg            A23,        A_xlow1
        .asg            A3,         A_c1
        .asg            A23,        A_p3
        .asg            A22,        A_p2
        .asg            A20,        A_xhigh1
        .asg            A27,        A_xhi1
        .asg            A25,        A_s1
        .asg            B9,         B_xh2
        .asg            B8,         B_xl2
        .asg            B3,         B_xlow2
        .asg            B3,         B_c2
        .asg            B27,        B_p5
        .asg            B26,        B_p4
        .asg            B16,        B_xhigh2
        .asg            B3,         B_xhi2
        .asg            B24,        B_s2
        .asg            B31,        B_xh3
        .asg            B30,        B_xl3
        .asg            B21,        B_xlow3
        .asg            B27,        B_c3
        .asg            B19,        B_p7
        .asg            B18,        B_p6
        .asg            B19,        B_xhigh3
        .asg            B19,        B_xhi3
        .asg            B25,        B_s3
        .asg            A19,        A_xh4
        .asg            A18,        A_xl4
        .asg            A5,         A_xlow4
        .asg            A7,         A_c4
        .asg            A21,        A_p9
        .asg            A20,        A_p8
        .asg            A3,         A_xhigh4
        .asg            A3,         A_xhi4
        .asg            A20,        A_s4
        .asg            A21,        A_xh5
        .asg            A20,        A_xl5
        .asg            A1,         A_xlow5
        .asg            A1,         A_c5
        .asg            A27,        A_pB
        .asg            A26,        A_pA
        .asg            A3,         A_xhigh5
        .asg            A21,        A_xhi5
        .asg            A21,        A_s5
        .asg            B17,        B_xh6
        .asg            B16,        B_xl6
        .asg            B20,        B_xlow6
        .asg            B0,         B_c6
        .asg            B21,        B_pD
        .asg            B20,        B_pC
        .asg            B5,         B_xhigh6
        .asg            B5,         B_xhi6
        .asg            B16,        B_s6
        .asg            B23,        B_xh7
        .asg            B22,        B_xl7
        .asg            B5,         B_xlow7
        .asg            B30,        B_c7
        .asg            B17,        B_pF
        .asg            B16,        B_pE
        .asg            B17,        B_xhigh7
        .asg            B17,        B_xhi7
        .asg            B17,        B_s7
        .asg            B2,         B_p
* ========================================================================= *
        SHR     .S2     B_nx,       3,          B_nx            ;[ 2,0]
||      MV      .L1x    B_return,   A_ret                       ;
||      B       .S1     L_7 + 24                                ;

        ADD     .D2X    A_r,        8,          B_r             ;[ 3,0]
||      ADD     .D1X    B_y,        8,          A_y             ;[ 3,0]
||      MVC     .S2     CSR,        B_csr                       ;

        ADD     .D2X    A_x,        8,          B_x             ;[ 4,0]
||      SUB     .S1X    B_nx,       2,          A_i             ;[ 4,0]
||      AND     .L2     B_csr,     -2,          B_no_gie        ;

* =========================== PIPE LOOP PROLOG ============================ *
        LDDW    .D2T2   *B_x++[2],  B_x3:B_x2                   ;[ 1,1]
||      LDDW    .D1T1   *A_x++[2],  A_x1:A_x0                   ;[ 1,1]
||      B       .S1     LOOP                                    ;

        MVC     .S2     B_no_gie,   CSR                         ;

        LDDW    .D1T2   *A_y++[2],  B_y3:B_y2                   ;[ 3,1]
||      LDDW    .D2T1   *B_y++[2],  A_y1:A_y0                   ;[ 3,1]
||      MVKL    .S2     0x2,        B_p                         ;
; ===== branch occurs

* =========================== PIPE LOOP KERNEL ============================ *
LOOP:
        SHR     .S2     B_xlow3,    31,         B_c3            ;[16,1]
||      ADD     .L2     B_xh2,      B_p5,       B_xhigh2        ;[16,1]
||      ADDU    .L1     A_xl1,      A_xlow1,    A_p3:A_p2       ;[16,1]
||      SHR     .S1     A_xlow0,    31,         A_c0            ;[16,1]
||      LDDW    .D1T2   *A_y++[2],  B_y7:B_y6                   ;[ 7,2]
||      LDDW    .D2T1   *B_y++[2],  A_y5:A_y4                   ;[ 7,2]

        SHR     .S2     B_xlow6,    31,         B_c6            ;[17,1]
||      ADDU    .L1     A_xl5,      A_xlow5,    A_pB:A_pA       ;[17,1]
||      ADDU    .L2     B_xl3,      B_xlow3,    B_p7:B_p6       ;[17,1]
||      ADD     .D2     B_xhigh2,   B_c2,       B_xhi2          ;[17,1]
||      ADD     .D1     A_xh1,      A_p3,       A_xhigh1        ;[17,1]
||      ADD     .S1     A_xh0,      A_p1,       A_xhigh0        ;[17,1]
||      MPYHI   .M2     B_x2,       B_y2,       B_xh2:B_xl2     ;[ 8,2]
||      MPYHI   .M1     A_x0,       A_y0,       A_xh0:A_xl0     ;[ 8,2]

        SHR     .S2     B_xlow7,    31,         B_c7            ;[18,1]
||      ADDU    .L2     B_xl6,      B_xlow6,    B_pD:B_pC       ;[18,1]
||      ADD     .D1     A_xh5,      A_pB,       A_xhigh5        ;[18,1]
||      SHR     .S1     A_xlow5,    31,         A_c5            ;[18,1]
||      ADD     .L1     A_xhigh1,   A_c1,       A_xhi1          ;[18,1]
||      MPYLUHS .M2     B_x3,       B_y3,       B_xlow3         ;[ 9,2]
||      MPYLUHS .M1     A_x1,       A_y1,       A_xlow1         ;[ 9,2]
||[B_p] SUB     .D2     B_p,        1,          B_p             ;

        BDEC    .S1     LOOP,       A_i                         ;[19,1]
||      ADDU    .L2     B_xl7,      B_xlow7,    B_pF:B_pE       ;[19,1]
||      ADD     .S2     B_xh6,      B_pD,       B_xhigh6        ;[19,1]
||      ADDU    .L1     A_xl4,      A_xlow4,    A_p9:A_p8       ;[19,1]
||      MPYHI   .M2     B_x3,       B_y3,       B_xh3:B_xl3     ;[10,2]
||      MPYHI   .M1     A_x1,       A_y1,       A_xh1:A_xl1     ;[10,2]
||      LDDW    .D2T2   *B_x++[2],  B_x3:B_x2                   ;[ 1,3]
||      LDDW    .D1T1   *A_x++[2],  A_x1:A_x0                   ;[ 1,3]

        ADD     .L2     B_xh7,      B_pF,       B_xhigh7        ;[20,1]
||      ADD     .S2     B_xhigh6,   B_c6,       B_xhi6          ;[20,1]
||      ADD     .S1     A_xhigh5,   A_c5,       A_xhi5          ;[20,1]
||      ADD     .L1     A_xh4,      A_p9,       A_xhigh4        ;[20,1]
||      ADD     .D2     B_xh3,      B_p7,       B_xhigh3        ;[20,1]
||      ADD     .D1     A_xhigh0,   A_c0,       A_xhi0          ;[20,1]
||      MPYLUHS .M2     B_x2,       B_y2,       B_xlow2         ;[11,2]
||      MPYLUHS .M1     A_x0,       A_y0,       A_xlow0         ;[11,2]

        PACKLH2 .S1     A_xhi5,     A_pA,       A_s5            ;[21,1]
||      ADD     .L2     B_xhigh3,   B_c3,       B_xhi3          ;[21,1]
||      PACKLH2 .S2     B_xhi2,     B_p4,       B_s2            ;[21,1]
||      PACKLH2 .L1     A_xhi1,     A_p2,       A_s1            ;[21,1]
||      MPYHI   .M2     B_x7,       B_y7,       B_xh7:B_xl7     ;[12,2]
||      MPYHI   .M1     A_x5,       A_y5,       A_xh5:A_xl5     ;[12,2]
||      LDDW    .D1T2   *A_y++[2],  B_y3:B_y2                   ;[ 3,3]
||      LDDW    .D2T1   *B_y++[2],  A_y1:A_y0                   ;[ 3,3]

L_7:
        ADD     .S2     B_xhigh7,   B_c7,       B_xhi7          ;[22,1]
||      ADD     .L1     A_xhigh4,   A_c4,       A_xhi4          ;[22,1]
||      PACKLH2 .L2     B_xhi3,     B_p6,       B_s3            ;[22,1]
||      PACKLH2 .S1     A_xhi0,     A_p0,       A_s0            ;[22,1]
||      MPYLUHS .M2     B_x7,       B_y7,       B_xlow7         ;[13,2]
||      MPYLUHS .M1     A_x4,       A_y4,       A_xlow4         ;[13,2]
||      LDDW    .D2T2   *B_x++[2],  B_x7:B_x6                   ;[ 4,3]
||      LDDW    .D1T1   *A_x++[2],  A_x5:A_x4                   ;[ 4,3]

L_8:
  [!B_p]STDW    .D2T2   B_s3:B_s2,  *B_r++[2]                   ;[23,1]
||[!B_p]STDW    .D1T1   A_s1:A_s0,  *A_r++[2]                   ;[23,1]
||      PACKLH2 .L2     B_xhi7,     B_pE,       B_s7            ;[23,1]
||      PACKLH2 .S2     B_xhi6,     B_pC,       B_s6            ;[23,1]
||      PACKLH2 .L1     A_xhi4,     A_p8,       A_s4            ;[23,1]
||      MPYHI   .M2     B_x6,       B_y6,       B_xh6:B_xl6     ;[14,2]
||      MPYHI   .M1     A_x4,       A_y4,       A_xh4:A_xl4     ;[14,2]
||      SHR     .S1     A_xlow1,    31,         A_c1            ;[14,2]

L_9:
  [!B_p]STDW    .D2T2   B_s7:B_s6,  *B_r++[2]                   ;[24,1]
||[!B_p]STDW    .D1T1   A_s5:A_s4,  *A_r++[2]                   ;[24,1]
||      MPYLUHS .M2     B_x6,       B_y6,       B_xlow6         ;[15,2]
||      MPYLUHS .M1     A_x5,       A_y5,       A_xlow5         ;[15,2]
||      SHR     .S1     A_xlow4,    31,         A_c4            ;[15,2]
||      ADDU    .L2     B_xl2,      B_xlow2,    B_p5:B_p4       ;[15,2]
||      SHR     .S2     B_xlow2,    31,         B_c2            ;[15,2]
||      ADDU    .L1     A_xl0,      A_xlow0,    A_p1:A_p0       ;[15,2]

* =========================== PIPE LOOP EPILOG ============================ *
        SHR     .S2     B_xlow3,    31,         B_c3            ;[16,3]
||      ADD     .L2     B_xh2,      B_p5,       B_xhigh2        ;[16,3]
||      ADDU    .L1     A_xl1,      A_xlow1,    A_p3:A_p2       ;[16,3]
||      SHR     .S1     A_xlow0,    31,         A_c0            ;[16,3]

        SHR     .S2     B_xlow6,    31,         B_c6            ;[17,3]
||      ADDU    .L1     A_xl5,      A_xlow5,    A_pB:A_pA       ;[17,3]
||      ADDU    .L2     B_xl3,      B_xlow3,    B_p7:B_p6       ;[17,3]
||      ADD     .D2     B_xhigh2,   B_c2,       B_xhi2          ;[17,3]
||      ADD     .D1     A_xh1,      A_p3,       A_xhigh1        ;[17,3]
||      ADD     .S1     A_xh0,      A_p1,       A_xhigh0        ;[17,3]

        SHR     .S2     B_xlow7,    31,         B_c7            ;[18,3]
||      ADDU    .L2     B_xl6,      B_xlow6,    B_pD:B_pC       ;[18,3]
||      ADD     .D1     A_xh5,      A_pB,       A_xhigh5        ;[18,3]
||      SHR     .S1     A_xlow5,    31,         A_c5            ;[18,3]
||      ADD     .L1     A_xhigh1,   A_c1,       A_xhi1          ;[18,3]

        ADDU    .L2     B_xl7,      B_xlow7,    B_pF:B_pE       ;[19,3]
||      ADD     .D2     B_xh6,      B_pD,       B_xhigh6        ;[19,3]
||      ADDU    .L1     A_xl4,      A_xlow4,    A_p9:A_p8       ;[19,3]
||      B       .S2x    A_ret                                   ;

        ADD     .L2     B_xh7,      B_pF,       B_xhigh7        ;[20,3]
||      ADD     .S2     B_xhigh6,   B_c6,       B_xhi6          ;[20,3]
||      ADD     .S1     A_xhigh5,   A_c5,       A_xhi5          ;[20,3]
||      ADD     .L1     A_xh4,      A_p9,       A_xhigh4        ;[20,3]
||      ADD     .D2     B_xh3,      B_p7,       B_xhigh3        ;[20,3]
||      ADD     .D1     A_xhigh0,   A_c0,       A_xhi0          ;[20,3]

        PACKLH2 .S1     A_xhi5,     A_pA,       A_s5            ;[21,3]
||      ADD     .L2     B_xhigh3,   B_c3,       B_xhi3          ;[21,3]
||      PACKLH2 .S2     B_xhi2,     B_p4,       B_s2            ;[21,3]
||      PACKLH2 .L1     A_xhi1,     A_p2,       A_s1            ;[21,3]

        ADD     .S2     B_xhigh7,   B_c7,       B_xhi7          ;[22,3]
||      ADD     .L1     A_xhigh4,   A_c4,       A_xhi4          ;[22,3]
||      PACKLH2 .L2     B_xhi3,     B_p6,       B_s3            ;[22,3]
||      PACKLH2 .S1     A_xhi0,     A_p0,       A_s0            ;[22,3]

        STDW    .D2T2   B_s3:B_s2,  *B_r++[2]                   ;[23,3]
||      STDW    .D1T1   A_s1:A_s0,  *A_r++[2]                   ;[23,3]
||      PACKLH2 .L2     B_xhi7,     B_pE,       B_s7            ;[23,3]
||      PACKLH2 .S2     B_xhi6,     B_pC,       B_s6            ;[23,3]
||      PACKLH2 .L1     A_xhi4,     A_p8,       A_s4            ;[23,3]

        STDW    .D2T2   B_s7:B_s6,  *B_r++[2]                   ;[24,3]
||      STDW    .D1T1   A_s5:A_s4,  *A_r++[2]                   ;[24,3]
||      MVC     .S2     B_csr,      CSR                         ;

* ========================================================================= *
*   End of file:  dsp_mul32.asm                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
neg32.asm/      1061588610  0     0     0       10597     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.5     Mon Dec 10 20:51:15 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_neg32                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and may be called using the following   *
*       C function prototype:                                               *
*                                                                           *
*           void DSP_neg32                                                  *
*           (                                                               *
*               int   *x,      /* Input data array     */                   *
*               int   *r,      /* Output data array    */                   *
*               short nx       /* Number of elements.  */                   *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine negates an array of 32-bit integers, and stores        *
*       the result either in a new array, or back to the same array.        *
*                                                                           *
*           void DSP_neg32                                                  *
*           (                                                               *
*               int   *x,      /* Input data array     */                   *
*               int   *r,      /* Output data array    */                   *
*               short nx       /* Number of elements.  */                   *
*           )                                                               *
*           {                                                               *
*               int i;                                                      *
*                                                                           *
*               for (i = 0; i < nx; i++)                                    *
*                   r[i] = -x[i];                                           *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input must be at least 8 elements long, and a multiple of 4.    *
*                                                                           *
*       The input and output arrays must not overlap, except in the         *
*       special case where the input and output pointers are exactly        *
*       equal.                                                              *
*                                                                           *
*       The x and r arrays must be double-word aligned                      *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No memory bank hits will occur.                                     *
*       This kernel is ENDIAN NEUTRAL.                                      *
*                                                                           *
*   NOTES                                                                   *
*       Code is interrupt tolerant but not interruptible.  It locks out     *
*       interrupts for its entire duration.                                 *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = nx/2 + 19.                                                 *
*       nx = 96, cycles = 56 cycles                                         *
*                                                                           *
*   CODESIZE                                                                *
*       124 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_neg32
_DSP_neg32:                   

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x
        .asg            B4,         B_r
        .asg            A6,         A_nx
        .asg            B5,         B_x
        .asg            B19,        B_x76
        .asg            B18,        B_x54
        .asg            A19,        A_x32
        .asg            A18,        A_x10
        .asg            B9,         B_r76
        .asg            B8,         B_r54
        .asg            A17,        A_r32
        .asg            A16,        A_r10
        .asg            B0,         B_p
        .asg            A5,         A_r
        .asg            A0,         A_i
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        B       .S2     loop
||      SHR     .S1     A_nx,       2,          A_i
||      ADD     .L2X    A_x,        8,          B_x

        LDDW    .D1T1   *A_x++[2],  A_x32:A_x10                 ;[ 1,1]
||      LDDW    .D2T2   *B_x++[2],  B_x76:B_x54                 ;[ 1,1]
||      SUB             A_i,        2,          A_i

  [ A_i]BDEC    .S1     loop,       A_i                         ;[ 4,2]
||      ADD     .L1X    B_r,        8,          A_r

        LDDW    .D1T1   *A_x++[2],  A_x32:A_x10                 ;[ 1,2]
||      LDDW    .D2T2   *B_x++[2],  B_x76:B_x54                 ;[ 1,2]
||      MVK             2,          B_p

; ===== 2 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [ B_p]SUB     .L2     B_p,        1,          B_p             ;[ 8,1]
||[!B_p]STDW    .D2T1   A_r32:A_r10,            *B_r++[2]       ;[ 8,1]
||[!B_p]STDW    .D1T2   B_r76:B_r54,            *A_r++[2]       ;[ 8,1]
||[ A_i]BDEC    .S1     loop,       A_i                         ;[ 4,3]

        NEG     .S1     A_x10,      A_r10                       ;[ 7,2]
||      NEG     .L1     A_x32,      A_r32                       ;[ 7,2]
||      NEG     .L2     B_x54,      B_r54                       ;[ 7,2]
||      NEG     .S2     B_x76,      B_r76                       ;[ 7,2]
||      LDDW    .D1T1   *A_x++[2],  A_x32:A_x10                 ;[ 1,5]
||      LDDW    .D2T2   *B_x++[2],  B_x76:B_x54                 ;[ 1,5]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 2 epilog stages collapsed

        STDW    .D2T1   A_r32:A_r10,            *B_r++[2]       ;[ 8,4]
||      STDW    .D1T2   B_r76:B_r54,            *A_r++[2]       ;[ 8,4]
||      B               B3

        NEG     .S1     A_x10,      A_r10                       ;[ 7,5]
||      NEG     .L1     A_x32,      A_r32                       ;[ 7,5]
||      NEG     .L2     B_x54,      B_r54                       ;[ 7,5]
||      NEG     .S2     B_x76,      B_r76                       ;[ 7,5]

        STDW    .D2T1   A_r32:A_r10,            *B_r            ;[ 8,5]
||      STDW    .D1T2   B_r76:B_r54,            *A_r            ;[ 8,5]

        NOP             3

* ========================================================================= *
*   End of file:  dsp_neg32.asm                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

q15tofl.asm/    1061588610  0     0     0       12173     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.5     Mon Mar 11 23:38:14 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_q15tofl -- Q.15 to IEEE float conversion                        *
*                                                                           *
*   REVISION DATE                                                           *
*       17-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSP_q15tofl (short *x, float *r, int nx);                  *
*                                                                           *
*           x[nx]  ---  Pointer to Q15 input vector of size nx              *
*           r[nx]  ---  Pointer to floating-point output data vector        *
*                       of size nx containing the floating-point equivalent *
*                       of vector input                                     *
*           nx     ---  length of input and output data vectors             *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*       Converts the Q15 stored in vector input to IEEE floating point      *
*       numbers stored in vector output.                                    *
*                                                                           *
*       void DSP_q15tofl (short *x, float *r, int nx)                       *
*       {                                                                   *
*        int i;                                                             *
*                                                                           *
*        for (i=0;i<nx;i++)                                                 *
*             r[i]=(float)x[i]/0x8000;                                      *
*       }                                                                   *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code may have some restrictions, as     *
*       noted below.                                                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       unrolled loop 2x                                                    *
*       split live-too-longs B_input_1 and B_input_2                        *
*       collapsed 2 prolog and epilog stages                                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx >=2 and multiple of 2                                            *
*                                                                           *
*   MEMORY NOTE                                                             *
*       no bank conflicts occur ever                                        *
*                                                                           *
*   NOTES                                                                   *
*       this routine is interrupt-tolerant but not interruptible            *
*       this routine is ENDIAN NEUTRAL                                      *
*                                                                           *
*   CYCLES                                                                  *
*       14 + 2 * nx                                                         *
*                                                                           *
*   CODESIZE                                                                *
*       184 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_q15tofl
_DSP_q15tofl:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            B0,         B_p
        .asg            B16,        B_mask
        .asg            A3,         A_offset
        .asg            A2,         A_n
        .asg            A4,         A_q15_ptr
        .asg            B4,         B_float_ptr
        .asg            B8,         B_input_1
        .asg            B7,         B_input_cp_1
        .asg            B2,         B_sign_1
        .asg            A0,         A_inputa_1
        .asg            A7,         A_exp_1
        .asg            A8,         A_mant_1
        .asg            A8,         A_mants_1
        .asg            A6,         A_exp128_1
        .asg            B8,         B_exp128s_1
        .asg            B9,         B_u_float_1
        .asg            B7,         B_float32_1
        .asg            B6,         B_input_2
        .asg            B5,         B_input_cp_2
        .asg            B1,         B_sign_2
        .asg            A1,         A_inputa_2
        .asg            A0,         A_exp_2
        .asg            A1,         A_mant_2
        .asg            A7,         A_mants_2
        .asg            A5,         A_exp128_2
        .asg            B6,         B_exp128s_2
        .asg            B9,         B_u_float_2
        .asg            B5,         B_float32_2
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        LDH     .D1T2   *A_q15_ptr++,           B_input_1       ;[ 1,1]

        MVK     .S2     0x1,    B_mask                          ; setup

        LDH     .D1T2   *A_q15_ptr++,           B_input_2       ;[ 3,1]
||      MVK     .S1     143,    A_offset                        ; setup

        SHL     .S2     B_mask, 31,             B_mask          ; setup

        LDH     .D1T2   *A_q15_ptr++,           B_input_1       ;[ 1,2]
||      B       .S2     loop
||      SHR     .S1     A6,     1,      A_n                     ; setup

        ABS     .L1X    B_input_1,  A_inputa_1                  ;[ 6,1]
||      SUB     .S1     A_n,    2,      A_n                     ; setup
||      MVK     .S2     0xFFFF8000,     B_p                     ; setup

* =========================== PIPE LOOP KERNEL ============================ *
loop:
        OR      .D2X    A_mants_2,  B_exp128s_2,B_u_float_2     ;[15,1]
||      OR      .S2     B_u_float_1,B_sign_1,   B_float32_1     ;[15,1]
||[!A_inputa_2]MPY.M1   0,          A_exp128_2, A_exp128_2      ;[11,2]
||      AND     .L2     B_input_cp_1, B_mask,   B_sign_1        ;[11,2]
||      LMBD    .L1     1,          A_inputa_1, A_exp_1         ;[ 7,3]
||      LDH     .D1T2   *A_q15_ptr++,           B_input_2       ;[ 3,4]

  [!B_p]STW     .D2T2   B_float32_1,            *B_float_ptr++  ;[16,1]
||      EXTU    .S1     A_mant_2,   1,  9,      A_mants_2       ;[12,2]
||      SHL     .S2X    A_exp128_1, 23,         B_exp128s_1     ;[12,2]
||      ABS     .L1X    B_input_2,  A_inputa_2                  ;[ 8,3]
||[ A_inputa_1]SUB.D1   A_offset,   A_exp_1,    A_exp128_1      ;[ 8,3]
||      ROTL    .M1     A_inputa_1, A_exp_1,    A_mant_1        ;[ 8,3]
||      MV      .L2     B_input_1,  B_input_cp_1                ;[ 8,3]

        OR      .S2     B_u_float_2, B_sign_2,  B_float32_2     ;[17,1]
||      AND     .L2     B_input_cp_2,B_mask,    B_sign_2        ;[13,2]
||      OR      .D2X    A_mants_1,  B_exp128s_1,B_u_float_1     ;[13,2]
||      BDEC    .S1     loop,       A_n                         ;[13,2]
||      LMBD    .L1     1,          A_inputa_2, A_exp_2         ;[ 9,3]
||[!A_inputa_1]MPY.M1   0,          A_exp128_1, A_exp128_1      ;[ 9,3]
||      LDH     .D1T2   *A_q15_ptr++,           B_input_1       ;[ 1,5]

  [!B_p]STW     .D2T2   B_float32_2,            *B_float_ptr++  ;[18,1]
||      SHL     .S2X    A_exp128_2, 23,         B_exp128s_2     ;[14,2]
||      MPY     .M2     2,          B_p,        B_p             ;prolog coll
||[ A_inputa_2]SUB.D1   A_offset,   A_exp_2,    A_exp128_2      ;[10,3]
||      ROTL    .M1     A_inputa_2, A_exp_2,    A_mant_2        ;[10,3]
||      MV      .L2     B_input_2,  B_input_cp_2                ;[10,3]
||      EXTU    .S1     A_mant_1,   1,  9,      A_mants_1       ;[10,3]
||      ABS     .L1X    B_input_1,  A_inputa_1                  ;[ 6,4]

* =========================== PIPE LOOP EPILOG ============================ *

        OR      .L2X    A_mants_2,  B_exp128s_2,B_u_float_2     ;[15,5]
||      OR      .D2     B_u_float_1,B_sign_1,   B_float32_1     ;[15,5]
||      B       .S2     B3

        STW     .D2T2   B_float32_1, *B_float_ptr++             ;[16,5]

        OR      .S2     B_u_float_2, B_sign_2,  B_float32_2     ;[17,5]

        STW     .D2T2   B_float32_2,            *B_float_ptr++  ;[18,5]

        NOP     2

* ========================================================================= *
*   End of file:  dsp_q15tofl.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

r4fft.asm/      1061588610  0     0     0       25059     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.1     Fri Dec  7 02:42:02 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS INC.                                                  *
*                                                                           *
*   NAME                                                                    *
*       Complex FFT (Radix 4)                                               *
*                                                                           *
*   REVISION DATE                                                           *
*       06-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable and can the called as                    *
*                                                                           *
*       void DSP_r4fft(int n, short *restrict x, const short *restrict w);  *
*                                                                           *
*       n    --- FFT size (power of 4)                  (input)             *
*       x[]  --- input and output sequences (dim-n)     (input/output)      *
*       w[]  --- FFT coefficients (dim-n)               (input)             *
*                                                                           *
*       If the routine is not to be used as a C callable function,          *
*       then all instructions relating to stack should be removed.          *
*       Refer to comments of individual instructions. You will also         *
*       need to initialize values for all the values passed as these        *
*       are assumed to be in registers as defined by the calling            *
*       convention of the compiler, (refer to the C compiler reference      *
*       guide.)                                                             *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the Assembly Code without the           *
*       assumptions listed below. Note that the assembly code is hand       *
*       optimized and assumptions apply.                                    *
*                                                                           *
*       SOURCE:Burrus, Parks p .113                                         *
*                                                                           *
*   void DSP_r4fft(int n, short *restrict x, const short *restrict w)       *
*   {                                                                       *
*       int             n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;    *
*       short           t, r1, r2, s1, s2, co1, co2, co3, si1, si2, si3;    *
*                                                                           *
*       n2 = n;                                                             *
*       ie = 1;                                                             *
*       for (k = n; k > 1; k >>= 2)                                         *
*       {                                                                   *
*           n1 = n2;                                                        *
*           n2 >>= 2;                                                       *
*           ia1 = 0;                                                        *
*           for (j = 0; j < n2; j++)                                        *
*           {                                                               *
*               ia2 = ia1 + ia1;                                            *
*               ia3 = ia2 + ia1;                                            *
*               co1 = w[ia1 * 2 + 1];                                       *
*               si1 = w[ia1 * 2];                                           *
*               co2 = w[ia2 * 2 + 1];                                       *
*               si2 = w[ia2 * 2];                                           *
*               co3 = w[ia3 * 2 + 1];                                       *
*               si3 = w[ia3 * 2];                                           *
*               ia1 = ia1 + ie;                                             *
*               for (i0 = j; i0 < n; i0 += n1)                              *
*               {                                                           *
*                   i1 = i0 + n2;                                           *
*                   i2 = i1 + n2;                                           *
*                   i3 = i2 + n2;                                           *
*                   r1 = x[2 * i0] + x[2 * i2];                             *
*                   r2 = x[2 * i0] - x[2 * i2];                             *
*                   t = x[2 * i1] + x[2 * i3];                              *
*                   x[2 * i0] = r1 + t;                                     *
*                   r1 = r1 - t;                                            *
*                   s1 = x[2 * i0 + 1] + x[2 * i2 + 1];                     *
*                   s2 = x[2 * i0 + 1] - x[2 * i2 + 1];                     *
*                   t = x[2 * i1 + 1] + x[2 * i3 + 1];                      *
*                   x[2 * i0 + 1] = s1 + t;                                 *
*                   s1 = s1 - t;                                            *
*                   x[2 * i2] = (r1 * co2 + s1 * si2) >> 15;                *
*                   x[2 * i2 + 1] = (s1 * co2-r1 * si2)>>15;                *
*                   t = x[2 * i1 + 1] - x[2 * i3 + 1];                      *
*                   r1 = r2 + t;                                            *
*                   r2 = r2 - t;                                            *
*                   t = x[2 * i1] - x[2 * i3];                              *
*                   s1 = s2 - t;                                            *
*                   s2 = s2 + t;                                            *
*                   x[2 * i1] = (r1 * co1 + s1 * si1)  >>15;                *
*                   x[2 * i1 + 1] = (s1 * co1-r1 * si1)>>15;                *
*                   x[2 * i3] = (r2 * co3 + s2 * si3)  >>15;                *
*                   x[2 * i3 + 1] = (s2 * co3-r2 * si3)>>15;                *
*               }                                                           *
*           }                                                               *
*           ie <<= 2;                                                       *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine is used to compute FFT of a complex sequece            *
*       of size n, a power of 4, with "decimation-in-frequency              *
*       decomposition" method. The output is in digit-reversed              *
*       order. Each complex value is with interleaved 16-bit real           *
*       and imaginary parts.                                                *
*                                                                           *
*   TECHNIQUES                                                              *
*       1. Loading input x as well as coefficient w in word.                *
*       2. Both loops j and i0 shown in the C code are placed in the        *
*          INNERLOOP of the assembly code.                                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       4 <= n <= 65536                                                     *
*       x is aligned on a 4*N Byte (N*word) boundary                        *
*       w is aligned on an odd word boundary                                *
*       x data is stored in the order real[0], image[0], real[1], ...       *
*       w coef is stored in the order k*sin[0*delta], k*cos[0*delta],       *
*              k*sin[1*delta], ...  where delta = 2*PI/N, k = 32767         *
*                                                                           *
*   MEMORY NOTE                                                             *
*       x must be aligned on a 4*N Byte (N*word) boundary for circular      *
*       buffering.  w should be aligned on an odd word boundary to          *
*       minimize memory bank hits.  There are N/4 memory bank hits total    *
*                                                                           *
*   CYCLES                                                                  *
*       LOGBASE4(N) * (10 * N/4 + 29) + 36 + N/4                            *
*       (This includes all function-call overhead, as well as stack         *
*       save and restore overhead.)                                         *
*                                                                           *
*   CODESIZE                                                                *
*       736 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .global _DSP_r4fft
        .text

        .text
        .global _DSP_r4fft
_DSP_r4fft:

; ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A3,         A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
        .asg            B2,         B_irp       ; Old value of IRP
; ========================================================================= ;
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T1   A15,        *B_SP--[16]             ; Get stk, Save A15
||      MV              B_SP,       A_SP                    ; Twin Stack Ptr

        STW     .D1T1   A14,        *-A_SP[ 2]              ; Save A14
||      STW     .D2T2   B14,        *+B_SP[13]              ; Save B14
||      MVC     .S2     CSR,        B_csr                   ; Get CSR's state

        STW     .D1T1   A13,        *-A_SP[ 4]              ; Save A13
||      STW     .D2T2   B13,        *+B_SP[11]              ; Save B13
||      AND             B_csr,      -2,         B_no_gie    ; Clear GIE
;-
        STW     .D1T1   A12,        *-A_SP[ 6]              ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 9]              ; Save B12

        STW     .D1T1   A11,        *-A_SP[ 8]              ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 7]              ; Save B11
||      MV              B_csr,      A_csr                   ; Partitioning MV

        STW     .D1T1   A10,        *-A_SP[10]              ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 5]              ; Save B10
||      MVC     .S2     B_no_gie,   CSR                     ; Disable ints.
; ===== Interrupts masked here =====
;-
        STW     .D1T1   A_csr,      *-A_SP[12]              ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 3]              ; Save return addr.
||      MVC     .S2     IRP,        B_irp

        STW     .D2T2   B_irp,      *+B_SP[ 2]
||      MVK     .S1     32,     A1              ; A1 = 32
||      LMBD    .L1     1,      A4,     A2      ; 31 - log2(n)
||      SHR     .S2X    A4,     2,      B6      ; n2 = n / 4
||      ZERO    .L2     B7                      ; mask
;-
        SUB     .L1     A1,     A2,     A4      ; log2(n)+1 (circ buff size)
||      SHR     .S1     A4,     1,      A7      ; 2 * n2 = n / 2, a-side
||      SHR     .S2X    A4,     1,      B9      ; 2 * n2 = n / 2, b-side

        SHL     .S1     A4,     16,     A4      ; shift into BK0 field
||      LDW     .D1T1   *+A6[2],        A1      ; setup twiddle factor pointer

        ADDK    .S1     0404h,  A4              ; A5, B5 set circ mode on BK0
||      OR      .L2     B7,     1,      B8      ; ie = 1
||      MVC     .S2     B_SP,       IRP
;-
        MVC     .S2X    A4,     AMR             ; load AMR
||      SUB     .L2     B6,     1,      B0      ; loop coutner = n / 4 - 1
||      STW     .D2T2   B4,         *+B_SP[ 1]

K_LOOP:
        MV      .L2     B4,     B5              ; reset X load pointer
||      MV      .L1X    B4,     A5              ; reset X store pointer
||      ADD     .D2     B0,     1,      B1      ; i = loop counter + 1

        SUBAW   .D1     A5,     A7,     A5      ; setup for first preincrement
||      AND     .S2     B1,     B7,     B1      ; j loop twiddle reload test
;-
        SUBAW   .D1     A5,     A7,     A5      ; setup for first preincrement
||      MPY     .M2     B1,     1,      B2      ; j loop twiddle reload test

        LDW     .D2     *B5++[B6],      B10     ; xi0=xt[0*n2],yi0 = yt[0*n2+1]

        LDW     .D2     *B5++[B6],      A8      ; xi1=xt[2*n2],yi1 = yt[2*n2+1]
||[!B2] LDW     .D1     *A6,            B15     ; si1 = w[2 * j], co1 = w[2*j+1]

        LDW     .D2     *B5++[B6],      B11     ; xi2=xt[4*n2],yi2 = yt[4*n2+1]
||[!B2] LDW     .D1     *A6,            A3      ; si2 = w[4*j], co2 = w[4*j+1]

        LDW     .D2     *B5++[B6],      A9      ; xi3=xt[6*n2],yi3 = yt[6*n2+1]
;-
        ZERO    .S1     A4                      ; j = 0

  [!B2] ADD     .L1X    A4,     B8,     A4      ; j += ie

  [!B2] LDW     .D1     *A6,            A13     ; si3 = w[6*j], co3 = w[6*j+1]

        SUB2    .S2     B10,    B11,    B3      ; r2a=xi0 - xi2,s2a = yi0 - yi2
||      ADD     .L2     B0,     0,      B1      ;* i = loop counter

        SUB2    .S1     A8,     A9,     A10     ; t3=xi1 - xi3,  t1 = yi1 - yi3
||      AND     .S2     B1,     B7,     B1      ;* j loop twiddle reload test
||      ZERO    .L1     A2                      ; first pass cond. init to zero
;-
        ADD2    .S1     A8,     A9,     A8      ; t0=xi1 + xi3,  t2 = yi1 + yi3
||      ADD2    .S2     B10,    B11,    B1      ; r1a=xi0 + xi2,s1a = yi0 + yi2
||      MPY     .M2     B1,     1,      B2      ;* j loop twiddle reload test
||[!B1] ADDAW   .D2     B5,     1,      B5      ;* reset x input, (circular)
||[!B2] SUBAW   .D1     A5,     1,      A5      ;
||      ADD     .L2     B0,     1,      B0      ;
;-
LOOP:

        SHR     .S1X    B3,     16,     A9      ;* extract s2a
||      SHR     .S2X    A10,    16,     B10     ;* extract t1
||[!B2] ADDAW   .D1     A5,     1,      A5      ;* reset x output, (circular)
||      LDW     .D2     *B5++[B6],      B10     ;** xi0=xt[0*n2], yi0=yt[0*n2+1]
||      MV      .L1     A6,     A1              ;** reset w
;-
        ADD     .L2     B3,     B10,    B11     ;* r1c = r2a + t1
||      SUB     .L1     A9,     A10,    A12     ;* s1c = s2a - t3
||      SUB2    .S2X    B1,     A8,     B1      ;* r1b=r1a - t0, s1b = s1a - t2
||      ADD2    .S1X    B1,     A8,     A8      ;* xo0=r1a + t0, yo0 = s1a + t2
||      LDW     .D2     *B5++[B6],      A8      ;** xi1=xt[2*n2], yi1=yt[2*n2+1]
||[!B2] LDW     .D1     *++A1[A4],      B15     ;** si1 = w[2*j], co1 = w[2*j+1]
;-
  [A2]  ADD     .S2X    A11,    2,      B3      ; copy B-side x store pointer
||[A2]  SHR     .S1     A14,    15,     A14     ; xo2 = xa2 >> 15
||      SUB     .L2     B3,     B10,    B12     ;* r2c = r2a - t1
||      ADD     .L1     A9,     A10,    A9      ;* s2c = s2a + t3
||      MPY     .M1X    A12,    B15,    A10     ;* ss1 = s1c * si1
||      MPYLH   .M2     B11,    B15,    B10     ;* rc1 = r1c * co1
||      LDW     .D2     *B5++[B6],      B11     ;** xi2=xt[4*n2], yi2=yt[4*n2+1]
||[!B2] LDW     .D1     *++A1[A4],      A3      ;** si2 = w[4*j], co2 = w[4*j+1]
;-
  [A2]  SHR     .S2     B13,    15,     B13     ; yo1 = ya1 >> 15
||[A2]  SHR     .S1     A15,    15,     A15     ; xo3 = xa3 >> 15
||      MPYLH   .M1X    B1,     A3,     A10     ;* rc2 = r1b * co2
||      MPYLH   .M2X    A12,    B15,    B11     ;* sc1 = s1c * co1
||      LDW     .D2     *B5++[B6],      A9      ;** xi3=xt[6*n2], yi3=yt[6*n2+1]
||      ADDAW   .D1     A5,     A7,     A5      ;
;-
  [A2]  SHR     .S2     B14,    15,     B14     ; yo2 = ya2 >> 15
||[B0]  B       .S1     LOOP                    ; for i
||      MPY     .M1     A9,     A13,    A12     ;* ss3 = s2c * si3
||      ADD     .L1X    B10,    A10,    A8      ;* xa1 = rc1 + ss1
||      MPY     .M2     B11,    B15,    B13     ;* rs1 = r1c * si1
||[B0]  STW     .D1     A8,     *++A5[A7]       ;* xt[0*n2]=xo0,  yt[0*n2+1]=yo0
;-
  [A2]  STH     .D2     B13,    *B3++[B9]       ; yt[2 * n2 + 1] = yo1
||[A2]  SHR     .S2     B4,     15,     B4      ; yo3 = ya3 >> 15
||[A2]  STH     .D1     A0,     *A11++[A7]      ; xt[2 * n2] = xo1
||      SHR     .S1     A8,     15,     A0      ;* xo1 = xa1 >> 15
||      MPYH    .M2X    B1,     A3,     B14     ;* sc2 = s1b * co2
||      MPYHL   .M1X    B1,     A3,     A9      ;* ss2 = s1b * si2
;-
  [A2]  STH     .D2     B14,    *B3++[B9]       ; yt[4 * n2 + 1] = yo2
||      MPYLH   .M1     A9,     A13,    A1      ;* sc3 = s2c * co3
||      MPY     .M2X    B1,     A3,     B12     ;* rs2 = r1b * si2
||      SUB     .L2     B11,    B13,    B13     ;* ya1 = sc1 - rs1
||[!B2] LDW     .D1     *++A1[A4],      A13     ;** si3 = w[6*j], co3 = w[6*j+1]
||[!B2] ADD     .L1X    A4,     B8,     A4      ;** j += ie
||      SUB     .S2     B0,     1,      B0      ;*** generate loop counter
;-
  [A2]  STH     .D2     B4,     *B3             ; yt[6 * n2 + 1] = yo3
||[A2]  STH     .D1     A14,    *A11++[A7]      ; xt[4 * n2] = xo2
||      MPY     .M2X    B12,    A13,    B12     ;* rs3 = r2c * si3
||      MPYLH   .M1X    B12,    A13,    A11     ;* rc3 = r2c * co3
||      ADD     .L1     A10,    A9,     A14     ;* xa2 = rc2 + ss2
||      SUB2    .S2     B10,    B11,    B3      ;** r2a = xi0-xi2, s2a = yi0-yi2
||      SUB     .L2     B0,     1,      B1      ;*** i = loop counter - 1
;-
  [A2]  STH     .D1     A15,    *A11            ; xt[6 * n2] = xo3
||      SUB     .L2     B14,    B12,    B14     ;* ya2 = sc2 - rs2
||      SUB2    .S1     A8,     A9,     A10     ;** t3=xi1 - xi3,  t1 = yi1-yi3
||      AND     .S2     B1,     B7,     B1      ;*** j loop twiddle reload test
||[!A2] ADD     .L1     A2,     1,      A2      ; First Pass Done Set Cond. Reg
;-
        ADDAH   .D1     A5,     A7,     A11     ;* copy A-side x store pointer
||      SUB     .L2X    A1,     B12,    B4      ;* ya3 = sc3 - rs3
||      ADD     .L1     A11,    A12,    A15     ;* xa3 = rc3 + ss3
||      ADD2    .S1     A8,     A9,     A8      ;** t0=xi1 + xi3,  t2 = yi1+yi3
||      ADD2    .S2     B10,    B11,    B1      ;** r1a = xi0+xi2, s1a = yi0+yi2
||      MPY     .M2     B1,     1,      B2      ;*** j loop twiddle reload test
||[!B1] ADDAW   .D2     B5,     1,      B5      ;*** reset x input, (circular)

; LOOP ends here

        MPY     .M2     B6,     B8,     B0      ; n/4 = n2 * ie
||      B       .S1     K_LOOP
||      MVC     .S2     IRP,    B_SP

        SHR     .S1     A7,     2,      A7      ; 2 * n2 >>= 2
||      SHL     .S2     B7,     2,      B7      ; mask   <<= 2
||      LDW     .D2T2   *B_SP[1],       B4      ; restore x pointer

;-
        SUB     .D2     B0,     1,      B0      ; loop counter = n/4 - 1
||      ADD     .L2     B7,     3,      B7      ; mask    += 3
||      SHL     .S2     B8,     2,      B8      ; ie     <<= 2

        SHR     .S2     B9,     2,      B9      ; 2 * n2 >>= 2
||      CMPGT   .L2     B7,     B0,     B1      ; kcond    = mask > n / 4 - 1

        .asg            B0,     B_amr           ; AMR value to restore

  [!B1] SHR     .S2     B6,     2,      B6      ; n2     >>= 2
||[ B1] B       .S1     DONE
||[ B1] ZERO            B_amr
;-
  [ B1] MVC     .S2     B_amr,      AMR         ; Restore AMR

DONE:

; K_LOOP ends here


; ================ SYMBOLIC REGISTER ASSIGNMENTS: CLEANUP ================= ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A6,         A_SP        ; Stack pointer, A datapath
        .asg            A0,         A_csr       ; CSR value to restore
        .asg            B0,         B_amr       ; AMR value to restore
        .asg            B2,         B_irp       ; IRP value to restore
        .asg            B3,         B_ret       ; Return address
; ========================================================================= ;

        MV              B_SP,       A_SP
||      LDW     .D2T2   *+B_SP[ 2], B_irp

        LDW     .D1T2   *+A_SP[ 3], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 4], A_csr       ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 5], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 6], A10         ; Restore A10
;-
        LDW     .D1T2   *+A_SP[ 7], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 8], A11         ; Restore A11

        LDW     .D1T2   *+A_SP[ 9], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[10], A12         ; Restore A12

        LDW     .D1T2   *+A_SP[11], B13         ; Restore B13
||      LDW     .D2T1   *+B_SP[12], A13         ; Restore A13
||      MVC     .S2     B_irp,      IRP
;-
        LDW     .D1T2   *+A_SP[13], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[14], A14         ; Restore A14
||      B       .S2     B_ret                   ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
||      LDW     .D2T1   *++B_SP[16],A15         ; Restore A15
; ===== Interruptibility state restored here =====

        NOP             4
;-
; ===== Branch Occurs =====

* ========================================================================= *
*   End of file:  rfft4_h.asm                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

radix2.asm/     1061588610  0     0     0       21393     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.3     Fri Mar 22 02:08:27 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_radix2 -- In-place Radix-2 FFT (Little Endian)                  *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_radix2(int n, short *restrict xy,                          *
*                   const short *restrict w);                               *
*                                                                           *
*       n    -- FFT size                            (input)                 *
*       xy[] -- input and output sequences (dim-n)  (input/output)          *
*       w[]  -- FFT coefficients (dim-n/2)          (input)                 *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine is used to compute FFT of a complex sequece of size    *
*       n, a power of 2, with "decimation-in-frequency decomposition"       *
*       method, ie, the output is in bit-reversed order. Each complex       *
*       value is with interleaved 16-bit real and imaginary parts. To       *
*       prevent overflow, input samples may have to be scaled by 1/n.       *
*                                                                           *
*       void DSP_radix2(int n, short *restrict xy,                          *
*                   const short *restrict w)                                *
*       {                                                                   *
*           short n1,n2,ie,ia,i,j,k,l;                                      *
*           short xt,yt,c,s;                                                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k=n; k > 1; k = (k >> 1) )                                 *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 = n2>>1;                                                 *
*               ia = 0;                                                     *
*               for (j=0; j < n2; j++)                                      *
*               {                                                           *
*                   c = w[2*ia];                                            *
*                   s = w[2*ia+1];                                          *
*                   ia = ia + ie;                                           *
*                   for (i=j; i < n; i += n1)                               *
*                   {                                                       *
*                       l = i + n2;                                         *
*                       xt      = xy[2*l] - xy[2*i];                        *
*                       xy[2*i] = xy[2*i] + xy[2*l];                        *
*                       yt      = xy[2*l+1] - xy[2*i+1];                    *
*                       xy[2*i+1] = xy[2*i+1] + xy[2*l+1];                  *
*                       xy[2*l]   = (c*xt + s*yt)>>15;                      *
*                       xy[2*l+1] = (c*yt - s*xt)>>15;                      *
*                   }                                                       *
*               }                                                           *
*               ie = ie<<1;                                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       16 <= n <= 32768                                                    *
*       Both input xy and coefficient w must be aligned on word boundary.   *
*       w coef stored ordered is k*(-cos[0*delta]), k*(-sin[0*delta]),      *
*       k*(-cos[1*delta]), ...  where delta = 2*PI/N, k = 32767             *
*       Assembly code is written for processor in Little Endian mode        *
*       Input xy and coefficients w are 16 bit data.                        *
*                                                                           *
*   MEMORY NOTE                                                             *
*       Align xy and w on different word boundaries to minimize             *
*       memory bank hits.                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       1. Loading input xy as well as coefficient w in word.               *
*       2. Both loops j and i shown in the C code are placed in the         *
*          INNERLOOP of the assembly code.                                  *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = log2(N) * (4*N/2+7) + 34 + N/4.                            *
*                                                                           *
*       (The N/4 term is due to bank conflicts that occur when xy and w     *
*       are aligned as suggested above, under "MEMORY NOTE.")               *
*                                                                           *
*       For N = 256, cycles = 4250.                                         *
*                                                                           *
*   CODESIZE                                                                *
*       800 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_radix2
_DSP_radix2:
        STW     .D2T1   A15, *B15--[12] ; push A15 to SP[12]
||      SUB     .L1X    B15, 4, A15

        STW     .D1T1   A10, *A15--[10] ; push A10 to SP[11]
||      STW     .D2T2   B10, *+B15[10]  ; push B10 to SP[10]
||      MVC     .S2     CSR, B0

        STW     .D1T1   A11, *+A15[8]   ; push A11 to SP[ 9]
||      STW     .D2T2   B11, *+B15[8]   ; push B11 to SP[ 8]
||      AND     .S2     B0, -2, B1
;-
        STW     .D1T1   A12, *+A15[6]   ; push A12 to SP[ 7]
||      STW     .D2T2   B12, *+B15[6]   ; push B12 to SP[ 6]
||      MVC     .S2     B1,  CSR
        ;== Interrupts disabled here ===

        STW     .D1T1   A13, *+A15[4]   ; push A13 to SP[ 5]
||      STW     .D2T2   B13, *+B15[4]   ; push B13 to SP[ 4]

        STW     .D1T1   A14, *+A15[2]   ; push A14 to SP[ 3]
||      STW     .D2T2   B14, *+B15[2]   ; push B14 to SP[ 2]
||      MV      .L1X    B4,A9           ; &XY
;-
        LMBD    .L1     1,A4,A1         ; outer loop count calculation
||      MV      .L2X    A4,B13          ; &N
||      STW     .D1T2   B0,  *+A15[0]   ; push CSR to SP[ 1]

        MVK     .S1     1,A2            ; IE = 1
||      MV      .D2     B13,B10         ; XY index setup
||      MV      .L1     A4,A7           ; XY index setup
||      SHL     .S2     B13,2,B14       ; calculating reset offset
||      MV      .L2X    A6,B12          ; permanent ptr for W[0]
;-
        SHR     .S2     B13,1,B13       ; used for loop count
||      SUB     .D2     B14,4,B14       ; calculating reset offset
||      SUB     .L1X    B14,4,A8        ; calculating reset offset

        ADDAH   .D1     A9,A7,A3        ; setup ptr for X[i+N2] & Y[i+N2]
||      MV      .L2X    A9,B9           ; setup ptr for X[i] & Y[i]
||      SUB     .D2     B13,4,B13       ; inner loop count
||      MVK     .S2     31,B7           ; outer loop count calculation
;-
        MV      .S2     B9,B4           ; setup store ptr for X[i] & Y[i]
||      MV      .L2     B9,B11          ; permanent ptr for X[0] & Y[0]
||      SUB     .L1X    B7,A1,A1        ; outer loop conter

        LDW     .D2     *B9++[B10],B7   ; X[i] & Y[i]
||      MV      .L2X    A2,B2           ; reset twiddle factor counter
||      LDW     .D1     *A6++[A2],A5    ; CS = W[IA] & W[IA+1]
||      SHL     .S1     A7,1,A0         ; calculating reset offset
;-
  [ B2] SUB             B2,1,B2         ; decrement twiddle factor counter
||      LDW     .D1     *A3++[A7],A13   ; X[i+N2] & Y[i+N2]

  [!B2] SUB             B9,B14,B9       ; reset load X[i] & Y[i] ptrs

  [!B2] SUB             A3,A8,A3        ; reset load X[i+N2] & Y[i+N2] ptrs

OUTLOOP:
        LDW     .D2     *B9++[B10],B7   ;* X[i] & Y[i]
||[!B2] MV      .L2X    A2,B2           ;* reset twiddle factor counter
||[!B2] LDW     .D1     *A6++[A2],A5    ;* CS = W[IA] & W[IA+1]
||      MPY     .M2     B2,1,B0         ; move to next iteration
;-
  [ B2] SUB             B2,1,B2         ;* decrement twiddle factor counter
||      LDW     .D1     *A3++[A7],A13   ;* X[i+N2] & Y[i+N2]

        SUB2    .S1X    A13,B7,A9       ; XYT = X[i]-X[i+N2] & Y[i]-Y[i+N2]
||      MV              A5,A10          ; move to other file
||      ADD2    .S2X    B7,A13,B7       ; X[i]+X[i+N2] & Y[i]+Y[i+N2]
||[!B2] SUB             B9,B14,B9       ;* reset load X[i] & Y[i] ptrs

        MPYHL   .M1     A9,A5,A14       ; (C)*(YT)
||      STW     .D2     B7,*B4++[B10]   ; XY[i] = X[i]+X[i+N2] & Y[i]+Y[i+N2]
;-
        MPYLH   .M1     A9,A5,A15       ; (S)*XT
||      LDW     .D2     *B9++[B10],B7   ;** X[i] & Y[i]
||[!B2] MV      .L2X    A2,B2           ;** reset twiddle factor counter
||[!B2] LDW     .D1     *A6++[A2],A5    ;** CS = W[IA] & W[IA+1]
||      SUB     .L1X    B4,A0,A4        ; set store X[i+N2] ptr
||      MPY     .M2     B2,1,B0         ;* move to next iteration
||[!B2] SUB             A3,A8,A3        ;* reset load X[i+N2] & Y[i+N2] ptrs
;-
        MPY     .M1     A9,A10,A13      ; (C)*XT
||[!B0] SUB             B4,B14,B4       ; reset store X[i] & Y[i] ptrs
||[ B2] SUB             B2,1,B2         ;** decrement twiddle factor counter
||      LDW     .D1     *A3++[A7],A13   ;** X[i+N2] & Y[i+N2]

        MPYH    .M1     A9,A10,A14      ; (S)*(YT)
||      SUB2    .S1X    A13,B7,A9       ;* XYT = X[i]-X[i+N2] & Y[i]-Y[i+N2]
||      ADD2    .S2X    B7,A13,B7       ;* X[i]+X[i+N2] & Y[i]+Y[i+N2]
||[!B2] SUB             B9,B14,B9       ;** reset load X[i] & Y[i] ptrs
;-
        SUB     .S1     A14,A15,A15     ; Y[i+N2] = C*YT - S*XT
||      MPYHL   .M1     A9,A5,A14       ;* (C)*(YT)
||      STW     .D2     B7,*B4++[B10]   ;* XY[i] = X[i]+X[i+N2] & Y[i]+Y[i+N2]
||[!B2] SUB     .D1     A3,A8,A3        ;** reset load X[i+N2] & Y[i+N2] ptrs
||      MV      .L2X    A4,B6           ; set store X[i+N2] ptr
||      MV      .S2     B13,B1          ; set inner loop counter
||      MV      .L1     A5,A10          ;* move to other file

        B       .S2     LOOP            ; for (i=j; i < N; i += N1)
||      ADD     .S1     A14,A13,A13     ; X[i+N2] = C*XT + S*YT
||      MPYLH   .M1     A9,A5,A15       ;* (S)*XT
||      LDW     .D2     *B9++[B10],B7   ;*** X[i] & Y[i]
||[!B2] MV      .L2X    A2,B2           ;*** reset twiddle factor counter
||[!B2] LDW     .D1     *A6++[A2],A5    ;*** CS = W[IA] & W[IA+1]
||      SUB     .L1X    B4,A0,A4        ;* set store X[i+N2] ptr
||      MPY     .M2     B2,1,B0         ;** move to next iteration

        SHR     .S2X    A13,15,B5       ; scale X[i+N2]
||      SHR     .S1     A15,15,A11      ; scale Y[i+N2]
||      MPY     .M1     A9,A10,A13      ;* (C)*XT
||[!B0] SUB     .L2     B4,B14,B4       ;* reset store X[i] & Y[i] ptrs
||[ B2] SUB     .D2     B2,1,B2         ;*** decrement twiddle factor counter
||      LDW     .D1     *A3++[A7],A13   ;*** X[i+N2] & Y[i+N2]
||      ADD     .L1X    B6,2,A12        ; set store Y[i+N2] ptr

LOOP:
        STH     .D2     B5,*B6          ; X[i+N2] = C*YT + S*XT
||      STH     .D1     A11,*A12        ; Y[i+N2] = C*YT - S*XT
||      MPYH    .M1     A9,A10,A14      ;* (S)*(YT)
||      SUB2    .S1X    A13,B7,A9       ;** XYT = X[i]-X[i+N2] & Y[i]-Y[i+N2]
||      MV      .L1     A5,A10          ;** move to other file
||      ADD2    .S2X    B7,A13,B7       ;** X[i]+X[i+N2] & Y[i]+Y[i+N2]
||[!B2] SUB     .L2     B9,B14,B9       ;*** reset load X[i] & Y[i] ptrs

        SUB     .D1     A14,A15,A15     ;* Y[i+N2] = C*YT - S*XT
||      MV      .L2X    A4,B6           ;* set store X[i+N2] ptr
||[ B1] SUB     .S2     B1,1,B1         ;** dec i lp cntr
||      MPYHL   .M1     A9,A5,A14       ;** (C)*(YT)
||      STW     .D2     B7,*B4++[B10]   ;** XY[i] = X[i]+X[i+N2] & Y[i]+Y[i+N2]
||[!B2] SUB     .S1     A3,A8,A3        ;*** reset load X[i+N2] & Y[i+N2] ptrs

  [ B1] B       .S2     LOOP            ;* for (i=j; i < N; i += N1)
||      ADD     .S1     A13,A14,A13     ;* X[i+N2] = C*XT + S*YT
||      MPYLH   .M1     A9,A5,A15       ;** (S)*XT
||      SUB     .L1X    B4,A0,A4        ;** set store X[i+N2] ptr
||      LDW     .D2     *B9++[B10],B7   ;**** X[i] & Y[i]
||[!B2] MV      .L2X    A2,B2           ;**** reset twiddle factor counter
||[!B2] LDW     .D1     *A6++[A2],A5    ;**** CS = W[IA] & W[IA+1]
||      MPY     .M2     B2,1,B0         ;*** move to next iteration

        SHR     .S2X    A13,15,B5       ;* scale X[i+N2]
||      SHR     .S1     A15,15,A11      ;* scale Y[i+N2]
||      ADD     .L1X    B6,2,A12        ;* set store Y[i+N2] ptr
||[!B0] SUB     .L2     B4,B14,B4       ;** reset store X[i] & Y[i] ptrs
||      MPY     .M1     A9,A10,A13      ;** (C)*XT
||[ B2] SUB     .D2     B2,1,B2         ;**** decrement twiddle factor counter
||      LDW     .D1     *A3++[A7],A13   ;**** X[i+N2] & Y[i+N2]
; - - - - - - - - - - - - - - - - - - - ; LOOP ENDS HERE
;-
        STH     .D2     B5,*B6          ; X[i+N2] = C*YT + S*XT
||      STH     .D1     A11,*A12        ; Y[i+N2] = C*YT - S*XT
||      MPYH    .M1     A9,A10,A14      ;* (S)*(YT)
||      SUB2    .S1X    A13,B7,A9       ;** XYT = X[i]-X[i+N2] & Y[i]-Y[i+N2]
||      MV      .L1     A5,A10          ;** move to other file
||      ADD2    .S2X    B7,A13,B7       ;** X[i]+X[i+N2] & Y[i]+Y[i+N2]
||      MV      .L2     B11,B9          ; set up load ptr to X[0] & Y[0]
;-
        SUB     .D1     A14,A15,A15     ;* Y[i+N2] = C*YT - S*XT
||      MV      .L2X    A4,B6           ;* set store X[i+N2] ptr
||      MPYHL   .M1     A9,A5,A14       ;** (C)*(YT)
||      STW     .D2     B7,*B4++[B10]   ;** XY[i] = X[i]+X[i+N2] & Y[i]+Y[i+N2]
||      SHL     .S1     A2,1,A2         ; IE << 1
||      SUB     .L1     A1,1,A1         ; decrement outer loop counter
;-
        ADD     .D1     A14,A13,A13     ;* X[i+N2] = C*XT + S*YT
||      MPYLH   .M1     A9,A5,A15       ;** (S)*XT
||      SUB     .L1X    B4,A0,A4        ;** set store X[i+N2] ptr
||      SHR     .S1     A15,15,A11      ;* scale Y[i+N2]

        SHR     .S2X    A13,15,B5       ;* scale X[i+N2]
||      ADD     .L1X    B6,2,A12        ;* set store Y[i+N2] ptr
||      MPY     .M1     A9,A10,A13      ;** (C)*XT
||[ A1] B       .S1     OUTLOOP         ; branch to next stage
;-
        STH     .D2     B5,*B6          ; X[i+N2] = C*YT + S*XT
||      STH     .D1     A11,*A12        ; Y[i+N2] = C*YT - S*XT
||      MPYH    .M1     A9,A10,A10      ;* (S)*(YT)
||      SHR     .S2     B10,1,B10       ; load index >> 1
||      SHR     .S1     A0,1,A0         ; N2 >> 1
||      MV      .L1X    B12,A6          ; reset W ptr
||      MV      .L2X    A2,B2           ; reset twiddle factor counter
;-
        MV      .L2X    A4,B6           ;* set store X[i+N2] ptr
||      LDW     .D2     *B9++[B10],B7   ; X[i] & Y[i]
||      ADD     .L1X    A7,B9,A3        ; set up load ptr to X[N2] & Y[N2]
||      LDW     .D1     *A6++[A2],A5    ; CS = W[IA] & W[IA+1]
||      SHR     .S1     A7,1,A7         ; load index >> 1
||[B2]  SUB     .S2     B2,1,B2         ; decrement twiddle factor counter
;-
        ADD     .L1     A10,A13,A13     ;* X[i+N2] = C*XT + S*YT
||      SUB     .S1     A14,A15,A15     ;* Y[i+N2] = C*YT - S*XT
||[ A1] LDW     .D1     *A3++[A7],A13   ; X[i+N2] & Y[i+N2]
||[!B2] SUB     .L2     B9,B14,B9       ; reset load X[i] & Y[i] ptrs

        SHR     .S2X    A13,15,B5       ;* scale X[i+N2]
||      SHR     .S1     A15,15,A11      ;* scale Y[i+N2]
||      ADD     .L1X    B6,2,A12        ;* set store Y[i+N2] ptr
||[!B2] SUB             A3,A8,A3        ; reset load X[i+N2] & Y[i+N2] ptrs
;-
        STH     .D2     B5,*B6          ; X[i+N2] = C*YT + S*XT
||      STH     .D1     A11,*A12        ; Y[i+N2] = C*YT - S*XT
||      SHL     .S1     A7,1,A0         ; calculating reset offset
||      MV      .S2     B11,B4          ; set up store ptr to X[0] & Y[0]
; - - - - - - - - - - - - - - - - - - - ; OUTLOOP ENDS HERE

        LDW     .D2T2   *+B15[1],  B0   ; pop CSR from SP[ 1]
||      MV              B15, A15

        LDW     .D1T1   *+A15[11], A10  ; pop A10 from SP[11]
||      LDW     .D2T2   *+B15[10], B10  ; pop B10 from SP[10]
;-
        LDW     .D1T1   *+A15[9],  A11  ; pop A11 from SP[ 9]
||      LDW     .D2T2   *+B15[8],  B11  ; pop B11 from SP[ 8]

        LDW     .D1T1   *+A15[7],  A12  ; pop A12 from SP[ 7]
||      LDW     .D2T2   *+B15[6],  B12  ; pop B12 from SP[ 6]

        LDW     .D1T1   *+A15[5],  A13  ; pop A13 from SP[ 5]
||      LDW     .D2T2   *+B15[4],  B13  ; pop B13 from SP[ 4]
;-
        LDW     .D2T2   *+B15[2],  B14  ; pop B14 from SP[ 2]
||      LDW     .D1T1   *+A15[3],  A14  ; pop A14 from SP[ 3]
||      B               B3

        LDW     .D2T1   *++B15[12],A15  ; pop A15 from SP[12]

        MVC             B0, CSR

        NOP             3
;-

* ========================================================================= *
*    End of file: dsp_radix2.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

recip16.asm/    1061588610  0     0     0       14511     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Thu Sep  6 18:22:58 2001 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_recip16                                                         *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       20-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_recip16 (short *x, short *rfrac, short *rexp, short nx);   *
*                                                                           *
*       x[nx]     = Pointer to input vector of size nx                      *
*       rfrac[nx] = Pointer to output vector of size nx to                  *
*                   contain the fractional part of the reciprocal           *
*       rexp[nx]  = Pointer to output vector of size nx to                  *
*                   contain the exponent part of the reciprocal             *
*       nx        = Number of elements in input vector                      *
*                                                                           *
*       (See the C compiler reference guide.)                               *
*                                                                           *
*   DESCRIPTION                                                             *
*       This program performs a reciprocal on a vector of Q15 numbers.      *
*       The result is stored in two parts: a Q15 part and an exponent       *
*       (power of two) of the fraction.                                     *
*       First, the input is loaded, then its absolute value is taken,       *
*       then it is normalized, then divided using a loop of conditional     *
*       subtracts, and finally it is negated if the original input was      *
*       negative.                                                           *
*                                                                           *
*       void DSP_recip16 (short *x, short *rfrac, short *rexp, short nx)    *
*       {                                                                   *
*          int i,j,a,b;                                                     *
*          short neg, normal;                                               *
*                                                                           *
*          for(i = nx; i > 0; i--)                                          *
*          {                                                                *
*              a = *(x++);                                                  *
*              if(a < 0)             /* take absolute value */              *
*              {                                                            *
*                  a = -a;                                                  *
*                  neg = 1;                                                 *
*              }                                                            *
*              else                                                         *
*                  neg = 0;                                                 *
*              normal = _norm(a);              /* normalize */              *
*              a = a << normal;                                             *
*              *(rexp++) = normal - 15;   /* store exponent */              *
*              b = 0x80000000;              /* dividend = 1 */              *
*              for(j = 15; j > 0; j--)                                      *
*                  b = _subc(b,a);                /* divide */              *
*              b = b & 0x7FFF;           /* clear remainder */              *
*              if(neg) b = -b;       /* if negative, negate */              *
*              *(rfrac++) = b;            /* store fraction */              *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       LITTLE ENDIAN Configuration used                                    *
*       x and rfrac are Q15 format                                          *
*       output is accurate up to the least significant bit of rfrac, but    *
*       note that this bit could carry over and change rexp too             *
*                                                                           *
*   MEMORY NOTE                                                             *
*       There are no memory bank hits in this procedure                     *
*                                                                           *
*   NOTE                                                                    *
*       interruptible (single assignment code)                              *
*                                                                           *
*   TECHNIQUES                                                              *
*       The conditional subtract instruction, SUBC, is used for division    *
*       SUBC is used once for every bit of quotient needed (15).            *
*       2 stages of prolog and epilog collapsed                             *
*       split 2 live-too-longs (A_neg and B_norm)                           *
*                                                                           *
*   CYCLES                                                                  *
*        8 * nx + 14                                                        *
*                                                                           *
*   CODESIZE                                                                *
*        196 bytes                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_recip16
_DSP_recip16:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x
        .asg            B4,         B_rfrac
        .asg            A6,         A_rexp
        .asg            B1,         B_nx
        .asg            A3,         A_b
        .asg            A1,         A_neg
        .asg            A0,         A_a
        .asg            B6,         B_neg1
        .asg            B0,         B_neg2
        .asg            A7,         A_n
        .asg            A5,         A_norm
        .asg            B8,         B_exp
        .asg            A9,         A_b1
        .asg            A8,         A_b2
        .asg            A8,         A_b3
        .asg            A9,         A_b4
        .asg            A9,         A_b5
        .asg            A9,         A_b6
        .asg            A8,         A_b7
        .asg            B8,         B_b7
        .asg            B5,         B_norm
        .asg            B7,         B_norm1
        .asg            B8,         B_b8
        .asg            B6,         B_b9
        .asg            B7,         B_b10
        .asg            B5,         B_b11
        .asg            B8,         B_b12
        .asg            B8,         B_b13
        .asg            B8,         B_b14
        .asg            B7,         B_b15
        .asg            B7,         B_bc
        .asg            B2,         B_p
        .asg            A2,         A_p
* ========================================================================= *

* =========================== PIPE LOOP PROLOG ============================ *
        LDH     .D1T1   *A_x++,     A_a                         ;[ 1,1]
||      ZERO    .L1     A_b

        MVKH    .S1     0x80000000, A_b

        SUB     .L2     B6,         1,          B_nx

        MVK     .S1     1,          A_p                         ; prolog coll

        MVK     .S2     3,          B_p                         ; prolog coll

        SHR     .S1     A_a,        31,         A_neg           ;[ 6,1]

  [ A_neg]NEG   .S1     A_a,        A_a                         ;[ 7,1]

* =========================== PIPE LOOP KERNEL ============================ *
loop:
        SUBC    .L2     B_b11,      B_norm1,    B_b12           ;[24,1]
||      MV      .S2X    A_norm,     B_norm                      ;[16,2]
||[!A_p]STH     .D1T2   B_exp,      *A_rexp++                   ;[16,2]
||      NORM    .L1     A_a,        A_n                         ;[ 8,3]

        SUBC    .L2     B_b12,      B_norm1,    B_b13           ;[25,1]
||      SUBC    .L1     A_b6,       A_norm,     A_b7            ;[17,2]
||      SHL     .S1     A_a,        A_n,        A_norm          ;[ 9,3]
||      LDH     .D1T1   *A_x++,     A_a                         ;[ 1,4]

        BDEC    .S2     loop,       B_nx                        ;[26,1]
||      SUBC    .L2     B_b13,      B_norm1,    B_b14           ;[26,1]
||      SUBC    .L1     A_b,        A_norm,     A_b1            ;[10,3]
||[ A_p]SUB     .D1     A_p,        1,          A_p             ; prolog coll

        SUBC    .L2     B_b14,      B_norm1,    B_b15           ;[27,1]
||      MV      .S2X    A_b7,       B_b7                        ;[19,2]
||      SUBC    .L1     A_b1,       A_norm,     A_b2            ;[11,3]

        CLR     .S2     B_b15,      15, 31,     B_bc            ;[28,1]
||      SUBC    .L2     B_b7,       B_norm,     B_b8            ;[20,2]
||      SUBC    .L1     A_b2,       A_norm,     A_b3            ;[12,3]
||[ B_p]SUB     .D2     B_p,        1,          B_p             ; prolog coll

  [ B_neg2]NEG  .S2     B_bc,       B_bc                        ;[29,1]
||      SUBC    .L2     B_b8,       B_norm,     B_b9            ;[21,2]
||      MV      .D2     B_neg1,     B_neg2                      ;[21,2]
||      SUBC    .L1     A_b3,       A_norm,     A_b4            ;[13,3]

  [!B_p]STH     .D2T2   B_bc,       *B_rfrac++                  ;[30,1]
||      SUBC    .L2     B_b9,       B_norm,     B_b10           ;[22,2]
||      SUBC    .L1     A_b4,       A_norm,     A_b5            ;[14,3]
||      MV      .S2X    A_neg,      B_neg1                      ;[14,3]
||      SHR     .S1     A_a,        31,         A_neg           ;[ 6,4]

        SUBC    .L2     B_b10,      B_norm,     B_b11           ;[23,2]
||      MV      .D2     B_norm,     B_norm1                     ;[23,2]
||      SUBC    .L1     A_b5,       A_norm,     A_b6            ;[15,3]
||      SUB     .S2X    A_n,        15,         B_exp           ;[15,3]
||[ A_neg]NEG   .S1     A_a,        A_a                         ;[ 7,4]

* =========================== PIPE LOOP EPILOG ============================ *
        SUBC    .L2     B_b11,      B_norm1,    B_b12           ;[24,4]

        SUBC    .L2     B_b12,      B_norm1,    B_b13           ;[25,4]
||      B       .S2     B3

        SUBC    .L2     B_b13,      B_norm1,    B_b14           ;[26,4]

        SUBC    .L2     B_b14,      B_norm1,    B_b15           ;[27,4]

        CLR     .S2     B_b15,      15, 31,     B_bc            ;[28,4]

  [ B_neg2]NEG  .S2     B_bc,       B_bc                        ;[29,4]

        STH     .D2T2   B_bc,       *B_rfrac++                  ;[30,4]

; Branch occurs

* ========================================================================= *
*   End of file:  dsp_recip16.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


vecsumsq.asm/   1061588610  0     0     0       11499     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.7     Fri Mar 29 20:51:57 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_vecsumsq                                                        *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           int DSP_vecsumsq                                                *
*           (                                                               *
*               const short *x,    /* Pointer to vector  */                 *
*               int          nx    /* Length of vector.  */                 *
*           );                                                              *
*                                                                           *
*       This routine returns the sum of squares as its return value.        *
*                                                                           *
*   DESCRIPTION                                                             *
*       The "DSP_vecsumsq" function returns the sum of squares of the       *
*       elements contained in vector "x".                                   *
*                                                                           *
*   C CODE                                                                  *
*       The following C code is a general implementation without            *
*       restrictions.  This implementation may have restrictions, as        *
*       noted under "ASSUMPTIONS" below.                                    *
*                                                                           *
*           int DSP_vecsumsq                                                *
*           (                                                               *
*               const short *x,    /* Pointer to vector  */                 *
*               int          nx    /* Length of vector.  */                 *
*           )                                                               *
*           {                                                               *
*               int i, sum = 0;                                             *
*                                                                           *
*               for (i = 0; i < nx; i++)                                    *
*                   sum += x[i] * x[i];                                     *
*                                                                           *
*               return sum;                                                 *
*           }                                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*       The code is unrolled 4 times to enable full memory and multiplier   *
*       bandwidth to be utilized.                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input length is a multiple of 4 and at >= 12.                   *
*                                                                           *
*   NOTES                                                                   *
*       This code is ENDIAN NEUTRAL                                         *
*                                                                           *
*       This function is interrupt tolerant, but not interruptible.         *
*       It locks out interrupts for its entire duration.                    *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This function is ENDIAN NEUTRAL.                                    *
*       No bank conflicts occur under any conditions.                       *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = nx/2 + 11.                                                 *
*                                                                           *
*   CODESIZE                                                                *
*       148 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_vecsumsq
_DSP_vecsumsq:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_ret_val
        .asg            A4,         A_x
        .asg            A6,         A_sum
        .asg            A7,         A_prod
        .asg            A8,         A_reg0
        .asg            A9,         A_reg1
        .asg            B3,         B_return
        .asg            B4,         B_i
        .asg            B4,         B_nx
        .asg            B5,         B_reg1
        .asg            B6,         B_sum
        .asg            B7,         B_prod
*======================================================================== *
        SHRU    .S2     B_nx,       2,          B_i             ;[ 2,0]
||      LDNDW   .D      *A_x++,     A_reg1:A_reg0               ;[ 1,1]
||      B       .S1     LOOP                                    ;

        SUB     .D2     B_i,        4,          B_i             ;[ 3,0]
||      LDNDW   .D      *A_x++,     A_reg1:A_reg0               ;[ 1,2]
||      B       .S1     LOOP                                    ;

        LDNDW   .D      *A_x++,     A_reg1:A_reg0               ;[ 1,3]
||      BDEC    .S2     LOOP,       B_i                         ;

        LDNDW   .D      *A_x++,     A_reg1:A_reg0               ;[ 1,4]
||      BDEC    .S2     LOOP,       B_i                         ;

        LDNDW   .D      *A_x++,     A_reg1:A_reg0               ;[ 1,5]
||      BDEC    .S2     LOOP,       B_i                         ;
||      ZERO    .L2     B_prod:B_sum                            ;[ 3,0]
||      ZERO    .L1     A_prod:A_sum                            ;[ 3,0]

        DOTP2   .M1     A_reg0,     A_reg0,     A_prod          ;[ 6,1]
||      MV      .L2X    A_reg1,     B_reg1                      ;[ 6,1]
||      LDNDW   .D      *A_x++,     A_reg1:A_reg0               ;[ 1,6]
||      BDEC    .S2     LOOP,       B_i                         ;
; ===== 5 prolog stages collapsed.
* =========================== PIPE LOOP KERNEL ============================ *
LOOP:
        ADD     .D2     B_sum,      B_prod,     B_sum           ;[11,1]
||      ADD     .L1     A_sum,      A_prod,     A_sum           ;[10,3]
||      BDEC    .S2     LOOP,       B_i                         ;[ 7,6]
||      DOTP2   .M2     B_reg1,     B_reg1,     B_prod          ;[ 7,6]
||      DOTP2   .M1     A_reg0,     A_reg0,     A_prod          ;[ 6,7]
||      MV      .L2X    A_reg1,     B_reg1                      ;[ 6,7]
||      LDNDW   .D      *A_x++,     A_reg1:A_reg0               ;[ 1,12]

* =========================== PIPE LOOP EPILOG ============================ *

        ADD     .D2     B_sum,      B_prod,     B_sum           ;[11,8]
||      ADD     .L1     A_sum,      A_prod,     A_sum           ;[10,9]
||      DOTP2   .M2     B_reg1,     B_reg1,     B_prod          ;[ 7,12]
||      B       .S2     B_return                                ;return

        ADD     .D2     B_sum,      B_prod,     B_sum           ;[11,9]
||      ADD     .L1     A_sum,      A_prod,     A_sum           ;[10,10]

        ADD     .D2     B_sum,      B_prod,     B_sum           ;[11,10]
||      ADD     .L1     A_sum,      A_prod,     A_sum           ;[10,11]

        ADD     .D2     B_sum,      B_prod,     B_sum           ;[11,11]
||      ADD     .L1     A_sum,      A_prod,     A_sum           ;[10,12]

        ADD     .D2     B_sum,      B_prod,     B_sum           ;[11,12]

        ADD     .L1X    A_sum,      B_sum,      A_ret_val       ;ret_value

* ========================================================================= *
*   End of file:  vecsum_sq_h. asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


w_vec.asm/      1061588610  0     0     0       12921     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.12    Fri Mar 29 21:04:54 2002 (UTC)              *;
;*      Snapshot date:  17-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_w_vec: Weighted vector sum                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSP_w_vec                                                  *
*           (                                                               *
*               const short *x,     /* Vector being weighted  */            *
*               const short *y,     /* Non-weighted vector    */            *
*               short m,            /* weighting factor       */            *
*               short *restrict r,  /* Result vector          */            *
*               int nr              /* Number of samples.     */            *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       The benchmark performs a weighted vector sum.  The elements         *
*       of the x[] vector are weighted according to the Q15 value 'm',      *
*       and then added to the corresponding elements of the y[] vector.     *
*       The results are written to the r[] vector.                          *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C code description of the algorithm.  This       *
*       implementation may have restrictions, as noted under                *
*       "ASSUMPTIONS" below.                                                *
*                                                                           *
*           void DSP_w_vec                                                  *
*           (                                                               *
*               const short *x,     /* Vector being weighted  */            *
*               const short *y,     /* Non-weighted vector    */            *
*               short m,            /* weighting factor       */            *
*               short *restrict r,  /* Result vector          */            *
*               int nr              /* Number of samples.     */            *
*           )                                                               *
*           {                                                               *
*               int i;                                                      *
*                                                                           *
*               for (i = 0; i < nr; i++)                                    *
*                   r[i] = ((m * x[i]) >> 15) + y[i];                       *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       m is not -32768.                                                    *
*       nr >= 8, nr is multiple of eight.                                   *
*       Input and output arrays must be double-word aligned.                *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*       This code is endian neutral.                                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       1.  Load double words for input data.                               *
*       2.  Use packed data processing to sustain throughput.               *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt tolerant but not interruptible.              *
*                                                                           *
*   CYCLES                                                                  *
*       3*nr/8 + 18                                                         *
*       For nr = 256, cycles = 114.                                         *
*                                                                           *
*   CODESIZE                                                                *
*       144 bytes                                                           *
*                                                                           *
*   SOURCE                                                                  *
*       DSPLIB.                                                             *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_w_vec
_DSP_w_vec:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            B3,         B_ret_addr
        .asg            A4,         A_x
        .asg            B4,         B_y
        .asg            A6,         A_m
        .asg            B6,         B_r
        .asg            A8,         A_nr
        .asg            B0,         B_p
        .asg            A1,         A_i
        .asg            B7,         B_x
        .asg            B19,        B_x76
        .asg            B18,        B_x54
        .asg            A9,         A_x32
        .asg            A8,         A_x10
        .asg            A5,         A_y
        .asg            A6,         A_w
        .asg            B17,        B_y76
        .asg            B16,        B_y54
        .asg            A17,        A_y32
        .asg            A16,        A_y10
        .asg            B19,        B_wx7
        .asg            B18,        B_wx6
        .asg            B17,        B_wx5
        .asg            B16,        B_wx4
        .asg            B9,         B_wx76
        .asg            B20,        B_wx54
        .asg            B9,         B_r76
        .asg            B8,         B_r54
        .asg            A9,         A_wx3
        .asg            A8,         A_wx2
        .asg            A17,        A_wx1
        .asg            A16,        A_wx0
        .asg            A7,         A_wx32
        .asg            A7,         A_wx10
        .asg            A21,        A_r32
        .asg            A20,        A_r10
        .asg            A3,         A_r
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        ADD     .L2X    A_x,        8,          B_x

        LDDW    .D1T1   *A_x++[2],  A_x32:A_x10                 ;[ 1,1]
||      LDDW    .D2T2   *B_x++[2],  B_x76:B_x54                 ;[ 1,1]
||      SHR     .S1     A_nr,       3,          A_i

        MVK     .L2     3,          B_p
||      PACK2   .L1     A_m,        A_m,        A_w

        BDEC    .S1     LOOP,       A_i
||      ADD     .D1X    B_y,        8,          A_y

        LDDW    .D1T1   *A_x++[2],  A_x32:A_x10                 ;[ 1,2]
||      LDDW    .D2T2   *B_x++[2],  B_x76:B_x54                 ;[ 1,2]

        ADD     .S1     B_r,        8,          A_r

; 3 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
LOOP:
  [ B_p]SUB     .L2     B_p,        1,          B_p             ; prol coll.
||      ADD2    .L1     A_wx32,     A_y32,      A_r32           ;[12,1]
||      ADD2    .S2     B_wx76,     B_y76,      B_r76           ;[12,1]
||[ A_i]BDEC    .S1     LOOP,       A_i                         ;[ 9,2]
||      LDDW    .D2T1   *B_y++[2],  A_y32:A_y10                 ;[ 6,3]
||      LDDW    .D1T2   *A_y++[2],  B_y76:B_y54                 ;[ 6,3]
||      SMPY2   .M1     A_w,        A_x10,      A_wx1:A_wx0     ;[ 6,3]
||      SMPY2   .M2X    A_w,        B_x54,      B_wx5:B_wx4     ;[ 6,3]
L2:
        PACKH2  .L1     A_wx1,      A_wx0,      A_wx10          ;[10,2]
||      PACKH2  .S2     B_wx5,      B_wx4,      B_wx54          ;[10,2]
||      SMPY2   .M1     A_w,        A_x32,      A_wx3:A_wx2     ;[ 7,3]
||      SMPY2   .M2X    A_w,        B_x76,      B_wx7:B_wx6     ;[ 7,3]
||      LDDW    .D1T1   *A_x++[2],  A_x32:A_x10                 ;[ 1,5]
||      LDDW    .D2T2   *B_x++[2],  B_x76:B_x54                 ;[ 1,5]
L3:
  [!B_p]STDW    .D2T1   A_r32:A_r10,            *B_r++[2]       ;[14,1]
||[!B_p]STDW    .D1T2   B_r76:B_r54,            *A_r++[2]       ;[14,1]
||      ADD2    .L1     A_wx10,     A_y10,      A_r10           ;[11,2]
||      PACKH2  .S1     A_wx3,      A_wx2,      A_wx32          ;[11,2]
||      ADD2    .S2     B_wx54,     B_y54,      B_r54           ;[11,2]
||      PACKH2  .L2     B_wx7,      B_wx6,      B_wx76          ;[11,2]

* =========================== PIPE LOOP EPILOG ============================ *
; 3 epilog stages collapsed

        ADD2    .L1     A_wx32,     A_y32,      A_r32           ;[12,5]
||      ADD2    .S2     B_wx76,     B_y76,      B_r76           ;[12,5]

        BNOP    .S2     B_ret_addr, 4

        STDW    .D2T1   A_r32:A_r10,            *B_r            ;[14,5]
||      STDW    .D1T2   B_r76:B_r54,            *A_r            ;[14,5]

* ========================================================================= *
*   End of file:  dsp_w_vec.asm                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

