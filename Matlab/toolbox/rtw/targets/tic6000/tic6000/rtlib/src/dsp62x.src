!<arch>
autocor.asm/    1019093835  0     0     0       17865     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.5     Fri Mar 22 00:59:57 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_autocor                                                         *
*                                                                           *
*   REVISION DATE                                                           *
*       21-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*       void DSP_autocor                                                    *
*       (                                                                   *
*           short       *restrict r,                                        *
*           const short *restrict x,                                        *
*           int          nx,                                                *
*           int          nr                                                 *
*       )                                                                   *
*                                                                           *
*       r[nr]   : Output array.                                             *
*       x[nr+nx]: Input  array.                                             *
*                 Must be word aligned.                                     *
*       nx      : Length of autocorrelation.                                *
*                 Must be multiple of 8.                                    *
*       nr      : Number of lags.                                           *
*                 Must be multiple of 2.                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine performs an autocorrelation of an input vector         *
*       x. The length of the autocorrelation is nx samples. Since nr        *
*       such autocorrelations are performed, input vector x needs to be     *
*       of length nx + nr. This produces nr output results which are        *
*       stored in an output array r.                                        *
*                                                                           *
*       The following diagram illustrates how the correlations are          *
*       obtained.                                                           *
*                                                                           *
*       Example for nr=8, nx=24:                                            *
*       0       nr                  nx+nr-1                                 *
*       |-------|----------------------|  <- x[]                            *
*       |       |----------------------|  -> r[0]                           *
*       |      |----------------------|   -> r[1]                           *
*       |     |----------------------|    -> r[2]                           *
*       |    |----------------------|     -> r[3]                           *
*       |   |----------------------|      -> r[4]                           *
*       |  |----------------------|       -> r[5]                           *
*       | |----------------------|        -> r[6]                           *
*                                                                           *
*       Note that x[0] is never used, but is required for padding to make   *
*       x[nr] word aligned.                                                 *
*                                                                           *
*     C CODE                                                                *
*       void autcor(short r[],short x[], int nx, int nr)                    *
*       {                                                                   *
*           int i,k,sum;                                                    *
*                                                                           *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               sum = 0;                                                    *
*               for (k = nr; k < nx+nr; k++)                                *
*                   sum += x[k] * x[k-i];                                   *
*               r[i] = (sum >> 15);                                         *
*            }                                                              *
*       }                                                                   *
*                                                                           *
*     TECHNIQUES                                                            *
*       The inner loop is unrolled eight times thus the length of           *
*       the input array must be a multiple of eight.  The outer             *
*       loop is unrolled twice so the length of output array must           *
*       be a multiple of 2.                                                 *
*                                                                           *
*       The outer loop is conditionally executed in parallel with the       *
*       inner loop.  This allows for a zero overhead outer loop.            *
*                                                                           *
*     ASSUMPTIONS                                                           *
*       nx must be a multiple of 8                                          *
*       nr must be a multiple of 2                                          *
*       x[] must be word aligned                                            *
*       No alignment restrictions on r[]                                    *
*                                                                           *
*     MEMORY NOTE                                                           *
*       nr/2 - 1 memory hits occur.                                         *
*       This code is a LITTLE ENDIAN implementation.                        *
*                                                                           *
*     NOTES                                                                 *
*       This code is interrupt tolerant but not interuptible.               *
*                                                                           *
*    CYCLES                                                                 *
*        nr * nx /2 + 31 + (nr/2 - 1)                                       *
*                                                                           *
*        For nx = 24, nr =  8: 130 cycles                                   *
*        For nx = 40, nr = 10: 237 cycles                                   *
*                                                                           *
*    CODESIZE                                                               *
*         544 bytes                                                         *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_autocor
_DSP_autocor:

;save current CSR & disable interrupts
       MVC     .S2     CSR, B9
||     MV      .L1x    B15,A9

       SUBAW   .D1     A9, 12, A9
||     STW     .D2     B9, *B15--[12]

       STW     .D1     A14,*+A9 [1]     ; push A14 on stack
||     STW     .D2     B14,*+B15[2]     ; push B14 on stack

       STW     .D1     A11,*+A9 [3]     ; push A11 on stack
||     STW     .D2     B11,*+B15[4]     ; push B11 on stack
||     AND     .S2     B9, -2, B9       ; DISABLE GIE bit

       STW     .D1     A12,*+A9 [5]     ; push A12 on stack
||     STW     .D2     B12,*+B15[6]     ; push B12 on stack
||     MVC     .S2     B9,  CSR         ; DISABLE Interupts

       SHL     .S1     A6,1,A14         ; for inner lp setup; nx Hwords
||     MPY     .M2X     A6,B6,B0        ; nx*M
||     STW     .D1     A13,*+A9 [7]     ; push A13 on stack
||     STW     .D2     B13,*+B15[8]     ; push B13 on stack

       ADD     .L2X    2,A4,B14         ; a[i+1] other reg file
||     ADDAH   .D2     B4,B6,B3         ; x[k] & x[k+1]
||     MV      .L1X    B3,A13           ; store return pointer
||     STW     .D1     A10,*+A9[9]      ; push A10 on stack

       MV     .L1X     B3,A3            ; x[k] & x[k+1]
||     SUB     .L2     B3,4,B4          ; x[k-i-2] & x[k-i-1]
||     SHR     .S1     A6,3,A0          ; for inner lp setup; nx/8
||     STW     .D1     A15,*+A9 [11]    ; push A15 on stack
||     STW     .D2     B10,*+B15[10]    ; push B10 on stack

       LDW     .D1     *A3++[2],A5      ; x[k] & x[k+1]
||     MV     .L1     A3,A15            ; x[k-i] & x[k-i+1]
||     MV     .S1     A0,A1             ; Set inner loop count

       LDW     .D2     *B4++[2],B5      ; x[k-i-2]& x[k-i-1]
||     LDW     .D1     *A15++[2],A6     ; x[k-i]& x[k-i+1]
||     SHL     .S2X     A6,1,B1         ; for inner lp setup; nx Hwords
||     MPY     .M1     A8,0,A8          ; initialize to zero
||     MPY     .M2     B9,0,B9          ; initialize to zero
||     MVK     .S1     1,A2             ; initialize count
||     ZERO     .L2     B2              ; initialize to zero
||     ADD     .L1     A0,-1,A0         ;

       LDW     .D2     *++B3[1],B6      ; x[k+2] & x[k+3]
||     MVK     .S1     1,A2             ; initialize priming cnt
||     MPY     .M1     A7,0,A7          ; initialize to zero
||     MPY     .M2     B11,0,B11        ; initialize to zero
||     ZERO     .D1     A5              ; initialize to zero
||     ZERO     .L2     B6              ; initialize to zero
||     SUB     .L1X     0,B10,A11       ; initialize to zero (1st cycle 1st)
||     SUB     .S2     0,B8,B12         ; initialize to zero (1st cycle 1st)

LOOP1:
       ADD     .L1X     B10,A11,A11     ; tmp_ra2 +s= p2a2
||[A2] ADD     .L2     B8,B12,B8        ; tmp_rb0 +s= p2b0
||     MPY     .M1     A5,A6,A9         ; p2a4 = x[k+4]*x[k-i+4]
||     MPYLH     .M2X     A5,B7,B8      ; p2b4 = x[k+4]*x[k-i+3]
||     LDW     .D2     *B4++[2],B7      ;*x[k-i+2]&x[k-i+3]
||[!A2]SHR     .S2     B12,15,B13       ; (0x0000ffffL & (tmp_rb >> 16)

       ADD     .L1X     B11,A11,A11     ; tmp_ra3 +s= p2a3
||     ADD     .L2X     A7,B8,B12       ; tmp_rb1 +s= p2b1
||     MPY     .M2     B6,B7,B10        ; p2a6 = x[k+6]*x[k-i+6]
||     MPYHL     .M1     A5,A6,A7       ; p2b5 = x[k+5]*x[k-i+4]
||     LDW     .D1     *A3++[2],A5      ;* x[k+4] & x[k+5]
||[!A1]ADD     .S1     A0,1,A1          ; reset inner lp cntr
||[!B2]SHR     .S2     B0,4,B0          ; nr*nx/16
||[!B2]ADDAW     .D2     B3,2,B3          ; x[k+2] & x[k+3]

       ADD     .L2X    A8,B12,B12       ; tmp_rb2 +s= p2b2
||     ADD     .L1     A9,A11,A9        ; tmp_ra4 +s= p2a4
||     MPYH    .M2     B6,B7,B11        ; p2a7 = x[k+7]*x[k-i+7]
||     MPYLH   .M1X    B6,A6,A8         ; p2b6 = x[k+6]*x[k-i+5]
||[!A2]STH     .D2     B13,*B14++[2]    ; r[0][i+1]=(tmp_rb>> 16)
||     LDW     .D1     *A15++[2],A6     ;*x[k-i+4]& x[k-i+5]
|| [B0]B       .S2     LOOP1              ; Branch inner most loop
|| [A1]ADD     .S1     -1,A1,A1         ; dec lp cntr

       ADD     .L2     B9,B12,B12       ; tmp_rb3 +s= p2b3
|| [B2]ADD     .L1     A10,A9,A11       ; tmp_ra5 +s= p2a5
||     MPYHL     .M2     B6,B7,B9       ; p2b7 = x[k+7]*x[k-i+6]
||     MPYH     .M1     A5,A6,A10       ;* p2a1 = x[k+1]*x[k-i+1]
||     LDW     .D2     *B3++[2],B6      ;* x[k+6] & x[k+7]
||[!A1]SUB     .S1     A15,A14,A15      ; reset ptr
||[!A1]SUB     .D1     A3,A14,A3        ; reset ptr

       ADD     .L1X    B10,A11,A11      ; tmp_ra6 +s= p2a6
||     ADD     .L2     B8,B12,B8        ; tmp_rb4 +s= p2b4
||     MPY     .M1     A5,A6,A9         ;* p2a0 = x[k]*x[k-i]
||     MPYLH   .M2X    A5,B5,B8         ;* p2b0 = x[k]*x[k-i-1]
||     LDW     .D2     *B4,B7           ;*x[k-i+6]&x[k-i+7]
||[!A1]SUB     .S2     B4,B1,B4         ; reset ptr
|| [B2]SUB     .S1     A1,A0,A2         ; dec lp cntr
||[!A2]STH     .D1     A12,*A4++[2]     ; r[0][i] =(tmp_ra >> 16)

       ADD     .L1X     B11,A11,A11     ; tmp_ra7 +s= p2a7
||     ADD     .L2X     A7,B8,B12       ; tmp_rb5 +s= p2b5
||     MPY     .M2     B6,B7,B10        ;* p2a2 = x[k+2]*x[k-i+2]
||     MPYHL     .M1     A5,A6,A7       ;* p2b1 = x[k+1]*x[k-i]
||     LDW     .D1     *A3++[2],A5      ;** x[k] & x[k+1]
||[!A1]SUB     .D2     B3,B1,B3         ; reset ptr
||[!A1]SUB     .S2     B4,4,B4          ; reset ptr
||[!A1]SUB     .S1     A15,4,A15        ; reset ptr

       ADD     .L2X     A8,B12,B12      ; tmp_rb6 +s= p2b6
|| [A2]ADD     .L1     A9,A11,A9        ;* tmp_ra0 +s= p2a0
||     MPYH     .M2     B6,B7,B11       ;* p2a3 = x[k+3]*x[k-i+3]
||     MPYLH     .M1X     B6,A6,A8      ;* p2b2 = x[k+2]*x[k-i+1]
||     LDW     .D2     *B4++[2],B5      ;**x[k-i-2]&x[k-i-1]
||     LDW     .D1     *A15++[2],A6     ;**x[k-i]& x[k-i+1]
||[!A2]SHR     .S1     A11,15,A12       ; (0x0000ffffL & (tmp_ra >> 16)
||[!B2]MVK     .S2     1,B2             ;

       ADD     .L2     B9,B12,B12       ; tmp_rb7 +s= p2b7
||     ADD     .L1     A10,A9,A11       ;* tmp_ra1 +s= p2a1
||     MPYHL     .M2     B6,B7,B9       ;* p2b3 = x[k+3]*x[k-i+2]
||     MPYH     .M1     A5,A6,A10       ;* p2a5 = x[k+5]*x[k-i+5]
||     LDW     .D2     *B3++[2],B6      ;** x[k+2] & x[k+3]
|| [B0]ADD     .S2     -1,B0,B0         ; dec outer lp cntr

; LOOP1 ENDS HERE

       SHR     .S2     B12,15,B13       ; (0x0000ffffL & (tmp_rb >> 16)
||     LDW     .D2     *+B15[2]  ,B14   ; pop B14 off stack

       STH     .D1     A12,*A4          ; r[0][i] =(tmp_ra >> 16)
||     STH     .D2     B13,*B14         ; r[0][i+1]=(tmp_rb>> 16)
||     MV      .L1x    B15,A4           ;

       LDW     .D1     *+A4 [1]  ,A14   ; pop A14 off stack
||     LDW     .D2     *+B15[4]  ,B11   ; pop B11 off stack
||     MV     .L2x     A13,B3           ; get return pointer

       LDW     .D1     *+A4 [3]  ,A11   ; pop A11 off stack
||     LDW     .D2     *+B15[6]  ,B12   ; pop B12 off stack

       LDW     .D1     *+A4 [5]  ,A12   ; pop A12 off stack
||     LDW     .D2     *+B15[8]  ,B13   ; pop B13 off stack

       LDW     .D1     *+A4 [7]  ,A13   ; pop A13 off stack
||     LDW     .D2     *+B15[10] ,B10   ; pop B10 off stack

       B       .S2     B3               ; Return from call
||     LDW     .D1     *+A4 [9]  ,A10   ; pop A10 off stack
||     LDW     .D2     *++B15[12],B9

       LDW     .D1     *+A4 [11] ,A15   ; pop A15 off stack

       NOP          3

       MVC             B9, CSR

* ========================================================================= *
*   End of file:  dsp_autocor.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

bexp.asm/       1019093835  0     0     0       11774     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.8     Fri Mar 29 20:22:54 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_bexp -- Block exponent of a vector                              *
*                                                                           *
*   REVISION DATE                                                           *
*       28-Jan-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           int DSP_bexp                                                    *
*           (                                                               *
*               const int *x,   /* Input Data         */                    *
*               unsigned  nx    /* Number of elements */                    *
*           );                                                              *
*                                                                           *
*       The DSP_bexp routine accepts a list of 'num' input points and       *
*       performs the determination of the block exponent.  It returns       *
*       the minimum number of "redundant sign bits" observed on the         *
*       block of data.                                                      *
*                                                                           *
*   DESCRIPTION                                                             *
*       The DSP_bexp function, performs a determination of the block        *
*       exponent of the vector of elements and returns the maximum          *
*       exponent.  This information can then be used to re-normalize        *
*       the vector.  This operation is useful when auto-scaling is          *
*       required as in a FFT.  The DSP_bexp operation returns the           *
*       minimum norm of the vector.  The minimum norm corresponds to        *
*       the maximum exponent.                                               *
*                                                                           *
*   C CODE                                                                  *
*       The following is a general C code description of the algorithm      *
*       without restrictions.  This implementation may have restrictions    *
*       as noted under 'ASSUMPTIONS' below.                                 *
*                                                                           *
*       int DSP_bexp(const int *x, short nx)                                *
*       {                                                                   *
*           int i;                                                          *
*           int mask, mag;                                                  *
*                                                                           *
*           mask = 0;                                                       *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Merge the absolute values of all the elements       */      *
*           /*  together.  The leftmost bit-change on this mask     */      *
*           /*  gives us the magnitude we desire.                   */      *
*           /* ---------------------------------------------------- */      *
*           for (i = 0; i < nx; i++)                                        *
*               mask |= x[i] ^ (x[i] >> 31);                                *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Find the magnitude of the mask.                     */      *
*           /* ---------------------------------------------------- */      *
*           for (mag = 0; (1 << mag) < mask; mag++)                         *
*               ;                                                           *
*                                                                           *
*           return 31 - mag;                                                *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx >= 6.                                                            *
*       nx % 2 == 0.                                                        *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt tolerant, but not interruptible.  It masks   *
*       interrupts for its entire duration with branch delay slots.         *
*                                                                           *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   SOURCE                                                                  *
*       DSPLIB.                                                             *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = nx + 17, including 6 cycle function call overhead.         *
*       For nx = 32, cycles = 49.                                           *
*                                                                           *
*   CODESIZE                                                                *
*       128 bytes.                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_bexp
_DSP_bexp:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x
        .asg            B4,         B_nx
        .asg            A4,         A_ret_val
        .asg            B3,         B_ret
        .asg            B7,         B_x
        .asg            A6,         A_x1
        .asg            B8,         B_x0
        .asg            A7,         A_a1
        .asg            B6,         B_a0
        .asg            A7,         A_b1
        .asg            B6,         B_b0
        .asg            A0,         A_m
        .asg            A1,         A_p
        .asg            B0,         B_m
        .asg            B2,         B_i
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *

        ADD             A_x,        4,          B_x

        B       .S1     loop
||      LDW     .D1T2   *A_x++[2],  B_x0                        ;[ 1,1]
||      LDW     .D2T1   *B_x++[2],  A_x1                        ;[ 1,1]

        SHR             B_nx,       1,          B_i

        B       .S1     loop                                    ;[ 3,1]
||      LDW     .D1T2   *A_x++[2],  B_x0                        ;[ 1,2]
||      LDW     .D2T1   *B_x++[2],  A_x1                        ;[ 1,2]
;-
        ZERO            B_m
||      ZERO            A_p:A_m
||[ B_i]SUB     .S2     B_i,        3,          B_i             ;[ 1,2]
; ===== 1 prolog stage collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        XOR     .L2     B_x0,       B_a0,       B_b0            ;[ 7,1]
||      XOR     .L1     A_x1,       A_a1,       A_b1            ;[ 7,1]
||[ B_i]B       .S1     loop                                    ;[ 3,3]
||      LDW     .D1T2   *A_x++[2],  B_x0                        ;[ 1,4]
||      LDW     .D2T1   *B_x++[2],  A_x1                        ;[ 1,4]
;-
  [ A_p]OR      .L2     B_b0,       B_m,        B_m             ;[ 8,1]
||[ A_p]OR      .L1     A_b1,       A_m,        A_m             ;[ 8,1]
||      SHR     .S2     B_x0,       31,         B_a0            ;[ 6,2]
||      SHR     .S1     A_x1,       31,         A_a1            ;[ 6,2]
||[!A_p]ADD     .D1     A_p,        1,          A_p
||[ B_i]SUB     .D2     B_i,        1,          B_i             ;[ 1,4]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 2 epilog stages collapsed
;-
        XOR     .L2     B_x0,       B_a0,       B_b0            ;[ 7,4]
||      XOR     .L1     A_x1,       A_a1,       A_b1            ;[ 7,4]
||      B               B_ret

        OR      .L2     B_b0,       B_m,        B_m             ;[ 8,4]
||      OR      .L1     A_b1,       A_m,        A_m             ;[ 8,4]

        OR      .L1X    B_m,        A_m,        A_m

        NORM    .L1     A_m,        A_ret_val

        NOP             2

* ========================================================================= *
*   End of file:  dsp_bexp.asm                                              *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
bitrev_cpl.asm/ 1019093835  0     0     0       19986     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Tue Feb 26 13:35:28 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_bitrev_cplx                                                     *
*                                                                           *
*   REVISION DATE                                                           *
*       18-Sep-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       void DSP_bitrev_cplx(int *x, short *index, int nx)                  *
*                                                                           *
*       x[nx]  : Input array to be bit-reversed.                            *
*       index[]: Array of size ~sqrt(nx) created by the routine             *
*                bitrev_index to allow the fast implementation of the       *
*                bit-reversal.                                              *
*       nx     : Number of points in array x[]. Must be power of 2.         *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine performs the bit-reversal of the input array x[].      *
*       where x[] is an array of length nx 16-bit complex pairs of data.    *
*       This requires the index array provided by the program below.  This  *
*       index should be generated at compile time not by the DSP. The code  *
*       is given below.                                                     *
*                                                                           *
*       TI retains all rights, title and interest in this code and only     *
*       authorizes the use of the bit-reversal code and related table       *
*       generation code with TMS320-family DSPs manufactured by TI.         *
*                                                                           *
*       // ----------------------------------------------------------- //   *
*       //  This routine calculates the index for bit reversal of      //   *
*       //  an array of length n.  The length of the index table is    //   *
*       //  2^(2*ceil(k/2)) where n = 2^k.                             //   *
*       //                                                             //   *
*       //  In other words, the length of the index table is:          //   *
*       //                                                             //   *
*       //                 Even power      Odd Power                   //   *
*       //                  of radix        of radix                   //   *
*       //                  sqrt(n)        sqrt(2*n)                   //   *
*       //                                                             //   *
*       // ----------------------------------------------------------- //   *
*       void bitrev_index(short *index, int n)                              *
*       {                                                                   *
*           int   i, j, k, radix = 2;                                       *
*           short nbits, nbot, ntop, ndiff, n2, raddiv2;                    *
*                                                                           *
*           nbits = 0;                                                      *
*           i = n;                                                          *
*           while (i > 1)                                                   *
*           {                                                               *
*               i = i >> 1;                                                 *
*               nbits++;                                                    *
*           }                                                               *
*                                                                           *
*           raddiv2 = radix >> 1;                                           *
*           nbot    = nbits >> raddiv2;                                     *
*           nbot    = nbot << raddiv2 - 1;                                  *
*           ndiff   = nbits & raddiv2;                                      *
*           ntop    = nbot + ndiff;                                         *
*           n2      = 1 << ntop;                                            *
*                                                                           *
*           index[0] = 0;                                                   *
*           for ( i = 1, j = n2/radix + 1; i < n2 - 1; i++)                 *
*           {                                                               *
*               index[i] = j - 1;                                           *
*                                                                           *
*               for (k = n2/radix; k*(radix-1) < j; k /= radix)             *
*                   j -= k*(radix-1);                                       *
*                                                                           *
*               j += k;                                                     *
*           }                                                               *
*           index[n2 - 1] = n2 - 1;                                         *
*       }                                                                   *
*                                                                           *
*     C CODE                                                                *
*         void bitrev(int *x, short *index, int nx)                         *
*         {                                                                 *
*             int     i;                                                    *
*             short       i0, i1, i2, i3;                                   *
*             short       j0, j1, j2, j3;                                   *
*             int     xi0, xi1, xi2, xi3;                                   *
*             int     xj0, xj1, xj2, xj3;                                   *
*             short       t;                                                *
*             int     a, b, ia, ib, ibs;                                    *
*             int     mask;                                                 *
*             int     nbits, nbot, ntop, ndiff, n2, halfn;                  *
*             short   *xs = (short *) x;                                    *
*                                                                           *
*             nbits = 0;                                                    *
*             i = nx;                                                       *
*             while (i > 1)                                                 *
*             {                                                             *
*                 i = i >> 1;                                               *
*                 nbits++;                                                  *
*             }                                                             *
*                                                                           *
*             nbot    = nbits >> 1;                                         *
*             ndiff   = nbits & 1;                                          *
*             ntop    = nbot + ndiff;                                       *
*             n2      = 1 << ntop;                                          *
*             mask    = n2 - 1;                                             *
*             halfn   = nx >> 1;                                            *
*                                                                           *
*             for (i0 = 0; i0 < halfn; i0 += 2)                             *
*             {                                                             *
*                 b   = i0 & mask;                                          *
*                 a   = i0 >> nbot;                                         *
*                 if (!b) ia  = index[a];                                   *
*                 ib  = index[b];                                           *
*                 ibs = ib << nbot;                                         *
*                                                                           *
*                 j0  = ibs + ia;                                           *
*                 t   = i0 < j0;                                            *
*                 xi0 = x[i0];                                              *
*                 xj0 = x[j0];                                              *
*                                                                           *
*                 if (t){x[i0] = xj0;                                       *
*                 x[j0] = xi0;}                                             *
*                                                                           *
*                 i1  = i0 + 1;                                             *
*                 j1  = j0 + halfn;                                         *
*                 xi1 = x[i1];                                              *
*                 xj1 = x[j1];                                              *
*                 x[i1] = xj1;                                              *
*                 x[j1] = xi1;                                              *
*                                                                           *
*                 i3  = i1 + halfn;                                         *
*                 j3  = j1 + 1;                                             *
*                 xi3 = x[i3];                                              *
*                 xj3 = x[j3];                                              *
*                 if (t){x[i3] = xj3;                                       *
*                 x[j3] = xi3;}                                             *
*             }                                                             *
*         }                                                                 *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx must be a power of 2.                                            *
*       The table from bitrev_index is already created.                     *
*       LITTLE ENDIAN configuration used.                                   *
*                                                                           *
*   NOTES                                                                   *
*       If N <= 4K one can use the char (8-bit) data type for               *
*       the "index" variable. This would require changing the LDH when      *
*       loading index values in the assembly routine to LDB. This would     *
*       further reduce the size of the Index Table by half its size.        *
*                                                                           *
*       This code is interrupt tolerant, but not interruptible.             *
*                                                                           *
*   CYCLES                                                                  *
*       (N/4 + 2) * 7 + 18                                                  *
*                                                                           *
*       e.g. N = 256, cycles = 480                                          *
*                                                                           *
*   CODESIZE                                                                *
*       352 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .text
        .global _DSP_bitrev_cplx
_DSP_bitrev_cplx:

;-
                LMBD.L1     1,  A6, A1      ; leftzeros = lmbd(1, nx)
    ||          MVK .S2     31, B0          ; constant 31
    ||          STW .D2     A15,*B15--[8]   ; push A15
    ||          MV  .S1X    B15,A15         ; copy stack pointer

                SUB .L1X    B0, A1, A8      ; nbits = 31 - leftzeros
    ||          SHR .S2X    A6, 1,  B6      ; halfn = nx >> 1
    ||          STW .D1     A10,*-A15[1]    ; push A10  B15[7]
    ||          STW .D2     B10,*+B15[6]    ; push B10  B15[6]
;-
                SHR .S1     A8, 1,  A0      ; nbot = nbits >> 1
    ||          AND .L1     A8, 1,  A11     ; ndiff = nbits & 1
    ||          SHR .S2     B6, 1,  B5      ; loop nx/4 +2 times
    ||          STW .D1     A11,*-A15[3]    ; push A11  B15[5]
    ||          STW .D2     B11,*+B15[4]    ; push B11  B15[4]
    ||          MV  .L2X    A4, B8          ; copy x
    ||          MPY .M2     B0, 0, B0
    ||          MPY .M1     A3, 0, A3       ; i0 = 0
;-
                ADD .D1     A0, A11,A11     ; ntop = nbot + ndiff
    ||          MVK .S1     1,  A2,         ; constant 1
    ||          ADD .L2     2,  B5, B2      ; loop nx/4 +2
    ||          MVK .S2     1,  B1          ; setup priming count
    ||          MV  .L1X    B4, A5          ; copy index

                SHL .S1     A2, A11,A1      ; n2 = 1 << ntop
    ||          STW .D1     A12,*-A15[5]    ; push A12  B15[3]
    ||          STW .D2     B12,*+B15[2]    ; push B12  B15[2]
;-
                SUB .L2X    A1, 1,  B13     ; mask = n2 - 1
    ||          ZERO.L1     A1              ; prevent stores on first iter
    ||          STW .D2     B13,*+B15[1]    ; push B13  B15[1]
    ||          ZERO.S1     A10             ; zero A10

                ZERO        A11
    ||          B   .S2     NO_INT_1

                LDH .D2     *B4[0],B0       ;** ib = index[b]
    ||          ADD .L2X    A3, 1,  B5      ;** i1 = i0 + 1
;-
                ADD         B5, B6, B7      ;** i3 = i1 + halfn

                LDW .D2     *B8[B7],B9      ;** xi3 = x[i3]
    ||          ZERO.D1     A12             ; zero A12
LOOP:
        [A1]    STW .D2     B9, *B8[B0]     ; if (t) x[j3] = xi3
    ||  [B2]    SUB         B2, 1,  B2      ; decrement loop counter
    ||          MPY .M1     A1, 1,  A2      ; copy t
    ||          LDW .D1     *A4[A3],A11     ;* xi0 = x[i0]
;-
        [A1]    STW .D1     A11,*A4[A10]    ; if (t) x[j0] = xi0
    ||  [B2]    B   .S2     LOOP            ; for loop
    ||          SHL .S1X    B0, A0, A10     ;* ibs = ib << nbot
    ||          ADD         A3, 2,  A3      ;* ai0 += 2
    ||          MPY .M2     B5, 1,  B10     ;* copy ai1
    ||          LDW .D2     *B8[B5],B11     ;* xi1 = x[i1]
    ||          MPY .M1     A3, 1,  A9      ;* copy ai0
;-
NO_INT_1:
        [!B1]   STW .D2     A11,*B8[B10]    ; x[i1] = xj1
    ||  [!B1]   STW .D1     B11,*A4[A6]     ; x[j1] = xi1
    ||          ADD         A10,A12,A10     ;* j0 = ibs + ia
    ||          SHR .S1     A3, A0, A11     ;** a = i0 >> nbot
    ||          AND .L2X    A3,B13, B0      ;** b = i0 & mask
;-
                ADD .L1X    A10,B6, A6      ;* j1 = j0 + halfn
    ||          MPY .M2     B7, 1,  B12     ;* copy ai3
    ||  [B1]    SUB .S2     B1, 1,  B1      ; decrement priming counter
    ||          LDH .D2     *B4[B0],B0      ;** ib = index[b]
    ||          ADD .L2X    A3, 1,  B5      ;** i1 = i1 + 1
    ||  [!B0]   LDH .D1     *A5[A11],A12    ;** if (!b) ia = index[a]
    ||  [B2]    B   .S1     NO_INT_1
;-
        [A1]    STW .D2     B0, *B8[B12]    ; if (t) x[i3] = xj3
    ||          ADD .L2X    A6, 1,  B0      ;* j3 = j0 + 1
    ||  [!B1]   CMPLT.L1    A9, A10,A1      ;* t = i0 < j0
    ||          LDW .D1     *A4[A6],A11     ;* xj1 = x[j1]
    ||  [B1]    MPY .M1     A4, 0,  A1      ; prime conditional store
    ||          ADD         B5, B6, B7      ;** i3 = i1 + halfn

                LDW .D1     *A4[A10],A7     ;* xj0 = x[j0]
    ||          LDW .D2     *B8[B7],B9      ;** xi3 = x[i3]
;-
        [A2]    STW .D1     A7, *A4[A8]     ; if (t) x[i0] = xj0
    ||          LDW .D2     *B8[B0],B0      ;* xj3 = x[j3]
    ||          MPY .M1     A9, 1,  A8      ;* copy ai0 again
END_LOOP:
                LDW .D1     *-A15[1],A10    ; pop A10  B15[7]
    ||          LDW .D2     *+B15[6],B10    ; pop B10  B15[6]

                LDW .D1     *-A15[3],A11    ; pop A11  B15[5]
    ||          LDW .D2     *+B15[4],B11    ; pop B11  B15[4]
;-
                LDW .D1     *-A15[5],A12    ; pop A12  B15[3]
    ||          LDW .D2     *+B15[2],B12    ; pop B12  B15[2]
    ||          B   .S2     B3              ; return

                LDW .D1     *-A15[7],B13    ; pop B13  B15[1]
    ||          LDW .D2     *++B15[8],A15   ; pop A15

                NOP 4
;-
* ========================================================================= *
*   End of file:  dsp_bitrev_cplx.asm                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
blk_eswap0.asm/ 1019093836  0     0     0       11661     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.3     Mon Mar 25 11:02:44 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_blk_eswap16 -- Endian-swap a block of 16-bit values             *
*                                                                           *
*   REVISION DATE                                                           *
*       25-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           void DSP_blk_eswap16                                            *
*           (                                                               *
*               void *restrict src,     /* Source data                 */   *
*               void *restrict dst,     /* Destination array           */   *
*               int  n_hwords           /* Number of halfwords to swap */   *
*           );                                                              *
*                                                                           *
*       This function performs an endian-swap on the data in the "src"      *
*       array, writing the results to "dst".  If NULL is passed in for      *
*       the destination, then the endian-swap is performed in-place.        *
*       The "n_hwords" argument gives the total length of the array in      *
*       half-words.                                                         *
*                                                                           *
*   DESCRIPTION                                                             *
*       The data in the "src" array is endian swapped, meaning that the     *
*       byte-order of the bytes within each word of the src[] array is      *
*       reversed.  This is meant to facilitate moving big-endian data       *
*       to a little-endian system or vice-versa.                            *
*                                                                           *
*       When the "dst" pointer is non-NULL, the endian-swap occurs          *
*       out-of-place, similar to a block move.  When the "dst" pointer      *
*       is NULL, the endian-swap occurs in-place, allowing the swap to      *
*       occur without using any additional storage.                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays do not overlap, except in the very          *
*       specific case that "dst == NULL" so that the operation occurs       *
*       in-place.                                                           *
*                                                                           *
*       The input array and output array are expected to be word            *
*       aligned, and a multiple of 8 half-words must be processed.          *
*                                                                           *
*   NOTES                                                                   *
*       This function locks out interrupts for its entire duration.         *
*       It is interrupt tolerant, but not interruptible.                    *
*                                                                           *
*   CODESIZE                                                                *
*       256 bytes                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 19 + 0.375 * n_hwords.                                     *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_blk_eswap16
_DSP_blk_eswap16:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A1,         A_x
        .asg            A4,         A_src
        .asg            A5,         A_dst
        .asg            A6,         A_nx
        .asg            A6,         A0_b
        .asg            A6,         A0_d
        .asg            A6,         A0_f
        .asg            A6,         A1_d
        .asg            A6,         A1_f
        .asg            A7,         A0_c
        .asg            A7,         A0_e
        .asg            A7,         A1_b
        .asg            A7,         A1_e
        .asg            A8,         A0_a
        .asg            A8,         A1_a
        .asg            A8,         A1_c
        .asg            B2,         B0_d
        .asg            B3,         B_ret_addr
        .asg            B4,         B_dst
        .asg            B5,         B0_a
        .asg            B5,         B0_c
        .asg            B5,         B0_e
        .asg            B5,         B1_d
        .asg            B6,         B_src
        .asg            B7,         B0_b
        .asg            B7,         B0_f
        .asg            B7,         B1_a
        .asg            B7,         B1_c
        .asg            B8,         B1_b
        .asg            B8,         B1_e
        .asg            B8,         B1_f
        .asg            B9,         B_msk
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        B               loop                  ; block interrupts
||      SHR             A_nx,   3,      A_x
||      ADD             A_src,  4,      B_src
||      MV              B_dst,  B0

        LDW     .D2T1   *B_src[2],      A0_a  ;[ 1,1]
||      LDW     .D1T2   *A_src[2],      B0_a  ;[ 1,1]
||[!B0] MV              A_src,  B_dst
||      MVKL            0xFF00FF00,     B_msk
;-
        ADD             B_dst,  4,      A_dst
||      MVKH            0xFF00FF00,     B_msk

        LDW     .D2T1   *B_src++[4],    A1_a  ;[ 3,1]
||      LDW     .D1T2   *A_src++[4],    B1_a  ;[ 3,1]

        SUB             A_x,    1,      A_x

  [ A_x]B               loop
||      MVK             1,      B0            ; prolog collapse
; ===== 1 prolog stage collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        ADD     .L1     A1_d,   A1_e,   A1_f  ;[11,1] f = d | e
||      SHL     .S1     A0_a,   8,      A0_c  ;[ 6,2] c =  a << 8
||      SHL     .S2     B0_a,   8,      B0_c  ;[ 6,2] c =  a << 8
||      AND     .L2     B0_a,   B_msk,  B0_b  ;[ 6,2] b =  a & 0xFF00FF00
||      LDW     .D2T1   *B_src[2],      A0_a  ;[ 1,3]
||      LDW     .D1T2   *A_src[2],      B0_a  ;[ 1,3]

  [!B0] STW     .D1T1   A1_f,   *A_dst++[4]   ;[12,1]
||[!B0] STW     .D2T2   B1_f,   *B_dst++[4]   ;[12,1]
||[ A_x]SUB     .S1     A_x,    1,      A_x   ;[ 7,2]
||      AND     .L1X    A0_a,   B_msk,  A0_b  ;[ 7,2] b =  a & 0xFF00FF00
||      AND     .L2     B0_c,   B_msk,  B0_e  ;[ 7,2] e = (a << 8)&0xFF00FF00
||      SHRU    .S2     B0_b,   8,      B0_d  ;[ 7,2] d = (a & 0xFF00FF00)>>8

        SHL     .S2     B1_a,   8,      B1_c  ;[ 8,2] c =  a << 8
||      AND     .L2     B1_a,   B_msk,  B1_b  ;[ 8,2] b =  a & 0xFF00FF00
||      AND     .L1X    A0_c,   B_msk,  A0_e  ;[ 8,2] e = (a << 8)&0xFF00FF00
||      SHRU    .S1     A0_b,   8,      A0_d  ;[ 8,2] d = (a & 0xFF00FF00)>>8
||      LDW     .D2T1   *B_src++[4],    A1_a  ;[ 3,3]
||      LDW     .D1T2   *A_src++[4],    B1_a  ;[ 3,3]

        SHL     .S1     A1_a,   8,      A1_c  ;[ 9,2] c =  a << 8
||      AND     .L1X    A1_a,   B_msk,  A1_b  ;[ 9,2] b =  a & 0xFF00FF00
||      AND     .L2     B1_c,   B_msk,  B1_e  ;[ 9,2] e = (a << 8)&0xFF00FF00
||      SHRU    .S2     B1_b,   8,      B1_d  ;[ 9,2] d = (a & 0xFF00FF00)>>8
||      ADD     .D1     A0_d,   A0_e,   A0_f  ;[ 9,2] f = d | e
||      ADD     .D2     B0_d,   B0_e,   B0_f  ;[ 9,2] f = d | e

  [ A_x]B       .S2     loop                  ;[10,2]
||      AND     .L1X    A1_c,   B_msk,  A1_e  ;[10,2] e = (a << 8)&0xFF00FF00
||      SHRU    .S1     A1_b,   8,      A1_d  ;[10,2] d = (a & 0xFF00FF00)>>8
||      ADD     .L2     B1_d,   B1_e,   B1_f  ;[10,2] f = d | e
||      STW     .D1T1   A0_f,   *A_dst[2]     ;[10,2]
||      STW     .D2T2   B0_f,   *B_dst[2]     ;[10,2]
||      MPY             B0,     0,      B0    ; prolog collapse

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 1 epilog stage collapsed
        ADD     .L1     A1_d,   A1_e,   A1_f  ;[11,3] f = d | e
||      B               B_ret_addr            ; return to caller

        STW     .D1T1   A1_f,   *A_dst        ;[12,3]
||      STW     .D2T2   B1_f,   *B_dst        ;[12,3]

        NOP             4
* ========================================================================= *
*   End of file:  dsp_blk_eswap16.asm                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

blk_eswap1.asm/ 1019093836  0     0     0       11529     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Sat Mar  9 05:04:15 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_blk_eswap32 -- Endian-swap a block of 32-bit values             *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           void DSP_blk_eswap32                                            *
*           (                                                               *
*               void *restrict src,     /* Source data             */       *
*               void *restrict dst,     /* Destination array       */       *
*               int  n_words            /* Number of words to swap */       *
*           );                                                              *
*                                                                           *
*       This function performs an endian-swap on the data in the "src"      *
*       array, writing the results to "dst".  If NULL is passed in for      *
*       the destination, then the endian-swap is performed in-place.        *
*       The "n_words" argument gives the total length of the array.         *
*                                                                           *
*   DESCRIPTION                                                             *
*       The data in the "src" array is endian swapped, meaning that the     *
*       byte-order of the bytes within each word of the src[] array is      *
*       reversed.  This is meant to facilitate moving big-endian data       *
*       to a little-endian system or vice-versa.                            *
*                                                                           *
*       When the "dst" pointer is non-NULL, the endian-swap occurs          *
*       out-of-place, similar to a block move.  When the "dst" pointer      *
*       is NULL, the endian-swap occurs in-place, allowing the swap to      *
*       occur without using any additional storage.                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays do not overlap, except in the very          *
*       specific case that "dst == NULL" so that the operation occurs       *
*       in-place.                                                           *
*                                                                           *
*       The input array and output array are expected to be word            *
*       aligned, and a multiple of 2 words must be processed.               *
*                                                                           *
*       The input array must be at least 4 words long.                      *
*                                                                           *
*   NOTES                                                                   *
*       This function locks out interrupts for its entire duration.         *
*       It is interrupt tolerant, but not interruptible.                    *
*                                                                           *
*   CODESIZE                                                                *
*       224 bytes                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 20 + 1.5 * n_words                                         *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_blk_eswap32
_DSP_blk_eswap32:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,     A_src
        .asg            B5,     B_src
        .asg            B4,     B_dst
        .asg            A5,     A_dst
        .asg            A6,     A_nx
        .asg            A1,     A_x
        .asg            B0,     B_a
        .asg            A0,     A_a
        .asg            B9,     B_msk
        .asg            B0,     B_b
        .asg            B2,     B_c
        .asg            B0,     B_d
        .asg            B2,     B_e
        .asg            B7,     B_f
        .asg            A9,     A_k
        .asg            B8,     B_g
        .asg            B6,     B_h
        .asg            B6,     B_i
        .asg            A6,     A_b
        .asg            A0,     A_c
        .asg            A8,     A_d
        .asg            A2,     A_e
        .asg            A6,     A_f
        .asg            A7,     A_g
        .asg            A3,     A_h
        .asg            A7,     A_i
        .asg            B3,     B_ret_addr
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        ADD             A_src,  4,      B_src
||      SHR             A_nx,   1,      A_x

        LDW     .D1T2   *A_src++[2],    B_a     ;[ 1,1]
||      LDW     .D2T1   *B_src++[2],    A_a     ;[ 1,1]
||      MV      .L2     B_dst,  B2

        B       .S1     loop
||      MVK     .S2     0x4000, B1              ; prolog collapse
||[!B2] SUB     .L2     B_src,  12,     B_dst
;-
        MVKL    .S2     0xFF00FF00,     B_msk
||      MVKL    .S1     0x00018000,     A_k
||      SUB     .L1     A_x,    1,      A_x

        LDW     .D1T2   *A_src++[2],    B_a     ;[ 1,1]
||      LDW     .D2T1   *B_src++[2],    A_a     ;[ 1,1]
||      MVKH    .S2     0xFF00FF00,     B_msk
||      MVKH    .S1     0x00018000,     A_k
||      ADD     .L1X    B_dst,  4,      A_dst
;-
; ===== 3 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        ADDAH   .D2     B_g,    B_h,    B_i     ;[14,1] i = (f << 16)|(f >> 16)
||      ADDAH   .D1     A_g,    A_h,    A_i     ;[14,1] i = (f << 16)|(f >> 16)
||      MPYHU   .M1     A_f,    A_k,    A_g     ;[11,2] g = f >> 16
||[A_x] B       .S2     loop                    ;[11,2]
||      MPYU    .M2X    B_f,    A_k,    B_h     ;[11,2] h = f << 15
||      AND     .S1X    A_c,    B_msk,  A_e     ;[ 8,3] e = (a << 8)&0xFF00FF00
||      ADD     .L2     B_d,    B_e,    B_f     ;[ 8,3] f = d | e
||[A_x] SUB     .L1     A_x,    1,      A_x     ;[ 8,3]

  [!B1] STW     .D2T2   B_i,    *B_dst++[2]     ;[15,1]
||[!B1] STW     .D1T1   A_i,    *A_dst++[2]     ;[15,1]
||      MPYU    .M1     A_f,    A_k,    A_h     ;[12,2] h = f << 15
||      AND     .L1X    A_a,    B_msk,  A_b     ;[ 6,4] b =  a & 0xFF00FF00
||      SHL     .S1     A_a,    8,      A_c     ;[ 6,4] c =  a << 8
||      AND     .L2     B_a,    B_msk,  B_b     ;[ 6,4] b =  a & 0xFF00FF00
||      SHL     .S2     B_a,    8,      B_c     ;[ 6,4] c =  a << 8
||[ B1] MPY     .M2     B1,     2,      B1      ; prolog collapse

        ADD     .L1     A_d,    A_e,    A_f     ;[10,3] f = d | e
||      MPYHU   .M2X    B_f,    A_k,    B_g     ;[10,3] g = f >> 16
||      SHRU    .S1     A_b,    8,      A_d     ;[ 7,4] d = (a & 0xFF00FF00)>>8
||      SHRU    .S2     B_b,    8,      B_d     ;[ 7,4] d = (a & 0xFF00FF00)>>8
||      AND     .L2     B_c,    B_msk,  B_e     ;[ 7,4] e = (a << 8)&0xFF00FF00
||      LDW     .D1T2   *A_src++[2],    B_a     ;[ 1,6]
||      LDW     .D2T1   *B_src++[2],    A_a     ;[ 1,6]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 3 epilog stages collapsed
        ADDAH   .D2     B_g,    B_h,    B_i     ;[14,5] i = (f << 16)|(f >> 16)
||      ADDAH   .D1     A_g,    A_h,    A_i     ;[14,5] i = (f << 16)|(f >> 16)
||      MPYHU   .M1     A_f,    A_k,    A_g     ;[11,6] g = f >> 16
||      MPYU    .M2X    B_f,    A_k,    B_h     ;[11,6] h = f << 15
||      B       .S2     B_ret_addr

  [!B1] STW     .D2T2   B_i,    *B_dst++[2]     ;[15,5]
||[!B1] STW     .D1T1   A_i,    *A_dst++[2]     ;[15,5]
||      MPYU    .M1     A_f,    A_k,    A_h     ;[12,6] h = f << 15
;-
        NOP             2

        ADDAH   .D2     B_g,    B_h,    B_i     ;[14,6] i = (f << 16)|(f >> 16)
||      ADDAH   .D1     A_g,    A_h,    A_i     ;[14,6] i = (f << 16)|(f >> 16)

        STW     .D2T2   B_i,    *B_dst          ;[15,6]
||      STW     .D1T1   A_i,    *A_dst          ;[15,6]
;-
* ========================================================================= *
*   End of file:  dsp_blk_eswap32.asm                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

blk_eswap2.asm/ 1019093836  0     0     0       11600     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.5     Mon Mar 11 21:56:18 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_blk_eswap64 -- Endian-swap a block of 64-bit values             *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Aug-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine has the following C prototype:                         *
*                                                                           *
*           void DSP_blk_eswap64                                            *
*           (                                                               *
*               void *restrict src, /* Source data                    */    *
*               void *restrict dst, /* Destination array              */    *
*               int  n_dbls         /* Number of double-words to swap */    *
*           );                                                              *
*                                                                           *
*       This function performs an endian-swap on the data in the "src"      *
*       array, writing the results to "dst".  If NULL is passed in for      *
*       the destination, then the endian-swap is performed in-place.        *
*       The "n_dbls" argument gives the total length of the array in        *
*       double-words.                                                       *
*                                                                           *
*   DESCRIPTION                                                             *
*       The data in the "src" array is endian swapped, meaning that the     *
*       byte-order of the bytes within each double-word of the src[]        *
*       array is reversed.  This is meant to facilitate moving big-endian   *
*       data to a little-endian system or vice-versa.                       *
*                                                                           *
*       When the "dst" pointer is non-NULL, the endian-swap occurs          *
*       out-of-place, similar to a block move.  When the "dst" pointer      *
*       is NULL, the endian-swap occurs in-place, allowing the swap to      *
*       occur without using any additional storage.                         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Input and output arrays do not overlap, except in the very          *
*       specific case that "dst == NULL" so that the operation occurs       *
*       in-place.                                                           *
*                                                                           *
*       The input array and output array are expected to be double-word     *
*       aligned, and a multiple of 2 double-words long.                     *
*                                                                           *
*       The input array must be at least 2 double-words long.               *
*                                                                           *
*   NOTES                                                                   *
*       This function locks out interrupts for its entire duration.         *
*       It is interrupt tolerant, but not interruptible.                    *
*                                                                           *
*   CODESIZE                                                                *
*       224 bytes                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 20 + 3 * n_dbls                                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_blk_eswap64
_DSP_blk_eswap64:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,     A_src
        .asg            B5,     B_src
        .asg            B4,     B_dst
        .asg            A5,     A_dst
        .asg            A6,     A_nx
        .asg            A1,     A_x
        .asg            B0,     B_a
        .asg            A0,     A_a
        .asg            B9,     B_msk
        .asg            B0,     B_b
        .asg            B2,     B_c
        .asg            B0,     B_d
        .asg            B2,     B_e
        .asg            B7,     B_f
        .asg            A9,     A_k
        .asg            B8,     B_g
        .asg            B6,     B_h
        .asg            B6,     B_i
        .asg            A6,     A_b
        .asg            A0,     A_c
        .asg            A8,     A_d
        .asg            A2,     A_e
        .asg            A6,     A_f
        .asg            A7,     A_g
        .asg            A3,     A_h
        .asg            A7,     A_i
        .asg            B3,     B_ret_addr
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        ADD             A_src,  4,      B_src
||      MV              A_nx,   A_x

        LDW     .D1T2   *A_src++[2],    B_a     ;[ 1,1]
||      LDW     .D2T1   *B_src++[2],    A_a     ;[ 1,1]
||      MV      .L2     B_dst,  B2

        B       .S1     loop
||      MVK     .S2     0x4000, B1              ; prolog collapse
||[!B2] SUB     .L2     B_src,  12,     B_dst
;-
        MVKL    .S2     0xFF00FF00,     B_msk
||      MVKL    .S1     0x00018000,     A_k
||      SUB     .L1     A_x,    1,      A_x

        LDW     .D1T2   *A_src++[2],    B_a     ;[ 1,1]
||      LDW     .D2T1   *B_src++[2],    A_a     ;[ 1,1]
||      MVKH    .S2     0xFF00FF00,     B_msk
||      MVKH    .S1     0x00018000,     A_k
||      ADD     .L1X    B_dst,  4,      A_dst
;-
; ===== 3 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        ADDAH   .D2     B_g,    B_h,    B_i     ;[14,1] i = (f << 16)|(f >> 16)
||      ADDAH   .D1     A_g,    A_h,    A_i     ;[14,1] i = (f << 16)|(f >> 16)
||      MPYHU   .M1     A_f,    A_k,    A_g     ;[11,2] g = f >> 16
||[A_x] B       .S2     loop                    ;[11,2]
||      MPYU    .M2X    B_f,    A_k,    B_h     ;[11,2] h = f << 15
||      AND     .S1X    A_c,    B_msk,  A_e     ;[ 8,3] e = (a << 8)&0xFF00FF00
||      ADD     .L2     B_d,    B_e,    B_f     ;[ 8,3] f = d | e
||[A_x] SUB     .L1     A_x,    1,      A_x     ;[ 8,3]

  [!B1] STW     .D1T2   B_i,    *A_dst++[2]     ;[15,1]
||[!B1] STW     .D2T1   A_i,    *B_dst++[2]     ;[15,1]
||      MPYU    .M1     A_f,    A_k,    A_h     ;[12,2] h = f << 15
||      AND     .L1X    A_a,    B_msk,  A_b     ;[ 6,4] b =  a & 0xFF00FF00
||      SHL     .S1     A_a,    8,      A_c     ;[ 6,4] c =  a << 8
||      AND     .L2     B_a,    B_msk,  B_b     ;[ 6,4] b =  a & 0xFF00FF00
||      SHL     .S2     B_a,    8,      B_c     ;[ 6,4] c =  a << 8
||[ B1] MPY     .M2     B1,     2,      B1      ; prolog collapse

        ADD     .L1     A_d,    A_e,    A_f     ;[10,3] f = d | e
||      MPYHU   .M2X    B_f,    A_k,    B_g     ;[10,3] g = f >> 16
||      SHRU    .S1     A_b,    8,      A_d     ;[ 7,4] d = (a & 0xFF00FF00)>>8
||      SHRU    .S2     B_b,    8,      B_d     ;[ 7,4] d = (a & 0xFF00FF00)>>8
||      AND     .L2     B_c,    B_msk,  B_e     ;[ 7,4] e = (a << 8)&0xFF00FF00
||      LDW     .D1T2   *A_src++[2],    B_a     ;[ 1,6]
||      LDW     .D2T1   *B_src++[2],    A_a     ;[ 1,6]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 3 epilog stages collapsed
        ADDAH   .D2     B_g,    B_h,    B_i     ;[14,5] i = (f << 16)|(f >> 16)
||      ADDAH   .D1     A_g,    A_h,    A_i     ;[14,5] i = (f << 16)|(f >> 16)
||      MPYHU   .M1     A_f,    A_k,    A_g     ;[11,6] g = f >> 16
||      MPYU    .M2X    B_f,    A_k,    B_h     ;[11,6] h = f << 15
||      B       .S2     B_ret_addr

  [!B1] STW     .D1T2   B_i,    *A_dst++[2]     ;[15,5]
||[!B1] STW     .D2T1   A_i,    *B_dst++[2]     ;[15,5]
||      MPYU    .M1     A_f,    A_k,    A_h     ;[12,6] h = f << 15
;-
        NOP             2

        ADDAH   .D2     B_g,    B_h,    B_i     ;[14,6] i = (f << 16)|(f >> 16)
||      ADDAH   .D1     A_g,    A_h,    A_i     ;[14,6] i = (f << 16)|(f >> 16)

        STW     .D1T2   B_i,    *A_dst          ;[15,6]
||      STW     .D2T1   A_i,    *B_dst          ;[15,6]
;-
* ========================================================================= *
*   End of file:  dsp_blk_eswap64.asm                                       *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
blk_move.asm/   1019093836  0     0     0       10119     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.7     Fri Mar 22 02:00:23 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   NAME                                                                    *
*       DSP_blk_move -- Move a block of memory.  Endian Neutral             *
*                                                                           *
*   REVISION DATE                                                           *
*       11-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_blk_move(const short *restrict x,                          *
*                     short *restrict r, int nx);                           *
*                                                                           *
*           x  --- block of data to be moved                                *
*           r  --- destination of block of data                             *
*           nx --- number of elements in block                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       Move nx 16-bit elements from one memory location                    *
*       to another.                                                         *
*                                                                           *
*       void DSP_blk_move(const short *restrict x,                          *
*                     short *restrict r, int nx)                            *
*       {                                                                   *
*           int i;                                                          *
*           for (i = 0 ; i < nx; i++)                                       *
*               r[i] = x[i];                                                *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx greater than or equal to 4                                       *
*       nx a multiple of 2                                                  *
*       Source and destination arrays are word aligned.                     *
*       Source and destination arrays do not overlap.                       *
*                                                                           *
*   TECHNIQUES                                                              *
*       Twin input and output pointers are used.                            *
*       Unrolled 4 times to use parallel LDWs and STWs.                     *
*       Peeled off half-iteration to allow mult. of 2 instead mult. of 4.   *
*       Return branch issued from loop kernel to save cycles.               *
*                                                                           *
*   NOTES                                                                   *
*       This function is interrupt tolerant, but not interruptible.         *
*       It locks out interrupts for its entire duration.                    *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur in this code.                               *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = MAX(2 * (nx >> 2) + 15, 21)                                *
*       For nx <= 14,  cycles == 21.                                        *
*       For nx == 16,  cycles == 23.                                        *
*       For nx == 100, cycles == 65.                                        *
*                                                                           *
*   CODESIZE                                                                *
*       128 bytes.                                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_blk_move
_DSP_blk_move:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x         ; Source
        .asg            B4,         B_r         ; Destination
        .asg            A6,         A_nx        ; Element count
        .asg            B5,         B_x         ; Twin source pointer
        .asg            A5,         A_r         ; Twin destination pointer
        .asg            B7,         B_in32      ; \__ Set of four inputs
        .asg            A7,         A_in10      ; /
        .asg            A1,         A_i         ; Loop counter
        .asg            A2,         A_o         ; "Odd word" flag
        .asg            B0,         B_e         ; "In Epilog" flag
        .asg            B1,         B_l         ; "Leave kernel" flag
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        ADD     .L2X    A_x,        4,          B_x
||      ADD     .L1X    B_r,        4,          A_r
||      SHR     .S1     A_nx,       2,          A_i

        LDW     .D1T1   *A_x++[2],  A_in10                      ;[ 1,1]
||      LDW     .D2T2   *B_x++[2],  B_in32                      ;[ 1,1]
||[ A_i]SUB     .L1     A_i,        1,          A_i             ;[ 1,3]
||      ZERO    .L2     B_l:B_e
||      AND     .S1     A_nx,       3,          A_o
;-
  [ A_i]B       .S1     DSP_blk_move                            ;[ 2,1]

        LDW     .D1T1   *A_x++[2],  A_in10                      ;[ 1,2]
||      LDW     .D2T2   *B_x++[2],  B_in32                      ;[ 1,2]
||[ A_i]SUB     .L1     A_i,        1,          A_i             ;[ 1,3]

  [ A_i]B       .S1     DSP_blk_move                            ;[ 2,2]

        LDW     .D1T1   *A_x++[2],  A_in10                      ;[ 1,3]
||      LDW     .D2T2   *B_x++[2],  B_in32                      ;[ 1,3]
||[ A_i]SUB     .L1     A_i,        1,          A_i             ;[ 1,3]
;-
* =========================== PIPE LOOP KERNEL ============================ *
DSP_blk_move:
        STW     .D2T1   A_in10,     *B_r++[2]                   ;[ 6,1]
||      STW     .D1T2   B_in32,     *A_r++[2]                   ;[ 6,1]
||[ A_i]B       .S1     DSP_blk_move                            ;[ 2,3]
||[ A_i]SUB     .L1     A_i,        1,          A_i             ;[ 0,4]
||[!A_i]XOR     .L2     B_e,        1,          B_l
;-
  [ B_l]B       .S2     B3
||[ B_l]OR      .L2     B_e,        1,          B_e
||[!B_e]LDW     .D1T1   *A_x++[2],  A_in10                      ;[ 1,4]
||[!B_e]LDW     .D2T2   *B_x++[2],  B_in32                      ;[ 1,4]

* ========================================================================= *
; ===== Epilog removed completely
  [ A_o]STW     .D2T1   A_in10,     *B_r                        ;[ 6,2]
||      NOP             5                ; maybe wait for branch
; ===== Return branch occurs here.


* ========================================================================= *
*   End of file:  dsp_blk_move.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

dotp_sqr.asm/   1019093836  0     0     0       12248     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Fri Mar 29 20:07:39 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*    TEXAS INSTRUMENTS, INC.                                                *
*                                                                           *
*   NAME                                                                    *
*       DSP_dotp_sqr                                                        *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and can be called as:                   *
*                                                                           *
*       int DSP_dotp_sqr                                                    *
*       (                                                                   *
*           int G,            /* Sum-of-y-squared initial value */          *
*           const short  *x,  /* First input array.             */          *
*           const short  *y,  /* Second input array.            */          *
*           int *restrict r,  /* Accumulation of x[] * y[].     */          *
*           int nx            /* Length of the input vector.    */          *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine computes the dot product of x[] and y[] arrays,        *
*       adding it to the value in the location pointed to by 'r'.           *
*                                                                           *
*       Additionally, it computes the sum of the squares of the terms       *
*       in the y[] array, adding it to the argument G.  The final value     *
*       of G is given as the return value of the function.  This value      *
*       is used by the VSELP vocoder.                                       *
*                                                                           *
*       The following C code is an implementation of the algorithm          *
*       without restrictions.  Optimized implementations may add            *
*       restrictions as noted under the heading "ASSUMPTIONS."              *
*                                                                           *
*       int DSP_dotp_sqr                                                    *
*       (                                                                   *
*           int G,            /* Sum-of-y-squared initial value */          *
*           const short  *x,  /* First input array.             */          *
*           const short  *y,  /* Second input array.            */          *
*           int *restrict r,  /* Accumulation of x[] * y[].     */          *
*           int nx            /* Length of the input vector.    */          *
*       )                                                                   *
*       {                                                                   *
*           int i;                                                          *
*                                                                           *
*           for (i = 0; i < nx; i++)                                        *
*           {                                                               *
*               *r += x[i] * y[i];                                          *
*               G  += y[i] * y[i];                                          *
*           }                                                               *
*                                                                           *
*           return G;                                                       *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx >= 12, nx % 4 == 0.                                              *
*                                                                           *
*   TECHNIQUES                                                              *
*       Unrolled 4 times to maximize multiplier utilization.                *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur under any conditions.                       *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   CYCLES                                                                  *
*       nx + 20                                                             *
*                                                                           *
*   CODESIZE                                                                *
*       192 bytes.                                                          *
*                                                                           *
*   SOURCE                                                                  *
*       DSPLIB.                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_dotp_sqr
_DSP_dotp_sqr:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_g
        .asg            B4,         B_x
        .asg            A6,         A_y
        .asg            B6,         B_r
        .asg            A8,         A_nx
        .asg            B9,         B_sum
        .asg            A9,         A_x
        .asg            B5,         B_x1
        .asg            A7,         A_x0
        .asg            B7,         B_y
        .asg            A5,         A_y1
        .asg            B8,         B_y0
        .asg            A5,         A_y0
        .asg            B1,         B_p1
        .asg            B1,         B_p0
        .asg            A7,         A_s1
        .asg            A8,         A_s0
        .asg            A1,         A_p
        .asg            B0,         B_i
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        LDW     .D2T2   *B_r,       B_sum
||      ADD             B_x,        2,          A_x
||      ADD             A_y,        2,          B_y
||      B               loop

        LDH     .D1T2   *A_x++[2],  B_x1                        ;[ 1,1]
||      SHR             A_nx,       1,          B_i
||      MVK             3,          A_p
;-
        LDH     .D1T2   *A_y++[2],  B_y0                        ;[ 2,1]
||      LDH     .D2T1   *B_y++[2],  A_y1                        ;[ 2,1]
||      B               loop

        LDH     .D2T1   *B_x++[2],  A_x0                        ;[ 3,1]
||      LDH     .D1T2   *A_x++[2],  B_x1                        ;[ 1,2]
||      SUB             B_i,        2,          B_i
;-
; ===== 3 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [ A_p]SUB     .S1     A_p,        1,          A_p             ;[10,1]
||[!A_p]ADD     .L1     A_s0,       A_g,        A_g             ;[10,1]
||[!A_p]ADD     .L2     B_p0,       B_sum,      B_sum           ;[10,1]
||      MPY     .M1     A_y0,       A_y0,       A_s0            ;[ 8,2]
||      MPY     .M2X    A_x0,       B_y0,       B_p0            ;[ 8,2]
||[ B_i]B       .S2     loop                                    ;[ 6,3]
||      LDH     .D1T2   *A_y++[2],  B_y0                        ;[ 2,5]
||      LDH     .D2T1   *B_y++[2],  A_y1                        ;[ 2,5]

  [!A_p]ADD     .S1     A_s1,       A_g,        A_g             ;[ 9,2]
||[!A_p]ADD     .S2     B_p1,       B_sum,      B_sum           ;[ 9,2]
||      MPY     .M1     A_y1,       A_y1,       A_s1            ;[ 7,3]
||      MPY     .M2X    B_x1,       A_y1,       B_p1            ;[ 7,3]
||      MV      .L1X    B_y0,       A_y0                        ;[ 7,3]
||[ B_i]SUB     .L2     B_i,        1,          B_i             ;[ 5,4]
||      LDH     .D2T1   *B_x++[2],  A_x0                        ;[ 3,5]
||      LDH     .D1T2   *A_x++[2],  B_x1                        ;[ 1,6]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 4 epilog stages collapsed
        ADD     .L1     A_s0,       A_g,        A_g             ;[10,5]
||      ADD     .L2     B_p0,       B_sum,      B_sum           ;[10,5]
||      MPY     .M1     A_y0,       A_y0,       A_s0            ;[ 8,6]
||      MPY     .M2X    A_x0,       B_y0,       B_p0            ;[ 8,6]
||      B               B3

        ADD     .S1     A_s1,       A_g,        A_g             ;[ 9,6]
||      ADD     .S2     B_p1,       B_sum,      B_sum           ;[ 9,6]
;-
        ADD     .L1     A_s0,       A_g,        A_g             ;[10,6]
||      ADD     .L2     B_p0,       B_sum,      B_sum           ;[10,6]

        STW     .D2T2   B_sum,      *B_r

        NOP             2

* ========================================================================= *
*   End of file:  dsp_dotp_sqr.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
dotprod.asm/    1019093836  0     0     0       10152     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Wed Apr 17 15:49:07 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_dotprod                                                         *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           int DSP_dotprod                                                 *
*           (                                                               *
*               const short *x,    /* first input vector  */                *
*               const short *y,    /* second input vector */                *
*               int nx             /* number of elements  */                *
*           );                                                              *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine takes two vectors and calculates their vector          *
*       product.  The inputs are 16-bit number, and the result is           *
*       a 32-bit number.                                                    *
*                                                                           *
*       This is the C equivalent of the assembly code without restrictions: *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*           int DSP_dotprod                                                 *
*           (                                                               *
*               const short *x,                                             *
*               const short *y,                                             *
*               int nx                                                      *
*           )                                                               *
*           {                                                               *
*               int sum = 0, i;                                             *
*                                                                           *
*               for (i = 0; i < nx; i++)                                    *
*                   sum += x[i] * y[i];                                     *
*                                                                           *
*               return sum;                                                 *
*           }                                                               *
*                                                                           *
*   TECHNIQUES                                                              *
*       Load words are used to load two 16-bit values at a time.            *
*       The loop is unrolled once.                                          *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx must be a multiple of 2 and greater than 2.                      *
*       Vectors x and y must be aligned on word boundaries.                 *
*                                                                           *
*   MEMORY NOTE                                                             *
*       Vectors x and y should be aligned on opposite memory banks          *
*       to avoid memory hits. Example:                                      *
*           #pragma DATA_MEM_BANK(x, 0)                                     *
*           #pragma DATA_MEM_BANK(y, 2)                                     *
*                                                                           *
*   NOTES                                                                   *
*       This code is ENDIAN NEUTRAL.                                        *
*       This code is interrupt-tolerant but not interruptible.              *
*                                                                           *
*   CYCLES                                                                  *
*      nx/2 + 12                                                            *
*      For nx = 40: 32 cycles                                               *
*                                                                           *
*   CODESIZE                                                                *
*      160 bytes                                                            *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .text
        .global _DSP_dotprod
_DSP_dotprod:

        LDW     .D1     *A4++,A0        ; aData[0] & aData[1]
||      LDW     .D2     *B4++,B0        ; bData[0] & bData[1]
||      B       .S2     LOOP            ; branch to loop
||      ZERO    .L1     A7:A6           ; clear reg.
||      ZERO    .L2     B7:B6           ; clear reg.
||      MV      .S1     A6,A2           ; nx

        LDW     .D1     *A4++,A0        ; aData[2] & aData[3]
||      LDW     .D2     *B4++,B0        ; bData[2] & bData[3]
||[A2]  B       .S2     LOOP            ; branch to loop
||      SUB     .L1     A2,2,A2         ; decrement loop counter

        LDW     .D1     *A4++,A0        ; aData[4] & aData[5]
||      LDW     .D2     *B4++,B0        ; bData[4] & bData[5]
||[A2]  B       .S2     LOOP            ; branch to loop
||[A2]  SUB     .S1     A2,2,A2         ; decrement loop counter

        LDW     .D1     *A4++,A0        ; aData[6] & aData[7]
||      LDW     .D2     *B4++,B0        ; bData[6] & bData[7]
||[A2]  B       .S2     LOOP            ; branch to loop
||[A2]  SUB     .S1     A2,2,A2         ; decrement loop counter

        LDW     .D1     *A4++,A0        ; aData[8] & aData[9]
||      LDW     .D2     *B4++,B0        ; bData[8] & bData[9]
||[A2]  B       .S2     LOOP            ; branch to loop
||[A2]  SUB     .S1     A2,2,A2         ; decrement loop counter

LOOP:

        LDW     .D1     *A4++,A0        ; aData[10] & aData[11]
||      LDW     .D2     *B4++,B0        ; bData[10] & bData[11]
||      MPY     .M1X    A0,B0,A6        ; aData[0]*bData[0]
||      MPYH    .M2X    A0,B0,B6        ; aData[1]*bData[1]
||      ADD     .L1     A6,A7,A7        ; Sum1 += x[i] * y[i]
||      ADD     .L2     B6,B7,B7        ; Sum2 += x[i+1] * y[i+1]
||[A2]  SUB     .S1     A2,2,A2         ; decrement loop counter
||[A2]  B       .S2     LOOP            ; branch to loop

        B       .S2     B3              ; return
||      ADD     .L1X    A7,B7,A4        ; return dot product in A4

        NOP     5

* ========================================================================= *
*   End of file:  dsp_dotprod.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
fft16x16r.asm/  1019093836  0     0     0       68639     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.8     Fri Mar 22 02:06:40 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*  TEXAS INSTRUMENTS, INC.                                                  *
*                                                                           *
*  NAME                                                                     *
*        DSP_fft16x16r                                                      *
*                                                                           *
*                                                                           *
*  REVISION DATE                                                            *
*      12-Sep-2000                                                          *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fft16x16r                                                  *
*       (                                                                   *
*           int             N,                                              *
*           short           *x,                                             *
*           short           *w,                                             *
*           unsigned char   *brev,                                          *
*           short           *y,                                             *
*           int             n_min,                                          *
*           int             offset,                                         *
*           int             nmax                                            *
*       );                                                                  *
*                                                                           *
*       N      : Length of fft in complex samples, power of 2 <=16384       *
*       x      : Pointer to complex data input                              *
*       w      : Pointer to complex twiddle factor (see below)              *
*       brev   : Pointer to bit reverse table containing 64 entries         *
*       y      : Pointer to complex data output                             *
*       n_min  : Smallest fft butterfly used in computation                 *
*                used for decomposing fft into subffts, see notes           *
*       offset : Index in complex samples of sub-fft from start of main     *
*                fft                                                        *
*       nmax   : Size of main fft in complex samples                        *
*                                                                           *
*   DESCRIPTION                                                             *
*       The benchmark performs a mixed radix forward FFT using a special    *
*       sequence of coefficients generated in the following way:            *
*                                                                           *
*        void tw_gen(short *w, int N)                                       *
*        {                                                                  *
*          int j, k;                                                        *
*          double x_t, y_t, theta1, theta2, theta3;                         *
*          const double PI = 3.141592654, M = 32767.0;                      *
*                      /* M is 16383 for scale by 4 */                      *
*                                                                           *
*          for (j=1, k=0; j <= N>>2; j = j<<2)                              *
*          {                                                                *
*              for (i=0; i < N>>2; i+=j)                                    *
*              {                                                            *
*                  theta1 = 2*PI*i/N;                                       *
*                  x_t = M*cos(theta1);                                     *
*                  y_t = M*sin(theta1);                                     *
*                  w[k]   =  (short)x_t;                                    *
*                  w[k+1] =  (short)y_t;                                    *
*                                                                           *
*                  theta2 = 4*PI*i/N;                                       *
*                  x_t = M*cos(theta2);                                     *
*                  y_t = M*sin(theta2);                                     *
*                  w[k+2] =  (short)x_t;                                    *
*                  w[k+3] =  (short)y_t;                                    *
*                                                                           *
*                  theta3 = 6*PI*i/N;                                       *
*                  x_t = M*cos(theta3);                                     *
*                  y_t = M*sin(theta3);                                     *
*                  w[k+4] =  (short)x_t;                                    *
*                  w[k+5] =  (short)y_t;                                    *
*                  k+=6;                                                    *
*              }                                                            *
*           }                                                               *
*        }                                                                  *
*                                                                           *
*       This redundent set of twiddle factors is size 2*N short samples.    *
*       As pointed out later dividing these twiddle factors by 2 will give  *
*       an effective divide by 4 at each stage to guarentee no overflow.    *
*       The function is accurate to about 68dB of signal to noise ratio to  *
*       the DFT function below:                                             *
*                                                                           *
*       void dft(int n, short x[], short y[])                               *
*       {                                                                   *
*          int k,i, index;                                                  *
*          const double PI = 3.14159654;                                    *
*          short *p_x;                                                      *
*          double arg, fx_0, fx_1, fy_0, fy_1, co, si;                      *
*                                                                           *
*          for(k = 0; k<n; k++)                                             *
*          {                                                                *
*            p_x = x;                                                       *
*            fy_0 = 0;                                                      *
*            fy_1 = 0;                                                      *
*            for(i=0; i<n; i++)                                             *
*            {                                                              *
*              fx_0 = (double)p_x[0];                                       *
*              fx_1 = (double)p_x[1];                                       *
*              p_x += 2;                                                    *
*              index = (i*k) % n;                                           *
*              arg = 2*PI*index/n;                                          *
*              co = cos(arg);                                               *
*              si = -sin(arg);                                              *
*              fy_0 += ((fx_0 * co) - (fx_1 * si));                         *
*              fy_1 += ((fx_1 * co) + (fx_0 * si));                         *
*            }                                                              *
*            y[2*k] = (short)2*fy_0/sqrt(N);                                *
*            y[2*k+1] = (short)2*fy_1/sqrt(N);                              *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*       Scaling takes place at each stage except the last one.  This is     *
*       a divide by 2 to prevent overflow. All shifts are rounded to        *
*       reduce truncation noise power by 3dB.  The function takes the       *
*       table and input data and calculates the fft producing the           *
*       frequency domain data in the Y array.  As the fft allows every      *
*       input point to effect every output point in a cache based           *
*       system such as the TMS320C6211, this causes cache thrashing.        *
*       This is mitigated by allowing the main fft of size N to be          *
*       divided into several steps, allowing as much data reuse as          *
*       possible.                                                           *
*                                                                           *
*       For example the following function:                                 *
*                                                                           *
*       DSP_fft16x16r  (1024, &x_asm[0],&w[0],y_asm,brev,4,  0,1024);       *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSP_fft16x16r(1024,&x_asm[2*0],  &w[0]    ,y_asm,brev,256, 0,1024); *
*       DSP_fft16x16r(256, &x_asm[2*0],  &w[2*768],y_asm,brev,4,   0,1024); *
*       DSP_fft16x16r(256, &x_asm[2*256],&w[2*768],y_asm,brev,4, 256,1024); *
*       DSP_fft16x16r(256, &x_asm[2*512],&w[2*768],y_asm,brev,4, 512,1024); *
*       DSP_fft16x16r(256, &x_asm[2*768],&w[2*768],y_asm,brev,4, 768,1024); *
*                                                                           *
*       Notice how the 1st fft function is called on the entire 1K data     *
*       set it covers the 1st pass of the fft until the butterfly size      *
*       is 256.  The following 4 ffts do 256 pt ffts 25% of the size.       *
*       These continue down to the end when the buttefly is of size 4.      *
*       The use an index to the main twiddle factor array of 0.75*2*N.      *
*       This is because the twiddle factor array is composed of             *
*       successively decimated versions of the main array.                  *
*                                                                           *
*       N not equal to a power of 4 can be used, i.e. 512.  In this         *
*       case to decompose the fft the following would be needed:            *
*                                                                           *
*       DSP_fft16x16r   (512, &x_asm[0],&w[0],y_asm,brev,2,  0,512);        *
*                                                                           *
*       is equvalent to:                                                    *
*                                                                           *
*       DSP_fft16x16r(512, &x_asm[0],    &w[0],    y_asm,brev,128, 0,512);  *
*       DSP_fft16x16r(128, &x_asm[2*0],  &w[2*384],y_asm,brev,4,   0,512);  *
*       DSP_fft16x16r(128, &x_asm[2*128],&w[2*384],y_asm,brev,4, 128,512);  *
*       DSP_fft16x16r(128, &x_asm[2*256],&w[2*384],y_asm,brev,4, 256,512);  *
*       DSP_fft16x16r(128, &x_asm[2*384],&w[2*384],y_asm,brev,4, 384,512);  *
*                                                                           *
*       The twiddle factor array is composed of log4(N) sets of twiddle     *
*       factors, (3/4)*N, (3/16)*N, (3/64)*N, etc.  The index into this     *
*       array for each stage of the fft is calculated by summing these      *
*       indices up appropriately.  For multiple ffts they can share the     *
*       same table by calling the small ffts from further down in the       *
*       twiddle factor array. In the same way as the decomposition works    *
*       for more data reuse.                                                *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       N must be a power of 2 and 8 <=  N <= 16384.  Complex time data     *
*       x[] and twiddle facotrs w[] are aligned on double word              *
*       boundaries.  Real values are stored in even word positions and      *
*       imaginary values in odd positions.                                  *
*                                                                           *
*       All data is in short precision integer fixed point form.  The       *
*       complex frequency data will be returned in linear order.            *
*                                                                           *
*       This code is interrupt tolerant, interrupts are disabled on         *
*       entry to the function and reenabled on exit.                        *
*                                                                           *
*       If Interruption is required the decomposition can be used to        *
*       allow interrupts to occur in between function calls.  In this       *
*       way interrupts can occur roughly every 20% of the time through      *
*       the overall FFT.                                                    *
*                                                                           *
*   MEMORY NOTE                                                             *
*       Configuration is LITTLE ENDIAN.  This code will not function if     *
*       the -me flag is enabled.  It can, however, be modified for big      *
*       endian usage.                                                       *
*                                                                           *
*       No memory bank hits occur in this code.                             *
*                                                                           *
*   TECHNIQUES                                                              *
*       A special sequence of coefficients used as generated above          *
*       produces the fft.  This collapses the inner 2 loops in the          *
*       traditional Burrus and Parks implementation Fortran Code.           *
*                                                                           *
*       The revised FFT uses a redundant sequence of twiddle factors to     *
*       allow a linear access through the data.  This linear access         *
*       enables data and instruction level parallelism.  The data           *
*       produced by the DSP_fft16x16r fft is in normal form, the whole      *
*       data array is written into a new output buffer.                     *
*                                                                           *
*       The DSP_fft16x16r butterfly is bit reversed, i.e. the inner 2       *
*       points of the butterfly are crossed over, this has the effect       *
*       of making the data come out in bit reversed rather than in          *
*       radix 4 digit reversed order.  This simplifies the last pass of     *
*       the loop.  A simple table is used to do the bit reversal out of     *
*       place.                                                              *
*                                                                           *
*          unsigned char brev[64] = {                                       *
*                0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,              *
*                0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,              *
*                0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,              *
*                0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,              *
*                0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,              *
*                0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,              *
*                0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,              *
*                0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f               *
*          };                                                               *
*                                                                           *
*   NOTES                                                                   *
*       For more aggressive overflow control the shift in the DC term       *
*       can be adjusted to 2 and the twiddle factors shifted right by       *
*       1.  This gives a divide by 4 at each stage.  For better             *
*       accuracy the data can be pre asserted left by so many bits so       *
*       that as it builds in magnitude the divide by 2 prevents too         *
*       much growth.  An optimal point for example with an 8192pt fft       *
*       with input data precision of 8 bits is to asert the input 4         *
*       bits left to make it 12 bits.  This gives an SNR of 68dB at the     *
*       output.  By trying combinations the optimal can be found.  If       *
*       scaling is not required it is possible to replace the MPY by        *
*       SMPY this will give a shift left by 1 so a shift right by 16        *
*       gives a total 15 bit shift right.  The DC term must be adjusted     *
*       to give a zero shift.                                               *
*                                                                           *
*   C CODE                                                                  *
*       This is the C equivalent of the assembly code without               *
*       restrictions.  Note that the assembly code is hand optimized        *
*       and restrictions may apply.                                         *
*                                                                           *
*       void DSP_fft16x16r                                                  *
*       (                                                                   *
*           int             n,                                              *
*           short           *ptr_x,                                         *
*           short           *ptr_w,                                         *
*           unsigned char   *brev,                                          *
*           short           *y,                                             *
*           int             radix,                                          *
*           int             offset,                                         *
*           int             nmax                                            *
*       )                                                                   *
*       {                                                                   *
*           int   i, l0, l1, l2, h2, predj;                                 *
*           int   l1p1,l2p1,h2p1, tw_offset, stride, fft_jmp;               *
*           short xt0, yt0, xt1, yt1, xt2, yt2;                             *
*           short si1,si2,si3,co1,co2,co3;                                  *
*           short xh0,xh1,xh20,xh21,xl0,xl1,xl20,xl21;                      *
*           short x_0, x_1, x_l1, x_l1p1, x_h2 , x_h2p1, x_l2, x_l2p1;      *
*           short *x,*w;                                                    *
*           short *ptr_x0, *ptr_x2, *y0;                                    *
*           unsigned int j, k, j0, j1, k0, k1;                              *
*           short x0, x1, x2, x3, x4, x5, x6, x7;                           *
*           short xh0_0, xh1_0, xh0_1, xh1_1;                               *
*           short xl0_0, xl1_0, xl0_1, xl1_1;                               *
*           short yt3, yt4, yt5, yt6, yt7;                                  *
*           unsigned a, num;                                                *
*                                                                           *
*           stride = n;         /* n is the number of complex samples */    *
*           tw_offset = 0;                                                  *
*           while (stride > radix)                                          *
*           {                                                               *
*               j = 0;                                                      *
*               fft_jmp = stride + (stride>>1);                             *
*               h2 = stride>>1;                                             *
*               l1 = stride;                                                *
*               l2 = stride + (stride>>1);                                  *
*               x = ptr_x;                                                  *
*               w = ptr_w + tw_offset;                                      *
*                                                                           *
*               for (i = 0; i < n>>1; i += 2)                               *
*               {                                                           *
*                   co1 = w[j+0];                                           *
*                   si1 = w[j+1];                                           *
*                   co2 = w[j+2];                                           *
*                   si2 = w[j+3];                                           *
*                   co3 = w[j+4];                                           *
*                   si3 = w[j+5];                                           *
*                   j += 6;                                                 *
*                                                                           *
*                   x_0    = x[0];                                          *
*                   x_1    = x[1];                                          *
*                   x_h2   = x[h2];                                         *
*                   x_h2p1 = x[h2+1];                                       *
*                   x_l1   = x[l1];                                         *
*                   x_l1p1 = x[l1+1];                                       *
*                   x_l2   = x[l2];                                         *
*                   x_l2p1 = x[l2+1];                                       *
*                                                                           *
*                   xh0  = x_0    + x_l1;                                   *
*                   xh1  = x_1    + x_l1p1;                                 *
*                   xl0  = x_0    - x_l1;                                   *
*                   xl1  = x_1    - x_l1p1;                                 *
*                                                                           *
*                   xh20 = x_h2   + x_l2;                                   *
*                   xh21 = x_h2p1 + x_l2p1;                                 *
*                   xl20 = x_h2   - x_l2;                                   *
*                   xl21 = x_h2p1 - x_l2p1;                                 *
*                                                                           *
*                   ptr_x0 = x;                                             *
*                   ptr_x0[0] = ((short)(xh0 + xh20))>>1;                   *
*                   ptr_x0[1] = ((short)(xh1 + xh21))>>1;                   *
*                                                                           *
*                   ptr_x2 = ptr_x0;                                        *
*                   x += 2;                                                 *
*                   predj = (j - fft_jmp);                                  *
*                   if (!predj) x += fft_jmp;                               *
*                   if (!predj) j = 0;                                      *
*                                                                           *
*                   xt0  = xh0 - xh20;                                      *
*                   yt0  = xh1 - xh21;                                      *
*                   xt1  = xl0 + xl21;                                      *
*                   yt2  = xl1 + xl20;                                      *
*                   xt2  = xl0 - xl21;                                      *
*                   yt1  = xl1 - xl20;                                      *
*                                                                           *
*                   l1p1 = l1+1;                                            *
*                   h2p1 = h2+1;                                            *
*                   l2p1 = l2+1;                                            *
*                                                                           *
*                   ptr_x2[l1  ] = (xt1 * co1 + yt1 * si1                   *
*                                   + 0x00008000) >> 16;                    *
*                   ptr_x2[l1p1] = (yt1 * co1 - xt1 * si1                   *
*                                   + 0x00008000) >> 16;                    *
*                   ptr_x2[h2  ] = (xt0 * co2 + yt0 * si2                   *
*                                   + 0x00008000) >> 16;                    *
*                   ptr_x2[h2p1] = (yt0 * co2 - xt0 * si2                   *
*                                   + 0x00008000) >> 16;                    *
*                   ptr_x2[l2  ] = (xt2 * co3 + yt2 * si3                   *
*                                   + 0x00008000) >> 16;                    *
*                   ptr_x2[l2p1] = (yt2 * co3 - xt2 * si3                   *
*                                   + 0x00008000) >> 16;                    *
*               }                                                           *
*                                                                           *
*               tw_offset += fft_jmp;                                       *
*               stride = stride>>2;                                         *
*           } /* end while */                                               *
*                                                                           *
*           j = offset>>2;                                                  *
*           ptr_x0 = ptr_x;                                                 *
*           y0 = y;                                                         *
*                                                                           *
*           /* determine l0 = _norm(nmax) - 17 */                           *
*           l0 = 31;                                                        *
*           if (((nmax>>31)&1)==1)                                          *
*               num = ~nmax;                                                *
*           else                                                            *
*               num = nmax;                                                 *
*           if (!num)                                                       *
*               l0 = 32;                                                    *
*           else                                                            *
*           {                                                               *
*               a=num&0xFFFF0000; if (a) { l0-=16; num=a; }                 *
*               a=num&0xFF00FF00; if (a) { l0-= 8; num=a; }                 *
*               a=num&0xF0F0F0F0; if (a) { l0-= 4; num=a; }                 *
*               a=num&0xCCCCCCCC; if (a) { l0-= 2; num=a; }                 *
*               a=num&0xAAAAAAAA; if (a) { l0-= 1; }                        *
*           }                                                               *
*           l0 -= 1;                                                        *
*                                                                           *
*           l0 -= 17;                                                       *
*                                                                           *
*           if(radix == 2 || radix  == 4)                                   *
*               for (i = 0; i < n; i += 4)                                  *
*               {                                                           *
*                       /* reversal computation */                          *
*                                                                           *
*                       j0 = (j     ) & 0x3F;                               *
*                       j1 = (j >> 6) & 0x3F;                               *
*                       k0 = brev[j0];                                      *
*                       k1 = brev[j1];                                      *
*                       k = (k0 << 6) |  k1;                                *
*                       if (l0 < 0)                                         *
*                         k = k << -l0;                                     *
*                       else                                                *
*                         k = k >> l0;                                      *
*                       j++;        /* multiple of 4 index */               *
*                                                                           *
*                       x0   = ptr_x0[0];  x1 = ptr_x0[1];                  *
*                       x2   = ptr_x0[2];  x3 = ptr_x0[3];                  *
*                       x4   = ptr_x0[4];  x5 = ptr_x0[5];                  *
*                       x6   = ptr_x0[6];  x7 = ptr_x0[7];                  *
*                       ptr_x0 += 8;                                        *
*                                                                           *
*                       xh0_0  = x0 + x4;                                   *
*                       xh1_0  = x1 + x5;                                   *
*                       xh0_1  = x2 + x6;                                   *
*                       xh1_1  = x3 + x7;                                   *
*                                                                           *
*                       if (radix == 2)                                     *
*                       {                                                   *
*                         xh0_0 = x0;                                       *
*                         xh1_0 = x1;                                       *
*                         xh0_1 = x2;                                       *
*                         xh1_1 = x3;                                       *
*                       }                                                   *
*                                                                           *
*                       yt0  = xh0_0 + xh0_1;                               *
*                       yt1  = xh1_0 + xh1_1;                               *
*                       yt4  = xh0_0 - xh0_1;                               *
*                       yt5  = xh1_0 - xh1_1;                               *
*                                                                           *
*                       xl0_0  = x0 - x4;                                   *
*                       xl1_0  = x1 - x5;                                   *
*                       xl0_1  = x2 - x6;                                   *
*                       xl1_1  = x3 - x7;                                   *
*                                                                           *
*                       if (radix == 2)                                     *
*                       {                                                   *
*                         xl0_0 = x4;                                       *
*                         xl1_0 = x5;                                       *
*                         xl1_1 = x6;                                       *
*                         xl0_1 = x7;                                       *
*                       }                                                   *
*                                                                           *
*                       yt2  = xl0_0 + xl1_1;                               *
*                       yt3  = xl1_0 - xl0_1;                               *
*                                                                           *
*                       yt6  = xl0_0 - xl1_1;                               *
*                       yt7  = xl1_0 + xl0_1;                               *
*                                                                           *
*                       if (radix == 2)                                     *
*                       {                                                   *
*                         yt7  = xl1_0 - xl0_1;                             *
*                         yt3  = xl1_0 + xl0_1;                             *
*                       }                                                   *
*                                                                           *
*                       y0[k] = yt0; y0[k+1] = yt1;                         *
*                       k += n>>1;                                          *
*                       y0[k] = yt2; y0[k+1] = yt3;                         *
*                       k += n>>1;                                          *
*                       y0[k] = yt4; y0[k+1] = yt5;                         *
*                       k += n>>1;                                          *
*                       y0[k] = yt6; y0[k+1] = yt7;                         *
*               }                                                           *
*       }                                                                   *
*                                                                           *
*   CYCLES                                                                  *
*       2.5 * N * ceil(log4(N)) - N/2 + 164                                 *
*                                                                           *
*       For N = 1024:  cycles = 12452                                       *
*       For N = 512:   cycles = 6308                                        *
*       For N = 256:   cycles = 2568                                        *
*                                                                           *
*   CODESIZE                                                                *
*       1344 bytes                                                          *
*                                                                           *
*   REFERENCES                                                              *
*       [1] C. S. Burrus and T.W. Parks (1985) "DFT/FFT and Convolution     *
*           Algos - Theory and Implementation", J. Wiley.                   *
*       [2] Implementation of Various Precision Fast Fourier Transforms on  *
*           the TMS320C6400 processor - DJH, ESC 2000                       *
*       [3] Burrus - Rice University and Papamichalis - TI (1988) - Paper   *
*           on the convertion of radix4 to radix2 digit reversal.           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .text
        .global _DSP_fft16x16r
_DSP_fft16x16r:
*======================= SYMBOLIC REGISTER ASSIGNMENTS =====================*
        .asg    A4,         A_n         ;number of point in FFT
        .asg    B4,         B_ptr_x     ;pointer to complex data
        .asg    A6,         A_ptr_w     ;pointer to twiddle factor array
        .asg    B6,         B_brev      ;pointer to bit reverse table
        .asg    A8,         A_ptr_y     ;pointer to linear order frequency data
        .asg    B8,         B_radix     ;minimum size butterfly or radix(2 or 4)
        .asg    A10,        A_offset    ;offset into main fft for decomposed fft
        .asg    B10,        B_nmax      ;maximum size of main FFT
        .asg    B15,        B_SP        ;stack pointer
        .asg    A7,         A_SP        ;copy of stack pointer
        .asg    A5,         A_irp       ;interupt return copy IRP
        .asg    B5,         B_irp       ;interupt return copy IRP or stack pntr
        .asg    B7,         B_csr       ;copy of CSR
        .asg    B9,         B_csr_no_gie;copy of CSR with interupts disabled
        .asg    B1,         B_wh        ;while predicate for outer loop
        .asg    A0,         A_tw_offset ;offset into twiddle factor array
        .asg    A1,         A_stride_1  ;intermediate value stride/2
        .asg    A2,         A_fft_jmp   ;correction factor for twiddle array
        .asg    A1,         A_w0        ;pointer to current section of tw array
        .asg    B14,        B_w0        ;pointer to current section of tw array
        .asg    B10,        B_x         ;copy of pointer to data array
        .asg    B13,        B_j         ;counter for jump in fft array
        .asg    B15,        B_stride    ;size of butterfly
        .asg    A7,         A_stride    ;size of butterfly
        .asg    A2,         A_i         ;loop counter for loop 1
        .asg    A15,        A_f0        ;mask for merging 16 bits to 32 bits
        .asg    B11,        B_x1x0      ;x[2*i+1], x[2*i]
        .asg    A0,         A_xh2p1xh2  ;x[2*i+2*N/4+1], x[2*i+2*N/4]
        .asg    B1,         B_stride2   ;stride/4
        .asg    B8,         B_xl1p1xl1  ;x[2*i+N+1], x[2*i+N]
        .asg    B6,         B_stride3   ;3*stride/4
        .asg    A3,         A_xl2p1xl2  ;x[2*i+6*N/4+1], x[2*i+6*N/4]
        .asg    B4,         B_xh1xh0    ;intermediate butterfly computation
        .asg    B7,         B_xl1xl0    ;intermediate butterfly computation
        .asg    A3,         A_xh21xh20  ;intermediate butterfly computation
        .asg    A1,         A_xl21xl20  ;intermediate butterfly computation
        .asg    B9,         B_x2        ;copy of pointer to data
        .asg    B4,         B_x3        ;copy of pointer to data
        .asg    A12,        A_x1        ;copy of pointer to data
        .asg    A13,        A_si10co10  ;sin(wt), cos(wt)
        .asg    B1,         B_si20co20  ;sin(2*wt), cos(2*wt)
        .asg    A9,         A_si30co30  ;sin(3*wt), cos(3*wt)
        .asg    B12,        B_fft_jmp   ;index to next sub fft
        .asg    B2,         B_predj     ;condition whether to jmp to next fft
        .asg    B5,         B_y1y0      ;DC output from butterfly
        .asg    A3,         A_y1_       ;image DC output /2
        .asg    B5,         B_y0_       ;real DC output /2
        .asg    B6,         B_yt0xt0    ;intermediate butterfly computation
        .asg    A4,         A_xl20xl21  ;intermediate butterfly computation
        .asg    A7,         A_l21       ;intermediate butterfly computation
        .asg    A5,         A_yt2xt1    ;intermediate butterfly computation
        .asg    B7,         B_yt1xt2    ;intermediate butterfly computation
        .asg    A14,        A_1         ;const = 1
        .asg    A6,         A_rnd       ;rounding value 1 << 15
        .asg    B0,         B_p0        ;intermediate butterfly computation
        .asg    B6,         B_p1        ;intermediate butterfly computation
        .asg    B0,         B_p01       ;intermediate butterfly computation
        .asg    B3,         B_p2        ;intermediate butterfly computation
        .asg    B6,         B_p3        ;intermediate butterfly computation
        .asg    A8,         A_p4        ;intermediate butterfly computation
        .asg    A4,         A_p5        ;intermediate butterfly computation
        .asg    A1,         A_p6        ;intermediate butterfly computation
        .asg    A10,        A_p7        ;intermediate butterfly computation
        .asg    A1,         A_p61       ;intermediate butterfly computation
        .asg    A5,         A_p8        ;intermediate butterfly computation
        .asg    B7,         B_p9        ;intermediate butterfly computation
        .asg    A0,         A_p9        ;intermediate butterfly computation
        .asg    A11,        A_pa        ;intermediate butterfly computation
        .asg    A5,         A_pb        ;intermediate butterfly computation
        .asg    B2,         B_return    ;predicate whether to quit from fft
*===========================================================================*
        STW    .D2T1 A15,        *-B_SP[1]             ;[13,0]save A15
||      MV     .L1X  B_SP,       A_SP                  ;copy stack pointer
||      MVC    .S2   CSR,        B_csr                 ;Get current GIE bit

        STW    .D2T2 B14,        *-B_SP[2]             ;[10,0]save B14
||      STW    .D1T1 A14,        *-A_SP[3]             ;[ 4,0]save A14
||      AND    .L2   B_csr, -2,  B_csr_no_gie          ;Clear GIE

        STW    .D2T2 B13,        *-B_SP[4]             ;[ 9,0]save B13
||      STW    .D1T1 A13,        *-A_SP[5]             ;[ 7,0]save A13
||      MVC    .S2   B_csr_no_gie,CSR                  ;Disable interrupts

        STW    .D2T2 B12,        *-B_SP[6]             ;[ 6,0]save B12
||      STW    .D1T1 A12,        *-A_SP[7]             ;[ 6,0]save A12

        STW    .D2T2 B11,        *-B_SP[8]             ;[ 7,0]save B11
||      STW    .D1T1 A11,        *-A_SP[9]             ;[ 5,0]save A11

        STW    .D2T2 B10,        *-B_SP[11]            ;[ 8,0]save nmax
||      STW    .D1T1 A10,        *-A_SP[10]            ;[ 8,0]save offset

        STW    .D2T2 B_ptr_x,    *-B_SP[12]            ;[11,0]save ptr_x
||      STW    .D1T1 A_ptr_w,    *-A_SP[13]            ;[ 9,0]save ptr_w
||      MVC    .S2   IRP,        B_irp                 ;copy IRP

        STW    .D2T2 B_csr,      *-B_SP[14]            ;save orginal CSR
||      STW    .D1T1 A_n,        *-A_SP[15]            ;[10,0]save n
||      MV     .L1X  B_irp,      A_irp                 ;copy irp to A file

        STW    .D2T2 B3,         *-B_SP[16]            ;[12,0]save B3 (ret pntr)
||      STW    .D1T1 A_irp,      *-A_SP[17]            ;[12,0]save IRP

        STW    .D2T2 B_radix,    *-B_SP[19]            ;save radix
||      STW    .D1T1 A_ptr_y,    *-A_SP[20]            ;save ptr_y

        MVC    .S2   B_SP,       IRP                   ;save stack pointer
||      ZERO   .L1   A_tw_offset                       ;[ 2,0]tw_offset=0
||      MV     .L2X  A_n,        B_stride              ;[ 2,0]stride=n
||      SHR    .S1   A_n,        1,          A_stride_1;[ 4,0]stride_1=stride>>1
||      STW    .D2T2 B_brev,     *-B_SP[21]            ;save brev pointer

*                                       /* M is 16383 for scale by 4 */     *
        ADD    .S1X  A_stride_1, B_stride,   A_fft_jmp ;[ 5,0]fft_jmp=1.5*stride
||      ADDAH  .D1   A_ptr_w,    A_tw_offset,A_w0      ;[5,0]w=ptr_w+tw_offset
||      SHRU   .S2   B_stride,   2,          B_stride  ;[ 7,0]stride>>=2

        ADD    .S2   B_stride,   B_stride,   B_stride2 ;[ 1,1]stride2=2*stride
||      LDW    .D2T2 *B_ptr_x[0],B_x1x0                ;[ 1,1]load x[1],x[0]

        MPYSU  .M2   3,          B_stride,   B_stride3 ;[ 2,1]stride3=stride*3
||      LDW    .D2T2 *B_ptr_x[B_stride2],    B_xl1p1xl1;[ 2,1]x[N+1],x[N]

        ADD    .L1   A_tw_offset,A_fft_jmp, A_tw_offset;[6,0]tw_offset+=fft_jmp
||      MV     .S2X  A_w0,       B_w0                  ;[ 6,0]copy w0
*========================== PIPE LOOP PROLOG ===============================*
LOOP_WHILE:
        STW    .D1T1 A_tw_offset,            *-A_SP[18];[7,0]save tw_offset

        LDW    .D2T1 *B_ptr_x[B_stride3],    A_xl2p1xl2;[ 5,1]x[3N/2+1],x[3N/2]

        MVK    .S2   12,         B_j                   ;[ 6,1]j= 0
||      MPYSU  .M2   12,         B_stride,   B_fft_jmp ;[ 6,1]fft_jmp=stride*3/4
||      LDW    .D2T1 *B_ptr_x[B_stride],     A_xh2p1xh2;[ 6,1]x[N/2+1],x[N/2]
||      MV     .L2   B_ptr_x,    B_x                   ;[ 7,0]x=ptr_x

        SUB    .L1   A_n,        0,          A_i       ;[ 7,0]for(i=0; i < n){

        SUB    .L2   B_fft_jmp,  B_j,        B_predj   ;[8,1]predj=(j==fft_jmp)

        MV     .L2   B_x,        B_x2                  ;[ 9,1]x2 = x

  [!B_predj]ADD.S2   B_x,        B_fft_jmp,  B_x       ;[10,1](!predj)x+=fft_jmp
||      LDW    .D2T1 *B_w0++[3], A_si10co10            ;[10,1]si1=w[j+1]co1=w[j]

        SUB2   .S1   A_xh2p1xh2, A_xl2p1xl2, A_xl21xl20;[11,1]xl20=x[h2]-x[l2]
||      ADD    .S2   B_stride,   B_stride,   B_stride2 ;[1,2]stride2=2*stride
||      LDW    .D2T2 *++B_x[1],  B_x1x0                ;[1,2]x[2*i+1],x[2*i]

        SHL    .S1   A_xl21xl20, 16,         A_xl20xl21;[12,1]rotate xl21xl20
||      MPYSU  .M2   3,          B_stride,   B_stride3 ;[2,2]stride=stride*3
||      LDW    .D2T2 *B_x[B_stride2],        B_xl1p1xl1;[2,2]x[2*i+N+1],x[2*i+N]

        LDW    .D2T2 *-B_w0[2],  B_si20co20            ;[13,1]si2co2=w[j+3,2]
||      SHRU   .S1   A_xl21xl20, 16,         A_l21     ;[13,1]rotate xl21xl20

 [!B_predj]ZERO.L2   B_j                               ;[14,1]if (!predj) j=0
||      LDW    .D2T1 *-B_w0[1],  A_si30co30            ;[14,1]si3co3=w[j+5,4]
||      ADD2   .S2   B_x1x0,     B_xl1p1xl1, B_xh1xh0  ;[14,1]xh0=x[0]+x[l1]
||      ADD2   .S1   A_xh2p1xh2, A_xl2p1xl2, A_xh21xh20;[14,1]xh20=x[h2]+x[l2]

        SUB2   .S2   B_x1x0,     B_xl1p1xl1, B_xl1xl0  ;[15,1]xl0=x[0]-x[l1]
||      ADD    .D1   A_l21,      A_xl20xl21, A_xl20xl21;[15,1]rotate xl21xl20
||      LDW    .D2T1 *B_x[B_stride3],        A_xl2p1xl2;[ 5,2]x[2*i+3N/2+1,0]
||      MPYSU  .M1   0,          A_f0,       A_f0      ;[ 6,0]mask 0xffff0000
||      MV     .L1X  B_x,        A_x1                  ;copy x to x1 for prolog
||      B      .S1   PROLOG3+4                         ;skip 1st

        SUB2   .S2X  B_xh1xh0,   A_xh21xh20, B_yt0xt0  ;[16,1]xt0=xh0-xh20
||      ADD2   .S1X  A_xl20xl21, B_xl1xl0,   A_yt2xt1  ;[16,1]xt1=xl0+xl21
||      ADD    .L2   B_j,        12,         B_j       ;[ 6,2]j += 1
||      MPYSU  .M2   12,         B_stride,   B_fft_jmp ;[ 6,2]fft_jmp=3/4*stride
||      LDW    .D2T1 *B_x[B_stride],         A_xh2p1xh2;[ 6,2]x[2*i+N/2+1,0]

        MV     .L1X  B_stride,   A_stride              ;dummy out 2nd store
||[!B_predj]SUB.D2   B_w0,       B_fft_jmp,  B_w0      ;[17,1](!predj)w-=fft_jmp
||      ADD2   .S2X  B_xh1xh0,   A_xh21xh20, B_y1y0    ;[17,1]y[0]=xh0+xh20
||      MPY    .M1   A_si10co10, A_yt2xt1,   A_p5      ;[17,1]p5=co10*xt1
||      MVKLH  .S1   0FFFFh,     A_f0                  ;[ 7,0]mask = 0xffff0000

        MPYHL  .M1   A_si10co10, A_yt2xt1,   A_p7      ;[18,1]p7=si10*xt1
||      MV     .D2   B_x2,       B_x3                  ;[18,1]x3 = x2
||      SUB2   .S2X  B_xl1xl0,   A_xl20xl21, B_yt1xt2  ;[18,1]xt2=xl0-xl21
||      CMPEQ  .L1   A_f0,       A_f0,       A_1       ;[18,1]const = 1
||      SHR    .S1X  B_y1y0,     17,         A_y1_     ;[18,1]y1>>=1(>>18 for 2)
||      MPYH   .M2   B_si20co20, B_yt0xt0,   B_p0      ;[18,1]p0 = si20*yt0
||      SUB    .L2   B_fft_jmp,  B_j,        B_predj   ;[ 8,2]predj=j-fft_jmp
*========================== PIPE LOOP KERNEL ===============================*
LOOP_FOR:
        ADD    .D1   A_p4,       A_p61,      A_p61     ;[29,1]p61=p4+p61
||      STH    .D2T1 A_y1_,      *B_x3[1]              ;[19,2]Im X[i]=y1>>1
||      MPYH   .M1X  A_si10co10, B_yt1xt2,   A_p4      ;[19,2]p2=si10*yt1
||      MPYLH  .M2   B_si20co20, B_yt0xt0,   B_p2      ;[19,2]p2=co20*yt0
||      SHL    .S1   A_1,        15,         A_rnd     ;[19,2]rnd = 0x8000
||      MV     .L2   B_x,        B_x2                  ;[ 9,3]x2 = x

        SUB    .L1   A_i,        4,          A_i       ;[30,1]i += 4
||      ADD    .D1   A_pa,       A_p9,       A_pa      ;[30,1]pa += p9
||      MPYH   .M1   A_yt2xt1,   A_si30co30, A_p8      ;[20,2]p8 = si30*yt2
||      MPYHL  .M2   B_si20co20, B_yt0xt0,   B_p3      ;[20,2]p3 = si20*xt0
||      ADD    .L2X  B_p0,       A_rnd,      B_p0      ;[20,2]p0 = p0 + 0x8000
||[!B_predj]ADD.S2   B_x,        B_fft_jmp,  B_x       ;[10,3](!predj)x+=fft_jmp
||      LDW    .D2T1 *B_w0++[3], A_si10co10            ;[10,3]si1=w[j+1]co1=w[j]
PROLOG3:
        STW    .D1T1 A_p61,      *++A_x1[A_stride]     ;[31,1]x[2*i+N/2+1,0]
||      ADD    .L1   A_p4,       A_p5,       A_p4      ;[21,2]p4=p4+p5
||      MPY    .M2   B_si20co20, B_yt0xt0,   B_p1      ;[21,2]p1=co20*xt0
||      ADD    .L2X  B_p2,       A_rnd,      B_p2      ;[21,2]p2 = p2 + 0x8000
||      MPYLH  .M1   A_si30co30, A_yt2xt1,   A_pa      ;[21,2]pa = co30*yt2
||      SUB2   .S1   A_xh2p1xh2, A_xl2p1xl2, A_xl21xl20;[11,3]xl20=x[h2]-x[l2]
||      ADD    .S2   B_stride,   B_stride,   B_stride2 ;[ 1,4]stride2=2*stride
||      LDW    .D2T2 *++B_x[1],  B_x1x0                ;[ 1,4]X[i]

        STW    .D1T1 A_pa,       *A_x1[A_stride]       ;[32,1]X[i+3N/4]
||      EXT    .S2   B_y1y0,     16, 17,     B_y0_     ;[22,2]y0_=y0>>1(17to18)
||      SUB    .L2   B_p2,       B_p3,       B_p2      ;[22,2]p2 = p2 - p3
||      ADD    .L1   A_p4,       A_rnd,      A_p4      ;[22,2]p4 = p4 + 0x8000
||      MPYLH  .M1X  A_si10co10, B_yt1xt2,   A_p6      ;[22,2]p6=co10*yt1
||      SHL    .S1   A_xl21xl20, 16,         A_xl20xl21;[12,3]xl20____
||      MPYSU  .M2   3,          B_stride,   B_stride3 ;[ 2,4]stride3=3*stride
||      LDW    .D2T2 *B_x[B_stride2],        B_xl1p1xl1;[ 2,4]X[i+N/2]

  [ A_i]B      .S2   LOOP_FOR                          ;[33,1]for(i < n){
||      MPY    .M2X  B_yt1xt2,   A_si30co30, B_p9      ;[23,2]p9=co30*xt2
||      ADD    .L2   B_p0,       B_p1,       B_p0      ;[23,2]p0=p0+p1
||      ADD    .D1   A_p8,       A_rnd,      A_p8      ;[23,2]p8 = p8 + 0x8000
||      MV     .L1X  B_x3,       A_x1                  ;[23,2]x1 = x3
||      MPYLHU .M1   A_1,        A_p4,       A_p4      ;[23,2]p4 = p4 >> 16
||      LDW    .D2T2 *-B_w0[2],  B_si20co20            ;[13,3]si2co2=w[j+3,2]
||      SHRU   .S1   A_xl21xl20, 16,         A_l21     ;[13,3]____xl21

        MPYHLU .M2X  B_p0,       A_1,        B_p01     ;[24,2]p01 = p0 >> 16
||      MPYHL  .M1X  A_si30co30, B_yt1xt2,   A_pb      ;[24,2]pb = si30*xt2
||      ADD    .L1   A_pa,       A_rnd,      A_pa      ;[24,2]pa = pa + 0x8000
||      ADD    .D1   A_p6,       A_rnd,      A_p6      ;[24,2]p6 = p6 + 0x8000
||[!B_predj]ZERO.L2  B_j                               ;[14,3]if(!predj) j = 0
||[ A_i]LDW    .D2T1 *-B_w0[1],  A_si30co30            ;[14,3]si3co3=w[6*j+5,4]
||      ADD2   .S2   B_x1x0,     B_xl1p1xl1, B_xh1xh0  ;[14,3]xh0=x[0]+x[l1]
||      ADD2   .S1   A_xh2p1xh2, A_xl2p1xl2, A_xh21xh20;[14,3]xh20=x[h2]+x[l2]

        AND    .L2X  B_p2,       A_f0,       B_p2      ;[25,2]p2=p2 & 0xffff0000
||      MPYSU  .M1   1,          A_i,        A_i       ;[25,2]copy i
||      SUB    .L1   A_p6,       A_p7,       A_p6      ;[25,2]p6 = p6 + p7
||      ADD    .S1X  B_p9,       A_p8,       A_p9      ;[25,2]p9 = p8+p9
||      SUB2   .S2   B_x1x0,     B_xl1p1xl1, B_xl1xl0  ;[15,3]xl0=x[0]-x[l1]
||      ADD    .D1   A_l21,      A_xl20xl21, A_xl20xl21;[15,3]rotate xl21xl20
||[ A_i]LDW    .D2T1 *B_x[B_stride3],        A_xl2p1xl2;[ 5,4]X[i+3N/4]

        AND    .L1   A_p6,       A_f0,       A_p61     ;[26,2]p61=p6& 0xffff0000
||      SUB    .D1   A_pa,       A_pb,       A_pa      ;[26,2]pa = pa - pb
||      MPYLHU .M1   A_1,        A_p9,       A_p9      ;[26,2]p9 = p9 >> 16
||      SUB2   .S2X  B_xh1xh0,   A_xh21xh20, B_yt0xt0  ;[16,3]xt0=xh0-xh20
||      ADD2   .S1X  A_xl20xl21, B_xl1xl0,   A_yt2xt1  ;[16,3]xt1=xl0+xl21
||      ADD    .L2   B_j,        12,         B_j       ;[ 6,4]j += 1
||      MPYSU  .M2   12,         B_stride,   B_fft_jmp ;[ 6,4]fft_jmp=3*stride/4
||[ A_i]LDW    .D2T1 *B_x[B_stride],         A_xh2p1xh2;[ 6,4]X[i+N/4]

        MV     .S1X  B_stride,   A_stride              ;[27,2]copy stride
||      ADD    .L2   B_p2,       B_p01,      B_p2      ;[27,2]p2 = p2 + p01
||      STH    .D1T2 B_y0_,      *A_x1[0]              ;[27,2]Re(X[i]) = y0 >>1
||      AND    .L1   A_pa,       A_f0,       A_pa      ;[27,2]pa=pa & 0xffff0000
||[!B_predj]SUB.D2   B_w0,       B_fft_jmp,  B_w0      ;[17,3](!predj)w-=fft_jmp
||      ADD2   .S2X  B_xh1xh0,   A_xh21xh20, B_y1y0    ;[17]y1y0=xh1xh0+xh21xh20
||      MPY    .M1   A_si10co10, A_yt2xt1,   A_p5      ;[17,3]p5 = co10*xt1

        STW    .D1T2 B_p2,       *++A_x1[A_stride]     ;[28,2]X[i+N/2]
||      MPYHL  .M1   A_si10co10, A_yt2xt1,   A_p7      ;[18,3]p7=si10*xt1
||      MV     .D2   B_x2,       B_x3                  ;[18,3]x3 = x2
||      SUB2   .S2X  B_xl1xl0,   A_xl20xl21, B_yt1xt2  ;[18,3]xt2=xl0-xl21
||      CMPEQ  .L1   A_f0,       A_f0,       A_1       ;[18,3]const = 1
||      SHR    .S1X  B_y1y0,     17,         A_y1_     ;[18,3]y1>>=1(>>18 for 2)
||      MPYH   .M2   B_si20co20, B_yt0xt0,   B_p0      ;[18,3]p0 = si20*co20
||      SUB    .L2   B_fft_jmp,  B_j,        B_predj   ;[8,4]predj=j-fft_jmp
*============================= PIPE LOOP EPILOG ============================*
        MVC    .S2   IRP,        B_irp                 ;put Stack ptr into irp

        LDW    .D2T2 *-B_irp[19],B_radix               ;reload B_radix

        ADD    .D1   A_p4,       A_p61,      A_p61     ;[29,4]p61 = p4 + p61

        STW    .D1T1 A_p61,      *++A_x1[A_stride]     ;[31,4]X[i+N/4]
||      ADD    .L1   A_pa,       A_p9,       A_pa      ;[30,4]pa = pa + p9

        STW    .D1T1 A_pa,       *A_x1[A_stride]       ;[32,4]X[i+3N/4]
||      MV     .L1X  B_irp,      A_SP                  ;SP = irp

        LDW    .D1T1 *-A_SP[13], A_ptr_w               ;[ 9,0]restore ptr_w
||      LDW    .D2T2 *-B_irp[12],B_ptr_x               ;[11,0]restore ptr_x

        LDW    .D1T1 *-A_SP[18], A_tw_offset           ;[ 7,0]restore tw_offset
||      CMPGTU .L2   B_stride,   B_radix,    B_wh      ;while(stride > radix){

  [B_wh]B      .S1   LOOP_WHILE                        ;do while
||      LDW    .D1T1 *-A_SP[15], A_n                   ;[10,0]restore n
||      CMPGTU .L2   B_radix,    4,          B_return  ;if radix > 4 exit

  [B_wh]SHR    .S1X  B_stride,   1,          A_stride_1;[ 4,0]stride_1=stride/2
||[!B_wh]LDW   .D1T1 *-A_SP[20], A_ptr_y               ;restore ptr_y
||[!B_wh]LDW   .D2T2 *-B_irp[11],B_nmax                ;restore nmax
||[B_return]B  .S2   EARLY_EXIT                        ;return early

  [B_wh]ADD    .L1X  A_stride_1, B_stride,   A_fft_jmp ;[5,0]fft_jmp=1.5*stride
||[B_wh]SHRU   .S2   B_stride,   2,          B_stride  ;[7,0]stride >>=2
||[!B_wh]LDW   .D1T2 *-A_SP[21], B_brev                ;restore brev table ptr
||[!B_wh]LDW   .D2T1 *-B_irp[10],A_offset              ;restore offset

  [B_wh]ADD    .L2   B_stride,   B_stride,   B_stride2 ;[ 1,1]stride2=2*stride
||[B_wh]LDW    .D2T2 *B_ptr_x[0],B_x1x0                ;[ 1,1]X[0]

  [B_wh]MPYSU  .M2   3,          B_stride,   B_stride3 ;[ 2,1]stride3=3*stride
||[B_wh]LDW    .D2T2 *B_ptr_x[B_stride2],    B_xl1p1xl1;[ 2,1]X[N/2]
||[B_wh]ADDAH  .D1   A_ptr_w,    A_tw_offset,A_w0      ;[5,0]w=ptr_w+tw_offset

  [B_wh]ADD    .L1   A_tw_offset,A_fft_jmp, A_tw_offset;[6,0]tw_offset+=fft_jmp
||[B_wh]MV     .L2X  A_w0,       B_w0                  ;[6,0]copy w0 in Bfile
*==================== SYMBOLIC REGISTER ASSIGNMENTS ========================*
        .asg   A4,         A_n          ;number of complex points in fft
        .asg   B7,         B_n          ;number of complex points in fft
        .asg   B4,         B_ptr_x      ;ptr to data
        .asg   B6,         B_brev       ;ptr to bit reverse table
        .asg   A13,        A_brev       ;copy of brev
        .asg   A8,         A_ptr_y      ;ptr to frequnecy data
        .asg   B8,         B_radix      ;radix of fft 2 or 4
        .asg   A0,         A_3f         ;mask = 0x3f
        .asg   A3,         A_64         ;const = 64
        .asg   B12,        B_y0         ;pointer to 1st n/4 frequnecy points
        .asg   B13,        B_y1         ;pointer to 2nd n/4 frequnecy points
        .asg   B14,        B_y2         ;pointer to 3rd n/4 frequnecy points
        .asg   B0,         B_y3         ;pointer to 4th n/4 frequnecy points
        .asg   B2,         B_i          ;loop counter
        .asg   B5,         B_x          ;copy of data pointer
        .asg   A10,        A_x          ;copy of data pointer
        .asg   A12,        A_j          ;index into data
        .asg   A2,         A_r2         ;radix2 decision
        .asg   B11,        B_l0         ;shoft for correcting bit reversal
        .asg   A1,         A_pro        ;prolog collapse counter
        .asg   A4,         A_j0         ;partial bit reverse index
        .asg   A5,         A_j1         ;partial bit reverse index
        .asg   B3,         B_k0         ;partial bit reverse index
        .asg   B1,         B_k1         ;partial bit reverse index
        .asg   B4,         B_k0_        ;partial bit reverse index
        .asg   B6,         B_k          ;bit reversed index
        .asg   B7,         B_x1x0       ;data point X[i]
        .asg   A11,        A_x3x2       ;data point X[i+1]
        .asg   B8,         B_x5x4       ;data point X[i+2]
        .asg   A8,         A_x7x6       ;data point X[i+3]
        .asg   B3,         B_xh1_0xh0_0 ;partial butterfly calculation
        .asg   A8,         A_xh1_1xh0_1 ;partial butterfly calculation
        .asg   B10,        B_xl1_0xl0_0 ;partial butterfly calculation
        .asg   A6,         A_xl1_1xl0_1 ;partial butterfly calculation
        .asg   A9,         A_1          ;const = 1
        .asg   A9,         A_x7         ;Im(X[i+3])
        .asg   A7,         A_x6         ;Re(X[i+3])
        .asg   A7,         A_xl0_1      ;partial butterfly calculation
        .asg   A4,         A_mxl0_1     ;partial butterfly calculation
        .asg   A6,         A_xl1_1      ;partial butterfly calculation
        .asg   A5,         A_mxl0_1xl1_1;partial butterfly calculation
        .asg   A6,         A_xl0_1xl1_1 ;partial butterfly calculation
        .asg   A4,         A_yt1yt0     ;frequnecy F[i]
        .asg   B4,         B_yt5yt4     ;frequnecy F[i+N/4]
        .asg   B9,         B_yt3yt2     ;frequnecy F[i+N/2]
        .asg   B4,         B_yt7yt6     ;frequnecy F[i+3*N/4]
*========================== PIPE LOOP PROLOG ===============================*
        CMPEQ  .L1   A_pro,      A_pro,      A_pro     ;[ 3,0]pro ! = 0
||      NORM   .L2   B_nmax,     B_l0                  ;[ 3,0]l0 = _norm(nmax)
||      MVK    .S1   64,         A_64                  ;[ 4,0]const = 64
||      MVC    .S2   IRP,        B_SP                  ;restore SP

        SUB    .D2   B_l0,       16,         B_l0      ;[ 4,0]l0 > = 16
||      MV     .L2   B_nmax,     B_n                   ;n = nmax
||      MVK    .S1   03Fh,       A_3f                  ;[ 5,0]const = 0x3f
||      SUB    .L1X  B_radix,    2,          A_r2      ;[ 3,0]r2 = radix - 2

        SHRU   .S1   A_offset,   2,          A_j       ;[ 5,0]j = offset >> 2
||      MV     .D2   B_ptr_x,    B_x                   ;[ 5,0]x = ptr_x
||      ADD    .L2X  A_n,        4,          B_i       ;[ 5,0] i = n

        AND    .L1   A_3f,       A_j,        A_j0      ;[ 1,1]j0 = j & 0x3f
||      MV     .S2X  A_ptr_y,    B_y0                  ;[ 2,0]y0 = ptr_y
||      ADD    .S1X  B_ptr_x,    4,          A_x       ;[ 4,0]x = ptr_x

        LDW    .D1T1 *A_x++[2],  A_x3x2                ;[2,1]X[i+1]
||      LDW    .D2T2 *B_x++[2],  B_x1x0                ;[2,1]X[i]
||      SHRU   .S1   A_j,        6,          A_j1      ;[2,1]j1 = j >> 6

        LDW    .D1T1 *A_x++[2],  A_x7x6                ;[3,1]X[i+3]
||      LDW    .D2T2 *B_x++[2],  B_x5x4                ;[3,1]X[i+2]
||      AND    .S1   A_3f,       A_j1,       A_j1      ;[ 3,1] j1 = j1 & 0x3f
||      MV     .L1X  B_brev,     A_brev                ;[ 5,0]copy brev

        LDBU   .D1T2 *A_brev[A_j0],          B_k0      ;[ 4,1]k0 = brev[j0]
||      ADD    .D2   B_y0,       B_n,        B_y1      ;[ 3,0]y1= y0 + N/4

        CMPEQ  .L1   A_r2,       A_r2,       A_1       ;[ 5,1]const = 1
||      ADD    .S2   B_y1,       B_n,        B_y2      ;[ 4,0]y2 = y1 + N/4

        ADD    .D2   B_y2,       B_n,        B_y3      ;[ 5,0]y3 = y2 + N/4
*========================== PIPE LOOP KERNEL ==========v====================*
LOOP_FOR_Y:
        ADD    .L1   A_mxl0_1,   A_xl1_1, A_mxl0_1xl1_1;[15,1]reformat data
||[!A_r2]MV    .D2   B_x5x4,     B_xl1_0xl0_0          ;[15,1](!r2)xl0_0=x4
||      ADD2   .S1X  B_xh1_0xh0_0,A_xh1_1xh0_1,A_yt1yt0;[15,1]yt0=xh0_0+xh0_1
||      SHRU   .S2   B_k,        B_l0,       B_k       ;[15,1]k = k >> l0
||      LDBU   .D1T2 *A_brev[A_j1],          B_k1      ;[ 7,2]k1 = brev[j1]

        SUB    .L2   B_i,        4,          B_i       ;[16,1]i+=4
||[!A_pro]STW  .D2T2 B_yt5yt4,   *B_y2[B_k]            ;[16,1]Y[i+3*N/4]
||      ADD2   .S2X  B_xl1_0xl0_0,A_mxl0_1xl1_1,B_yt3yt2;[16,1]yt2=xl0_0+xl1_1
||      ADD    .D1   A_xl0_1,    A_xl1_1,  A_xl0_1xl1_1;[16,1]rotate xl1_1xl0_1
||      SHL    .S1   A_x7x6,     16,         A_x6      ;[ 8,2]x6____
||      ADD    .L1   A_j,        1,          A_j       ;[ 8,2]j++

  [ B_i]B      .S1   LOOP_FOR_Y                        ;[17,1]for(i=0;i<n;i+=4){
||[!A_pro]STW  .D2T1 A_yt1yt0,   *B_y0[B_k]            ;[17,1]Y[i]
||      SUB2   .S2X  B_xl1_0xl0_0,A_mxl0_1xl1_1,B_yt7yt6;[17,1]yt6=xl0_0-xl1_1
||      AND    .L1   A_3f,       A_j,        A_j0      ;[ 1,3]j0 = j & 0x3f

  [!A_r2]SUB2  .S2X  B_xl1_0xl0_0,A_xl0_1xl1_1,B_yt7yt6;[18](!r2)yt6=xl0_0-xl1_1
||      MPYHLU .M1   A_x7x6,     A_1,        A_x7      ;[10,2]____x7
||[ B_i]LDW    .D1T1 *A_x++[2],  A_x3x2                ;[ 2,3]X[i+1]
||[ B_i]LDW    .D2T2 *B_x++[2],  B_x1x0                ;[ 2,3]X[i]
||      SHRU   .S1   A_j,        6,          A_j1      ;[ 2,3]j1 = j >> 6

  [!A_r2]ADD2  .S2X  B_xl1_0xl0_0,A_xl0_1xl1_1,B_yt3yt2;[19](!r2)yt2=xl0_0+xl1_1
||      SUB2   .S1   A_x3x2,     A_x7x6,   A_xl1_1xl0_1;[11,2]xl0_1= x2 - x6
||[ B_i]LDW    .D1T1 *A_x++[2],  A_x7x6                ;[ 3,3]X[i+3]
||[ B_i]LDW    .D2T2 *B_x++[2],  B_x5x4                ;[ 3,3]X[i+2]
||      AND    .L1   A_3f,       A_j1,       A_j1      ;[ 3,3]j1 = j1 & 0x3f

  [!A_r2]ADD   .L1   A_x6,       A_x7,     A_xl1_1xl0_1;[12,2](!r2)xl0_1=x6+x7
||      ADD2   .S1   A_x3x2,     A_x7x6,   A_xh1_1xh0_1;[12,2]xh0_1=x2+x6
||      ADD2   .S2   B_x1x0,     B_x5x4,   B_xh1_0xh0_0;[12,2]xh0_0=x0+x4
||      MPYU   .M2X  B_k0,       A_64,       B_k0_     ;[12,2]k0_ = k0 << 6
||[ B_i]LDBU   .D1T2 *A_brev[A_j0],          B_k0      ;[ 4,3]k0 = brev[j0]

        MPYSU  .M1   0,          A_pro,    A_pro       ;[21,1]pro = 0
||[!A_pro]STW  .D2T2 B_yt7yt6,   *B_y3[B_k]            ;[21,1]y0[i+3N/4]
||      SHL    .S1   A_xl1_1xl0_1,16,      A_xl0_1     ;[13,2]xl0_1____
||      SUB2   .S2   B_x1x0,     B_x5x4,   B_xl1_0xl0_0;[13,2]xl0_0=x0-x4
||[!A_r2]MV    .D1   A_x3x2,     A_xh1_1xh0_1          ;[13,2](!r2)xh0_1=x2
||[!A_r2]MV    .L2   B_x1x0,     B_xh1_0xh0_0          ;[13,2](!r2)xh0_0=x0
||      CMPEQ  .L1   A_r2,       A_r2,     A_1         ;[ 5,3]const = 1

  [!A_pro]STW  .D2T2 B_yt3yt2,   *B_y1[B_k]            ;[22,1]y0[i+N/2]
||      SHRU   .S1   A_xl1_1xl0_1,16,        A_xl1_1   ;[14,2]____xl1_1
||      SUB    .L1   0,          A_xl0_1,    A_mxl0_1  ;[14,2]mxl0_1 = -xl0_1
||      SUB2   .S2X  B_xh1_0xh0_0,A_xh1_1xh0_1,B_yt5yt4;[14,2]yt4=xh0_0-xh0_1
||      ADD    .L2   B_k0_,      B_k1,       B_k       ;[14,2]k = bitrev[j]
*========================== PIPE LOOP EPILOG ===============================*
EARLY_EXIT:
        LDW    .D2T2 *-B_SP[17], B_irp                 ;[12,0]restore IRP
||      MV     .L1X  B_SP,       A_SP                  ;copy stack pointer

        LDW    .D2T2 *-B_SP[16], B3                    ;[12,0]restore B3
||      LDW    .D1T1 *-A_SP[1],  A15                   ;[13,0]restore A15

        LDW    .D2T2 *-B_SP[14], B_csr                 ;get orginal CSR
||      LDW    .D1T1 *-A_SP[3],  A14                   ;[ 4,0]restore A14

        LDW    .D2T2 *-B_SP[4],  B13                   ;[ 9,0]restore B13
||      LDW    .D1T1 *-A_SP[5],  A13                   ;[ 7,0]restore A13

        LDW    .D2T2 *-B_SP[6],  B12                   ;[ 6,0]restore B12
||      LDW    .D1T1 *-A_SP[7],  A12                   ;[ 6,0]restore A12

        LDW    .D2T2 *-B_SP[8],  B11                   ;[ 7,0]restore B11
||      LDW    .D1T1 *-A_SP[9],  A11                   ;[ 5,0]restore A11
||      MVC    .S2   B_irp,      IRP                   ;restore IRP

        LDW    .D2T2 *-B_SP[11], B10                   ;[ 8,0]restore B10
||      LDW    .D1T1 *-A_SP[10], A10                   ;[ 8,0]restore B10
||      B      .S2   B3                                ;return to CALLER

        LDW    .D2T2 *-B_SP[2],  B14                   ;[10,0]restore B14

        MVC    .S2   B_csr,      CSR                   ;restore interupt state

        NOP          3
        ;BRANCH OCCURS HERE

* ========================================================================= *
*   End of file:  dsp_fft16x16r.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

fir_cplx.asm/   1019093836  0     0     0       15216     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.6     Wed Apr 17 15:48:16 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*     TEXAS INSTRUMENTS, INC.                                               *
*                                                                           *
*     NAME                                                                  *
*           DSP_fir_cplx                                                    *
*                                                                           *
*     REVISION DATE                                                         *
*         09-Apr-2002                                                       *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fir_cplx                                                   *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short *restrict r,                                              *
*           int nh,                                                         *
*           int nr                                                          *
*      )                                                                    *
*                                                                           *
*      x[2*(nr+nh-1)] : Input array. x must point to x[2*(nh-1)].           *
*      h[2*nh]        : Coefficient array (in normal order).                *
*      r[2*nr]        : Output array.                                       *
*      nh             : Number of complex coefficients.                     *
*                       Must be even.                                       *
*      nr             : Number of complex output samples.                   *
*                       nh * nr must be >= 4.                               *
*                                                                           *
*   DESCRIPTION                                                             *
*       This complex FIR computes nr complex output samples using nh        *
*       complex coefficients. It operates on 16-bit data with a 32-bit      *
*       accumulate. Each array consists of an even and odd term with even   *
*       terms representing the real part of the element and the odd terms   *
*       the imaginary part. The pointer to input array x must point to the  *
*       (nh)th complex sample, i.e. element 2*(nh-1), upon entry to the     *
*       function. The coefficients are expected in normal order.            *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_fir_cplx                                                   *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short *restrict r,                                              *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*       {                                                                   *
*           short i,j;                                                      *
*           int imag, real;                                                 *
*                                                                           *
*           for (i = 0; i < 2*nr; i += 2)                                   *
*           {                                                               *
*               imag = 0;                                                   *
*               real = 0;                                                   *
*               for (j = 0; j < 2*nh; j += 2)                               *
*               {                                                           *
*                   real += h[j] * x[i-j]   - h[j+1] * x[i+1-j];            *
*                   imag += h[j] * x[i+1-j] + h[j+1] * x[i-j];              *
*               }                                                           *
*               r[i]   = (real >> 15);                                      *
*               r[i+1] = (imag >> 15);                                      *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loop is unrolled twice.                                   *
*       The outer loop is conditionally executed in parallel with the       *
*       inner loop.                                                         *
*       Both the inner and outer loops are software pipelined.              *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nh must be even.                                                    *
*       nr * nh >=4.                                                        *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No memory bank hits under any conditions.                           *
*                                                                           *
*   NOTE                                                                    *
*       Little Endian                                                       *
*                                                                           *
*   CYCLES                                                                  *
*       2* nh * nr + 20                                                     *
*                                                                           *
*   CODESIZE                                                                *
*      384 bytes                                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_fir_cplx
_DSP_fir_cplx:
        ;use single assignment or disable interupts, make code interupt tolerant

        STW     .D2     B10,*B15--[4]   ; push register (for c-callable func)

        SHL     .S2     B6,2,B10        ; used to reset the pointer
||      LDW     .D2     *B4++[2],B5     ; h[j] & h[j+1] (real & imag)
||      LDW     .D1     *A4--[2],A5     ; x[i-j] & x[i+1-j]
||      SUB     .L2     B6,2,B1         ; nh - 2
||      MV      .S1X    B15,A2          ;

        ADD     .L1X    B10,4,A0        ; used to reset the pointer
||      CMPGT   .L2     B6,4,B2         ; nh > 4?
||      MPY     .M2X    A8,B6,B0        ; nr*nh, loop counter
||      ADD     .S2     B10,4,B9        ; used to reset the pointer
||      STW     .D2     A10,*B15[1]     ; push register (for c-callable func)
||      STW     .D1     B11,*A2[3]      ;
||      B       .S1     NO_INT

  [!B1] SUB     .S2     B4,B10,B4       ; reset the ptr
||      LDW     .D2     *-B4[1],A3      ; h[j+2] & hi[j+3] (real & imag)
||      LDW     .D1     *+A4[1],B2      ; x[i-2-j] & x[i-1-j]
||[!B1] ADD     .L1     A4,A0,A4        ; reset the ptr
||      MV      .S1X    B6,A7           ; N
||      MPY     .M1     A10,0,A10       ; zero reset counter value
||      SUB     .L2X    A4,4,B11        ; &x[i-2-j]

  [!B1] ADD     .S2     B11,B9,B11      ; reset the ptr
||[B1]  SUB     .L1X    B1,2,A1         ; decrement inner loop counter
||[!B1] SUB     .S1     A7,2,A1         ;* reset inner loop counter
||      LDW     .D2     *B4++[2],B5     ;* h[j] & h[j+1] (real & imag)

        LDW     .D2     *B11--[2],B2    ;* x[i-2-j] & x[i-1-j]
||      LDW     .D1     *A4--[2],A5     ;* x[i-j] & x[i+1-j]
||[B2]  SUB     .S1     A7,4,A10        ; setup reset counter offset
||      ADD     .L2X    A6,2,B6         ; set up reOut ptr to other reg file

        MPYLH   .M2X    A5,B5,B8        ; x[i-j] * h[j+1] (real * imag)
||      MPY     .M1X    A5,B5,A8        ; x[i-j] * h[j]   (real * real)
||[!A1] ADD     .S1     A4,A0,A4        ;* reset the ptr
||      STW     .D2     A11,*B15[2]     ; push register (for c-callable func)

        MPYHL   .M2X    A5,B5,B7        ; x[i+1-j] * h[j]   (imag * real)
||      MPYH    .M1X    A5,B5,A11       ; x[i+1-j] * h[j+1] (imag * imag)
||[B0]  B       .S2     LOOP            ; branch to the loop
||[!A1] SUB     .L2     B4,B10,B4       ;* reset the ptr
||      LDW     .D2     *-B4[1],A3      ;* h[j+2] & h[j+3] (real & imag)
NO_INT:
        MPYLH   .M2X    B2,A3,B7        ; x[i-2-j] * h[j+3] (real * imag)
||      MPY     .M1X    B2,A3,A11       ; x[i-2-j] * h[j+2] (real * real)
||      MVK     .S1     1,A2            ; prevent first stores from executing
||[B0]  SUB     .S2     B0,4,B0         ; decrement loop counter
||[!A1] ADD     .L2     B11,B9,B11      ;* reset the ptr
||[A1]  SUB     .D1     A1,2,A1         ;* decrement inner loop counter
||[!A1] SUB     .L1     A7,2,A1         ;** reset inner loop counter
||      LDW     .D2     *B4++[2],B5     ;** h[j] & h[j+1] (real & imag)

LOOP:
        ADD     .L2     B8,B7,B8        ; imag
||      SUB     .L1     A8,A11,A8       ; real
||      MPYHL   .M2X    B2,A3,B7        ; x[i-1-j] * h[j+2] (imag * real)
||      MPYH    .M1X    B2,A3,A11       ; x[i-1-j] * h[j+3] (imag * imag)
||      LDW     .D1     *A4--[2],A5     ;** x[i-j] & x[i+1-j]
||      LDW     .D2     *B11--[2],B2    ;** x[i-2-j] & x[i-1-j]
||[!A2] SHR     .S2     B1,15,B1        ; final r[i+1]
||[!A2] SHR     .S1     A9,15,A9        ; final r[i]

        ADD     .L2     B8,B7,B1        ; imag
||      ADD     .L1     A8,A11,A9       ; real
||      MPYLH   .M2X    A5,B5,B8        ;* x[i-j] * h[j+1] (real * imag)
||      MPY     .M1X    A5,B5,A8        ;* x[i-j] * h[j]   (real * real)
||[!A1] ADD     .S2     B11,B9,B11      ;** reset the pointer
||[!A1] ADD     .S1     A4,A0,A4        ;** reset the ptr
||[!A2] STH     .D2     B1,*B6++[2]     ; store imOut[0]
||[!A2] STH     .D1     A9,*A6++[2]     ; store reOut[0]

        ADD     .L2     B1,B7,B1        ; imag
||      SUB     .L1     A9,A11,A9       ; real
||      SUB     .D1     A1,A10,A2       ; decrement loop counter
||      MPYHL   .M2X    A5,B5,B7        ;* x[i+1-j] * h[j]   (imag * real)
||      MPYH    .M1X    A5,B5,A11       ;* x[i+1-j] * h[j+1] (imag * imag)
||[B0]  B       .S1     LOOP            ;* branch to the loop
||[!A1] SUB     .S2     B4,B10,B4       ;** reset the ptr
||      LDW     .D2     *-B4[1],A3      ;** h[j+2] & h[j+3] (real & imag)

  [A2]  ADD     .L2     B1,B8,B8        ; imag
||[A2]  ADD     .L1     A9,A8,A8        ; real
||      MPYLH   .M2X    B2,A3,B7        ;* x[i-2-j] * h[j+3] (real * imag)
||      MPY     .M1X    B2,A3,A11       ;* x[i-2-j] * h[j+2] (real * real)
||[B0]  SUB     .S2     B0,2,B0         ;** decrement loop counter
||[A1]  SUB     .D1     A1,2,A1         ;** decrement inner loop counter
||[!A1] SUB     .S1     A7,2,A1         ;*** reset inner loop counter
||      LDW     .D2     *B4++[2],B5     ;*** h[j] & h[j+1] (real & imag)
        ; Loop ends here

        SHR     .S2     B1,15,B1        ; final r[i+1]
||      SHR     .S1     A9,15,A9        ; final r[i]
||      LDW     .D2     *B15[1],A10     ; pop register (for c-callable func)
||      MV      .L1X    B15,A2          ;

        LDW     .D2     *B15[2],A11     ; pop register (for c-callable func)
||      LDW     .D1     *A2[3],B11      ;
||      B       .S2     B3              ; return

        LDW     .D2     *++B15[4],B10   ; pop register (for c-callable func)

        STH     .D2     B1,*B6++        ; store imOut[0]
||      STH     .D1     A9,*A6++        ; store reOut[0]

        NOP     3

* ========================================================================= *
*   End of file:  dsp_fir_cplx.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
fir_gen.asm/    1019093836  0     0     0       17332     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.5     Sun Mar 17 11:25:23 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*     TEXAS INSTRUMENTS, INC.                                               *
*                                                                           *
*     NAME                                                                  *
*           DSP_fir_gen                                                     *
*                                                                           *
*     REVISION DATE                                                         *
*         15-Feb-2002                                                       *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fir_gen                                                    *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short       *restrict r,                                        *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*                                                                           *
*       x[nr+nh-1] : Input array                                            *
*       h[nh]      : Coefficient array. Must be in reverse order.           *
*       r[nr]      : Output array                                           *
*       nh         : Number of coefficients. Must be >= 5.                  *
*       nr         : Number of output samples                               *
*                                                                           *
*   DESCRIPTION                                                             *
*       Computes a real FIR filter (direct-form) using coefficients stored  *
*       in vector h. The coefficients have to be arranged in reverse        *
*       order. The real data input is stored in vector x. The filter        *
*       output result is stored in vector r. It operates on 16-bit data     *
*       with a 32-bit accumulate. The filter is nr output samples and nh    *
*       coefficients.                                                       *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_fir_gen                                                    *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short       *restrict r,                                        *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*       {                                                                   *
*           int i, j, sum;                                                  *
*                                                                           *
*           for (j = 0; j < nr; j++)                                        *
*           {                                                               *
*               sum = 0;                                                    *
*               for (i = 0; i < nh; i++)                                    *
*                   sum += x[i + j] * h[i];                                 *
*               r[j] = sum >> 15;                                           *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loop is unrolled four times, but the last three           *
*       accumulates are executed conditionally to allow for a number of     *
*       coefficients that is not a multiple of four. The outer loop is      *
*       unrolled twice, but the last store is executed conditionally to     *
*       allow for a number of output samples that is not a multiple of      *
*       two. Both the inner and outer loops are software pipelined.         *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nh must be >= 5.                                                    *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No memory bank hits under any conditions.                           *
*                                                                           *
*   NOTES                                                                   *
*      This function is interrupt-tolerant but not interruptible.           *
*      This function is endian neutral.                                     *
*                                                                           *
*   CYCLES                                                                  *
*       (4 * ceil(nh/4) + 9) *  ceil(nr/2) + 18                             *
*                                                                           *
*       For nh = 13, nr = 19: 268 cycles                                    *
*                                                                           *
*   CODESIZE                                                                *
*       640 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_fir_gen
_DSP_fir_gen:

        STW     .D2T1   A14,*B15--[8]    ; push register (for c-callable func)
||      MV      .L1X    B15,A14

        STW     .D2T1   A13,*+B15[6]    ; push register (for c-callable func)
||      STW     .D1T2   B13,*-A14[4]    ; push register (for c-callable func)
||      SUB     .L2     B6,1,B6         ; used to do last h mults if necessary

        STW     .D1T1   A12,*-A14[3]    ; push register (for c-callable func)
||      STW     .D2T2   B11,*+B15[2]    ; push register (for c-callable func)
||      ADD     .S2     B6,4,B6         ; set up inner loop counter
||      AND     .L2     B6,3,B13        ; used to do last h mults if necessary
||      MVK     .S1     7,A13           ; used to do last h mults if necessary

        STW     .D2T2   B12,*+B15[3]    ; push register (for c-callable func)
||      SHR     .S2     B6,2,B12        ; set up inner loop counter
||      AND     .S1     A8,1,A12        ; used to do last r store if necessary
||      ADD     .L1     A8,1,A8         ; set up outer loop counter
||      XOR     .L2     3,B13,B13       ; used to do last h mults if necessary

        STW     .D1T2   B10,*-A14[7]    ; push register (for c-callable func)
||      ADD     .L2X    A6,2,B11        ; set up pointer to r[1]
||      SHR     .S1     A8,1,A2         ; set up outer loop counter

        LDH     .D1     *A4++,B8        ; x0 = x[j]
||      ADD     .L2X    A4,4,B1         ; set up pointer to x[j+2]
||      ADD     .L1X    B4,2,A8         ; set up pointer to h[1]
||[A2]  SUB     .S1     A2,1,A2         ; decrement outer loop counter

        LDH     .D2     *B1++[2],B0     ; x2 = x[j+i+2]
||      LDH     .D1     *A4++[2],A0     ; x1 = x[j+i+1]
||      SHR     .S2X    A13,B13,B13     ; used to do last h mults if necessary
||      XOR     .S1     A12,1,A12       ; used to do last r store if necessary

        LDH     .D1     *A8++[2],B6     ; h1 = h[i+1]
||      LDH     .D2     *B4++[2],A14    ; h0 = h[i]
||      SHL     .S1     B12,3,A3        ; used to rst x pointer each outer loop
||      SHL     .S2     B12,3,B10       ; used to rst h pointer each outer loop

        LDH     .D1     *A4++[2],A5     ; x3 = x[j+i+3]
||      LDH     .D2     *B1++[2],B5     ; x0 = x[j+i+4]
||      ADD     .L1     A3,10,A3                ; used to rst x pointer each outer loop
||      ADD     .L2     B10,8,B10       ; used to rst h pointer each outer loop
||      ADD     .S1X    B13,0,A13       ; used to do last h mults if necessary

OUTLOOP:
        LDH     .D2     *B4++[2],A7     ; h2 = h[i+2]
||      LDH     .D1     *A8++[2],B8     ; h3 = h[i+3]
||      ZERO    .L1     A9              ; zero out sum0
||      ZERO    .L2     B9              ; zero out sum1
||      B               NO_INT

        LDH     .D2     *B1++[2],B0     ;* x2 = x[j+i+2]
||      LDH     .D1     *A4++[2],A0     ;* x1 = x[j+i+1]
||      SUB     .S2     B12,2,B2        ; set up inner loop counter

        LDH     .D1     *A8++[2],B6     ;* h1 = h[i+1]
||      LDH     .D2     *B4++[2],A14    ;* h0 = h[i]

        MPY     .M1X    B8,A14,A0       ; x0 * h0
||      MPY     .M2X    A0,B6,B6        ; x1 * h1
||      LDH     .D1     *A4++[2],A5     ;* x3 = x[j+i+3]
||      LDH     .D2     *B1++[2],B5     ;* x0 = x[j+i+4]

  [B2]  B       .S1     LOOP            ; branch to loop
||      MPY     .M2     B0,B6,B7        ; x2 * h1
||      MPY     .M1     A0,A14,A14      ; x1 * h0
||      LDH     .D2     *B4++[2],A7     ;* h2 = h[i+2]
||      LDH     .D1     *A8++[2],B8     ;* h3 = h[i+3]
||[B2]  SUB     .S2     B2,1,B2         ;* decrement loop counter

        ADD     .L1     A0,A9,A9        ; sum0 += x0 * h0
||      MPY     .M2X    A5,B8,B8        ; x3 * h3
||      MPY     .M1X    B0,A7,A5        ; x2 * h2
||      LDH     .D2     *B1++[2],B0     ;** x2 = x[j+i+2]
||      LDH     .D1     *A4++[2],A0     ;** x1 = x[j+i+1]

NO_INT:
LOOP:
        ADD     .L2X    A14,B9,B9       ; sum1 += x1 * h0
||      ADD     .L1X    B6,A9,A9        ; sum0 += x1 * h1
||      MPY     .M2     B5,B8,B7        ; x0 * h3
||      MPY     .M1     A5,A7,A7        ; x3 * h2
||      LDH     .D1     *A8++[2],B6     ;** h1 = h[i+1]
||      LDH     .D2     *B4++[2],A14    ;** h0 = h[i]

        ADD     .L2     B7,B9,B9        ; sum1 += x2 * h1
||      ADD     .L1     A5,A9,A9        ; sum0 += x2 * h2
||      MPY     .M1X    B5,A14,A0       ;* x0 * h0
||      MPY     .M2X    A0,B6,B6        ;* x1 * h1
||      LDH     .D1     *A4++[2],A5     ;** x3 = x[j+i+3]
||      LDH     .D2     *B1++[2],B5     ;** x0 = x[j+i+4]

        ADD     .L2X    A7,B9,B9        ; sum1 += x3 * h2
||      ADD     .L1X    B8,A9,A9        ; sum0 += x3 * h3
||[B2]  B       .S1     LOOP            ;* branch to loop
||      MPY     .M2     B0,B6,B7        ;* x2 * h1
||      MPY     .M1     A0,A14,A14      ;* x1 * h0
||      LDH     .D2     *B4++[2],A7     ;** h2 = h[i+2]
||      LDH     .D1     *A8++[2],B8     ;** h3 = h[i+3]
||[B2]  SUB     .S2     B2,1,B2         ;** decrement loop counter

        ADD     .L2     B7,B9,B9        ; sum1 += x0 * h3
||      ADD     .L1     A0,A9,A9        ;* sum0 += x0 * h0
||      MPY     .M2X    A5,B8,B8        ;* x3 * h3
||      MPY     .M1X    B0,A7,A5        ;* x2 * h2
||      LDH     .D2     *B1++[2],B0     ;*** x2 = x[j+i+2]
||      LDH     .D1     *A4++[2],A0     ;*** x1 = x[j+i+1]
||[!B2] AND     .S1     A13,1,A1        ; nh % 4 >= 1? (for h1)
        ; inner loop branch occurs here

        ADD     .L2X    A14,B9,B9       ;e sum1 += x1 * h0
||[A1]  ADD     .L1X    B6,A9,A9        ;e sum0 += x1 * h1
||      MPY     .M2     B5,B8,B7        ;e x0 * h3
||      MPY     .M1     A5,A7,A7        ;e x3 * h2
||      SUB     .D1     A4,A3,A4        ;o reset x pointer to x[j]
||      SUB     .D2     B4,B10,B4       ;o reset h pointer to h[0]
||      AND     .S2     B13,2,B2        ;e nh % 4 >= 2? (for h2)

  [A1]  ADD     .D2     B7,B9,B9        ;e sum1 += x2 * h1
||[B2]  ADD     .L1     A5,A9,A9        ;e sum0 += x2 * h2
||      LDH     .D1     *A4++,B8        ;p x0 = x[j]
||      ADD     .L2X    A4,4,B1         ;p set up pointer to x[j+2]
||      ADD     .S1X    B4,2,A8         ;p set up pointer to h[1]
||[A2]  B       .S2     OUTLOOP         ;o branch to outer loop

        AND     .S1     A13,4,A1        ;e nh % 4 >= 3? (for h3)
||      ADD     .L2     B8,0,B0         ;e save B8
||      ADD     .L1     A7,0,A0         ;e save A0

  [B2]  ADD     .L2X    A0,B9,B9        ;e sum1 += x3 * h2
||[A1]  ADD     .L1X    B0,A9,A9        ;e sum0 += x3 * h3
||      LDH     .D2     *B1++[2],B0     ;p x2 = x[j+i+2]
||      LDH     .D1     *A4++[2],A0     ;p x1 = x[j+i+1]

  [A1]  ADD     .L2     B7,B9,B9        ;e sum1 += x0 * h3
||      SHR     .S1     A9,15,A9        ;e sum0 >> 15
||      LDH     .D1     *A8++[2],B6     ;p h1 = h[i+1]
||[A2]  LDH     .D2     *B4++[2],A14    ;p h0 = h[i]
||      OR      .L1     A12,A2,A1       ;e nr % 2 = 1? OR outer loop not done (for last nr)

        SHR     .S2     B9,15,B9        ;e sum1 >> 15
||      LDH     .D1     *A4++[2],A5     ;p x3 = x[j+i+3]
||      LDH     .D2     *B1++[2],B5     ;p x0 = x[j+i+4]
||[A2]  SUB     .S1     A2,1,A2         ;o decrement outer loop counter

        STH     .D1     A9,*A6++[2]     ;e r[j] = sum0 >> 15
||[A1]  STH     .D2     B9,*B11++[2]    ;e r[j+1] = sum1 >> 15
        ; outer loop branch occurs here

        LDW     .D2T2   *+B15[1],B10      ; pop register (for c-callable func)
||      MV      .L1X    B15,A14

        LDW     .D2T2   *+B15[3],B12      ; pop register (for c-callable func)
||      LDW     .D1T1   *+A14[6],A13      ; pop register (for c-callable func)

        LDW     .D2T2   *+B15[4],B13      ; pop register (for c-callable func)
||      LDW     .D1T1   *+A14[5],A12      ; pop register (for c-callable func)
||      B       .S2     B3                ; return

        LDW     .D2T1   *++B15[8],A14     ; pop register (for c-callable func)
||      LDW     .D1T2   *+A14[2],B11      ; pop register (for c-callable func)

        NOP     4

* ========================================================================= *
*   End of file:  dsp_fir_gen.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
fir_r4.asm/     1019093836  0     0     0       15035     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Fri Mar 22 01:51:54 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_fir_r4                                                          *
*                                                                           *
*   REVISION DATE                                                           *
*       25-Feb-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fir_r4                                                     *
*       (                                                                   *
*           const short *x,                                                 *
*           const short *h,                                                 *
*           short       *r,                                                 *
*           int nh,                                                         *
*           int nr                                                          *
*       );                                                                  *
*                                                                           *
*       x[nr+nh-1]: Input samples.                                          *
*       h[nh]     : Filter coefficients. Must be in reverse order.          *
*       r[nr]     : Output samples.                                         *
*       nh        : Number of filter coefficients.                          *
*                   Must be multiple of 4 and >= 8.                         *
*       nr        : Number of output samples.                               *
*                   Must be multiple of 2.                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       Computes a real FIR filter (direct-form) using coefficients stored  *
*       in vector h.  The real data input is stored in vector x. The        *
*       filter output is stored in vector r. The filter computes nr output  *
*       samples and nh coefficients. It operates on 16-bit data with a      *
*       32-bit accumulate.                                                  *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_fir_r4                                                     *
*       (                                                                   *
*           const short *x,                                                 *
*           const short *h,                                                 *
*           short       *r,                                                 *
*           int nh,                                                         *
*           int nr                                                          *
*       )                                                                   *
*       {                                                                   *
*          int i, j, sum;                                                   *
*                                                                           *
*          for (j = 0; j < nr; j++)                                         *
*          {                                                                *
*             sum = 0;                                                      *
*             for (i = 0; i < nh; i++)                                      *
*               sum += x[i + j] * h[i];                                     *
*             r[j] = sum >> 15;                                             *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nh must be a multiple of 4 and >= 8.                                *
*       nr must be a multiple of 2 and >= 2.                                *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No memory bank hits under any conditions.                           *
*       This code is Endian neutral.                                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       The assembly routine performs 2 output samples at a time.           *
*       The inner loop is unrolled four times.  The outer loop is unrolled  *
*       twice. Both the inner and outer loops are software pipelined.       *
*                                                                           *
*   CYCLES                                                                  *
*       (8 + nh) * nr/2 + 14                                                *
*                                                                           *
*   CODESIZE                                                                *
*       544 bytes                                                           *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_fir_r4
_DSP_fir_r4:

        ;add assembly code here
        STW     .D2     B10,*B15--[4]   ; push register (for c-callable func)

        STW     .D2     B11,*B15[1]     ; push register (for c-callable func)
||      SHR     .S1     A8,1,A2         ; set up outer loop counter
||      ADD     .L2     B6,B6,B10       ; used to rst h pointer each outer loop
||      B               OUTLOOP

        STW     .D2     B12,*B15[2]     ; push register (for c-callable func)
||      ADD     .L1X    B10,10,A3       ; used to rst x pointer each outer loop
||      ADD     .S2     B10,8,B10       ; used to rst h pointer each outer loop
||      ADD     .L2X    A6,2,B11        ; set up pointer to r[1]

        LDH     .D1     *A4++,B8        ; x0 = x[j]
||      ADD     .L2X    A4,4,B1         ; set up pointer to x[j+2]
||      ADD     .L1X    B4,2,A8         ; set up pointer to h[1]
||      SHR     .S2     B6,2,B12        ; set up inner loop counter
||[A2]  SUB     .S1     A2,1,A2         ; decrement outer loop counter

        LDH     .D2     *B1++[2],B0     ; x2 = x[j+i+2]
||      LDH     .D1     *A4++[2],A0     ; x1 = x[j+i+1]

        LDH     .D1     *A8++[2],B6     ; h1 = h[i+1]
||      LDH     .D2     *B4++[2],A1     ; h0 = h[i]

        LDH     .D1     *A4++[2],A5     ; x3 = x[j+i+3]
||      LDH     .D2     *B1++[2],B5     ; x0 = x[j+i+4]

OUTLOOP:
        LDH     .D2     *B4++[2],A7     ; h2 = h[i+2]
||      LDH     .D1     *A8++[2],B8     ; h3 = h[i+3]
||      ZERO    .L1     A9              ; zero out sum0
||      ZERO    .L2     B9              ; zero out sum1
||      B               LOOP            ; mask ints

        LDH     .D2     *B1++[2],B0     ;* x2 = x[j+i+2]
||      LDH     .D1     *A4++[2],A0     ;* x1 = x[j+i+1]
||      SUB     .S2     B12,2,B2        ; set up inner loop counter

        LDH     .D1     *A8++[2],B6     ;* h1 = h[i+1]
||      LDH     .D2     *B4++[2],A1     ;* h0 = h[i]

        MPY     .M1X    B8,A1,A0        ; x0 * h0
||      MPY     .M2X    A0,B6,B6        ; x1 * h1
||      LDH     .D1     *A4++[2],A5     ;* x3 = x[j+i+3]
||      LDH     .D2     *B1++[2],B5     ;* x0 = x[j+i+4]

  [B2]  B       .S1     LOOP            ; branch to loop
||      MPY     .M2     B0,B6,B7        ; x2 * h1
||      MPY     .M1     A0,A1,A1        ; x1 * h0
||      LDH     .D2     *B4++[2],A7     ;* h2 = h[i+2]
||      LDH     .D1     *A8++[2],B8     ;* h3 = h[i+3]
||[B2]  SUB     .S2     B2,1,B2         ;* decrement loop counter

        ADD     .L1     A0,A9,A9        ; sum0 += x0 * h0
||      MPY     .M2X    A5,B8,B8        ; x3 * h3
||      MPY     .M1X    B0,A7,A5        ; x2 * h2
||      LDH     .D2     *B1++[2],B0     ;** x2 = x[j+i+2]
||      LDH     .D1     *A4++[2],A0     ;** x1 = x[j+i+1]

LOOP:
        ADD     .L2X    A1,B9,B9        ; sum1 += x1 * h0
||      ADD     .L1X    B6,A9,A9        ; sum0 += x1 * h1
||      MPY     .M2     B5,B8,B7        ; x0 * h3
||      MPY     .M1     A5,A7,A7        ; x3 * h2
||      LDH     .D1     *A8++[2],B6     ;** h1 = h[i+1]
||      LDH     .D2     *B4++[2],A1     ;** h0 = h[i]

        ADD     .L2     B7,B9,B9        ; sum1 += x2 * h1
||      ADD     .L1     A5,A9,A9        ; sum0 += x2 * h2
||      MPY     .M1X    B5,A1,A0        ;* x0 * h0
||      MPY     .M2X    A0,B6,B6        ;* x1 * h1
||      LDH     .D1     *A4++[2],A5     ;** x3 = x[j+i+3]
||      LDH     .D2     *B1++[2],B5     ;** x0 = x[j+i+4]

        ADD     .L2X    A7,B9,B9        ; sum1 += x3 * h2
||      ADD     .L1X    B8,A9,A9        ; sum0 += x3 * h3
||[B2]  B       .S1     LOOP            ;* branch to loop
||      MPY     .M2     B0,B6,B7        ;* x2 * h1
||      MPY     .M1     A0,A1,A1        ;* x1 * h0
||      LDH     .D2     *B4++[2],A7     ;** h2 = h[i+2]
||      LDH     .D1     *A8++[2],B8     ;** h3 = h[i+3]
||[B2]  SUB     .S2     B2,1,B2         ;** decrement loop counter

        ADD     .L2     B7,B9,B9        ; sum1 += x0 * h3
||      ADD     .L1     A0,A9,A9        ;* sum0 += x0 * h0
||      MPY     .M2X    A5,B8,B8        ;* x3 * h3
||      MPY     .M1X    B0,A7,A5        ;* x2 * h2
||      LDH     .D2     *B1++[2],B0     ;*** x2 = x[j+i+2]
||      LDH     .D1     *A4++[2],A0     ;*** x1 = x[j+i+1]
        ; inner loop branch occurs here

        ADD     .L2X    A1,B9,B9        ;e sum1 += x1 * h0
||      ADD     .L1X    B6,A9,A9        ;e sum0 += x1 * h1
||      MPY     .M2     B5,B8,B7        ;e x0 * h3
||      MPY     .M1     A5,A7,A7        ;e x3 * h2
||      SUB     .D1     A4,A3,A4        ;o reset x pointer to x[j]
||      SUB     .D2     B4,B10,B4       ;o reset h pointer to h[0]
||[A2]  B       .S1     OUTLOOP         ;o branch to outer loop

        ADD     .D2     B7,B9,B9        ;e sum1 += x2 * h1
||      ADD     .L1     A5,A9,A9        ;e sum0 += x2 * h2
||      LDH     .D1     *A4++,B8        ;p x0 = x[j]
||      ADD     .L2X    A4,4,B1         ;p set up pointer to x[j+2]
||      ADD     .S1X    B4,2,A8         ;p set up pointer to h[1]

        ADD     .L2X    A7,B9,B9        ;e sum1 += x3 * h2
||      ADD     .L1X    B8,A9,A9        ;e sum0 += x3 * h3
||      LDH     .D2     *B1++[2],B0     ;p x2 = x[j+i+2]
||      LDH     .D1     *A4++[2],A0     ;p x1 = x[j+i+1]
||[A2]  SUB     .S1     A2,1,A2         ;o decrement outer loop counter

        ADD     .L2     B7,B9,B9        ;e sum1 += x0 * h3
||      SHR     .S1     A9,15,A9        ;e sum0 >> 15
||      LDH     .D1     *A8++[2],B6     ;p h1 = h[i+1]
||      LDH     .D2     *B4++[2],A1     ;p h0 = h[i]

        SHR     .S2     B9,15,B9        ;e sum1 >> 15
||      LDH     .D1     *A4++[2],A5     ;p x3 = x[j+i+3]
||      LDH     .D2     *B1++[2],B5     ;p x0 = x[j+i+4]

        STH     .D1     A9,*A6++[2]     ;e r[j] = sum0 >> 15
||      STH     .D2     B9,*B11++[2]    ;e r[j+1] = sum1 >> 15
        ; outer loop branch occurs here

        LDW     .D2     *B15[2],B12     ; pop register (for c-callable func)

        LDW     .D2     *B15[1],B11     ; pop register (for c-callable func)
||      B       .S2     B3              ; return


        LDW     .D2     *++B15[4],B10   ; pop register (for c-callable func)

        NOP     4

* ========================================================================= *
*   End of file:  dsp_fir_r4.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

fir_r8.asm/     1019093836  0     0     0       15857     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Thu Apr 18 00:44:13 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_fir_r8                                                          *
*                                                                           *
*   REVISION DATE                                                           *
*       25-Feb-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fir_r8                                                     *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short *restrict r,                                              *
*           int nh,                                                         *
*           int nr                                                          *
*       );                                                                  *
*                                                                           *
*       x[nr+nh-1]: Input samples.                                          *
*                   Must be word-aligned.                                   *
*       h[nh]     : Filter coefficients. Must be in reverse order.          *
*                   Must be word-aligned.                                   *
*       r[nr]     : Output samples.                                         *
*       nh        : Number of filter coefficients.                          *
*                   Must be multiple of 8 and >= 8.                         *
*       nr        : Number of output samples.                               *
*                   Must be multiple of 2.                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       Computes a real FIR filter (direct-form) using coefficients stored  *
*       in vector h.  The real data input is stored in vector x. The        *
*       filter output is stored in vector r. The filter computes nr output  *
*       samples and nh coefficients. It operates on 16-bit data with a      *
*       32-bit accumulate.                                                  *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_fir_r8                                                     *
*       (                                                                   *
*           const short *restrict x,                                        *
*           const short *restrict h,                                        *
*           short *restrict r,                                              *
*           int nh,                                                         *
*           int nr                                                          *
*       );                                                                  *
*       {                                                                   *
*          int i, j, sum;                                                   *
*                                                                           *
*          for (j = 0; j < nr; j++)                                         *
*          {                                                                *
*             sum = 0;                                                      *
*             for (i = 0; i < nh; i++)                                      *
*               sum += x[i + j] * h[i];                                     *
*             r[j] = sum >> 15;                                             *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nh must be a multiple of 8 and >= 8.                                *
*       nr must be a multiple of 2 and >= 2.                                *
*       x[] and h[] must be word-aligned.                                   *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No memory bank hits under any conditions.                           *
*       This code is LIITLE ENDIAN.                                         *
*                                                                           *
*   TECHNIQUES                                                              *
*       The assembly routine performs 2 output samples at a time.           *
*       The inner loop is unrolled eight times.  The outer loop is unrolled *
*       twice. Both the inner and outer loops are software pipelined.       *
*                                                                           *
*   CYCLES                                                                  *
*       nh * nr/2 + 28                                                      *
*                                                                           *
*   CODESIZE                                                                *
*       544 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *



        .text
        .global _DSP_fir_r8
_DSP_fir_r8:
        STW     .D2T1   A15, *B15--[12] ; Get stk, Save A15
||      MV      .S1X    B15, A3         ; Twin Stack Ptr

        STW     .D1T1   A14, *-A3[ 1]   ; Save A14
||      STW     .D2T2   B14, *+B15[10]  ; Save B14
||      MVC     .S2     CSR, B9         ; Get CSR's state

        STW     .D1T1   A13, *-A3[ 3]   ; Save A13
||      STW     .D2T2   B13, *+B15[ 8]  ; Save B13
||      AND     .L2     B9,  -2, B0     ; Clear GIE

        STW     .D1T1   A12, *-A3[ 5]   ; Save A12
||      STW     .D2T2   B12, *+B15[ 6]  ; Save B12

        MPY     .M2     B6,2,B5         ; used to reset h ptr (16*nh/8)
||      SHR     .S1X    B6,3,A5         ; set pointer reset lp cntr (nh/8)
||      ADD     .L2X    A6,2,B6         ; point to r[j+1]
||      STW     .D1T1   A11, *-A3[7]    ; Save A11
||      STW     .D2T2   B11, *+B15[4]   ; Save B11
||      MVC     .S2     B0, CSR         ; Disable ints.

        SHR     .S2X    A8,1,B0         ; nr/2
||      ZERO    .S1     A2              ; set store lp cntr (nh/8+1)
||      STW     .D1T1   A10, *-A3[ 9]   ; Save A10
||      STW     .D2T2   B10, *+B15[2]   ; Save B10

        MV      .L1X    B4,A0           ; point to h[0] & h[1]
||      ADD     .S2     B4,4,B14        ; point to h[2] & h[3]
||      MV      .L2X    A4,B1           ; point to x[j] & x[j+1]
||      ADD     .S1     A4,4,A4         ; point to x[j+2] & x[j+3]
||      STW     .D1T2   B9, *-A3[11]    ; Save CSR

        LDW     .D1     *A4++[2],B9     ; x[j+i+2] & x[j+i+3]
||      LDW     .D2     *B1++[2],A10    ; x[j+i+0] & x[j+i+1]
||      MV      .L1     A5,A1           ; set pointer reset lp cntr (nh/8)
||      MPY     .M2X    A5,B0,B0        ; set up loop counter ((nh/8)*(nr/2))
||      SUB     .S1X    B5,4,A3         ; used to reset x ptr (16*nh/8-4)
||      ZERO    .L2     B11             ; zero out initial accumulator
||      MVK     .S2     2,B2            ; initialize loop priming count

LOOP:
  [!A2] SHR     .S1     A10,15,A12      ; (Asum0 >> 15)
||      MPYH    .M2     B7,B9,B13       ; p03 = h[i+3]*x[j+i+3]
||[A2]  ADD     .L1     A7,A10,A7       ; sum0(p00) = p00 + sum0
||      MPYHL   .M1X    B7,A11,A10      ; p13 = h[i+3]*x[j+i+4]
||      ADD     .L2X    A14,B4,B7       ; sum1 += p11
||      LDW     .D2     *B14++[2],B7    ;* h[i+2] & h[i+3]
||      LDW     .D1     *A0++[2],A8     ;* h[i+0] & h[i+1]
||[B2]  SUB     .S2     B2,1,B2         ; dec loop priming count

        ADD     .L1     A10,A7,A13      ; sum0 += p01
||      MPYHL   .M2X    A9,B10,B12      ; p15 = h[i+5]*x[j+i+6]
||      MPYLH   .M1     A9,A11,A10      ; p14 = h[i+4]*x[j+i+5]
||      ADD     .L2     B13,B7,B7       ; sum1 +=  p12
||      LDW     .D2     *B1++[2],A11    ;* x[j+i+4] & x[j+i+5]
||      LDW     .D1     *A4++[2],B10    ;* x[j+i+6] & x[j+i+7]
||[A1]  SUB     .S1     A1,1,A1         ;* dec pointer reset lp cntr
||[!B2] SUB     .S2     B0,1,B0         ; dec outer lp cntr

  [B0]  B       .S2     LOOP            ; Branch outer loop
||      MPY     .M1     A9,A11,A11      ; p04 = h[i+4]*x[j+i+4]
||      ADD     .L1X    B9,A13,A13      ; sum0 += p02
||      MPYLH   .M2     B8,B10,B13      ; p16 = h[i+6]*x[j+i+7]
||      ADD     .L2X    A10,B7,B7       ; sum1 += p13
||      LDW     .D1     *A0++[2],A9     ;* h[i+4] & h[i+5]
||      LDW     .D2     *B14++[2],B8    ;* h[i+6] & h[i+7]
||[!A1] SUB     .S1     A4,A3,A4        ;* reset x ptr

        MPY     .M2     B8,B10,B11      ; p06 = h[i+6]*x[j+i+6]
||      MPYH    .M1     A9,A11,A11      ; p05 = h[i+5]*x[j+i+5]
||      ADD     .L1X    B13,A13,A9      ; sum0 += p03
||      ADD     .L2X    A10,B7,B7       ; sum1 += p14
||[!A1] SUB     .S2     B1,B5,B1        ;* reset x ptr
||[!A1] SUB     .S1     A0,A3,A0        ;* reset h ptr
||      LDH     .D2     *B1,A8          ;* x[j+i+8]
||[B2]  ADD     .D1     A5,1,A2         ; set store lp cntr (nh/8+1)

  [!A2] MV      .S1     A5,A2           ; reset store lp cntr (nh/8)
||      MPYH    .M2     B8,B10,B13      ; p07 = h[i+7]*x[j+i+7]
||      ADD     .L1     A11,A9,A9       ; sum0 += p04
||      MPYHL   .M1X    B8,A8,A9        ; p17 = h[i+7]*x[j+i+8]
||      ADD     .S2     B12,B7,B10      ; sum1 += p15
||[!A2] STH     .D2     B11,*B6++[2]    ; r[j+1] = (Bsum1 >> 15)
||[!A2] STH     .D1     A12,*A6++[2]    ; r[j] = (Asum0 >> 15)
||      ADD     .L2X    A10,0,B8        ;* move to other reg file

        ADD     .L1     A11,A9,A12      ; sum0 += p05
||      ADD     .L2     B13,B10,B8      ; sum1 += p16
||      MPYLH   .M2X    A8,B8,B4        ;* p10 = h[i+0]*x[j+i+1]
||[!A1] SUB     .D2     B14,B5,B14      ;* reset h ptr
||      MPYHL   .M1X    A8,B9,A14       ;* p11 = h[i+1]*x[j+i+2]
||[!A1] ADD     .S2     B1,4,B1         ;* reset x ptr
||[!A1] SUB     .S1     A0,4,A0         ;* reset x ptr

  [!B2] ADD     .L2X    A9,B8,B11       ; sum1 += p17
||      ADD     .L1X    B11,A12,A12     ; sum0 += p06
||      MPY     .M1     A8,A10,A7       ;* p00 = h[i+0]*x[j+i+0]
||      MPYLH   .M2     B7,B9,B13       ;* p12 = h[i+2]*x[j+i+3]
||[A2]  SUB     .D1     A2,1,A2         ;* dec store lp cntr
||[!A1] MV      .S1     A5,A1           ;* reset pointer reset lp cntr (nh/8)
||[B2]  ZERO    .D2     B11             ; zero out initial accumulator

  [!B2] ADD     .L1X    B13,A12,A10     ; sum0 += p07
||[!A2] SHR     .S2     B11,15,B11      ;* (Bsum1 >> 15)
||      MPY     .M2     B7,B9,B9        ;* p02 = h[i+2]*x[j+i+2]
||      MPYH    .M1     A8,A10,A10      ;* p01 = h[i+1]*x[j+i+1]
||[A2]  ADD     .L2     B4,B11,B4       ;* sum1(p10) = p10 + sum1
||      LDW     .D1     *A4++[2],B9     ;** x[j+i+2] & x[j+i+3]
||      LDW     .D2     *B1++[2],A10    ;** x[j+i+0] & x[j+i+1]
||[B2]  ZERO    .S1     A10             ; zero out initial accumulator
        ; Loop ends here

        SHR     .S1     A10,15,A12      ; (Asum0 >> 15)
||      LDW     .D2T1   *+B15[1],   A0  ; Get CSR's value

        STH     .D2T2   B11,*B6++[2]    ; r[j+1] = (Bsum1 >> 15)
||      STH     .D1T1   A12,*A6++[2]    ; r[j] = (Asum0 >> 15)
||      MV              B15,        A3  ; Twin Stack Pointer

        LDW     .D1T2   *+A3[2],    B10 ; Restore B10
||      LDW     .D2T1   *+B15[3],   A10 ; Restore A10

        LDW     .D1T2   *+A3[4],    B11 ; Restore B11
||      LDW     .D2T1   *+B15[5],   A11 ; Restore A11

        LDW     .D1T2   *+A3[6],    B12 ; Restore B12
||      LDW     .D2T1   *+B15[7],   A12 ; Restore A12

        LDW     .D1T2   *+A3[8],    B13 ; Restore B13
||      LDW     .D2T1   *+B15[9],   A13 ; Restore A13

        LDW     .D1T2   *+A3[10],   B14 ; Restore B14
||      LDW     .D2T1   *+B15[11],  A14 ; Restore A14
||      B       .S2     B3              ; Return to caller

        MVC     .S2X    A0,         CSR ; Restore CSR
||      LDW     .D2T1   *++B15[12], A15 ; Restore A15

        NOP             4

* ========================================================================= *
*   End of file:  dsp_fir_r8.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

firlms2.asm/    1019093836  0     0     0       11896     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Sun Mar 10 00:53:44 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_firlms2                                                         *
*                                                                           *
*   REVISION DATE                                                           *
*       06-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       long DSP_firlms2                                                    *
*       (                                                                   *
*           short       *restrict h,    // Coefficient Array           //   *
*           const short *restrict x,    // Input Array                 //   *
*           short b,                    // Error of from previous FIR  //   *
*           int   nh                    // Number of coefficients      //   *
*       );                                                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This is an Least Mean Squared Adaptive FIR Filter.  Given the       *
*       error from the previous sample and pointer to the next sample       *
*       it computes an update of the coefficents and then performs          *
*       the FIR for the given input. Coefficents h[], input x[] and error   *
*       b are in Q.15 format. The output sample is returned as Q.30.        *
*                                                                           *
*       long DSP_firlms2                                                    *
*       (                                                                   *
*           short       *restrict h,                                        *
*           const short *restrict x,                                        *
*           short b,                                                        *
*           int   nh                                                        *
*       )                                                                   *
*       {                                                                   *
*           int  i;                                                         *
*           long r = 0;                                                     *
*                                                                           *
*           for (i = 0; i < nh; i++)                                        *
*           {                                                               *
*               h[i] += (x[i    ] * b) >> 15;                               *
*               r    +=  x[i + 1] * h[i];                                   *
*           }                                                               *
*                                                                           *
*           return r;                                                       *
*       }                                                                   *
*                                                                           *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled once.                                          *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The number of coefficients nh must be a multiple of 2.              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This routine has no memory hits.                                    *
*                                                                           *
*   NOTES                                                                   *
*       This routine is interupt-tolerant but not interruptible.            *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   CYCLES                                                                  *
*       3 * nh/2 + 26                                                       *
*       For nh = 24: 62 cycles                                              *
*       For nh = 16: 50 cycles                                              *
*                                                                           *
*   CODESIZE                                                                *
*       256 bytes.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_firlms2
_DSP_firlms2:

                STW     .D2     B10,    *B15--[6]       ; push B10 on the stack
||              MV      .L1X    B15,    A8              ; copy stack pointer

                STW     .D2     A10,    *B15[4]         ; push A10 on the stack
||              STW     .D1     B11,    *-A8[3]         ; push B11 on the stack
||              MV      .L1X    B3,     A1              ; move return address
||              MV      .L2X    A6,     B5              ; copy b

                B       .S1     LOOP                    ; for i
||              MVK     .S2     4,      B1              ; setup priming
||              ADD     .L1X    2,      B4,     A3      ; copy x
||              LDH     .D2     *B4++[2],       A0      ;**** x0  = *x++, j=1

                ADD     .L2X    A4,     2,      B3      ; copy h
||              SHR     .S2     B6,     1,      B0      ; nh / 2
||              STW     .D2     A11,    *B15[2]         ;push A11 on the stack
||              STW     .D1     B12,    *-A8[5]         ; push B12 on the stack

                ADD     .S2     1,      B0,     B0      ; nh/2 + 1
||              ZERO    .L1     A11:A10                 ; y = 0
||              ZERO    .L2     B9:B8                   ; y = 0
||              LDH     .D1     *A3++[2],       B2      ;**** x0  = *x++, j=0
||              LDH     .D2     *B4++[2],       A0      ;**** x0  = *x++, j=1
LOOP:
        [B0]    B       .S1     LOOP                    ;* for i
||              MV      .L1X    B2,     A5              ;* copy x0, j=0
||              MPY     .M2X    1,      A0,     B6      ;* copy x0, j=1
||              SHR     .S2     B10,    15,     B10     ;* e  = f >> 15, j=1
||              MPY     .M1     A0,     A6,     A9      ;** f  = x0 * b, j=0
||              LDH     .D1     *A4++[2],       A2      ;*** h0  = *h++, j=0
||              LDH     .D2     *B3++[2],       B12     ;*** h0  = *h++, j=1
||      [B1]    SUB     .L2     B1,     1,      B1      ;* priming count

        [!B1]   STH     .D1     A7,     *-A4[8]         ; h[-1] = h1, j=0
||      [!B1]   STH     .D2     B7,     *-B3[8]         ; h[-1] = h1, j=1
||              ADD     .S1     A9,     A2,     A7      ;* h1  = h0 + e, j=0
||              ADD     .S2     B10,    B12,    B7      ;* h1  = h0 + e, j=1
||              MPY     .M2     B2,     B5,     B10     ;** f  = x0 * b, j=1

        [B0]    SUB     .S2     B0,     1,      B0      ; i++
||      [!B1]   ADD     .L1     A8,     A11:A10,A11:A10 ; y += p, j=0
||      [!B1]   ADD     .L2     B11,    B9:B8,  B9:B8   ; y += p, j=1
||              MPY     .M1     A5,     A7,     A8      ;* p  = x0 * h1, j=0
||              MPY     .M2     B6,     B7,     B11     ;* p  = x0 * h1, j=1
||              SHR     .S1     A9,     15,     A9      ;** e  = f >> 15, j=0
||              LDH     .D1     *A3++[2],       B2      ;**** x0  = *x++, j=0
||              LDH     .D2     *B4++[2],       A0      ;**** x0  = *x++, j=1
; end of LOOP

                LDW     .D2     *+ B15[4],      A10     ; pop A10 off stack
||              MV      .L2X    A1,     B3              ; move return address
||              MV      .L1X    B8,     A4              ;

                LDW     .D2     *+ B15[3],      B11     ; pop B11 off stack
||              ADD     .L1X    A11,    B9,     A5      ; sum sums

                LDW     .D2     *+ B15[2],      A11     ; pop A11 off stack
||              ADDU    .L1     A10,    A5:A4,  A5:A4   ; sum sums

                LDW     .D2     *+ B15[1],      B12     ; pop B12 off stack
||              B       .S2     B3

                LDW     .D2     *++B15[6],      B10     ; pop B10 off stack

                NOP     4

* ========================================================================= *
*   End of file:  dsp_firlms2.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
fltoq15.asm/    1019093836  0     0     0       14688     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Sun Mar 10 00:34:40 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*     TEXAS INSTRUMENTS, INC.                                               *
*                                                                           *
*     NAME                                                                  *
*           DSP_fltoq15                                                     *
*                                                                           *
*     REVISION DATE                                                         *
*         27-Jul-2001                                                       *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fltoq15                                                    *
*       (                                                                   *
*           const float *restrict x,                                        *
*           short       *restrict r,                                        *
*           int         nx                                                  *
*       );                                                                  *
*                                                                           *
*       x[nx] :  Pointer to values of type float                            *
*       r[nx] :  Contains Q15 values of x[nx]                               *
*       nx    :  Number of elements in arrays                               *
*                                                                           *
*   DESCRIPTION                                                             *
*       Convert the IEEE floating point numbers stored in vector x[] into   *
*       Q.15 format numbers stored in vector r[]. Results will be rounded   *
*       towards negative infinity. All values that exceed the size limit    *
*       will be saturated to 0x7fff if value is positive and 0x8000 if      *
*       value is negative.                                                  *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_fltoq15                                                    *
*       (                                                                   *
*           const float *restrict x,                                        *
*           short       *restrict r,                                        *
*           int         nx                                                  *
*       )                                                                   *
*       {                                                                   *
*           int i, a;                                                       *
*                                                                           *
*           for(i = 0; i < nx; i++)                                         *
*           {                                                               *
*               a = floor(32768 * x[i]);                                    *
*                                                                           *
*               // saturate to 16-bit //                                    *
*               if (a>32767)  a =  32767;                                   *
*               if (a<-32768) a = -32768;                                   *
*                                                                           *
*               r[i] = (short) a;                                           *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Loop is unrolled twice.                                             *
*       Collapsed 1 epilog stage, 2 prolog stages                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx >= 2 and a multiple of 2                                         *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt-tolerant but not interruptible.              *
*       This implementation is ENDIAN NEUTRAL.                              *
*                                                                           *
*   CYCLES                                                                  *
*       7 * nx/2 + 12                                                       *
*                                                                           *
*   CODESIZE                                                                *
*       320 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_fltoq15
_DSP_fltoq15:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x_ptr
        .asg            B4,         B_r_ptr
        .asg            A5,         A_ma_mask
        .asg            A6,         A_bit23
        .asg            B8,         B_cp119
        .asg            B7,         B_one
        .asg            B2,         B_nx
        .asg            A10,        A_flt
        .asg            B5,         B_flt
        .asg            A2,         A_s
        .asg            B0,         B_exp
        .asg            A0,         A_mantf
        .asg            A0,         A_mant
        .asg            B0,         B_r
        .asg            B5,         B_shf0
        .asg            B6,         B_shf1
        .asg            A2,         A_shf
        .asg            A9,         A_mant1
        .asg            B6,         B_mant2
        .asg            A1,         A_flt_2
        .asg            B5,         B_flt_2
        .asg            A1,         A_s_2
        .asg            B1,         B_exp_2
        .asg            A10,        A_mantf_2
        .asg            A3,         A_mant_2
        .asg            B1,         B_r_2
        .asg            B6,         B_shf0_2
        .asg            B5,         B_shf1_2
        .asg            A7,         A_shf_2
        .asg            A8,         A_mant1_2
        .asg            B5,         B_mant2_2
        .asg            B9,         B_p
* ========================================================================= *

* =========================== PIPE LOOP PROLOG ============================ *

        LDW     .D1T1   *A_x_ptr++, A_flt                       ;[ 1,1]
||      MVKL    .S1     0x7FFFFF,   A_ma_mask                   ;setup
||      ZERO    .L1     A_bit23                                 ;setup
||      SHR     .S2X    A6,         1,          B_nx            ;setup
||      ZERO    .L2     B_p                                     ;prolog coll

        STW     .D2T1    A10,       *B15--[2]                   ;setup
||      MVKH    .S1      0x7FFFFF,  A_ma_mask                   ;setup
||      SUB     .L2      B_nx,      1,         B_nx             ;setup

        LDW     .D1T1   *A_x_ptr++, A_flt_2                     ;[ 3,1]
||      SET     .S1     A_bit23,    23, 23,     A_bit23         ;setup
||      MVK     .S2     1,          B_one                       ;prolog coll

        MVK     .S2     119,        B_cp119                     ;setup

* =========================== PIPE LOOP KERNEL ============================ *
loop:
        STH     .D2T2   B_mant2_2,  *B_r_ptr++[B_p]             ;[19,1]
||      SSHL    .S2     B_shf0_2,   26,         B_shf1_2        ;[12,2]
||[ B_r]NEG     .L1     A_shf,      A_shf                       ;[12,2]
||[!B_r]SSHL    .S1     A_mant,     A_shf,      A_mant1         ;[12,2]

  [ B_nx]B      .S2     loop                                    ;[20,1]
||[ B_nx]SUB    .D2     B_nx,       1,          B_nx            ;[13,2]
||[ A_s_2]NEG   .L1     A_mant_2,   A_mant_2                    ;[13,2]
||      SHR     .S1X    B_shf1_2,   26,         A_shf_2         ;[13,2]
||      MV      .L2X    A_flt,      B_flt                       ;[ 6,3]

  [ B_r]SHR     .S1     A_mant,     A_shf,      A_mant1         ;[14,2]
||      EXTU    .S2     B_flt,      1,  24,     B_exp           ;[ 7,3]
||      CMPLT   .L1     A_flt,      0,          A_s             ;[ 7,3]

        SHR     .S2X    A_mant1,    16,         B_mant2         ;[15,2]
||      AND     .S1     A_flt_2,    A_ma_mask,  A_mantf_2       ;[ 8,3]
||      SUB     .L2     B_exp,      B_cp119,    B_shf0          ;[ 8,3]
||      AND     .L1     A_flt,      A_ma_mask,  A_mantf         ;[ 8,3]
||      LDW     .D1T1   *A_x_ptr++, A_flt                       ;[ 1,4]

  [ B_r_2]NEG   .L1     A_shf_2,    A_shf_2                     ;[16,2]
||[!B_r_2]SSHL  .S1     A_mant_2,   A_shf_2,    A_mant1_2       ;[16,2]
||      STH     .D2T2   B_mant2,    *B_r_ptr++[B_p]             ;[16,2]
||      MV      .L2X    A_flt_2,    B_flt_2                     ;[ 9,3]
||      SSHL    .S2     B_shf0,     26,         B_shf1          ;[ 9,3]
||      ADD     .D1     A_mantf,    A_bit23,    A_mant          ;[ 9,3]

  [ B_r_2]SHR   .S1     A_mant_2,   A_shf_2,    A_mant1_2       ;[17,2]
||      EXTU    .S2     B_flt_2,    1,  24,     B_exp_2         ;[10,3]
||      CMPLT   .L1     A_flt_2,    0,          A_s_2           ;[10,3]
||      CMPLT   .L2     B_exp,      B_cp119,    B_r             ;[10,3]
||      LDW     .D1T1   *A_x_ptr++, A_flt_2                     ;[ 3,4]

        SHR     .S2X    A_mant1_2,  16,         B_mant2_2       ;[18,2]
||      SUB     .D2     B_exp_2,    B_cp119,    B_shf0_2        ;[11,3]
||      CMPLT   .L2     B_exp_2,    B_cp119,    B_r_2           ;[11,3]
||      ADD     .D1     A_mantf_2,  A_bit23,    A_mant_2        ;[11,3]
||[ A_s]NEG     .L1     A_mant,     A_mant                      ;[11,3]
||      SHR     .S1X    B_shf1,     26,         A_shf           ;[11,3]
||      MPY     .M2     B_one,      B_one,      B_p             ;prolog coll

* =========================== PIPE LOOP EPILOG ============================ *

        STH     .D2T2   B_mant2_2,  *B_r_ptr++[B_p]             ;[19,3]
||      SSHL    .S2     B_shf0_2,   26,         B_shf1_2        ;[12,4]
||[ B_r]NEG     .L1     A_shf,      A_shf                       ;[12,4]
||[!B_r]SSHL    .S1     A_mant,     A_shf,      A_mant1         ;[12,4]

  [ B_nx]SUB    .L2     B_nx,       1,          B_nx            ;[13,4]
||[ A_s_2]NEG   .L1     A_mant_2,   A_mant_2                    ;[13,4]
||      SHR     .S1X    B_shf1_2,   26,         A_shf_2         ;[13,4]

  [ B_r]SHR     .S1     A_mant,     A_shf,      A_mant1         ;[14,4]
||      B       .S2     B3                                      ;exit
||      LDW     .D2T1   *++B15[2],  A10                         ;exit

        SHR     .S2X    A_mant1,    16,         B_mant2         ;[15,4]

  [ B_r_2]NEG   .L1     A_shf_2,    A_shf_2                     ;[16,4]
||[!B_r_2]SSHL  .S1     A_mant_2,   A_shf_2,    A_mant1_2       ;[16,4]
||      STH     .D2T2   B_mant2,    *B_r_ptr++                  ;[16,4]

  [ B_r_2]SHR   .S1     A_mant_2,   A_shf_2,    A_mant1_2       ;[17,4]

        SHR     .S2X    A_mant1_2,  16,         B_mant2_2       ;[18,4]

        STH     .D2T2   B_mant2_2,  *B_r_ptr++                  ;[19,4]

* ========================================================================= *
*   End of file:  dsp_fltoq15.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
iir.asm/        1019093836  0     0     0       13561     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.5     Fri Mar 29 15:47:22 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       iir                                                                 *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       11-Feb-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable and can be called as:                    *
*                                                                           *
*           void DSP_iir                                                    *
*           (                                                               *
*               short *restrict r1,      /* Output array (used)      */     *
*               const short     *x,      /* Input array              */     *
*               short *restrict r2,      /* Output array (stored)    */     *
*               const short     *h2,     /* Filter Coeffs. AR part   */     *
*               const short     *h1,     /* Filter Coeffs. FIR part  */     *
*               int             nr       /* Number of output samples */     *
*           )                                                               *
*                                                                           *
*   DESCRIPTION                                                             *
*       The IIR performs an auto-regressive moving-average (ARMA) filter    *
*       with 4 auto-regressive filter coefficients and 5 moving-average     *
*       filter coefficients for nr output samples. The output vector is     *
*       stored in two locations.  This routine is used as a high pass       *
*       filter in the VSELP vocoder.                                        *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_iir                                                        *
*       (                                                                   *
*           short *restrict r1,      /* Output array (used)      */         *
*           const short     *x,      /* Input array              */         *
*           short *restrict r2,      /* Output array (stored)    */         *
*           const short     *h2,     /* Filter Coeffs. AR part   */         *
*           const short     *h1,     /* Filter Coeffs. FIR part  */         *
*           int             nr       /* Number of output samples */         *
*       )                                                                   *
*       {                                                                   *
*           int j, i;                                                       *
*           int sum;                                                        *
*                                                                           *
*           for (i = 0; i < nr; i++)                                        *
*           {                                                               *
*               sum = h2[0] * x[4+i];                                       *
*                                                                           *
*               for (j = 1; j <= 4; j++)                                    *
*                   sum += h2[j] * x[4+i-j] - h1[j] * r1[4+i-j];            *
*                                                                           *
*               r1[4+i] = (sum >> 15);                                      *
*               r2[  i] = r1[4+i];                                          *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The inner loop is completely unrolled and software pipelined        *
*       (i.e. each time the 5 cycle loop "LOOP" is executed the inner       *
*       loop of the C code is executed.)                                    *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*       This code is interrupt-tolerant but not interruptible.              *
*                                                                           *
*   MEMORY NOTE                                                             *
*       To avoid memory hits r1[] and r2[] must be aligned on the next word *
*       boundary following the alignment of x[], e.g.:                      *
*           #pragma DATA_MEM_BANK(x, 0);                                    *
*           #pragma DATA_MEM_BANK(r1, 2);                                   *
*           #pragma DATA_MEM_BANK(r2, 2);                                   *
*                                                                           *
*   CYCLES                                                                  *
*       5 * nr + 30                                                         *
*                                                                           *
*       For nr = 40: 230 cycles                                             *
*                                                                           *
*   CODESIZE                                                                *
*       384 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_iir
_DSP_iir:
        STW     .D2     A10,*B15--[4]   ; push A10 on stack

        STW     .D2     B10,*+B15[1]    ; push B10 on stack
||      MV              B15,A1

        STW     .D2     B11,*+B15[3]    ; push B11 on stack
||      STW     .D1     A11,*+A1 [2]    ; push A11 on stack

        LDH     .D1     *+A8[2],A7      ; get h1[2]
||      LDH     .D2     *B6,B10         ; get h2[0]

        LDHU    .D1     *+A8[1],A10     ; get h1[1]
||      LDH     .D2     *+B6[2],B9      ; get h2[2]
||      ADD     .L2     8,B4,B4         ; i -> x[4]

        LDH     .D1     *+A8[4],A5      ; get h1[4]
||      LDHU    .D2     *+B6[1],B7      ; get h2[1]
||      MV      .S1     B8,A1           ; A1 = LEN (normally 160)

        LDHU    .D1     *+A8[3],A8      ; get h1[3]
||      LDH     .D2     *+B6[4],B5      ; get h2[4]

        LDHU    .D2     *+B6[3],B8      ; get h2[3]
||      B               LOOP            ; disable ints

        LDH     .D2     *B4--,B0        ; get x[4]
||      LDH     .D1     *A4++[2],A0     ; get r1[0]
||      ADD     .L1     8,A4,A11        ; used for store ptr
||      MVK     .S2     1,B1            ; second primer

        LDH     .D2     *B4--,B0        ; get x[3]
||      LDH     .D1     *A4--,A9        ; get r1[2]
||      SHL     .S1     A7,16,A7        ; put h1[2] in 16MSBs
||      SHL     .S2     B9,16,B9        ; put h2[2] in 16MSBs

        LDH     .D2     *B4--,B0        ; get x[2]
||      LDH     .D1     *A4++[2],A0     ; get r1[1]
||      OR      .L1     A7,A10,A7        ; h1[2] & h1[1]
||      OR      .L2     B9,B7,B9        ; h2[2] & h2[1]

        LDH     .D2     *B4--,B0        ; get x[1]
||      LDH     .D1     *A4--[2],A9     ; get r1[3]
||      SHL     .S1     A5,16,A5        ; put h1[4] in 16MSBs
||      SHL     .S2     B5,16,B5        ; put h2[4] in 16MSBs

        LDH     .D2     *B4++[5],B0     ; get x[0]
||      OR      .L1     A5,A8,A5        ; h1[4] & h1[3]
||      OR      .L2     B5,B8,B5        ; h2[4] & h2[3]
||      MVK     .S2     0,B2            ; used for store priming cnt
|| [A1] B       .S1     LOOP            ; for (i=0; i<nr; i++)

LOOP:
  [B2]  ADD     .S1     A2,A10,A2       ; o2*a2+o1*a3+o0*a4
||[B2]  ADD     .L2     B11,B7,B11      ; i4*b0+i3*b1+i2*b2+i1*b3
||      MPY     .M2     B0,B10,B8       ;* x[4] * h2[0]
||      MPYLH   .M1     A0,A5,A8        ;* r1[0] * h1[4]
||      LDH     .D2     *B4--,B0        ;** get x[4]
||      LDH     .D1     *A4++,A0        ;** get r1[0]

  [B2]  ADD     .S1     A2,A8,A2        ; o3*a1+o2*a2+o1*a3+o0*a4
||[B2]  ADD     .S2     B11,B7,B11      ; i4*b0+i3*b1+i2*b2+i1*b3+i0*b4
||      MPY     .M2     B0,B9,B7        ;* x[3] * h2[1]
||      MPYLH   .M1     A9,A7,A3        ;* r1[2] * h1[2]
||      LDH     .D2     *B4--,B0        ;** get x[3]
||[!B2] LDH     .D1     *+A4[1],A9      ;* get r1[2]
|| [A1] ADD     .L1     -1,A1,A1        ; decrement loop counter

  [B2]  SUB     .L1X    B11,A2,A2       ; r1[4] is computed here
||      MPYLH   .M2     B0,B9,B7        ;* x[2] * h2[2]
||      MPY     .M1     A0,A5,A10       ;* r1[1] * h1[3]
||      LDH     .D2     *B4--,B0        ;** get x[2]
||      LDH     .D1     *A4,A0          ;** get r1[1]

  [B2]  SHR     .S1     A2,15,A9        ; scale r1[4]
||[!B1] STH     .D1     A9,*A6++        ; store r1[4] to *r2
||      MPY     .M2     B0,B5,B7        ;* x[1] * h2[3]
||      ADD     .L2     B8,B7,B11       ;* i4*b0+i3*b1
||      LDH     .D2     *B4--,B0        ;** get x[1]
||[B1]  SUB     .S2     B1,B2,B1        ; prime first store

  [B2]  STH     .D1     A9,*+A4[1]      ; store r1[4] to *r1
||      MPYLH   .M2     B0,B5,B7        ;* x[0] * h2[4]
||      MPY     .M1     A7,A9,A8        ;* r1[3] * h1[1]
||      ADD     .L1     A3,A8,A2        ;* o2*a2+o1*a3
||      ADD     .S2     B11,B7,B11      ;* i4*b0+i3*b1+i2*b2
||      LDH     .D2     *B4++[5],B0     ;** get x[0]
|| [A1] B       .S1     LOOP            ;for (i=0; i<nr; i++)
||[!B2] ADD     .L2     1,B2,B2         ; used for store priming cnt
; LOOP ends here

        STH     .D1     A9,*A6          ; store r1[4] to *r2
||      MV      .L1X    B15,A1          ; copy stackpointer to A1

        LDW     .D2     *+B15[1],B10    ; pop B10 off stack
||      LDW     .D1     *+A1 [2],A11    ; pop A11 off stack
||      B       .S2     B3              ; return from call

        LDW     .D1     *  A1 [3],B11   ; pop B11 off stack
||      LDW     .D2     *++B15[4],A10   ; pop A10 off stack

        NOP     4

* ========================================================================= *
*   End of file:  dsp_iir.asm                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

iirlat.asm/     1019093836  0     0     0       17198     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.3     Fri Mar 22 01:52:54 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_iirlat                                                          *
*                                                                           *
*   REVISION DATE                                                           *
*       12-Feb-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C Callable and can be called as:                    *
*                                                                           *
*       void DSP_iirlat                                                     *
*       (                                                                   *
*           short       *x,                                                 *
*           int          nx,                                                *
*           const short *restrict k,                                        *
*           int          nk,                                                *
*           int         *restrict b,                                        *
*           short       *r                                                  *
*       );                                                                  *
*                                                                           *
*       x[nx]   : Input vector (16-bit)                                     *
*       nx      : Length of input vector.                                   *
*       k[nk]   : Reflection coefficients in Q.15 format                    *
*       nk      : Number of reflection coefficients/lattice stages          *
*                 Must be >=4. Make multiple of 2 to avoid bank conflicts.  *
*       b[nk+1] : Delay line elements from previous call. Should be         *
*                 initialized to all zeros prior to the first call.         *
*       r[nx]   : Output vector (16-bit)                                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine implements a real all-pole IIR filter in lattice       *
*       structure (AR lattice). The filter consists of nk lattice stages.   *
*       Each stage requires one reflection coefficient k and one delay      *
*       element b. The routine takes an input vector x[] and returns the    *
*       filter output in r[]. Prior to the first call of the routine the    *
*       delay elements in b[] should be set to zero. The input data may     *
*       have to be pre-scaled to avoid overflow or achieve better SNR. The  *
*       reflections coefficients lie in the range -1.0 < k < 1.0. The       *
*       order of the coefficients is such that k[nk-1] corresponds to the   *
*       first lattice stage after the input and k[0] corresponds to the     *
*       last stage.                                                         *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_iirlat                                                     *
*       (                                                                   *
*           short       *x,                                                 *
*           int         nx,                                                 *
*           const short *restrict k,                                        *
*           int         nk,                                                 *
*           int         *restrict b,                                        *
*           short       *r                                                  *
*       )                                                                   *
*       {                                                                   *
*           int rt;     // output       //                                  *
*           int i, j;                                                       *
*                                                                           *
*           for (j=0; j<nx; j++)                                            *
*           {                                                               *
*               rt = x[j] << 15;                                            *
*                                                                           *
*               for (i = nk - 1; i >= 0; i--)                               *
*               {                                                           *
*                   rt       = rt   - (short)(b[i] >> 15) * k[i];           *
*                   b[i + 1] = b[i] + (short)(rt   >> 15) * k[i];           *
*               }                                                           *
*                                                                           *
*               b[0] = rt;                                                  *
*                                                                           *
*               r[j] = rt >> 15;                                            *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Prolog and epilog of the inner loop are partially collapsed         *
*       and overlapped to reduce outer loop overhead.                       *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       - nk must be >= 4.                                                  *
*       - no special alignment requirements                                 *
*       - see MEMORY NOTE for avoiding bank conflicts                       *
*                                                                           *
*   MEMORY NOTE                                                             *
*       - nk should be a multiple of 2, otherwise bank conflicts occur      *
*         causing a penalty of 2*nx cycles.                                 *
*       - r[] and k[] should be located in separate memory halves on C620x  *
*         devices, otherwise bank conflicts occur causing a penalty of      *
*         nx/4 cycles.                                                      *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt-tolerant but not interruptible.              *
*       This code is ENDIAN NEUTRAL                                         *
*                                                                           *
*   CYCLES                                                                  *
*       (2 * nk + 8) * nx + 5                                               *
*       (assuming no bank conflicts occur)                                  *
*                                                                           *
*   CODESIZE                                                                *
*       352 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .asg            A1,         A_i
        .asg            A2,         A_p
        .asg            A3,         A_b
        .asg            A7,         A_r
        .asg            A4,         A_xp
        .asg            A5,         A_bk
        .asg            A6,         A_kp
        .asg            A7,         A_rt
        .asg            A7,         A_x
        .asg            A8,         A_bp
        .asg            A9,         A_nk
        .asg            B0,         B_j
        .asg            B1,         B_b1
        .asg            B1,         B_b__
        .asg            B2,         B_k
        .asg            B2,         B_rtk
        .asg            B4,         B_b___
        .asg            B4,         B_nx
        .asg            B5,         B_bp
        .asg            B6,         B_nk
        .asg            B7,         B_b_
        .asg            B8,         B_rp
        .asg            B9,         B_k_
        .asg            B1,         B_no_gie
        .asg            B6,         B_csr

* ========================================================================= *


        .text
        .global _DSP_iirlat
_DSP_iirlat:         ; A_xp, B_nx, A_kp, B_nk, A_bp, B_rp
                     ; A4,   B4,   A6,   B6,   A8,   B8

        MV      .L2     B_nx,       B_j
||      SHL     .S1X    B_nk,       2,      A_nk                ; word
||      LDH     .D1T1   *A_xp++,    A_x                         ; x[j]
||      MVC     .S2     CSR,        B_csr                       ; Get CSR's state

        ADD     .D1     A_bp,       A_nk,   A_bp                ; &b[nk]
||      SHR     .S1     A_nk,       1,      A_nk                ; half-word
||      AND     .L2     B_csr,      -2,     B_no_gie            ; Clear GIE

        ADD     .L1     A_kp,       A_nk,   A_kp                ; &k[nk]
||      LDW     .D1T1   *--A_bp,    A_b                         ;[ 1,1] b[i]
||      SHR     .S1     A_nk,       1,      A_nk                ; half-word
||      MVC     .S2     B_no_gie,   CSR                         ; Disable ints.

        LDH     .D1T2   *--A_kp,    B_k                         ;[ 2,1] k[i]

        LDW     .D1T1   *--A_bp,    A_b                         ;[ 1,2] b[i]

loop_j:

* =========================== PIPE LOOP PROLOG ============================ *

        LDH     .D1T2   *--A_kp,    B_k                         ;[ 2,2] k[i]
||      B       .S1     loop_i                                  ;[ 8,1]

        LDW     .D1T1   *--A_bp,    A_b                         ;[ 1,3] b[i]

        LDH     .D1T2   *--A_kp,    B_k                         ;[ 2,3] k[i]
||      B       .S2     loop_i                                  ;[ 8,1]
||      ADD     .L2X    A_bp,       12,         B_bp
||      MVK     .S1     3,          A_p
||      SUB     .L1     A_nk,       4,    A_i                   ; i=nk-4

        SHL     .S1     A_x,        16,         A_rt            ; rt=x[j]<<16
||      MV      .S2X    A_b,        B_b_                        ;[ 7,1]
||      MPY     .M2     B_k,        1,          B_k_            ;[ 7,1]
||      SMPYHL  .M1X    A_b,        B_k,        A_bk            ;[ 7,1] bk=b[i]*k[i]
||      LDW     .D1T1   *--A_bp,    A_b                         ;[ 1,4] b[i]
||      SUB     .L2     B_j,        1,          B_j

* =========================== PIPE LOOP KERNEL ============================ *
loop_i:
        ADD     .D2     B_b___,     B_rtk,      B_b1            ;[12,1] b1=b[i]+rtk
||      MV      .L2     B_b__,      B_b___                      ;[10,2]
||      SMPYHL  .M2X    A_rt,       B_k_,       B_rtk           ;[10,2] rtk=rt*k[i]
||[ A_i]B       .S1     loop_i                                  ;[ 8,3]
||      LDH     .D1T2   *--A_kp,    B_k                         ;[ 2,6] k[i]
||[ A_p]SUB     .L1     A_p,        1,          A_p             ;[ 7,4]

  [!A_p]STW     .D2T2   B_b1,       *B_bp--                     ;[13,1] b[i+1]=b1
||      MV      .L2     B_b_,       B_b__                       ;[ 9,3]
||      SUB     .L1     A_rt,       A_bk,       A_rt            ;[ 9,3] rt-=bk
||[ A_i]SUB     .S1     A_i,        1,          A_i             ;[ 7,4]
||      MV      .S2X    A_b,        B_b_                        ;[ 7,4]
||      MPY     .M2     B_k,        1,          B_k_            ;[ 7,4]
||      SMPYHL  .M1X    A_b,        B_k,        A_bk            ;[ 7,4] bk=b[i]*k[i]
||      LDW     .D1T1   *--A_bp,    A_b                         ;[ 1,7] b[i]

* =========================== PIPE LOOP EPILOG ============================ *

        ADD     .D2     B_b___,     B_rtk,      B_b1            ;[12,5] b1=b[i]+rtk
||      MV      .L2     B_b__,      B_b___                      ;[10,6]
||      SMPYHL  .M2X    A_rt,       B_k_,       B_rtk           ;[10,6] rtk=rt*k[i]
||[B_j] B       .S1     loop_j
||[!B_j]B       .S2     B3
||      LDH     .D1T1   *A_xp++,    A_x                         ; x[j]

        STW     .D2T2   B_b1,       *B_bp--                     ;[13,5] b[i+1]=b1
||      MV      .L2     B_b_,       B_b__                       ;[ 9,7]
||      SUB     .L1     A_rt,       A_bk,       A_rt            ;[ 9,7] rt-=bk
||      ADD     .S1     A_bp,       12,         A_bp            ; adjust: bp+=3
||      ADDAH   .D1     A_kp,       A_nk,       A_kp            ; &k[nk]

        ADD     .S2     B_b___,     B_rtk,      B_b1            ;[12,6] b1=b[i]+rtk
||      MV      .L2     B_b__,      B_b___                      ;[10,7]
||      SMPYHL  .M2X    A_rt,       B_k_,       B_rtk           ;[10,7] rtk=rt*k[i]
||      STW     .D2T1   A_rt,       *-B_bp[2]                   ; b[0]=rt
||      ADDAW   .D1     A_bp,       A_nk,       A_bp            ; &b[nk]

        STW     .D2T2   B_b1,       *B_bp--                     ;[13,6] b[i+1]=b1
||      SHR     .S1     A_rt,       16,         A_r             ; r=rt>>16
||      ADD     .L1     A_kp,       4,          A_kp            ; adjust: kp+=2
||      LDW     .D1T1   *--A_bp,    A_b                         ;[ 1,1] b[i]

        ADD     .L2     B_b___,     B_rtk,      B_b1            ;[12,7] b1=b[i]+rtk
||      STH     .D2T1   A_r,        *B_rp++                     ; r[j]=r
||      LDH     .D1T2   *--A_kp,    B_k                         ;[ 2,1] k[i]

        STW     .D2T2   B_b1,       *B_bp--                     ;[13,7] b[i+1]=b1
||      LDW     .D1T1   *--A_bp,    A_b                         ;[ 1,2] b[i]
||[!B_j]MVC     .S2     B_csr,      CSR                         ; Restore CSR

* ========================================================================= *
*   End of file:  dsp_iirlat.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
mat_mul.asm/    1019093836  0     0     0       24313     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.6     Fri Mar 22 01:53:17 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_mat_mul -- Matrix Multiply                                      *
*                                                                           *
*   REVISION DATE                                                           *
*       15-Jan-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSP_mat_mul                                                *
*           (                                                               *
*               const short *restrict x, int r1, int c1,                    *
*               const short *restrict y,         int c2,                    *
*               short       *restrict r,                                    *
*               int                   qs                                    *
*           );                                                              *
*                                                                           *
*       x  == Pointer to r1 by c1 input matrix.                             *
*       y  == Pointer to c1 by c2 input matrix.                             *
*       r  == Pointer to r1 by c2 output matrix.                            *
*                                                                           *
*       r1 == Number of rows in x.                                          *
*       c1 == Number of columns in x.  Also number of rows in y.            *
*       c2 == Number of columns in y.                                       *
*                                                                           *
*       qs == Final right-shift to apply to the result.                     *
*                                                                           *
*   DESCRIPTION                                                             *
*       This function computes the expression "r = x * y" for the           *
*       matrices x and y.  The columnar dimension of x must match           *
*       the row dimension of y.  The resulting matrix has the same          *
*       number of rows as x and the same number of columns as y.            *
*                                                                           *
*       The values stored in the matrices are assumed to be fixed-point     *
*       or integer values.  All intermediate sums are retained to 32-bit    *
*       precision, and no overflow checking is performed.  The results      *
*       are right-shifted by a user-specified amount, and then truncated    *
*       to 16 bits.                                                         *
*                                                                           *
*       This code is suitable for dense matrices.  No optimizations are     *
*       made for sparse matrices.                                           *
*                                                                           *
*       The following is a C description of the algorithm.  The assembly    *
*       code may place restrictions on the inputs that the C code version   *
*       does not.  These restrictions are noted under ASSUMPTIONS below.    *
*                                                                           *
*       void DSP_mat_mul                                                    *
*       (                                                                   *
*           const short *restrict x, int r1, int c1,                        *
*           const short *restrict y,         int c2,                        *
*           short       *restrict r,                                        *
*           int                   qs                                        *
*       )                                                                   *
*       {                                                                   *
*           int i, j, k;                                                    *
*           int sum;                                                        *
*                                                                           *
*           /* ---------------------------------------------------- */      *
*           /*  Multiply each row in x by each column in y.  The    */      *
*           /*  product of row m in x and column n in y is placed   */      *
*           /*  in position (m,n) in the result.                    */      *
*           /* ---------------------------------------------------- */      *
*           for (i = 0; i < r1; i++)                                        *
*               for (j = 0; j < c2; j++)                                    *
*               {                                                           *
*                   sum = 0;                                                *
*                                                                           *
*                   for (k = 0; k < c1; k++)                                *
*                       sum += x[k + i*c1] * y[j + k*c2];                   *
*                                                                           *
*                   r[j + i*c2] = sum >> qs;                                *
*               }                                                           *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The arrays 'x', 'y', and 'r' are stored in distinct arrays.  That   *
*       is, in-place processing is not allowed.                             *
*                                                                           *
*       The input matrices have minimum dimensions of at least 1 row and    *
*       1 column, and maximum dimensions of 32767 rows and 32767 columns.   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The outer two loops are unrolled 2x.  For odd-sized dimensions,     *
*       we end up doing extra multiplies along the edges.  This offsets     *
*       the overhead of the nested loop structure, though.                  *
*                                                                           *
*       The outer two levels of loop nest are collapsed, further reducing   *
*       the overhead of the looping structure.                              *
*                                                                           *
*   NOTES                                                                   *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*       This code is interrupt tolerant, but not interruptible.             *
*       Interrupts are locked out in the body of this function by branch    *
*       delay slots.                                                        *
*                                                                           *
*       For odd values of r1 or c2, this code rounds the dimension up to    *
*       the next larger even dimension when calculating loop trip counts.   *
*       Array addressing is not affected by this rounding.                  *
*                                                                           *
*   MEMORY NOTE                                                             *
*       The load instructions in the inner loop are predicated to avoid     *
*       significant over-fetching on the matrices.  However, since the      *
*       outer loops are unrolled, this code may fetch approximately one     *
*       full row beyond the end of the 'x' matrix and approximately one     *
*       word beyond the end of the 'y' matrix.  The values read are         *
*       discarded and do not affect the results of the computation.         *
*                                                                           *
*       The code is organized so that accesses to the 'x' and 'y' matrices  *
*       occur in parallel.  On C620x and C670x devices, this will result    *
*       in memory bank conflicts unless both 'x' and 'y' are placed in      *
*       separate memory spaces.  When both 'x' and 'y' are in separate      *
*       memory spaces, no conflicts occur.  On C621x and C671x, there are   *
*       no bank conflicts as the devices use dual-ported memory.            *
*                                                                           *
*       When 'x' and 'y' are placed in the same memory space (eg. the       *
*       same half of data memory on C620x and C670x devices), bank          *
*       conflicts will occur in a pattern that depends on the dimensions    *
*       of matrices and the number and size of the memory banks on the      *
*       specific device being used.  The code places the following          *
*       accesses in parallel:  (Refer to C code above for the meaning of    *
*       the indices 'i', 'j', and 'k'.)                                     *
*                                                                           *
*           x[k + (i + 0)*c1]  in parallel with  y[(j + 0) + k*c2]          *
*           x[k + (i + 1)*c1]  in parallel with  y[(j + 1) + k*c2]          *
*                                                                           *
*       The exact analysis of bank conflicts requires the dimensions of     *
*       the matrices being multiplied, and this calculation is left to      *
*       the user.  Bank conflicts cause between 3% and 40% degradation      *
*       on a 4-bank device such as C6201 when x and y are in the same       *
*       memory space.                                                       *
*                                                                           *
*   CYCLES                                                                  *
*       Assuming no bank conflicts, the following formula applies:          *
*                                                                           *
*       cycles = 0.5 * (r1'*c2'*c1) + 3 * (r1'*c2') + 24, where:            *
*       r1' = r1 + (r1&1);   // r1 rounded up to next even                  *
*       c2' = c2 + (c2&1);   // c2 rounded up to next even                  *
*                                                                           *
*       For r1= 1, c1= 1, c2= 1,  cycles =    38.                           *
*       For r1= 8, c1=20, c2= 8,  cycles =   856.                           *
*       For r1=12, c1=14, c2=18,  cycles =  2184.                           *
*       For r1=32, c1=32, c2=32,  cycles = 19480.                           *
*                                                                           *
*       The cycle count includes 6 cycles of function call overhead.  The   *
*       exact overhead seen by a given application will depend on the       *
*       compiler options used.                                              *
*                                                                           *
*   CODESIZE                                                                *
*       448 bytes.                                                          *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_mat_mul
_DSP_mat_mul:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x         ; Pointer to x matrix
        .asg            B4,         B_r1        ; Number of rows in x
        .asg            A6,         A_c1        ; Number of columns in x
        .asg            B6,         B_y         ; Pointer to y matrix
        .asg            A8,         A_c2        ; Number of columns in y
        .asg            B8,         B_r         ; Pointer to result matrix
        .asg            A10,        A_qs        ; Final right shift amount.

        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A3,         A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A7,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address

        .asg            A0,         A_i         ; Outer loop (I-loop) counter
        .asg            A1,         A_j         ; Middle loop (J-loop) counter
        .asg            A2,         A_I         ; Copy of A_i
        .asg            A2,         A_p         ; Prolog collapse predicate

        .asg            A3,         A_p00
        .asg            A3,         A_p01
        .asg            A5,         A_s00
        .asg            A5,         A_t00
        .asg            A7,         A_s01
        .asg            A7,         A_t01
        .asg            A8,         A_jc
        .asg            A9,         A_x0
        .asg            A11,        A_y_sv2
        .asg            A12,        A_x_sv
        .asg            A13,        A_y1
        .asg            B0,         B_p10
        .asg            B0,         B_ok01
        .asg            B1,         B_p11
        .asg            B1,         B_ok10
        .asg            B2,         B_k
        .asg            B2,         B_ok11
        .asg            B4,         B_c2
        .asg            B5,         B_c2o
        .asg            B7,         B_x1
        .asg            B7,         B_tmp
        .asg            B7,         B_ic
        .asg            B9,         B_r1o
        .asg            B10,        B_y_sv
        .asg            B11,        B_y0
        .asg            B12,        B_s10
        .asg            B12,        B_t10
        .asg            B13,        B_s11
        .asg            B13,        B_t11
        .asg            B14,        B_qs
; ========================================================================= ;
        ; Stack frame.  10 words:  A11..A13, B10..B14, CSR, pad
;-
        STW     .D2T1   A13,        *B_SP--[8]              ; Get stk, Save A13
||      AND     .L2     B_r1,       1,          B_r1o       ; Is r1 odd?
||      MVK     .S1     1,          A_I

        MV      .S1X    B_SP,       A_SP                    ; Twin Stack Ptr
||      STW     .D2T2   B14,        *+B_SP[ 7]              ; Save B14
||      AND     .S2X    A_c2,       1,          B_c2o       ; Is c2 odd?

        STW     .D1T1   A12,        *+A_SP[ 6]              ; Save A12
||      STW     .D2T2   B13,        *+B_SP[ 5]              ; Save B13
;-
        STW     .D1T1   A11,        *+A_SP[ 4]              ; Save A11
||      STW     .D2T2   B12,        *+B_SP[ 3]              ; Save B12
||      ADD     .L2     B_r1,       B_r1o,      B_ic        ; Round up to even
||      ADD     .L1     A_c2,       B_c2o,      A_jc        ; Round up to even
||      MV      .S2X    A_c2,       B_c2                    ; Partition move

        STW     .D2T2   B11,        *+B_SP[ 2]              ; Save B11
||      SHRU    .S1X    B_ic,       1,          A_i         ; I-loop trip cnt
||      SUB     .S2X    A_c1,       1,          B_k         ;[ 4,1]
;-
        STW     .D2T2   B10,        *+B_SP[ 1]              ; Save B10
||      SHRU    .S1     A_jc,       1,          A_jc        ; J-loop trip cnt
||      MV      .S2     B_y,        B_y_sv                  ; Remember y

        MV      .D1     A_jc,       A_j                     ; Init j loop
||      MV      .S1X    B_y,        A_y_sv2                 ; Remember y
||      MV      .L1     A_x,        A_x_sv                  ; Remember x
;-
* =========================== PIPE LOOP PROLOG ============================ *
loop_ij:
  [ A_I]LDH     .D2T1   *B_y[1],    A_y1                    ;[ 1,1]
||[ A_I]LDH     .D1T2   *A_x[A_c1], B_x1                    ;[ 1,1]
||[ A_I]B               loop_k
||[!A_j]ADD     .L2     B_r,        B_tmp,      B_r         ; Advance r 1 row

  [ A_I]LDH     .D2T2   *B_y++[B_c2],           B_y0        ;[ 2,1]
||[ A_I]LDH     .D1T1   *A_x++[1],  A_x0                    ;[ 2,1]
||[ A_I]ZERO    .L1     A_s00
||[ A_I]ZERO    .S1     A_s01
;-
  [ B_k]LDH     .D2T1   *B_y[1],    A_y1                    ;[ 1,2]
||[ B_k]LDH     .D1T2   *A_x[A_c1], B_x1                    ;[ 1,2]
||[ B_k]B               loop_k
||[!A_I]MV              B_SP,       A_SP                    ; Twin Stack Ptr
;-
  [ B_k]SUB     .S2     B_k,        1,          B_k         ;[ 4,1]
||[ B_k]LDH     .D2T2   *B_y++[B_c2],           B_y0        ;[ 2,2]
||[ B_k]LDH     .D1T1   *A_x++[1],  A_x0                    ;[ 2,2]
||      ZERO    .L2     B_s11:B_s10
||      MVK     .S1     2,          A_p                     ; Prolog collapse
||[!A_j]MV      .L1     A_jc,       A_j                     ; Re-init j loop
||      MPY     .M2X    A_qs,       1,          B_qs
; ===== 2 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop_k:
  [!A_p]ADD     .S2     B_s11,      B_p11,      B_s11       ;[ 9,1]
||[!A_p]ADD     .L2     B_s10,      B_p10,      B_s10       ;[ 9,1]
||[!A_p]ADD     .L1     A_s01,      A_p01,      A_s01       ;[ 9,1]
||      MPY     .M2     B_x1,       B_y0,       B_p10       ;[ 7,2]
||      MPY     .M1     A_x0,       A_y1,       A_p01       ;[ 7,2]
||[ B_k]B       .S1     loop_k                              ;[ 5,3]
||[ B_k]LDH     .D2T1   *B_y[1],    A_y1                    ;[ 1,5]
||[ B_k]LDH     .D1T2   *A_x[A_c1], B_x1                    ;[ 1,5]

  [ A_p]SUB     .L1     A_p,        1,          A_p         ;[10,1]
||[!A_p]ADD     .S1     A_s00,      A_p00,      A_s00       ;[10,1]
||      MPY     .M1X    A_x0,       B_y0,       A_p00       ;[ 8,2]
||      MPY     .M2X    B_x1,       A_y1,       B_p11       ;[ 6,3]
||[ B_k]SUB     .S2     B_k,        1,          B_k         ;[ 4,4]
||[ B_k]LDH     .D2T2   *B_y++[B_c2],           B_y0        ;[ 2,5]
||[ B_k]LDH     .D1T1   *A_x++[1],  A_x0                    ;[ 2,5]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 3 epilog stages collapsed
        CMPGT   .L2X    A_j,        B_c2o,      B_ok01
||      ADD     .S2     B_s11,      B_p11,      B_s11       ;[ 9,5]
||      ADD     .D2     B_s10,      B_p10,      B_s10       ;[ 9,5]
||      ADD     .L1     A_s01,      A_p01,      A_s01       ;[ 9,5]
||      SUB     .D1     A_j,        1,          A_j         ; Decr j loop cnt
||      B               loop_ij
;-
        CMPGT   .L2X    A_i,        B_r1o,      B_ok10
||      SHR     .S2     B_s10,      B_qs,       B_t10
||      ADD     .D2     B_y_sv,     4,          B_y_sv
||      ADD     .L1     A_s00,      A_p00,      A_s00       ;[10,5]
||      SHR     .S1     A_s01,      A_qs,       A_t01
||[!A_j]SUB     .D1     A_i,        1,          A_i         ; Decr ij loop cnt
;-
        SHR     .S1     A_s00,      A_qs,       A_t00
||      MV              A_i,        A_I
||      SHR     .S2     B_s11,      B_qs,       B_t11
||[ B_ok10] STH .D2T2   B_t10,      *B_r[B_c2]

  [!A_I]B               leave
||[!A_j]MV      .L2X    A_y_sv2,    B_y_sv                  ; Rewind y
||      STH     .D2T1   A_t00,      *B_r++[1]
||      AND     .S2     B_ok01,     B_ok10,     B_ok11
;-
  [ B_ok11] STH .D2T2   B_t11,      *B_r[B_c2]
||[!A_j]ADDAW   .D1     A_x_sv,     A_c1,       A_x_sv      ; Advance x 2 rows
||      MV      .S2     B_y_sv,     B_y                     ; Reset y ptr

  [ B_ok01] STH .D2T1   A_t01,      *B_r++[1]
||      ADD             B_c2,       B_c2,       B_tmp
||      MV      .L1     A_x_sv,     A_x                     ; Reset x ptr
||[!A_I]MPY             B_k,        0,          B_k
||[ A_I]SUB     .S2X    A_c1,       1,          B_k         ;[ 4,1]
;-
* ========================================================================= *
leave:
        LDW     .D1T1   *+A_SP[ 1], A0                      ; Restore B10
||      LDW     .D2T2   *+B_SP[ 2], B11                     ; Restore B11

        LDW     .D1T2   *+A_SP[ 3], B12                     ; Restore B12
||      LDW     .D2T1   *+B_SP[ 4], A11                     ; Restore A12

        LDW     .D1T2   *+A_SP[ 5], B13                     ; Restore B13
||      LDW     .D2T1   *+B_SP[ 6], A12                     ; Restore A13
||      B       .S2     B_ret                               ; Return to caller
;-
        LDW     .D1T2   *+A_SP[ 7], B14                     ; Restore B14
||      LDW     .D2T1   *++B_SP[8], A13                     ; Restore A15

        NOP             3

        MV              A0,         B10
;-
; ===== Interruptibility state restored here =====
; ===== Branch Occurs =====

* ========================================================================= *
*   End of file:  dsp_mat_mul.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mat_trans.asm/  1019093836  0     0     0       10446     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.3     Fri Mar 22 01:53:40 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_mat_trans                                                       *
*                                                                           *
*   REVISION DATE                                                           *
*       27-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_mat_trans                                                  *
*       (                                                                   *
*           const short *restrict x,                                        *
*           short       rows,                                               *
*           short       columns,                                            *
*           short       *restrict r                                         *
*       );                                                                  *
*                                                                           *
*       x[rows*columns] : Pointer to input matrix. In-place                 *
*                         processing not allowed.                           *
*       rows            : Number of rows in input matrix                    *
*       columns         : Number of columns in input matrix                 *
*       r[columns*rows] : Pointer to output matrix.                         *
*                                                                           *
*   DESCRIPTION                                                             *
*       The program transposes a matrix of 16-bit values with dimension     *
*       rows x columns, i.e. the value of an element in the output matrix   *
*       is equal to the value of the element from the input matrix with     *
*       switched coordinates.                                               *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_mat_trans(short *x, short rows, short columns, short *r)   *
*       {                                                                   *
*           short i,j;                                                      *
*                                                                           *
*           for(i = 0; i < columns; i++)                                    *
*               for(j = 0; j < rows; j++)                                   *
*                   r[i * rows + j] = x[i + columns * j];                   *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The kernel of the code combines two loops in one. As the program    *
*       goes accross the input matrix (always just incrementing pointer),   *
*       it must go down the output matrix (addition to pointer). After      *
*       each write it checks to see if the output pointer has reached the   *
*       end of the column. If so, it redirects the output pointer to the    *
*       beginning of the next column. This technique is good for most size  *
*       matrices, but for very large matrices, a more efficient technique   *
*       would use two loops so that the inner one could accomodate          *
*       more elements per cycle.                                            *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Matrices have 16-bit elements                                       *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*       No memory bank hits occur.                                          *
*                                                                           *
*   CYCLES                                                                  *
*       6 * floor[rows * columns / 3] + 11                                  *
*                                                                           *
*       For rows = 69, columns = 17: 2357 cycles                            *
*                                                                           *
*   CODESIZE                                                                *
*       192 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_mat_trans
_DSP_mat_trans:

;   A0: Y1                  B0: n2
;   A1: Y2                  B1: j
;   A2: Y3                  B2: n
;   A3:                     B3: return address
;   A4: x                   B4: [rows]
;   A5: r                   B5:
;   A6: columns             B6: [r]
;   A7: k                   B7:
;   A8: rows                B8:

                LDH.D1      *A4++[1],A0     ;   start loading input values
    ||          MPY.M2      B4,A6,B2        ;   n=rows*columns
    ||          MPY.M1      A6,B4,A7

                LDH.D1      *A4++[1],A1
    ||          MV.S1       B6,A5           ;   A5=output
    ||          MV.S2       A6,B1           ;   j=columns

                LDH.D1      *A4++[1],A2
    ||  [!B2]   B.S2        B3              ;   return if matrix size = 0
    ||  [B2]    SUB.L2      B2,1,B0
    ||          ADD.L1      -1,A7,A7
    ||          MV.S1       B4,A8           ;   A8=rows

        [B0]    SUB.L2      B0,1,B0
    ||          MPY.M1      -2,A7,A7        ;   k=(-rows*(columns-1)+1)<<1

        [B0]    SUB.L2      B0,1,B0         ;   n2-=3  (but no less than zero)

LOOP:   [B0]    B.S1        LOOP            ;   go across then down input matrix, go down then across output matrix
    ||  [B0]    LDH.D1      *A4++[1],A0     ;   load input
    ||  [!B0]   B.S2        B3              ;   return
    ||  [!B1]   ADD.L1      A7,A5,A5        ;   if end of input row, start output on next column
    ||  [!B1]   MV.L2       A6,B1           ;   if end of input row, reset j to j=columns
    ||  [B0]    SUB.D2      B0,1,B0         ;   n2--

        [B2]    STH.D1      A0,*A5++[A8]    ;   store output
    ||          ADD.S2      -1,B1,B1        ;   j--
    ||  [B2]    SUB.L2      B2,1,B2         ;   n-- (but not less than zero)

        [B0]    LDH.D1      *A4++[1],A1     ;   repeat 2 cycles above twice
    ||  [!B1]   ADD.S1      A7,A5,A5
    ||  [!B1]   MV.S2       A6,B1
    ||  [B0]    SUB.L2      B0,1,B0

        [B2]    STH.D1      A1,*A5++[A8]
    ||          ADD.S2      -1,B1,B1
    ||  [B2]    SUB.L2      B2,1,B2

        [B0]    LDH.D1      *A4++[1],A2
    ||  [!B1]   ADD.S1      A7,A5,A5
    ||  [!B1]   MV.S2       A6,B1
    ||  [B0]    SUB.L2      B0,1,B0

        [B2]    STH.D1      A2,*A5++[A8]
    ||          ADD.S2      -1,B1,B1
    ||  [B2]    SUB.L2      B2,1,B2

* ========================================================================= *
*   End of file:  dsp_mat_trans.asm                                         *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
maxidx.asm/     1019093836  0     0     0       10411     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Sun Mar 10 00:53:48 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_maxidx                                                          *
*                                                                           *
*   REVISION DATE                                                           *
*       28-Jan-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       int DSP_maxidx(const short x[], int nx)                             *
*                                                                           *
*       x[] : Vector array                                                  *
*       nx  : Number of elements in x[]                                     *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine finds the max value of a vector and returns the index  *
*       of the value. In case of ties the smallest index is returned.       *
*                                                                           *
*   C CODE                                                                  *
*       int DSP_maxidx(const short x[], int nx)                             *
*       {                                                                   *
*           int max, index, i;                                              *
*                                                                           *
*           max = -32768;                                                   *
*           index = 0;                                                      *
*                                                                           *
*           for (i = 0; i < nx; i++)                                        *
*               if (x[i] > max)                                             *
*               {                                                           *
*                   max = x[i];                                             *
*                   index = i;                                              *
*               }                                                           *
*           return index;                                                   *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       The loop is unrolled three times.                                   *
*       After finding a new max value, multiply units are used to move      *
*       value between registers.                                            *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx is a multiple of 3 and >= 3                                      *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No memory bank hits under any conditions.                           *
*                                                                           *
*   NOTE                                                                    *
*       This code is ENDIAN NEUTRAL.                                        *
*       This code is interrupt-tolerant but not interruptible.              *
*                                                                           *
*   CYCLES                                                                  *
*       2 * nx/3 + 13                                                       *
*                                                                           *
*       for nx = 108, cycles = 85                                           *
*                                                                           *
*   CODESIZE                                                                *
*       224 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_maxidx
_DSP_maxidx:

        ADD     .L2X    2,  A4, B6  ; copy a
||      B               LOOP

        LDH     .D1 *A4++[2],   A3  ; x[j] = x[i + j]
||      LDH     .D2 *B6++[3],   B2  ; x[j] = x[i + j]
||      SUB     .L2 B4, 3,  B0      ; nx - 3

        LDH     .D1 *A4++[1],   A0  ; x[j] = x[i + j]
||[B0]  B       .S2 LOOP            ; for
||[B0]  SUB     .L2 B0, 3,  B0      ; i += 3
;-
        LDH     .D1 *A4++[2],   A3  ;* x[j] = x[i + j]
||      LDH     .D2 *B6++[3],   B2  ;* x[j] = x[i + j]
||      MVK     .S1 3, A7           ; FIX
||      MVK     .S2 3, B7           ; FIX

        LDH     .D1 *A4++[1],   A0  ;* x[j] = x[i + j]
||      MVK     .S1 -32768, A5      ; max1 = -32768
||[B0]  B       .S2 LOOP            ;* for
||[B0]  SUB     .L2 B0, 3,  B0      ; i += 3
;-
        LDH     .D1 *A4++[2],   A3  ;** x[j] = x[i + j]
||      LDH     .D2 *B6++[3],   B2  ;** x[j] = x[i + j]
||      MVK     .S1 -32768, A6      ; max3 = -32768
||      MVK     .S2 -32768, B5      ; max2 = -32768
||      ZERO    .L2 B4              ; i = 0
||      ZERO    .L1 A2              ; FIX
||      MPY     .M1 A7, 1, A8
;-
LOOP:
  [B0]  B       .S2 LOOP            ; for
||[A2]  MV      .S1 A0, A6          ; if (t[j]) max3[j]=x[j]
||[A2]  MPY     .M1X    1,  B4, A8  ; if (t[j]) index3 = i
||      CMPLT   .L1 A5, A3, A1      ;* t[j] = max1 < x[j]
||      CMPLT   .L2 B5, B2, B1      ;* t[j] = max2 < x[j]
||      LDH     .D1 *A4++[1],   A0  ;*** x[j] = x[i + j]
||      ADD     .D2 3,  B4, B4      ; i += 3
;-
  [B0]  SUB     .S2 B0, 3,  B0      ; i += 3
||      CMPLT   .L1 A6, A0, A2      ; t[j] = max3 < x[j]
||[A1]  MV      .S1 A3, A5          ; if (t[j]) max1=x[j]
||[B1]  MV      .L2 B2, B5          ; if (t[j]) max2=x[j]
||[A1]  MPY     .M1X 1,  B4, A7     ; if (t[j]) index1 = i
||[B1]  MPY     .M2  1,  B4, B7     ; if (t[j]) index2 = i
||      LDH     .D2 *B6++[3],   B2  ;*** x[j] = x[i + j]
||      LDH     .D1 *A4++[2],   A3  ;*** x[j] = x[i + j]

LOOP_END:
        CMPLT   .L2X    A5, B5, B1  ; t = max1< max2
||[A2]  MV      .D1 A0, A6          ; if (t[j]) max3= x[j]

        CMPEQ   .L2X    B5, A5, B0  ; te = max1 == max2
||[A2]  MV      .L1X    B4, A8      ; if (t) index3 = i
||      B       .S2 B3              ; Return from call

  [B1]  MV      .L1X    B5, A5      ; if (t) max1 = max2
||[B0]  CMPLTU  .L2X    B7, A7, B1  ;if(te) ti=index2<index1
;-
  [!B1] SUB     .D1 A7, 2,  A4      ; if (!ti)||(!te||t) index = index1 w/ ofs
||[B1]  SUB     .S1X    B7, 1,  A4  ; if (t) index= index2 w/ offset
||      CMPLT   .L1 A5, A6, A1      ; t = max1 < max3

        CMPEQ   .L1 A5, A6, A2      ; te = max1 == max3

  [A2]  CMPLTU  .L1 A8, A4, A1      ; if(te) ti=index3<index

  [A1]  SUB     .L1 A8, 1,  A4      ; if (t)||(ti) index = index3 w/ offset
||[!A1] SUB     .D1 A4, 1,  A4      ; if !(t||ti) index = index w/ offset
;-
* ========================================================================= *
*   End of file:  dsp_maxidx.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

maxval.asm/     1019093836  0     0     0       11603     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.3     Fri Mar 29 15:02:51 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_maxval                                                          *
*                                                                           *
*   REVISION DATE                                                           *
*       27-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           short DSP_maxval(const short *x, int nx);                       *
*                                                                           *
*           x  = address to array of values                                 *
*           nx = number of values in array                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine finds the maximum value of a vector and returns        *
*       the value.                                                          *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C description of the algorithm without           *
*       restrictionms.  This implementation may have restrictions           *
*       as noted under 'ASSUMPTIONS' below.                                 *
*                                                                           *
*           short DSP_maxval(const short *x, int nx)                        *
*           {                                                               *
*               int i;                                                      *
*               short DSP_maxval = -32768;                                  *
*                                                                           *
*               for (i = 0; i < nx; i++)                                    *
*                   if (x[i] > DSP_maxval)                                  *
*                        DSP_maxval = x[i];                                 *
*                                                                           *
*               return DSP_maxval;                                          *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Nx must be a multiple of 4.                                         *
*       Nx must be greater then or equal to 16.                             *
*       x[] must be word-aligned.                                           *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt tolerant but not interruptible.              *
*                                                                           *
*   CODESIZE                                                                *
*       224 bytes                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = nx / 2 + 21.                                               *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_maxval
_DSP_maxval:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_ptr
        .asg            A1,         A_g0
        .asg            A1,         A_g1
        .asg            A5,         A_m1
        .asg            A6,         A_m0
        .asg            A7,         A_x1x0
        .asg            A8,         A_x0__
        .asg            A9,         A_k8k
        .asg            B1,         B_g0
        .asg            B1,         B_g1
        .asg            B4,         B_nx
        .asg            B4,         B_ptr
        .asg            B5,         B_x0__
        .asg            B6,         B_x1x0
        .asg            B7,         B_m1
        .asg            B8,         B_m0
        .asg            B9,         B_k8k
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *

        ADD             A_ptr,      4,          B_ptr
||      SHRU    .S2     B_nx,       2,          B0

        LDW     .D2T2   *B_ptr++[2],            B_m1            ;[ 1,1]
||      LDW     .D1T1   *A_ptr++[2],            A_m1            ;[ 1,1]
||      MVK             -32768,     B_k8k
||      MVK             -32768,     A_k8k

        B       .S1     loop                                    ; mask ints
||      SUB             B0,         4,          B0
;-
        LDW     .D2T2   *B_ptr++[2],            B_x1x0          ;[ 1,2]
||      LDW     .D1T1   *A_ptr++[2],            A_x1x0          ;[ 1,2]

        B       .S1     loop                                    ;[ 6,1]

        LDW     .D2T2   *B_ptr++[2],            B_x1x0          ;[ 1,3]
||      LDW     .D1T1   *A_ptr++[2],            A_x1x0          ;[ 1,3]

        B       .S1     loop                                    ;[ 6,2]
||      SMPY    .M2     B_m1,       B_k8k,      B_m0            ;init m0
||      SMPY    .M1     A_m1,       A_k8k,      A_m0            ;init m0
;-
        SMPY    .M2     B_m1,       B_k8k,      B_x0__          ;[ 7,1]
||      SMPY    .M1     A_m1,       A_k8k,      A_x0__          ;[ 7,1]
||      LDW     .D2T2   *B_ptr++[2],            B_x1x0          ;[ 1,4]
||      LDW     .D1T1   *A_ptr++[2],            A_x1x0          ;[ 1,4]
||      ZERO    .L2     B_g0
||      ZERO    .L1     A_g0
; ===== 1 prolog stage collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [ B_g0]MV     .D2     B_x0__,     B_m0                        ;[10,1]
||[ A_g0]MV     .D1     A_x0__,     A_m0                        ;[10,1]
||      CMPGT   .L2     B_x1x0,     B_m1,       B_g1            ;[ 6,3]
||      CMPGT   .L1     A_x1x0,     A_m1,       A_g1            ;[ 6,3]
||[ B0] B       .S1     loop                                    ;[ 6,3]
||[ B0] SUB     .S2     B0,         1,          B0              ;[ 6,3]

        CMPLT   .L2     B_x0__,     B_m0,       B_g0            ;[ 9,2]
||      CMPLT   .L1     A_x0__,     A_m0,       A_g0            ;[ 9,2]
||      SMPY    .M2     B_x1x0,     B_k8k,      B_x0__          ;[ 7,3]
||      SMPY    .M1     A_x1x0,     A_k8k,      A_x0__          ;[ 7,3]
||[ B_g1]MV     .S2     B_x1x0,     B_m1                        ;[ 7,3]
||[ A_g1]MV     .S1     A_x1x0,     A_m1                        ;[ 7,3]
||      LDW     .D2T2   *B_ptr++[2],            B_x1x0          ;[ 1,6]
||      LDW     .D1T1   *A_ptr++[2],            A_x1x0          ;[ 1,6]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 3 epilog stages collapsed
  [ B_g0]MV     .D2     B_x0__,     B_m0                        ;[10,5]
||[ A_g0]MV     .D1     A_x0__,     A_m0                        ;[10,5]

        CMPLT   .L2     B_x0__,     B_m0,       B_g0            ;[ 9,6]
||      CMPLT   .L1     A_x0__,     A_m0,       A_g0            ;[ 9,6]
||      B       .S2     B3

  [ B_g0]NEG    .L2     B_x0__,     B_m0                        ;[10,6]
||[ A_g0]NEG    .L1     A_x0__,     A_m0                        ;[10,6]
||[!B_g0]NEG    .S2     B_m0,       B_m0
||[!A_g0]NEG    .S1     A_m0,       A_m0

        CMPGT   .L2X    B_m1,       A_m1,       B_g1
||      CMPGT   .L1X    A_m0,       B_m0,       A_g1

  [ B_g1]MV     .L1X    B_m1,       A_m1
||[ A_g1]MV     .L2X    A_m0,       B_m0

        CMPGT   .L1X    A_m1,       B_m0,       A_g0
||      SHR     .S1     A_m1,       16,         A4

  [!A_g0]SHR    .S1X    B_m0,       16,         A4

* ========================================================================= *
*   End of file:  dsp_maxval.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

minerror.asm/   1019093836  0     0     0       16041     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Fri Mar 22 01:54:04 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_minerror                                                        *
*                                                                           *
*   REVISION DATE                                                           *
*       08-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       int DSP_minerror                                                    *
*       (                                                                   *
*           const short *restrict GSP0_TABLE,                               *
*           short       *restrict errCoefs,                                 *
*           int         *restrict max_index                                 *
*       );                                                                  *
*                                                                           *
*       GSP0_TABLE[256*9] :  Pointer to GSP0 terms array.                   *
*                            Must be word aligned.                          *
*       errCoefs[9]       :  Array of error coefficients.                   *
*                            Must be word aligned.                          *
*       max_index         :  Index to GSP0_TABLE[max_index], the first      *
*                            element of the 9-element vector that resulted  *
*                            in the maximum dot product.                    *
*       return int        :  Maximum dot product result.                    *
*                                                                           *
*   DESCRIPTION                                                             *
*       Performs a dot product on 256 pairs of 9 element vectors and        *
*       searches for the pair of vectors which produces the maximum dot     *
*       product result. This is a large part of the VSELP vocoder codebook  *
*       search.                                                             *
*                                                                           *
*   C CODE                                                                  *
*       This is the C equivalent of the assembly code without restrictions  *
*       Note that the assembly code is hand optimized and restrictions may  *
*       apply.                                                              *
*                                                                           *
*       int DSP_minerror                                                    *
*       (                                                                   *
*           const short *restrict GSP0_TABLE,                               *
*           short       *restrict errCoefs,                                 *
*           int         *restrict max_index                                 *
*       )                                                                   *
*       {                                                                   *
*           int val, maxVal = -50;                                          *
*           int i, j;                                                       *
*                                                                           *
*           for (i = 0; i < GSP0_NUM; i++)                                  *
*           {                                                               *
*               for (val = 0, j = 0; j < GSP0_TERMS; j++)                   *
*                   val += GSP0_TABLE[i*GSP0_TERMS+j] * errCoefs[j];        *
*                                                                           *
*               if (val > maxVal)                                           *
*               {                                                           *
*                   maxVal = val;                                           *
*                   *max_index = i*GSP0_TERMS;                              *
*               }                                                           *
*           }                                                               *
*                                                                           *
*           return (maxVal);                                                *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Inner loop is completely unrolled.                                  *
*       Word-wide loads are used to read in GSP0_TABLE and errCoefs.        *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Arrays GSP0_TABLE[] and errCoefs[] must be word aligned.            *
*                                                                           *
*   MEMORY NOTE                                                             *
*       Align GSP0_TABLE[] and errCoefs[] at different memory banks to      *
*       avoid 4 bank conflicts.                                             *
*                                                                           *
*   NOTES                                                                   *
*       This code is LITTLE ENDIAN.                                         *
*       This code is interrupt-tolerant but not interruptible.              *
*                                                                           *
*   CYCLES                                                                  *
*      1189                                                                 *
*                                                                           *
*   CODESIZE                                                                *
*       576 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_minerror
_DSP_minerror:

        STW    .D2      A15, *B15--[8]  ; push A15
||      MV     .L1X     B15, A15
||      MVC    .S2      CSR, B9

        STW    .D1      A12, *-A15[7]   ; push A12            B15[1]
||      MV     .L1      A6,A12          ; A12 = savePtr_ret
||      AND    .S2      B9, -2, B0
||      STW    .D2      B9,  *+B15[2]   ; push A15

        STW    .D1      A10, *-A15[5]   ; push A10            B15[3]
||      STW    .D2      B10, *+B15[4]   ; push B10
||      MV     .L1X     B4,A9           ; errCoefs
||      MVC    .S2      B0,  CSR

        STW    .D1      A11, *-A15[3]   ; push A11            B15[5]
||      STW    .D2      B11, *+B15[6]   ; push B11
||      MV     .L1X     B3,A11          ; save return address
||      MV     .L2X     A4,B8           ; arg GSP0_TABLE

START:
        LDW     .D1     *+A9[2],A8      ; A15 = g(5) & g(4)
||      MVK     .S2     -42,B6          ; used for evaluating savePtr
||      MV      .L2     B8,B2           ; used for evaluating savePtr

        LDW     .D1     *A9,A10         ; A10 = g(1) & g(0)
||      LDW     .D2     *B8++,B0        ; B0 = x(1) & x(0)
||      MVK     .S1     2,A1            ; A1 = 2
||      MVK     .S2     -50,B11         ; set maxval = 0;

        LDW     .D1     *+A9[1],A7      ; A7 = g(3) & g(2)
||      LDW     .D2     *B8++,B0        ; B0 = x(3) & x(2)
||      MVK     .S1     127,A2          ; initialize loop cntr (N-1)

        LDW     .D2     *B8++,B0        ; B0 = x(5) & x(4)

        LDW     .D1     *+A9[3],A5      ; A5 = g(7) & g(6)
||      LDW     .D2     *B8++,B0        ; B0 = x(7) & x(6)
||      MVK     .S2     0,B1            ; initialize compare reg

        MVK     .S2     0,B10           ; initialize val
||      LDH     .D1     *+A9[8],A0      ; A0 = g(8)
||      LDW     .D2     *B8++,B0        ; B0 = x(0) & x(8)
||      MV      .L2X    A8,B5           ; copy g(5) & g(4) to other reg file

OUTLOOP:                ; OUTER LOOP BEGINS HERE
        MPY     .M1X    B0,A10,A3       ; p0 = x(0) * g(0)
||      MPYH    .M2X    B0,A10,B4       ; p1 = x(1) * g(1)
||      ADD     .L1     A3,A6,A6        ;* val0 += p0,
||      ADD     .L2     B4,B7,B7        ;* val1 += p1,
||      LDW     .D2     *B8++,B0        ; B0 = x(2) & x(1)
|| [B1] MV      .S2     B10,B11         ;* make val = maxval

        MPY     .M1X    B0,A7,A3        ; p0 = x(2) * g(2)
||      MPYH    .M2X    B0,A7,B4        ; p1 = x(3) * g(3)
||      LDW     .D2     *B8++,B0        ; B0 = x(4) & x(3)
||      ADD     .L1     A6,A3,A6        ;* val0 += p0,
||      ADD     .L2     B7,B4,B7        ;* val1 += p1,
|| [B1] ADD     .S2     B6,B8,B3        ;* update saveptr

        MPY     .M1X    B0,A8,A3        ; p0 = x(4) * g(4)
||      MPYH    .M2     B0,B5,B4        ; p1 = x(5) * g(5)
||      ADD     .S1     0,A3,A6         ; val0 += p0,
||      ADD     .S2     0,B4,B7         ; val1 += p1,
||      LDW     .D2     *B8++,B0        ; B0 = x(6) & x(5)
||      ADD     .L2X    B7,A6,B10       ;* val = val0 + val1,

        MPY     .M1X    B0,A5,A3        ; p0 = x(6) * g(6)
||      MPYH    .M2X    B0,A5,B4        ; p1 = x(7) * g(7)
||      ADD     .L1     A3,A6,A6        ; val0 += p0,
||      ADD     .S2     B4,B7,B7        ; val1 += p1,
||      LDW     .D2     *B8++,B0        ; B0 = x(8) & x(7)
||      CMPGT   .L2     B10,B11,B1      ;* compare val with maxval
|| [A2] B       .S1     OUTLOOP         ; for OUTLOOP

        MPY     .M1X    B0,A0,A3        ; p0 = x(8) * g(8)
||      MPYHL   .M2X    B0,A10,B4       ; p0 = x(0) * g(0)
||      ADD     .L1     A3,A6,A6        ; val0 += p0,
||      ADD     .L2     B4,B7,B7        ; val1 += p1,
||      LDW     .D2     *B8++,B0        ; B0 = x(1) & x(0)
|| [B1] MV      .S2     B10,B11         ;* make maxval = val

        MPYLH   .M2X    B0,A10,B4       ; p1 = x(1) * g(1)
||      MPYHL   .M1X    B0,A7,A3        ; p0 = x(2) * g(2)
||      LDW     .D2     *B8++,B0        ; B0 = x(3) & x(2)
||      ADD     .L1     A3,A6,A6        ;* val0 += p0,
||      ADD     .L2     B4,B7,B7        ;* val1 += p1,
|| [B1] ADD     .S2     B6,B8,B3        ;* update saveptr

        MPYLH   .M2X    B0,A7,B4        ; p1 = x(3) * g(3)
||      MPYHL   .M1X    B0,A8,A3        ; p0 = x(4) * g(4)
||      LDW     .D2     *B8++,B0        ; B0 = x(5) & x(4)
||      ADD     .L1     A6,A3,A6        ;* val0 += p0,
||      ADD     .L2     0,B4,B9         ;* val1 += p1,
||      ADD     .S1     -1,A2,A2        ; A2-- dec loop counter
|| [B1] ADD     .S2     2,B3,B3             ;* update saveptr

        MPYLH   .M2     B0,B5,B4        ; p1 = x(5) * g(5)
||      MPYHL   .M1X    B0,A5,A3        ; p0 = x(6) * g(6)
||      ADD     .D1     0,A3,A6         ; val0 = p0,
||      ADD     .S2     B9,B4,B7        ; val1 = p1,
||      LDW     .D2     *B8++,B0        ; B0 = x(7) & x(6)
|| [A1] ADD     .S1     -1,A1,A1        ; A1-- dec store counter
||      ADD     .L2X    B7,A6,B10       ;* val = val0 + val1,

        MPYLH   .M2X    B0,A5,B4        ; p1 = x(7) * g(7)
||      MPYHL   .M1X    B0,A0,A3        ; p0 = x(8) * g(8)
||      ADD     .L1     A6,A3,A6        ; val0 += p0,
||      ADD     .S2     B7,B4,B7        ; val1 += p1,
||      LDW     .D2     *B8++,B0        ; B0 = x(0) & x(8)
||      CMPGT   .L2     B10,B11,B1      ;* compare val with maxval

; OUTLOOP ENDS HERE

        ADD     .L1     A6,A3,A6        ; val0 += p0,
||      ADD     .L2     B7,B4,B7        ; val1 += p1,

        ADD     .L1     A6,A3,A6        ; val0 += p0,
||      ADD     .L2     B7,B4,B7        ; val1 += p1,

        ADD     .L2X    B7,A6,B10       ; val0 += val1,

        CMPGT   .L2     B10,B11,B1      ; compare val with maxval

   [B1] MV      .S2     B10,B11         ; make val = maxval
|| [B1] ADD     .D2     -9,B8,B3        ; update saveptr

        MV      .L1X    B11,A4          ; store maxVal return value
||      MV      .D1     A12,A6
||      SUB     .S2     B3,B2,B3        ; update saveptr

        SHR     .S2     B3, 1, B3       ; $ index to halfword

        MV      .S1     A11, A0
||      LDW     .D1     *-A15[3], A11
||      LDW     .D2     *+B15[6], B11
||      ADD     .L2     -9,B3,B3        ; $ update saveptr

        LDW     .D1     *-A15[5], A10
||      LDW     .D2     *+B15[4], B10

        LDW     .D1     *-A15[7], A12
||      LDW     .D2     *+B15[2], B9
||      B       .S2X    A0

        LDW     .D2     *++B15[8],A15

        STW     .D1     B3,*A6          ; $ store saveptr in A12

        NOP             2

        MVC             B9, CSR

* ========================================================================= *
*   End of file:  dsp_minerror.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

minval.asm/     1019093836  0     0     0       11665     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Wed Apr 17 15:51:08 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*    DSP_minval                                                             *
*                                                                           *
*   REVISION DATE                                                           *
*       27-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*        short DSP_minval(const short *x, int nx);                          *
*                                                                           *
*           x  = address to array of values                                 *
*           nx = number of values in array                                  *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine finds the minimum value of a vector and returns        *
*       the value.                                                          *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C description of the algorithm without           *
*       restrictionms.  This implementation may have restrictions           *
*       as noted under 'ASSUMPTIONS' below.                                 *
*                                                                           *
*           short DSP_minval(const short *x, int nx)                        *
*           {                                                               *
*               int i;                                                      *
*               short DSP_minval = 32767;                                   *
*                                                                           *
*               for (i = 0; i < nx; i++)                                    *
*                   if (x[i] < DSP_minval)                                  *
*                        DSP_minval = x[i];                                 *
*                                                                           *
*               return DSP_minval;                                          *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       Nx must be a multiple of 4.                                         *
*       Nx must be greater then or equal to 16.                             *
*       x[] must be word-aligned.                                           *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code is ENDIAN NEUTRAL.                                        *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt tolerant but not interruptible.              *
*                                                                           *
*   CODESIZE                                                                *
*       224 bytes                                                           *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = nx / 2 + 21.                                               *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_minval
_DSP_minval:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_ptr
        .asg            A1,         A_g0
        .asg            A1,         A_g1
        .asg            A5,         A_m1
        .asg            A6,         A_m0
        .asg            A7,         A_x1x0
        .asg            A8,         A_x0__
        .asg            A9,         A_k4k
        .asg            B1,         B_g0
        .asg            B1,         B_g1
        .asg            B4,         B_nx
        .asg            B4,         B_ptr
        .asg            B5,         B_x0__
        .asg            B6,         B_x1x0
        .asg            B7,         B_m1
        .asg            B8,         B_m0
        .asg            B9,         B_k4k
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *

        ADD             A_ptr,      4,          B_ptr
||      SHRU    .S2     B_nx,       2,          B0

        LDW     .D2T2   *B_ptr++[2],            B_m1            ;[ 1,1]
||      LDW     .D1T1   *A_ptr++[2],            A_m1            ;[ 1,1]
||      MVK             0x4000,     B_k4k
||      MVK             0x4000,     A_k4k

        B       .S1     loop                                    ; mask ints
||      SUB             B0,         4,          B0
;-
        LDW     .D2T2   *B_ptr++[2],            B_x1x0          ;[ 1,2]
||      LDW     .D1T1   *A_ptr++[2],            A_x1x0          ;[ 1,2]

        B       .S1     loop                                    ;[ 6,1]

        LDW     .D2T2   *B_ptr++[2],            B_x1x0          ;[ 1,3]
||      LDW     .D1T1   *A_ptr++[2],            A_x1x0          ;[ 1,3]

        B       .S1     loop                                    ;[ 6,2]
||      SMPY    .M2     B_m1,       B_k4k,      B_m0            ;init m0
||      SMPY    .M1     A_m1,       A_k4k,      A_m0            ;init m0
;-
        SMPY    .M2     B_m1,       B_k4k,      B_x0__          ;[ 7,1]
||      SMPY    .M1     A_m1,       A_k4k,      A_x0__          ;[ 7,1]
||      LDW     .D2T2   *B_ptr++[2],            B_x1x0          ;[ 1,4]
||      LDW     .D1T1   *A_ptr++[2],            A_x1x0          ;[ 1,4]
||      ZERO    .L2     B_g0
||      ZERO    .L1     A_g0
; ===== 1 prolog stage collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [ B_g0]MV     .D2     B_x0__,     B_m0                        ;[10,1]
||[ A_g0]MV     .D1     A_x0__,     A_m0                        ;[10,1]
||      CMPLT   .L2     B_x1x0,     B_m1,       B_g1            ;[ 6,3]
||      CMPLT   .L1     A_x1x0,     A_m1,       A_g1            ;[ 6,3]
||[ B0] B       .S1     loop                                    ;[ 6,3]
||[ B0] SUB     .S2     B0,         1,          B0              ;[ 6,3]

        CMPLT   .L2     B_x0__,     B_m0,       B_g0            ;[ 9,2]
||      CMPLT   .L1     A_x0__,     A_m0,       A_g0            ;[ 9,2]
||      SMPY    .M2     B_x1x0,     B_k4k,      B_x0__          ;[ 7,3]
||      SMPY    .M1     A_x1x0,     A_k4k,      A_x0__          ;[ 7,3]
||[ B_g1]MV     .S2     B_x1x0,     B_m1                        ;[ 7,3]
||[ A_g1]MV     .S1     A_x1x0,     A_m1                        ;[ 7,3]
||      LDW     .D2T2   *B_ptr++[2],            B_x1x0          ;[ 1,6]
||      LDW     .D1T1   *A_ptr++[2],            A_x1x0          ;[ 1,6]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 3 epilog stages collapsed
  [ B_g0]MV     .D2     B_x0__,     B_m0                        ;[10,5]
||[ A_g0]MV     .D1     A_x0__,     A_m0                        ;[10,5]

        CMPLT   .L2     B_x0__,     B_m0,       B_g0            ;[ 9,6]
||      CMPLT   .L1     A_x0__,     A_m0,       A_g0            ;[ 9,6]
||      B       .S2     B3

  [ B_g0]ADD    .D2     B_x0__,     B_x0__,     B_m0            ;[10,5]
||[ A_g0]ADD    .D1     A_x0__,     A_x0__,     A_m0            ;[10,5]
||[!B_g0]ADD    .L2     B_m0,       B_m0,       B_m0            ;[10,5]
||[!A_g0]ADD    .L1     A_m0,       A_m0,       A_m0            ;[10,5]

        CMPLT   .L2X    B_m1,       A_m1,       B_g1
||      CMPLT   .L1X    A_m0,       B_m0,       A_g1

  [ B_g1]MV     .L1X    B_m1,       A_m1
||[ A_g1]MV     .L2X    A_m0,       B_m0

        CMPLT   .L1X    A_m1,       B_m0,       A_g0
||      SHR     .S1     A_m1,       16,         A4

  [!A_g0]SHR    .S1X    B_m0,       16,         A4

* ========================================================================= *
*   End of file:  dsp_minval.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

mul32.asm/      1019093836  0     0     0       11623     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Fri Mar 29 19:40:03 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   NAME                                                                    *
*       DSP_mul32                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSP_mul32                                                  *
*           (                                                               *
*               const int    *x,                                            *
*               const int    *y,                                            *
*               int *restrict r,                                            *
*               int           nx                                            *
*           );                                                              *
*                                                                           *
*           x[nx] = pointer to input vector 1 of size nx                    *
*           y[nx] = pointer to input vector 2 of size nx                    *
*           r[nx] = pointer to output vector of size nx                     *
*           nx    = number of elements in input and output vectors          *
*                                                                           *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine performs a 32-bit by 32-bit multiply, returning the    *
*       upper 32 bits of the 64-bit result.  This is equivalent to a        *
*       Q31 x Q31 multiply, yielding a Q30 result.                          *
*                                                                           *
*   NOTES                                                                   *
*       The 32 x 32 multiply is constructed from 16 x 16 multiplies.        *
*       For efficiency reasons, the 'lo * lo' term of the 32 x 32           *
*       multiply is omitted, as it has minimal impact on the final          *
*       result.  This is due to the fact that the 'lo * lo' term            *
*       primarily affects the lower 32 bits of the result, and these        *
*       are not returned.  Due to this omission, the results of this        *
*       function differ from the exact results of a 32 x 32 multiply by     *
*       at most 1.                                                          *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       "nx" is at least 8 and is a multiple of 2.                          *
*       Arrays x[], y[] and r[] must be word aligned.                       *
*       Input and output arrays are independent of each other.              *
*                                                                           *
*   NOTES                                                                   *
*       This code is ENDIAN NEUTRAL.                                        *
*       This function is interrupt tolerant, but not interruptible.         *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = 1.5*nx + 24.                                               *
*                                                                           *
*   CODESIZE                                                                *
*       224 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_mul32
_DSP_mul32:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A0,         A_hh
        .asg            A1,         A_hl
        .asg            A2,         A_p
        .asg            A3,         A_y
        .asg            A4,         A_x
        .asg            A5,         A_a0_
        .asg            A6,         A_r
        .asg            A7,         A_b0
        .asg            A8,         A_lh
        .asg            A8,         A_ml
        .asg            A8,         A_mm
        .asg            A9,         A_mh
        .asg            A9,         A_mt
        .asg            A9,         A_r0
        .asg            A10,        A_a0
        .asg            B0,         B_a1
        .asg            B0,         B_r1
        .asg            B1,         B_hh
        .asg            B1,         B_lh
        .asg            B2,         B_i
        .asg            B4,         B_y
        .asg            B5,         B_hl
        .asg            B6,         B_nx
        .asg            B6,         B_x
        .asg            B7,         B_r
        .asg            B8,         B_a1_
        .asg            B9,         B_b1
        .asg            B10,        B_ml
        .asg            B10,        B_mm
        .asg            B11,        B_mh
        .asg            B11,        B_mt
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *

        ADD     .L2X    A_x,        4,          B_x
||      ADD     .L1X    B_y,        4,          A_y
||      SHR             B_nx,       1,          B_i
||      STW     .D2T2   B10,        *B15--[4]

        LDW     .D2T2   *B_x++[2],  B_a1_                       ;[ 1,1]
||      LDW     .D1T1   *A_x++[2],  A_a0_                       ;[ 1,1]
||      B       .S1     loop
||      MV              B15,        A0
;-
        MVK     .S1     3,          A_p
||      ADD     .L2X    A_r,        4,         B_r
||      STW     .D1T1   A10,        *A0[1]
||      STW     .D2T2   B11,        *B15[2]

        LDW     .D1T2   *A_y++[2],  B_b1                        ;[ 3,1]
||      LDW     .D2T1   *B_y++[2],  A_b0                        ;[ 3,1]
;-
; ===== 3 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        ADD     .L2     B_hh,       B_mm,       B_r1            ;[13,1]
||      ADD     .S1     A_hh,       A_mm,       A_r0            ;[13,1]
||[ B_i]B       .S2     loop                                    ;[10,2]
||      MPYH    .M2     B_a1,       B_b1,       B_hh            ;[10,2]
||      MPYH    .M1     A_a0,       A_b0,       A_hh            ;[10,2]
||      MV      .L1     A_a0_,      A_a0                        ;[ 7,3]
||      LDW     .D2T2   *B_x++[2],  B_a1_                       ;[ 1,5]
||      LDW     .D1T1   *A_x++[2],  A_a0_                       ;[ 1,5]

  [ A_p]SUB     .S1     A_p,        1,          A_p             ;[14,1]
||[!A_p]STW     .D2T2   B_r1,       *B_r++[2]                   ;[14,1]
||[!A_p]STW     .D1T1   A_r0,       *A_r++[2]                   ;[14,1]
||      ADD     .L2     B_hl,       B_lh,       B_mh:B_ml       ;[11,2]
||      ADD     .L1     A_hl,       A_lh,       A_mh:A_ml       ;[11,2]
||      MPYHSLU .M2     B_a1_,      B_b1,       B_hl            ;[ 8,3]
||      MPYHSLU .M1     A_a0_,      A_b0,       A_hl            ;[ 8,3]
||      MV      .S2     B_a1_,      B_a1                        ;[ 8,3]

        SHR     .S2     B_mh:B_ml,  16,         B_mt:B_mm       ;[12,2]
||      SHR     .S1     A_mh:A_ml,  16,         A_mt:A_mm       ;[12,2]
||[ B_i]SUB     .L2     B_i,        1,          B_i             ;[ 9,3]
||      MPYLUHS .M2     B_a1,       B_b1,       B_lh            ;[ 9,3]
||      MPYLUHS .M1     A_a0,       A_b0,       A_lh            ;[ 9,3]
||      LDW     .D1T2   *A_y++[2],  B_b1                        ;[ 3,5]
||      LDW     .D2T1   *B_y++[2],  A_b0                        ;[ 3,5]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 3 epilog stages collapsed
;-
        ADD     .L2     B_hh,       B_mm,       B_r1            ;[13,5]
||      ADD     .S1     A_hh,       A_mm,       A_r0            ;[13,5]
||      LDW     .D2T2   *B15[2],    B11
||      MV              B15,        A0
||      B       .S2     B3

        LDW     .D1T1   *A0[1],     A10
||      LDW     .D2T2   *++B15[4],  B10

        NOP             3
;-
        STW     .D2T2   B_r1,       *B_r++[2]                   ;[14,5]
||      STW     .D1T1   A_r0,       *A_r++[2]                   ;[14,5]
;-
* ========================================================================= *
*   End of file:  dsp_mul32.asm                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

neg32.asm/      1019093836  0     0     0       8865      `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.7     Fri Mar 29 16:07:26 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_neg32                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and may be called using the following   *
*       C function prototype:                                               *
*                                                                           *
*           void DSP_neg32                                                  *
*           (                                                               *
*               const int *restrict x,      /* Input data array     */      *
*               int       *restrict r,      /* Output data array    */      *
*               int       nx                /* Number of elements.  */      *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine negates an array of 32-bit integers.                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx must be at least 4 and a multiple of 2.                          *
*       Arrays x[] and r[] must be word aligned.                            *
*       The input and output arrays must not overlap.                       *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt tolerant, but not interruptible.  It locks   *
*       out interrupts for its entire duration.                             *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This code has no bank conflicts, regardless of the alignment        *
*       of 'x' and 'r'.                                                     *
*                                                                           *
*       This kernel is ENDIAN NEUTRAL.                                      *
*                                                                           *
*   CYCLES                                                                  *
*       nx + 18                                                             *
*                                                                           *
*   CODESIZE                                                                *
*       128 bytes                                                           *
*                                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_neg32
_DSP_neg32:
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x
        .asg            B4,         B_r
        .asg            A6,         A_nx
        .asg            B6,         B_x
        .asg            B7,         B_x32
        .asg            A7,         A_x10
        .asg            B5,         B_r32
        .asg            A8,         A_r10
        .asg            B0,         B_p
        .asg            A5,         A_r
        .asg            A1,         A_i
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        B               loop
||      SHR             A_nx,       1,          A_i

        ADD     .L2X    A_x,        4,          B_x
||      ADD     .L1X    B_r,        4,          A_r
||      SUB             A_i,        2,          A_i

  [ A_i]B               loop
||      LDW     .D1T1   *A_x++[2],  A_x10                       ;[ 1,1]
||      LDW     .D2T2   *B_x++[2],  B_x32                       ;[ 1,1]
;-
        MVK             2,          B_p
||[ A_i]SUB             A_i,        1,          A_i

; ===== 2 prolog stages removed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [ A_i]B       .S2     loop                                    ;[ 3,3]
||[ A_i]SUB     .S1     A_i,        1,          A_i             ;[ 1,4]
||      LDW     .D1T1   *A_x++[2],  A_x10                       ;[ 1,4]
||      LDW     .D2T2   *B_x++[2],  B_x32                       ;[ 1,4]
;-
  [ B_p]SUB     .S2     B_p,        1,          B_p             ;[ 8,1]
||[!B_p]STW     .D2T1   A_r10,      *B_r++[2]                   ;[ 8,1]
||[!B_p]STW     .D1T2   B_r32,      *A_r++[2]                   ;[ 8,1]
||      NEG     .L1     A_x10,      A_r10                       ;[ 6,2]
||      NEG     .L2     B_x32,      B_r32                       ;[ 6,2]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 1 epilog stage removed

        B               B3
||      STW     .D2T1   A_r10,      *B_r                        ;[ 8,3]
||      STW     .D1T2   B_r32,      *A_r                        ;[ 8,3]
;-
        NEG     .L1     A_x10,      A_r10                       ;[ 6,4]
||      NEG     .S2     B_x32,      B_r32                       ;[ 6,4]

        STW     .D2T1   A_r10,      *B_r[2]                     ;[ 8,4]
||      STW     .D1T2   B_r32,      *A_r[2]                     ;[ 8,4]

        NOP             3
;-
* ========================================================================= *
*   End of file:  dsp_neg32.asm                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

q15tofl.asm/    1019093836  0     0     0       12515     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Fri Mar 22 01:54:29 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_q15tofl -- Q.15 to IEEE float conversion                        *
*                                                                           *
*   REVISION DATE                                                           *
*       17-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSP_q15tofl (short *x, float *r, int nx)                   *
*                                                                           *
*           x[nx]  ---  Pointer to Q15 input vector of size nx              *
*           r[nx]  ---  Pointer to floating-point output data vector        *
*                       of size nx containing the floating-point equivalent *
*                       of vector input                                     *
*           nx     ---  length of input and output data vectors             *
*                                                                           *
*   DESCRIPTION                                                             *
*       Converts the Q15 stored in vector input to IEEE floating point      *
*       numbers stored in vector output.                                    *
*                                                                           *
*       void DSP_q15tofl (short *x, float *r, int nx)                       *
*       {                                                                   *
*        int i;                                                             *
*                                                                           *
*        for (i=0;i<nx;i++)                                                 *
*             r[i]=(float)x[i]/0x8000;                                      *
*       }                                                                   *
*                                                                           *
*       The above C code is a general implementation without                *
*       restrictions.  The assembly code may have some restrictions, as     *
*       noted below.                                                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       unrolled loop 2x                                                    *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       nx must be a multiple of 2                                          *
*                                                                           *
*   MEMORY NOTE                                                             *
*       no bank conflicts occur ever                                        *
*                                                                           *
*   NOTES                                                                   *
*       this routine is interrupt-tolerant but not interruptible            *
*       this routine is ENDIAN NEUTRAL                                      *
*                                                                           *
*   CYCLES                                                                  *
*       5/2 * nx + 18                                                       *
*                                                                           *
*   CODESIZE                                                                *
*       288 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_q15tofl
_DSP_q15tofl:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_q15_ptr
        .asg            B9,         B_mask
        .asg            A3,         A_offset
        .asg            B4,         B_float_ptr
        .asg            B0,         B_n
        .asg            A0,         A_n
        .asg            B2,         B_p
        .asg            B1,         B_input_1
        .asg            B7,         B_sign_1
        .asg            A1,         A_inputa_1
        .asg            A7,         A_exp_1
        .asg            A5,         A_mant_1
        .asg            A6,         A_mants_1
        .asg            A6,         A_exp128_1
        .asg            B5,         B_exp128s_1
        .asg            B5,         B_u_float_1
        .asg            B5,         B_float32_1
        .asg            B8,         B_input_2
        .asg            B6,         B_sign_2
        .asg            A1,         A_inputa_2
        .asg            A7,         A_exp_2
        .asg            A7,         A_mant_2
        .asg            A7,         A_mants_2
        .asg            A5,         A_exp128_2
        .asg            B7,         B_exp128s_2
        .asg            B1,         B_u_float_2
        .asg            B5,         B_float32_2
* ========================================================================= *

        MVK     .S2     0x1,        B_mask                      ; setup

* =========================== PIPE LOOP PROLOG ============================ *
        LDH     .D1T2   *A_q15_ptr++,           B_input_1       ;[ 1,1]
||      SHL     .S2     B_mask,     31,         B_mask          ; setup

        LDH     .D1T2   *A_q15_ptr++,           B_input_2       ;[ 2,1]
||      MVK     .S2     0xFFFF8000, B_p                         ; setup
||      SHR     .S1     A6,         1,          A_n             ; setup

        B       .S2     loop                                    ;[13,2]
||      SUB     .L2X    A_n,        1,          B_n             ; setup
||      MVK     .S1     143,        A_offset                    ; setup

* =========================== PIPE LOOP KERNEL ============================ *
loop:
  [!B_p]STW     .D2T2   B_float32_2,            *B_float_ptr++  ;[14,1]
||      LMBD    .L1     1,          A_inputa_2, A_exp_2         ;[ 9,2]
||      SHL     .S2X    A_exp128_1, 23,         B_exp128s_1     ;[ 9,2]
||      EXTU    .S1     A_mant_1,   1,  9,      A_mants_1       ;[ 9,2]
||      MPY     .M1     0,          A_exp128_1, A_exp128_1      ;[ 4,3]

  [ B_n]SUB     .D2     B_n,        1,          B_n             ;[10,2]
||[ A_inputa_2]SUB.D1   A_offset,   A_exp_2,    A_exp128_2      ;[10,2]
||      SHL     .S1     A_inputa_2, A_exp_2,    A_mant_2        ;[10,2]
||      AND     .S2     B_input_2,  B_mask,     B_sign_2        ;[10,2]
||      ADD     .L2X    A_mants_1,  B_exp128s_1,B_u_float_1     ;[10,2]

        SHL     .S2X    A_exp128_2, 23,         B_exp128s_2     ;[11,2]
||      EXTU    .S1     A_mant_2,   1,  9,      A_mants_2       ;[11,2]
||      OR      .L2     B_u_float_1,B_sign_1,   B_float32_1     ;[11,2]
||      ABS     .L1X    B_input_1,  A_inputa_1                  ;[ 6,3]
||      LDH     .D1T2   *A_q15_ptr++,           B_input_1       ;[ 1,4]
||      MPY     .M2     2,          B_p,        B_p             ; prolog coll

        ADD     .L2X    A_mants_2,  B_exp128s_2,B_u_float_2     ;[12,2]
||      LMBD    .L1     1,          A_inputa_1, A_exp_1         ;[ 7,3]
||      AND     .S2     B_input_1,  B_mask,     B_sign_1        ;[ 7,3]
||      LDH     .D1T2   *A_q15_ptr++,           B_input_2       ;[ 2,4]

  [ B_n]B       .S2     loop                                    ;[13,2]
||      OR      .L2     B_u_float_2,B_sign_2,   B_float32_2     ;[13,2]
||[!B_p]STW     .D2T2   B_float32_1,            *B_float_ptr++  ;[13,2]
||      MPY     .M1     0,          A_exp128_2, A_exp128_2      ;[ 8,3]
||      ABS     .L1X    B_input_2,  A_inputa_2                  ;[ 8,3]
||[ A_inputa_1]SUB.D1   A_offset,   A_exp_1,    A_exp128_1      ;[ 8,3]
||      SHL     .S1     A_inputa_1, A_exp_1,    A_mant_1        ;[ 8,3]

* =========================== PIPE LOOP EPILOG ============================ *
        STW     .D2T2   B_float32_2,            *B_float_ptr++  ;[14,3]
||      LMBD    .L1     1,          A_inputa_2, A_exp_2         ;[ 9,4]
||      SHL     .S2X    A_exp128_1, 23,         B_exp128s_1     ;[ 9,4]
||      EXTU    .S1     A_mant_1,   1,  9,      A_mants_1       ;[ 9,4]

  [ B_n]SUB     .D2     B_n,        1,          B_n             ;[10,4]
||[ A_inputa_2]SUB.D1   A_offset,   A_exp_2,    A_exp128_2      ;[10,4]
||      SHL     .S1     A_inputa_2, A_exp_2,    A_mant_2        ;[10,4]
||      AND     .S2     B_input_2,  B_mask,     B_sign_2        ;[10,4]
||      ADD     .L2X    A_mants_1,  B_exp128s_1,B_u_float_1     ;[10,4]

        SHL     .S2X    A_exp128_2, 23,         B_exp128s_2     ;[11,4]
||      EXTU    .S1     A_mant_2,   1,  9,      A_mants_2       ;[11,4]
||      OR      .L2     B_u_float_1,B_sign_1,   B_float32_1     ;[11,4]

        ADD     .L2X    A_mants_2,  B_exp128s_2,B_u_float_2     ;[12,4]
||      B       .S2     B3

        OR      .L2     B_u_float_2,B_sign_2,   B_float32_2     ;[13,4]
||      STW     .D2T2   B_float32_1,*B_float_ptr++              ;[13,4]

        STW     .D2T2   B_float32_2,*B_float_ptr++              ;[14,4]

        NOP             3

* ========================================================================= *
*   End of file:  dsp_q15tofl.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

r4fft.asm/      1019093836  0     0     0       25059     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.1     Fri Dec  7 02:42:02 2001 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS INC.                                                  *
*                                                                           *
*   NAME                                                                    *
*       Complex FFT (Radix 4)                                               *
*                                                                           *
*   REVISION DATE                                                           *
*       06-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable and can the called as                    *
*                                                                           *
*       void DSP_r4fft(int n, short *restrict x, const short *restrict w);  *
*                                                                           *
*       n    --- FFT size (power of 4)                  (input)             *
*       x[]  --- input and output sequences (dim-n)     (input/output)      *
*       w[]  --- FFT coefficients (dim-n)               (input)             *
*                                                                           *
*       If the routine is not to be used as a C callable function,          *
*       then all instructions relating to stack should be removed.          *
*       Refer to comments of individual instructions. You will also         *
*       need to initialize values for all the values passed as these        *
*       are assumed to be in registers as defined by the calling            *
*       convention of the compiler, (refer to the C compiler reference      *
*       guide.)                                                             *
*                                                                           *
*   C CODE                                                                  *
*                                                                           *
*       This is the C equivalent of the Assembly Code without the           *
*       assumptions listed below. Note that the assembly code is hand       *
*       optimized and assumptions apply.                                    *
*                                                                           *
*       SOURCE:Burrus, Parks p .113                                         *
*                                                                           *
*   void DSP_r4fft(int n, short *restrict x, const short *restrict w)       *
*   {                                                                       *
*       int             n1, n2, ie, ia1, ia2, ia3, i0, i1, i2, i3, j, k;    *
*       short           t, r1, r2, s1, s2, co1, co2, co3, si1, si2, si3;    *
*                                                                           *
*       n2 = n;                                                             *
*       ie = 1;                                                             *
*       for (k = n; k > 1; k >>= 2)                                         *
*       {                                                                   *
*           n1 = n2;                                                        *
*           n2 >>= 2;                                                       *
*           ia1 = 0;                                                        *
*           for (j = 0; j < n2; j++)                                        *
*           {                                                               *
*               ia2 = ia1 + ia1;                                            *
*               ia3 = ia2 + ia1;                                            *
*               co1 = w[ia1 * 2 + 1];                                       *
*               si1 = w[ia1 * 2];                                           *
*               co2 = w[ia2 * 2 + 1];                                       *
*               si2 = w[ia2 * 2];                                           *
*               co3 = w[ia3 * 2 + 1];                                       *
*               si3 = w[ia3 * 2];                                           *
*               ia1 = ia1 + ie;                                             *
*               for (i0 = j; i0 < n; i0 += n1)                              *
*               {                                                           *
*                   i1 = i0 + n2;                                           *
*                   i2 = i1 + n2;                                           *
*                   i3 = i2 + n2;                                           *
*                   r1 = x[2 * i0] + x[2 * i2];                             *
*                   r2 = x[2 * i0] - x[2 * i2];                             *
*                   t = x[2 * i1] + x[2 * i3];                              *
*                   x[2 * i0] = r1 + t;                                     *
*                   r1 = r1 - t;                                            *
*                   s1 = x[2 * i0 + 1] + x[2 * i2 + 1];                     *
*                   s2 = x[2 * i0 + 1] - x[2 * i2 + 1];                     *
*                   t = x[2 * i1 + 1] + x[2 * i3 + 1];                      *
*                   x[2 * i0 + 1] = s1 + t;                                 *
*                   s1 = s1 - t;                                            *
*                   x[2 * i2] = (r1 * co2 + s1 * si2) >> 15;                *
*                   x[2 * i2 + 1] = (s1 * co2-r1 * si2)>>15;                *
*                   t = x[2 * i1 + 1] - x[2 * i3 + 1];                      *
*                   r1 = r2 + t;                                            *
*                   r2 = r2 - t;                                            *
*                   t = x[2 * i1] - x[2 * i3];                              *
*                   s1 = s2 - t;                                            *
*                   s2 = s2 + t;                                            *
*                   x[2 * i1] = (r1 * co1 + s1 * si1)  >>15;                *
*                   x[2 * i1 + 1] = (s1 * co1-r1 * si1)>>15;                *
*                   x[2 * i3] = (r2 * co3 + s2 * si3)  >>15;                *
*                   x[2 * i3 + 1] = (s2 * co3-r2 * si3)>>15;                *
*               }                                                           *
*           }                                                               *
*           ie <<= 2;                                                       *
*       }                                                                   *
*   }                                                                       *
*                                                                           *
*   DESCRIPTION                                                             *
*                                                                           *
*       This routine is used to compute FFT of a complex sequece            *
*       of size n, a power of 4, with "decimation-in-frequency              *
*       decomposition" method. The output is in digit-reversed              *
*       order. Each complex value is with interleaved 16-bit real           *
*       and imaginary parts.                                                *
*                                                                           *
*   TECHNIQUES                                                              *
*       1. Loading input x as well as coefficient w in word.                *
*       2. Both loops j and i0 shown in the C code are placed in the        *
*          INNERLOOP of the assembly code.                                  *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       4 <= n <= 65536                                                     *
*       x is aligned on a 4*N Byte (N*word) boundary                        *
*       w is aligned on an odd word boundary                                *
*       x data is stored in the order real[0], image[0], real[1], ...       *
*       w coef is stored in the order k*sin[0*delta], k*cos[0*delta],       *
*              k*sin[1*delta], ...  where delta = 2*PI/N, k = 32767         *
*                                                                           *
*   MEMORY NOTE                                                             *
*       x must be aligned on a 4*N Byte (N*word) boundary for circular      *
*       buffering.  w should be aligned on an odd word boundary to          *
*       minimize memory bank hits.  There are N/4 memory bank hits total    *
*                                                                           *
*   CYCLES                                                                  *
*       LOGBASE4(N) * (10 * N/4 + 29) + 36 + N/4                            *
*       (This includes all function-call overhead, as well as stack         *
*       save and restore overhead.)                                         *
*                                                                           *
*   CODESIZE                                                                *
*       736 bytes                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .global _DSP_r4fft
        .text

        .text
        .global _DSP_r4fft
_DSP_r4fft:

; ================= SYMBOLIC REGISTER ASSIGNMENTS: SETUP ================== ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A3,         A_SP        ; Stack pointer, A datapath
        .asg            B0,         B_csr       ; CSR's value
        .asg            B1,         B_no_gie    ; CSR w/ GIE bit cleared
        .asg            A0,         A_csr       ; Copy of CSR's value
        .asg            B3,         B_ret       ; Return address
        .asg            B2,         B_irp       ; Old value of IRP
; ========================================================================= ;
        ; Stack frame.  14 words:  A10..A15, B10..B14, B3, CSR, pad
;-
        STW     .D2T1   A15,        *B_SP--[16]             ; Get stk, Save A15
||      MV              B_SP,       A_SP                    ; Twin Stack Ptr

        STW     .D1T1   A14,        *-A_SP[ 2]              ; Save A14
||      STW     .D2T2   B14,        *+B_SP[13]              ; Save B14
||      MVC     .S2     CSR,        B_csr                   ; Get CSR's state

        STW     .D1T1   A13,        *-A_SP[ 4]              ; Save A13
||      STW     .D2T2   B13,        *+B_SP[11]              ; Save B13
||      AND             B_csr,      -2,         B_no_gie    ; Clear GIE
;-
        STW     .D1T1   A12,        *-A_SP[ 6]              ; Save A12
||      STW     .D2T2   B12,        *+B_SP[ 9]              ; Save B12

        STW     .D1T1   A11,        *-A_SP[ 8]              ; Save A11
||      STW     .D2T2   B11,        *+B_SP[ 7]              ; Save B11
||      MV              B_csr,      A_csr                   ; Partitioning MV

        STW     .D1T1   A10,        *-A_SP[10]              ; Save A10
||      STW     .D2T2   B10,        *+B_SP[ 5]              ; Save B10
||      MVC     .S2     B_no_gie,   CSR                     ; Disable ints.
; ===== Interrupts masked here =====
;-
        STW     .D1T1   A_csr,      *-A_SP[12]              ; Save CSR
||      STW     .D2T2   B_ret,      *+B_SP[ 3]              ; Save return addr.
||      MVC     .S2     IRP,        B_irp

        STW     .D2T2   B_irp,      *+B_SP[ 2]
||      MVK     .S1     32,     A1              ; A1 = 32
||      LMBD    .L1     1,      A4,     A2      ; 31 - log2(n)
||      SHR     .S2X    A4,     2,      B6      ; n2 = n / 4
||      ZERO    .L2     B7                      ; mask
;-
        SUB     .L1     A1,     A2,     A4      ; log2(n)+1 (circ buff size)
||      SHR     .S1     A4,     1,      A7      ; 2 * n2 = n / 2, a-side
||      SHR     .S2X    A4,     1,      B9      ; 2 * n2 = n / 2, b-side

        SHL     .S1     A4,     16,     A4      ; shift into BK0 field
||      LDW     .D1T1   *+A6[2],        A1      ; setup twiddle factor pointer

        ADDK    .S1     0404h,  A4              ; A5, B5 set circ mode on BK0
||      OR      .L2     B7,     1,      B8      ; ie = 1
||      MVC     .S2     B_SP,       IRP
;-
        MVC     .S2X    A4,     AMR             ; load AMR
||      SUB     .L2     B6,     1,      B0      ; loop coutner = n / 4 - 1
||      STW     .D2T2   B4,         *+B_SP[ 1]

K_LOOP:
        MV      .L2     B4,     B5              ; reset X load pointer
||      MV      .L1X    B4,     A5              ; reset X store pointer
||      ADD     .D2     B0,     1,      B1      ; i = loop counter + 1

        SUBAW   .D1     A5,     A7,     A5      ; setup for first preincrement
||      AND     .S2     B1,     B7,     B1      ; j loop twiddle reload test
;-
        SUBAW   .D1     A5,     A7,     A5      ; setup for first preincrement
||      MPY     .M2     B1,     1,      B2      ; j loop twiddle reload test

        LDW     .D2     *B5++[B6],      B10     ; xi0=xt[0*n2],yi0 = yt[0*n2+1]

        LDW     .D2     *B5++[B6],      A8      ; xi1=xt[2*n2],yi1 = yt[2*n2+1]
||[!B2] LDW     .D1     *A6,            B15     ; si1 = w[2 * j], co1 = w[2*j+1]

        LDW     .D2     *B5++[B6],      B11     ; xi2=xt[4*n2],yi2 = yt[4*n2+1]
||[!B2] LDW     .D1     *A6,            A3      ; si2 = w[4*j], co2 = w[4*j+1]

        LDW     .D2     *B5++[B6],      A9      ; xi3=xt[6*n2],yi3 = yt[6*n2+1]
;-
        ZERO    .S1     A4                      ; j = 0

  [!B2] ADD     .L1X    A4,     B8,     A4      ; j += ie

  [!B2] LDW     .D1     *A6,            A13     ; si3 = w[6*j], co3 = w[6*j+1]

        SUB2    .S2     B10,    B11,    B3      ; r2a=xi0 - xi2,s2a = yi0 - yi2
||      ADD     .L2     B0,     0,      B1      ;* i = loop counter

        SUB2    .S1     A8,     A9,     A10     ; t3=xi1 - xi3,  t1 = yi1 - yi3
||      AND     .S2     B1,     B7,     B1      ;* j loop twiddle reload test
||      ZERO    .L1     A2                      ; first pass cond. init to zero
;-
        ADD2    .S1     A8,     A9,     A8      ; t0=xi1 + xi3,  t2 = yi1 + yi3
||      ADD2    .S2     B10,    B11,    B1      ; r1a=xi0 + xi2,s1a = yi0 + yi2
||      MPY     .M2     B1,     1,      B2      ;* j loop twiddle reload test
||[!B1] ADDAW   .D2     B5,     1,      B5      ;* reset x input, (circular)
||[!B2] SUBAW   .D1     A5,     1,      A5      ;
||      ADD     .L2     B0,     1,      B0      ;
;-
LOOP:

        SHR     .S1X    B3,     16,     A9      ;* extract s2a
||      SHR     .S2X    A10,    16,     B10     ;* extract t1
||[!B2] ADDAW   .D1     A5,     1,      A5      ;* reset x output, (circular)
||      LDW     .D2     *B5++[B6],      B10     ;** xi0=xt[0*n2], yi0=yt[0*n2+1]
||      MV      .L1     A6,     A1              ;** reset w
;-
        ADD     .L2     B3,     B10,    B11     ;* r1c = r2a + t1
||      SUB     .L1     A9,     A10,    A12     ;* s1c = s2a - t3
||      SUB2    .S2X    B1,     A8,     B1      ;* r1b=r1a - t0, s1b = s1a - t2
||      ADD2    .S1X    B1,     A8,     A8      ;* xo0=r1a + t0, yo0 = s1a + t2
||      LDW     .D2     *B5++[B6],      A8      ;** xi1=xt[2*n2], yi1=yt[2*n2+1]
||[!B2] LDW     .D1     *++A1[A4],      B15     ;** si1 = w[2*j], co1 = w[2*j+1]
;-
  [A2]  ADD     .S2X    A11,    2,      B3      ; copy B-side x store pointer
||[A2]  SHR     .S1     A14,    15,     A14     ; xo2 = xa2 >> 15
||      SUB     .L2     B3,     B10,    B12     ;* r2c = r2a - t1
||      ADD     .L1     A9,     A10,    A9      ;* s2c = s2a + t3
||      MPY     .M1X    A12,    B15,    A10     ;* ss1 = s1c * si1
||      MPYLH   .M2     B11,    B15,    B10     ;* rc1 = r1c * co1
||      LDW     .D2     *B5++[B6],      B11     ;** xi2=xt[4*n2], yi2=yt[4*n2+1]
||[!B2] LDW     .D1     *++A1[A4],      A3      ;** si2 = w[4*j], co2 = w[4*j+1]
;-
  [A2]  SHR     .S2     B13,    15,     B13     ; yo1 = ya1 >> 15
||[A2]  SHR     .S1     A15,    15,     A15     ; xo3 = xa3 >> 15
||      MPYLH   .M1X    B1,     A3,     A10     ;* rc2 = r1b * co2
||      MPYLH   .M2X    A12,    B15,    B11     ;* sc1 = s1c * co1
||      LDW     .D2     *B5++[B6],      A9      ;** xi3=xt[6*n2], yi3=yt[6*n2+1]
||      ADDAW   .D1     A5,     A7,     A5      ;
;-
  [A2]  SHR     .S2     B14,    15,     B14     ; yo2 = ya2 >> 15
||[B0]  B       .S1     LOOP                    ; for i
||      MPY     .M1     A9,     A13,    A12     ;* ss3 = s2c * si3
||      ADD     .L1X    B10,    A10,    A8      ;* xa1 = rc1 + ss1
||      MPY     .M2     B11,    B15,    B13     ;* rs1 = r1c * si1
||[B0]  STW     .D1     A8,     *++A5[A7]       ;* xt[0*n2]=xo0,  yt[0*n2+1]=yo0
;-
  [A2]  STH     .D2     B13,    *B3++[B9]       ; yt[2 * n2 + 1] = yo1
||[A2]  SHR     .S2     B4,     15,     B4      ; yo3 = ya3 >> 15
||[A2]  STH     .D1     A0,     *A11++[A7]      ; xt[2 * n2] = xo1
||      SHR     .S1     A8,     15,     A0      ;* xo1 = xa1 >> 15
||      MPYH    .M2X    B1,     A3,     B14     ;* sc2 = s1b * co2
||      MPYHL   .M1X    B1,     A3,     A9      ;* ss2 = s1b * si2
;-
  [A2]  STH     .D2     B14,    *B3++[B9]       ; yt[4 * n2 + 1] = yo2
||      MPYLH   .M1     A9,     A13,    A1      ;* sc3 = s2c * co3
||      MPY     .M2X    B1,     A3,     B12     ;* rs2 = r1b * si2
||      SUB     .L2     B11,    B13,    B13     ;* ya1 = sc1 - rs1
||[!B2] LDW     .D1     *++A1[A4],      A13     ;** si3 = w[6*j], co3 = w[6*j+1]
||[!B2] ADD     .L1X    A4,     B8,     A4      ;** j += ie
||      SUB     .S2     B0,     1,      B0      ;*** generate loop counter
;-
  [A2]  STH     .D2     B4,     *B3             ; yt[6 * n2 + 1] = yo3
||[A2]  STH     .D1     A14,    *A11++[A7]      ; xt[4 * n2] = xo2
||      MPY     .M2X    B12,    A13,    B12     ;* rs3 = r2c * si3
||      MPYLH   .M1X    B12,    A13,    A11     ;* rc3 = r2c * co3
||      ADD     .L1     A10,    A9,     A14     ;* xa2 = rc2 + ss2
||      SUB2    .S2     B10,    B11,    B3      ;** r2a = xi0-xi2, s2a = yi0-yi2
||      SUB     .L2     B0,     1,      B1      ;*** i = loop counter - 1
;-
  [A2]  STH     .D1     A15,    *A11            ; xt[6 * n2] = xo3
||      SUB     .L2     B14,    B12,    B14     ;* ya2 = sc2 - rs2
||      SUB2    .S1     A8,     A9,     A10     ;** t3=xi1 - xi3,  t1 = yi1-yi3
||      AND     .S2     B1,     B7,     B1      ;*** j loop twiddle reload test
||[!A2] ADD     .L1     A2,     1,      A2      ; First Pass Done Set Cond. Reg
;-
        ADDAH   .D1     A5,     A7,     A11     ;* copy A-side x store pointer
||      SUB     .L2X    A1,     B12,    B4      ;* ya3 = sc3 - rs3
||      ADD     .L1     A11,    A12,    A15     ;* xa3 = rc3 + ss3
||      ADD2    .S1     A8,     A9,     A8      ;** t0=xi1 + xi3,  t2 = yi1+yi3
||      ADD2    .S2     B10,    B11,    B1      ;** r1a = xi0+xi2, s1a = yi0+yi2
||      MPY     .M2     B1,     1,      B2      ;*** j loop twiddle reload test
||[!B1] ADDAW   .D2     B5,     1,      B5      ;*** reset x input, (circular)

; LOOP ends here

        MPY     .M2     B6,     B8,     B0      ; n/4 = n2 * ie
||      B       .S1     K_LOOP
||      MVC     .S2     IRP,    B_SP

        SHR     .S1     A7,     2,      A7      ; 2 * n2 >>= 2
||      SHL     .S2     B7,     2,      B7      ; mask   <<= 2
||      LDW     .D2T2   *B_SP[1],       B4      ; restore x pointer

;-
        SUB     .D2     B0,     1,      B0      ; loop counter = n/4 - 1
||      ADD     .L2     B7,     3,      B7      ; mask    += 3
||      SHL     .S2     B8,     2,      B8      ; ie     <<= 2

        SHR     .S2     B9,     2,      B9      ; 2 * n2 >>= 2
||      CMPGT   .L2     B7,     B0,     B1      ; kcond    = mask > n / 4 - 1

        .asg            B0,     B_amr           ; AMR value to restore

  [!B1] SHR     .S2     B6,     2,      B6      ; n2     >>= 2
||[ B1] B       .S1     DONE
||[ B1] ZERO            B_amr
;-
  [ B1] MVC     .S2     B_amr,      AMR         ; Restore AMR

DONE:

; K_LOOP ends here


; ================ SYMBOLIC REGISTER ASSIGNMENTS: CLEANUP ================= ;
        .asg            B15,        B_SP        ; Stack pointer, B datapath
        .asg            A6,         A_SP        ; Stack pointer, A datapath
        .asg            A0,         A_csr       ; CSR value to restore
        .asg            B0,         B_amr       ; AMR value to restore
        .asg            B2,         B_irp       ; IRP value to restore
        .asg            B3,         B_ret       ; Return address
; ========================================================================= ;

        MV              B_SP,       A_SP
||      LDW     .D2T2   *+B_SP[ 2], B_irp

        LDW     .D1T2   *+A_SP[ 3], B_ret       ; Get return address
||      LDW     .D2T1   *+B_SP[ 4], A_csr       ; Get CSR's value

        LDW     .D1T2   *+A_SP[ 5], B10         ; Restore B10
||      LDW     .D2T1   *+B_SP[ 6], A10         ; Restore A10
;-
        LDW     .D1T2   *+A_SP[ 7], B11         ; Restore B11
||      LDW     .D2T1   *+B_SP[ 8], A11         ; Restore A11

        LDW     .D1T2   *+A_SP[ 9], B12         ; Restore B12
||      LDW     .D2T1   *+B_SP[10], A12         ; Restore A12

        LDW     .D1T2   *+A_SP[11], B13         ; Restore B13
||      LDW     .D2T1   *+B_SP[12], A13         ; Restore A13
||      MVC     .S2     B_irp,      IRP
;-
        LDW     .D1T2   *+A_SP[13], B14         ; Restore B14
||      LDW     .D2T1   *+B_SP[14], A14         ; Restore A14
||      B       .S2     B_ret                   ; Return to caller

        MVC     .S2X    A_csr,      CSR         ; Restore CSR
||      LDW     .D2T1   *++B_SP[16],A15         ; Restore A15
; ===== Interruptibility state restored here =====

        NOP             4
;-
; ===== Branch Occurs =====

* ========================================================================= *
*   End of file:  rfft4_h.asm                                               *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

radix2.asm/     1019093836  0     0     0       21393     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.3     Fri Mar 22 02:08:27 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_radix2 -- In-place Radix-2 FFT (Little Endian)                  *
*                                                                           *
*   REVISION DATE                                                           *
*       10-Dec-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_radix2(int n, short *restrict xy,                          *
*                   const short *restrict w);                               *
*                                                                           *
*       n    -- FFT size                            (input)                 *
*       xy[] -- input and output sequences (dim-n)  (input/output)          *
*       w[]  -- FFT coefficients (dim-n/2)          (input)                 *
*                                                                           *
*   DESCRIPTION                                                             *
*       This routine is used to compute FFT of a complex sequece of size    *
*       n, a power of 2, with "decimation-in-frequency decomposition"       *
*       method, ie, the output is in bit-reversed order. Each complex       *
*       value is with interleaved 16-bit real and imaginary parts. To       *
*       prevent overflow, input samples may have to be scaled by 1/n.       *
*                                                                           *
*       void DSP_radix2(int n, short *restrict xy,                          *
*                   const short *restrict w)                                *
*       {                                                                   *
*           short n1,n2,ie,ia,i,j,k,l;                                      *
*           short xt,yt,c,s;                                                *
*                                                                           *
*           n2 = n;                                                         *
*           ie = 1;                                                         *
*           for (k=n; k > 1; k = (k >> 1) )                                 *
*           {                                                               *
*               n1 = n2;                                                    *
*               n2 = n2>>1;                                                 *
*               ia = 0;                                                     *
*               for (j=0; j < n2; j++)                                      *
*               {                                                           *
*                   c = w[2*ia];                                            *
*                   s = w[2*ia+1];                                          *
*                   ia = ia + ie;                                           *
*                   for (i=j; i < n; i += n1)                               *
*                   {                                                       *
*                       l = i + n2;                                         *
*                       xt      = xy[2*l] - xy[2*i];                        *
*                       xy[2*i] = xy[2*i] + xy[2*l];                        *
*                       yt      = xy[2*l+1] - xy[2*i+1];                    *
*                       xy[2*i+1] = xy[2*i+1] + xy[2*l+1];                  *
*                       xy[2*l]   = (c*xt + s*yt)>>15;                      *
*                       xy[2*l+1] = (c*yt - s*xt)>>15;                      *
*                   }                                                       *
*               }                                                           *
*               ie = ie<<1;                                                 *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       16 <= n <= 32768                                                    *
*       Both input xy and coefficient w must be aligned on word boundary.   *
*       w coef stored ordered is k*(-cos[0*delta]), k*(-sin[0*delta]),      *
*       k*(-cos[1*delta]), ...  where delta = 2*PI/N, k = 32767             *
*       Assembly code is written for processor in Little Endian mode        *
*       Input xy and coefficients w are 16 bit data.                        *
*                                                                           *
*   MEMORY NOTE                                                             *
*       Align xy and w on different word boundaries to minimize             *
*       memory bank hits.                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       1. Loading input xy as well as coefficient w in word.               *
*       2. Both loops j and i shown in the C code are placed in the         *
*          INNERLOOP of the assembly code.                                  *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = log2(N) * (4*N/2+7) + 34 + N/4.                            *
*                                                                           *
*       (The N/4 term is due to bank conflicts that occur when xy and w     *
*       are aligned as suggested above, under "MEMORY NOTE.")               *
*                                                                           *
*       For N = 256, cycles = 4250.                                         *
*                                                                           *
*   CODESIZE                                                                *
*       800 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_radix2
_DSP_radix2:
        STW     .D2T1   A15, *B15--[12] ; push A15 to SP[12]
||      SUB     .L1X    B15, 4, A15

        STW     .D1T1   A10, *A15--[10] ; push A10 to SP[11]
||      STW     .D2T2   B10, *+B15[10]  ; push B10 to SP[10]
||      MVC     .S2     CSR, B0

        STW     .D1T1   A11, *+A15[8]   ; push A11 to SP[ 9]
||      STW     .D2T2   B11, *+B15[8]   ; push B11 to SP[ 8]
||      AND     .S2     B0, -2, B1
;-
        STW     .D1T1   A12, *+A15[6]   ; push A12 to SP[ 7]
||      STW     .D2T2   B12, *+B15[6]   ; push B12 to SP[ 6]
||      MVC     .S2     B1,  CSR
        ;== Interrupts disabled here ===

        STW     .D1T1   A13, *+A15[4]   ; push A13 to SP[ 5]
||      STW     .D2T2   B13, *+B15[4]   ; push B13 to SP[ 4]

        STW     .D1T1   A14, *+A15[2]   ; push A14 to SP[ 3]
||      STW     .D2T2   B14, *+B15[2]   ; push B14 to SP[ 2]
||      MV      .L1X    B4,A9           ; &XY
;-
        LMBD    .L1     1,A4,A1         ; outer loop count calculation
||      MV      .L2X    A4,B13          ; &N
||      STW     .D1T2   B0,  *+A15[0]   ; push CSR to SP[ 1]

        MVK     .S1     1,A2            ; IE = 1
||      MV      .D2     B13,B10         ; XY index setup
||      MV      .L1     A4,A7           ; XY index setup
||      SHL     .S2     B13,2,B14       ; calculating reset offset
||      MV      .L2X    A6,B12          ; permanent ptr for W[0]
;-
        SHR     .S2     B13,1,B13       ; used for loop count
||      SUB     .D2     B14,4,B14       ; calculating reset offset
||      SUB     .L1X    B14,4,A8        ; calculating reset offset

        ADDAH   .D1     A9,A7,A3        ; setup ptr for X[i+N2] & Y[i+N2]
||      MV      .L2X    A9,B9           ; setup ptr for X[i] & Y[i]
||      SUB     .D2     B13,4,B13       ; inner loop count
||      MVK     .S2     31,B7           ; outer loop count calculation
;-
        MV      .S2     B9,B4           ; setup store ptr for X[i] & Y[i]
||      MV      .L2     B9,B11          ; permanent ptr for X[0] & Y[0]
||      SUB     .L1X    B7,A1,A1        ; outer loop conter

        LDW     .D2     *B9++[B10],B7   ; X[i] & Y[i]
||      MV      .L2X    A2,B2           ; reset twiddle factor counter
||      LDW     .D1     *A6++[A2],A5    ; CS = W[IA] & W[IA+1]
||      SHL     .S1     A7,1,A0         ; calculating reset offset
;-
  [ B2] SUB             B2,1,B2         ; decrement twiddle factor counter
||      LDW     .D1     *A3++[A7],A13   ; X[i+N2] & Y[i+N2]

  [!B2] SUB             B9,B14,B9       ; reset load X[i] & Y[i] ptrs

  [!B2] SUB             A3,A8,A3        ; reset load X[i+N2] & Y[i+N2] ptrs

OUTLOOP:
        LDW     .D2     *B9++[B10],B7   ;* X[i] & Y[i]
||[!B2] MV      .L2X    A2,B2           ;* reset twiddle factor counter
||[!B2] LDW     .D1     *A6++[A2],A5    ;* CS = W[IA] & W[IA+1]
||      MPY     .M2     B2,1,B0         ; move to next iteration
;-
  [ B2] SUB             B2,1,B2         ;* decrement twiddle factor counter
||      LDW     .D1     *A3++[A7],A13   ;* X[i+N2] & Y[i+N2]

        SUB2    .S1X    A13,B7,A9       ; XYT = X[i]-X[i+N2] & Y[i]-Y[i+N2]
||      MV              A5,A10          ; move to other file
||      ADD2    .S2X    B7,A13,B7       ; X[i]+X[i+N2] & Y[i]+Y[i+N2]
||[!B2] SUB             B9,B14,B9       ;* reset load X[i] & Y[i] ptrs

        MPYHL   .M1     A9,A5,A14       ; (C)*(YT)
||      STW     .D2     B7,*B4++[B10]   ; XY[i] = X[i]+X[i+N2] & Y[i]+Y[i+N2]
;-
        MPYLH   .M1     A9,A5,A15       ; (S)*XT
||      LDW     .D2     *B9++[B10],B7   ;** X[i] & Y[i]
||[!B2] MV      .L2X    A2,B2           ;** reset twiddle factor counter
||[!B2] LDW     .D1     *A6++[A2],A5    ;** CS = W[IA] & W[IA+1]
||      SUB     .L1X    B4,A0,A4        ; set store X[i+N2] ptr
||      MPY     .M2     B2,1,B0         ;* move to next iteration
||[!B2] SUB             A3,A8,A3        ;* reset load X[i+N2] & Y[i+N2] ptrs
;-
        MPY     .M1     A9,A10,A13      ; (C)*XT
||[!B0] SUB             B4,B14,B4       ; reset store X[i] & Y[i] ptrs
||[ B2] SUB             B2,1,B2         ;** decrement twiddle factor counter
||      LDW     .D1     *A3++[A7],A13   ;** X[i+N2] & Y[i+N2]

        MPYH    .M1     A9,A10,A14      ; (S)*(YT)
||      SUB2    .S1X    A13,B7,A9       ;* XYT = X[i]-X[i+N2] & Y[i]-Y[i+N2]
||      ADD2    .S2X    B7,A13,B7       ;* X[i]+X[i+N2] & Y[i]+Y[i+N2]
||[!B2] SUB             B9,B14,B9       ;** reset load X[i] & Y[i] ptrs
;-
        SUB     .S1     A14,A15,A15     ; Y[i+N2] = C*YT - S*XT
||      MPYHL   .M1     A9,A5,A14       ;* (C)*(YT)
||      STW     .D2     B7,*B4++[B10]   ;* XY[i] = X[i]+X[i+N2] & Y[i]+Y[i+N2]
||[!B2] SUB     .D1     A3,A8,A3        ;** reset load X[i+N2] & Y[i+N2] ptrs
||      MV      .L2X    A4,B6           ; set store X[i+N2] ptr
||      MV      .S2     B13,B1          ; set inner loop counter
||      MV      .L1     A5,A10          ;* move to other file

        B       .S2     LOOP            ; for (i=j; i < N; i += N1)
||      ADD     .S1     A14,A13,A13     ; X[i+N2] = C*XT + S*YT
||      MPYLH   .M1     A9,A5,A15       ;* (S)*XT
||      LDW     .D2     *B9++[B10],B7   ;*** X[i] & Y[i]
||[!B2] MV      .L2X    A2,B2           ;*** reset twiddle factor counter
||[!B2] LDW     .D1     *A6++[A2],A5    ;*** CS = W[IA] & W[IA+1]
||      SUB     .L1X    B4,A0,A4        ;* set store X[i+N2] ptr
||      MPY     .M2     B2,1,B0         ;** move to next iteration

        SHR     .S2X    A13,15,B5       ; scale X[i+N2]
||      SHR     .S1     A15,15,A11      ; scale Y[i+N2]
||      MPY     .M1     A9,A10,A13      ;* (C)*XT
||[!B0] SUB     .L2     B4,B14,B4       ;* reset store X[i] & Y[i] ptrs
||[ B2] SUB     .D2     B2,1,B2         ;*** decrement twiddle factor counter
||      LDW     .D1     *A3++[A7],A13   ;*** X[i+N2] & Y[i+N2]
||      ADD     .L1X    B6,2,A12        ; set store Y[i+N2] ptr

LOOP:
        STH     .D2     B5,*B6          ; X[i+N2] = C*YT + S*XT
||      STH     .D1     A11,*A12        ; Y[i+N2] = C*YT - S*XT
||      MPYH    .M1     A9,A10,A14      ;* (S)*(YT)
||      SUB2    .S1X    A13,B7,A9       ;** XYT = X[i]-X[i+N2] & Y[i]-Y[i+N2]
||      MV      .L1     A5,A10          ;** move to other file
||      ADD2    .S2X    B7,A13,B7       ;** X[i]+X[i+N2] & Y[i]+Y[i+N2]
||[!B2] SUB     .L2     B9,B14,B9       ;*** reset load X[i] & Y[i] ptrs

        SUB     .D1     A14,A15,A15     ;* Y[i+N2] = C*YT - S*XT
||      MV      .L2X    A4,B6           ;* set store X[i+N2] ptr
||[ B1] SUB     .S2     B1,1,B1         ;** dec i lp cntr
||      MPYHL   .M1     A9,A5,A14       ;** (C)*(YT)
||      STW     .D2     B7,*B4++[B10]   ;** XY[i] = X[i]+X[i+N2] & Y[i]+Y[i+N2]
||[!B2] SUB     .S1     A3,A8,A3        ;*** reset load X[i+N2] & Y[i+N2] ptrs

  [ B1] B       .S2     LOOP            ;* for (i=j; i < N; i += N1)
||      ADD     .S1     A13,A14,A13     ;* X[i+N2] = C*XT + S*YT
||      MPYLH   .M1     A9,A5,A15       ;** (S)*XT
||      SUB     .L1X    B4,A0,A4        ;** set store X[i+N2] ptr
||      LDW     .D2     *B9++[B10],B7   ;**** X[i] & Y[i]
||[!B2] MV      .L2X    A2,B2           ;**** reset twiddle factor counter
||[!B2] LDW     .D1     *A6++[A2],A5    ;**** CS = W[IA] & W[IA+1]
||      MPY     .M2     B2,1,B0         ;*** move to next iteration

        SHR     .S2X    A13,15,B5       ;* scale X[i+N2]
||      SHR     .S1     A15,15,A11      ;* scale Y[i+N2]
||      ADD     .L1X    B6,2,A12        ;* set store Y[i+N2] ptr
||[!B0] SUB     .L2     B4,B14,B4       ;** reset store X[i] & Y[i] ptrs
||      MPY     .M1     A9,A10,A13      ;** (C)*XT
||[ B2] SUB     .D2     B2,1,B2         ;**** decrement twiddle factor counter
||      LDW     .D1     *A3++[A7],A13   ;**** X[i+N2] & Y[i+N2]
; - - - - - - - - - - - - - - - - - - - ; LOOP ENDS HERE
;-
        STH     .D2     B5,*B6          ; X[i+N2] = C*YT + S*XT
||      STH     .D1     A11,*A12        ; Y[i+N2] = C*YT - S*XT
||      MPYH    .M1     A9,A10,A14      ;* (S)*(YT)
||      SUB2    .S1X    A13,B7,A9       ;** XYT = X[i]-X[i+N2] & Y[i]-Y[i+N2]
||      MV      .L1     A5,A10          ;** move to other file
||      ADD2    .S2X    B7,A13,B7       ;** X[i]+X[i+N2] & Y[i]+Y[i+N2]
||      MV      .L2     B11,B9          ; set up load ptr to X[0] & Y[0]
;-
        SUB     .D1     A14,A15,A15     ;* Y[i+N2] = C*YT - S*XT
||      MV      .L2X    A4,B6           ;* set store X[i+N2] ptr
||      MPYHL   .M1     A9,A5,A14       ;** (C)*(YT)
||      STW     .D2     B7,*B4++[B10]   ;** XY[i] = X[i]+X[i+N2] & Y[i]+Y[i+N2]
||      SHL     .S1     A2,1,A2         ; IE << 1
||      SUB     .L1     A1,1,A1         ; decrement outer loop counter
;-
        ADD     .D1     A14,A13,A13     ;* X[i+N2] = C*XT + S*YT
||      MPYLH   .M1     A9,A5,A15       ;** (S)*XT
||      SUB     .L1X    B4,A0,A4        ;** set store X[i+N2] ptr
||      SHR     .S1     A15,15,A11      ;* scale Y[i+N2]

        SHR     .S2X    A13,15,B5       ;* scale X[i+N2]
||      ADD     .L1X    B6,2,A12        ;* set store Y[i+N2] ptr
||      MPY     .M1     A9,A10,A13      ;** (C)*XT
||[ A1] B       .S1     OUTLOOP         ; branch to next stage
;-
        STH     .D2     B5,*B6          ; X[i+N2] = C*YT + S*XT
||      STH     .D1     A11,*A12        ; Y[i+N2] = C*YT - S*XT
||      MPYH    .M1     A9,A10,A10      ;* (S)*(YT)
||      SHR     .S2     B10,1,B10       ; load index >> 1
||      SHR     .S1     A0,1,A0         ; N2 >> 1
||      MV      .L1X    B12,A6          ; reset W ptr
||      MV      .L2X    A2,B2           ; reset twiddle factor counter
;-
        MV      .L2X    A4,B6           ;* set store X[i+N2] ptr
||      LDW     .D2     *B9++[B10],B7   ; X[i] & Y[i]
||      ADD     .L1X    A7,B9,A3        ; set up load ptr to X[N2] & Y[N2]
||      LDW     .D1     *A6++[A2],A5    ; CS = W[IA] & W[IA+1]
||      SHR     .S1     A7,1,A7         ; load index >> 1
||[B2]  SUB     .S2     B2,1,B2         ; decrement twiddle factor counter
;-
        ADD     .L1     A10,A13,A13     ;* X[i+N2] = C*XT + S*YT
||      SUB     .S1     A14,A15,A15     ;* Y[i+N2] = C*YT - S*XT
||[ A1] LDW     .D1     *A3++[A7],A13   ; X[i+N2] & Y[i+N2]
||[!B2] SUB     .L2     B9,B14,B9       ; reset load X[i] & Y[i] ptrs

        SHR     .S2X    A13,15,B5       ;* scale X[i+N2]
||      SHR     .S1     A15,15,A11      ;* scale Y[i+N2]
||      ADD     .L1X    B6,2,A12        ;* set store Y[i+N2] ptr
||[!B2] SUB             A3,A8,A3        ; reset load X[i+N2] & Y[i+N2] ptrs
;-
        STH     .D2     B5,*B6          ; X[i+N2] = C*YT + S*XT
||      STH     .D1     A11,*A12        ; Y[i+N2] = C*YT - S*XT
||      SHL     .S1     A7,1,A0         ; calculating reset offset
||      MV      .S2     B11,B4          ; set up store ptr to X[0] & Y[0]
; - - - - - - - - - - - - - - - - - - - ; OUTLOOP ENDS HERE

        LDW     .D2T2   *+B15[1],  B0   ; pop CSR from SP[ 1]
||      MV              B15, A15

        LDW     .D1T1   *+A15[11], A10  ; pop A10 from SP[11]
||      LDW     .D2T2   *+B15[10], B10  ; pop B10 from SP[10]
;-
        LDW     .D1T1   *+A15[9],  A11  ; pop A11 from SP[ 9]
||      LDW     .D2T2   *+B15[8],  B11  ; pop B11 from SP[ 8]

        LDW     .D1T1   *+A15[7],  A12  ; pop A12 from SP[ 7]
||      LDW     .D2T2   *+B15[6],  B12  ; pop B12 from SP[ 6]

        LDW     .D1T1   *+A15[5],  A13  ; pop A13 from SP[ 5]
||      LDW     .D2T2   *+B15[4],  B13  ; pop B13 from SP[ 4]
;-
        LDW     .D2T2   *+B15[2],  B14  ; pop B14 from SP[ 2]
||      LDW     .D1T1   *+A15[3],  A14  ; pop A14 from SP[ 3]
||      B               B3

        LDW     .D2T1   *++B15[12],A15  ; pop A15 from SP[12]

        MVC             B0, CSR

        NOP             3
;-

* ========================================================================= *
*    End of file: dsp_radix2.asm                                            *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

recip16.asm/    1019093836  0     0     0       14412     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Fri Mar 22 02:10:54 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_recip16                                                         *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       20-Jul-2001                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_recip16 (short *x, short *rfrac, short *rexp, short nx);   *
*                                                                           *
*       x[nx]     = Pointer to input vector of size nx                      *
*       rfrac[nx] = Pointer to output vector of size nx to                  *
*                   contain the fractional part of the reciprocal           *
*       rexp[nx]  = Pointer to output vector of size nx to                  *
*                   contain the exponent part of the reciprocal             *
*       nx        = Number of elements in input vector                      *
*                                                                           *
*       (See the C compiler reference guide.)                               *
*                                                                           *
*   DESCRIPTION                                                             *
*       This program performs a reciprocal on a vector of Q15 numbers.      *
*       The result is stored in two parts: a Q15 part and an exponent       *
*       (power of two) of the fraction.                                     *
*       First, the input is loaded, then its absolute value is taken,       *
*       then it is normalized, then divided using a loop of conditional     *
*       subtracts, and finally it is negated if the original input was      *
*       negative.                                                           *
*                                                                           *
*       void DSP_recip16 (short *x, short *rfrac, short *rexp, short nx)    *
*       {                                                                   *
*          int i,j,a,b;                                                     *
*          short neg, normal;                                               *
*                                                                           *
*          for(i = nx; i > 0; i--)                                          *
*          {                                                                *
*              a = *(x++);                                                  *
*              if(a < 0)             /* take absolute value */              *
*              {                                                            *
*                  a = -a;                                                  *
*                  neg = 1;                                                 *
*              }                                                            *
*              else                                                         *
*                  neg = 0;                                                 *
*              normal = _norm(a);              /* normalize */              *
*              a = a << normal;                                             *
*              *(rexp++) = normal - 15;   /* store exponent */              *
*              b = 0x80000000;              /* dividend = 1 */              *
*              for(j = 15; j > 0; j--)                                      *
*                  b = _subc(b,a);                /* divide */              *
*              b = b & 0x7FFF;           /* clear remainder */              *
*              if(neg) b = -b;       /* if negative, negate */              *
*              *(rfrac++) = b;            /* store fraction */              *
*          }                                                                *
*       }                                                                   *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This code is endian neutral                                         *
*       x and rfrac are Q15 format                                          *
*       output is accurate up to the least significant bit of rfrac, but    *
*       note that this bit could carry over and change rexp too             *
*                                                                           *
*   MEMORY NOTE                                                             *
*       There are no memory bank hits in this procedure                     *
*                                                                           *
*   NOTE                                                                    *
*       fully interruptible                                                 *
*                                                                           *
*   TECHNIQUES                                                              *
*       The conditional subtract instruction, SUBC, is used for division    *
*       SUBC is used once for every bit of quotient needed (15).            *
*       2 stages of prolog and epilog collapsed                             *
*       split 2 live-too-longs (A_neg and B_norm)                           *
*                                                                           *
*   CYCLES                                                                  *
*        8 * nx + 14                                                        *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_recip16
_DSP_recip16:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x
        .asg            B4,         B_rfrac
        .asg            A6,         A_rexp
        .asg            B1,         B_nx
        .asg            A3,         A_b
        .asg            A1,         A_neg
        .asg            A8,         A_a
        .asg            B6,         B_neg1
        .asg            B0,         B_neg2
        .asg            A7,         A_n
        .asg            A5,         A_norm
        .asg            B8,         B_exp
        .asg            A9,         A_b1
        .asg            A8,         A_b2
        .asg            A8,         A_b3
        .asg            A9,         A_b4
        .asg            A9,         A_b5
        .asg            A9,         A_b6
        .asg            A8,         A_b7
        .asg            B8,         B_b7
        .asg            B5,         B_norm
        .asg            B7,         B_norm1
        .asg            B8,         B_b8
        .asg            B6,         B_b9
        .asg            B7,         B_b10
        .asg            B5,         B_b11
        .asg            B8,         B_b12
        .asg            B8,         B_b13
        .asg            B8,         B_b14
        .asg            B7,         B_b15
        .asg            B7,         B_bc
        .asg            B2,         B_p
        .asg            A2,         A_p
* ========================================================================= *

* =========================== PIPE LOOP PROLOG ============================ *
        LDH     .D1T1   *A_x++,     A_a                         ;[ 1,1]
||      ZERO    .L1     A_b

        MVKH            0x80000000, A_b

        MV              B6,         B_nx

        MVK             1,          A_p                         ; prolog coll

        MVK             3,          B_p                         ; prolog coll

        SHR     .S1     A_a,        31,         A_neg           ;[ 6,1]

  [ A_neg]NEG   .S1     A_a,        A_a                         ;[ 7,1]

* =========================== PIPE LOOP KERNEL ============================ *
loop:
        SUBC    .L2     B_b11,      B_norm1,    B_b12           ;[24,1]
||      MV      .S2X    A_norm,     B_norm                      ;[16,2]
||[!A_p]STH     .D1T2   B_exp,      *A_rexp++                   ;[16,2]
||      NORM    .L1     A_a,        A_n                         ;[ 8,3]

        SUBC    .L2     B_b12,      B_norm1,    B_b13           ;[25,1]
||      SUBC    .L1     A_b6,       A_norm,     A_b7            ;[17,2]
||      SHL     .S1     A_a,        A_n,        A_norm          ;[ 9,3]
||      LDH     .D1T1   *A_x++,     A_a                         ;[ 1,4]

  [ B_nx]B      .S1     loop                                    ;[26,1]
||      SUBC    .L2     B_b13,      B_norm1,    B_b14           ;[26,1]
||[ B_nx]SUB    .S2     B_nx,       1,          B_nx            ;[18,2]
||      SUBC    .L1     A_b,        A_norm,     A_b1            ;[10,3]
||[ A_p]SUB     .D1     A_p,        1,          A_p             ; prolog coll

        SUBC    .L2     B_b14,      B_norm1,    B_b15           ;[27,1]
||      MV      .S2X    A_b7,       B_b7                        ;[19,2]
||      SUBC    .L1     A_b1,       A_norm,     A_b2            ;[11,3]

        CLR     .S2     B_b15,      15, 31,     B_bc            ;[28,1]
||      SUBC    .L2     B_b7,       B_norm,     B_b8            ;[20,2]
||      SUBC    .L1     A_b2,       A_norm,     A_b3            ;[12,3]
||[ B_p]SUB     .D2     B_p,        1,          B_p             ; prolog coll

  [ B_neg2]NEG  .S2     B_bc,       B_bc                        ;[29,1]
||      SUBC    .L2     B_b8,       B_norm,     B_b9            ;[21,2]
||      MV      .D2     B_neg1,     B_neg2                      ;[21,2]
||      SUBC    .L1     A_b3,       A_norm,     A_b4            ;[13,3]

  [!B_p]STH     .D2T2   B_bc,       *B_rfrac++                  ;[30,1]
||      SUBC    .L2     B_b9,       B_norm,     B_b10           ;[22,2]
||      SUBC    .L1     A_b4,       A_norm,     A_b5            ;[14,3]
||      MV      .S2X    A_neg,      B_neg1                      ;[14,3]
||      SHR     .S1     A_a,        31,         A_neg           ;[ 6,4]

        SUBC    .L2     B_b10,      B_norm,     B_b11           ;[23,2]
||      MV      .D2     B_norm,     B_norm1                     ;[23,2]
||      SUBC    .L1     A_b5,       A_norm,     A_b6            ;[15,3]
||      SUB     .S2X    A_n,        15,         B_exp           ;[15,3]
||[ A_neg]NEG   .S1     A_a,        A_a                         ;[ 7,4]

* =========================== PIPE LOOP EPILOG ============================ *
        SUBC    .L2     B_b11,      B_norm1,    B_b12           ;[24,4]

        SUBC    .L2     B_b12,      B_norm1,    B_b13           ;[25,4]
||      B       .S2     B3

        SUBC    .L2     B_b13,      B_norm1,    B_b14           ;[26,4]

        SUBC    .L2     B_b14,      B_norm1,    B_b15           ;[27,4]

        CLR     .S2     B_b15,      15, 31,     B_bc            ;[28,4]

  [ B_neg2]NEG  .S2     B_bc,       B_bc                        ;[29,4]

        STH     .D2T2   B_bc,       *B_rfrac++                  ;[30,4]

; Branch occurs

* ========================================================================= *
*   End of file:  dsp_recip16.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
vecsumsq.asm/   1019093836  0     0     0       10899     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Fri Mar 29 20:00:04 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*                                                                           *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_vecsumsq                                                        *
*                                                                           *
*   REVISION DATE                                                           *
*       13-Aug-1999                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C callable, and has the following C prototype:      *
*                                                                           *
*           int DSP_vecsumsq                                                *
*           (                                                               *
*               const short *x,    /* Pointer to vector  */                 *
*               int          nx    /* Length of vector.  */                 *
*           )                                                               *
*                                                                           *
*       This routine returns the sum of squares as its return value.        *
*                                                                           *
*   DESCRIPTION                                                             *
*       The "DSP_vecsumsq" function returns the sum of squares of the       *
*       elements contained in vector "x".                                   *
*                                                                           *
*   C CODE                                                                  *
*       The following C code is a general implementation without            *
*       restrictions.  This implementation may have restrictions, as        *
*       noted under "ASSUMPTIONS" below.                                    *
*                                                                           *
*           int DSP_vecsumsq                                                *
*           (                                                               *
*               const short *x,    /* Pointer to vector  */                 *
*               int          nx    /* Length of vector.  */                 *
*           )                                                               *
*           {                                                               *
*               int i, sum = 0;                                             *
*                                                                           *
*               for (i = 0; i < nx; i++)                                    *
*                   sum += x[i] * x[i];                                     *
*                                                                           *
*               return sum;                                                 *
*           }                                                               *
*                                                                           *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       The input length is a multiple of 2 and at least 8.                 *
*                                                                           *
*   NOTES                                                                   *
*       This function is interrupt tolerant, but not interruptible.         *
*       It locks out interrupts for its entire duration.                    *
*                                                                           *
*   MEMORY NOTE                                                             *
*       This function is ENDIAN NEUTRAL.                                    *
*       No bank conflicts occur under any conditions.                       *
*                                                                           *
*   CYCLES                                                                  *
*       cycles = count/2 + 19.                                              *
*                                                                           *
*   CODESIZE                                                                *
*       192 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
        .text
        .global _DSP_vecsumsq
_DSP_vecsumsq: 
* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x
        .asg            A5,         A_p0
        .asg            A6,         A_sum
        .asg            A7,         A_x0
        .asg            B0,         B_i
        .asg            B5,         B_x
        .asg            B6,         B_sum
        .asg            B7,         B_x1
        .asg            B8,         B_p1
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *

        B               loop
||      SHR             B4,         1,          B_i
||      ADD             A_x,        2,          B_x

        B               loop
||[ B_i]SUB             B_i,        3,          B_i
||      ZERO            B_x1:B_sum
||      LDH     .D1T1   *A_x++[2],  A_x0                        ;[ 1,1]
||      LDH     .D2T2   *B_x++[2],  B_x1                        ;[ 1,1]
;-
  [ B_i]B               loop
||[ B_i]SUB             B_i,        1,          B_i
||      MPY             B_p1,       0,          B_p1
||      MPY             A_p0,       0,          A_p0
||      ZERO            A_x0:A_sum
||      LDH     .D1T1   *A_x++[2],  A_x0                        ;[ 1,2]
||      LDH     .D2T2   *B_x++[2],  B_x1                        ;[ 1,2]
;-
  [ B_i]B               loop
||[ B_i]SUB             B_i,        1,          B_i
||      LDH     .D1T1   *A_x++[2],  A_x0                        ;[ 1,3]
||      LDH     .D2T2   *B_x++[2],  B_x1                        ;[ 1,3]

  [ B_i]B               loop
||[ B_i]SUB             B_i,        1,          B_i
||      LDH     .D1T1   *A_x++[2],  A_x0                        ;[ 1,4]
||      LDH     .D2T2   *B_x++[2],  B_x1                        ;[ 1,4]
; ===== 3 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        ADD     .L1     A_p0,       A_sum,      A_sum           ;[ 8,1]
||      ADD     .L2     B_p1,       B_sum,      B_sum           ;[ 8,1]
||      MPY     .M1     A_x0,       A_x0,       A_p0            ;[ 6,3]
||      MPY     .M2     B_x1,       B_x1,       B_p1            ;[ 6,3]
||[ B_i]B       .S1     loop                                    ;[ 4,5]
||[ B_i]SUB     .S2     B_i,        1,          B_i             ;[ 3,6]
||      LDH     .D1T1   *A_x++[2],  A_x0                        ;[ 1,8]
||      LDH     .D2T2   *B_x++[2],  B_x1                        ;[ 1,8]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 5 epilog stages collapsed
        ADD     .L1     A_p0,       A_sum,      A_sum           ;[ 8,6]
||      ADD     .L2     B_p1,       B_sum,      B_sum           ;[ 8,6]
||      MPY     .M1     A_x0,       A_x0,       A_p0            ;[ 6,8]
||      MPY     .M2     B_x1,       B_x1,       B_p1            ;[ 6,8]
||      B               B3

        ADD     .L1     A_p0,       A_sum,      A_sum           ;[ 8,7]
||      ADD     .L2     B_p1,       B_sum,      B_sum           ;[ 8,7]
;-
        ADD     .L1     A_p0,       A_sum,      A_sum           ;[ 8,8]
||      ADD     .L2     B_p1,       B_sum,      B_sum           ;[ 8,8]

        ADD             A_sum,      B_sum,      A4

        NOP             2

* ========================================================================= *
*   End of file:  dsp_vecsumsq.asm                                          *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

w_vec.asm/      1019093836  0     0     0       13095     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.4     Fri Mar 29 21:10:31 2002 (UTC)              *;
;*      Snapshot date:  18-Apr-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_w_vec: Weighted vector sum                                      *
*                                                                           *
*                                                                           *
*   REVISION DATE                                                           *
*       29-Mar-2002                                                         *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*           void DSP_w_vec                                                  *
*           (                                                               *
*               const short *x,     /* Vector being weighted  */            *
*               const short *y,     /* Non-weighted vector    */            *
*               short m,            /* weighting factor       */            *
*               short *restrict r,  /* Result vector          */            *
*               int nr              /* Number of samples.     */            *
*           );                                                              *
*                                                                           *
*   DESCRIPTION                                                             *
*       The benchmark performs a weighted vector sum.  The elements         *
*       of the x[] vector are weighted according to the Q15 value 'm',      *
*       and then added to the corresponding elements of the y[] vector.     *
*       The results are written to the r[] vector.                          *
*                                                                           *
*   C CODE                                                                  *
*       The following is a C code description of the algorithm.  This       *
*       implementation may have restrictions, as noted under                *
*       "ASSUMPTIONS" below.                                                *
*                                                                           *
*           void DSP_w_vec                                                  *
*           (                                                               *
*               const short *x,     /* Vector being weighted  */            *
*               const short *y,     /* Non-weighted vector    */            *
*               short m,            /* weighting factor       */            *
*               short *restrict r,  /* Result vector          */            *
*               int nr              /* Number of samples.     */            *
*           )                                                               *
*           {                                                               *
*               int i;                                                      *
*                                                                           *
*               for (i = 0; i < nr; i++)                                    *
*                   r[i] = ((m * x[i]) >> 15) + y[i];                       *
*           }                                                               *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       m is not -32768.                                                    *
*       nr >= 4, nr is multiple of four.                                    *
*       Input and output arrays must be word aligned.                       *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No bank conflicts occur.                                            *
*       This code is endian neutral.                                        *
*                                                                           *
*   TECHNIQUES                                                              *
*       This loop is unrolled 4x to make full use of the available          *
*       memory bandwidth.                                                   *
*                                                                           *
*       SMPY is used in conjunction with shifts and masks so that the       *
*       m * x[i] terms may be packed pairs within 32-bit registers.  This   *
*       allows us to use packed-data processing for the rest of the         *
*       algorithm, thereby maximizing our load/store bandwidth.             *
*                                                                           *
*   NOTES                                                                   *
*       This code is interrupt tolerant but not interruptible.              *
*                                                                           *
*   CYCLES                                                                  *
*       3*nr/4 + 19                                                         *
*       For nr = 256,  cycles = 211.                                        *
*       For nr = 1000, cycles = 770.                                        *
*                                                                           *
*   CODESIZE                                                                *
*       192 bytes                                                           *
*                                                                           *
*   SOURCE                                                                  *
*       DSPLIB.                                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

        .text
        .global _DSP_w_vec
_DSP_w_vec:

* ===================== SYMBOLIC REGISTER ASSIGNMENTS ===================== *
        .asg            A4,         A_x
        .asg            B4,         B_y
        .asg            A6,         A_m
        .asg            B6,         B_r
        .asg            A8,         A_nx
        .asg            A0,         A_p1
        .asg            A0,         A_p10
        .asg            A0,         A_p1_
        .asg            A1,         A_x10
        .asg            A2,         A_i
        .asg            A3,         A_p0
        .asg            A3,         A_p0_
        .asg            A5,         A_r10
        .asg            A5,         A_y10
        .asg            A7,         A_y
        .asg            A9,         A_r
        .asg            B0,         B_p2
        .asg            B0,         B_p2_
        .asg            B0,         B_p3_
        .asg            B1,         B_x32
        .asg            B2,         B_p
        .asg            B5,         B_p3
        .asg            B5,         B_p32
        .asg            B7,         B_r32
        .asg            B7,         B_y32
        .asg            B8,         B_x
        .asg            B9,         B_msk
* ========================================================================= *
* =========================== PIPE LOOP PROLOG ============================ *
        ADD             A_x,        4,          B_x
||      SHR             A_nx,       2,          A_i

        LDW     .D1T1   *A_x++[2],  A_x10                       ;[ 1,1]
||      LDW     .D2T2   *B_x++[2],  B_x32                       ;[ 1,1]
||[ A_i]B               loop
||[ A_i]SUB             A_i,        1,          A_i

        ADD             B_y,        4,          A_y
||      MVK             0xFFFF8000, B_msk
;-
        ADD             B_r,        4,          A_r
||      ADD             B_msk,      B_msk,      B_msk
||      MVK             2,          B_p
; ===== 2 prolog stages collapsed
* =========================== PIPE LOOP KERNEL ============================ *
loop:
        ADD     .L1     A_p1,       A_p0,       A_p10           ;[10,1]
||      ADD     .L2     B_p3,       B_p2,       B_p32           ;[10,1]
||[ A_i]B       .S2     loop                                    ;[ 7,2]
||      SMPYHL  .M1     A_x10,      A_m,        A_p1_           ;[ 7,2]
||      SMPY    .M2X    B_x32,      A_m,        B_p2_           ;[ 7,2]
||      LDW     .D1T1   *A_x++[2],  A_x10                       ;[ 1,4]
||      LDW     .D2T2   *B_x++[2],  B_x32                       ;[ 1,4]

        ADD2    .S1     A_p10,      A_y10,      A_r10           ;[11,1]
||      ADD2    .S2     B_p32,      B_y32,      B_r32           ;[11,1]
||[ A_i]SUB     .L1     A_i,        1,          A_i             ;[ 4,3]
||      AND     .L2     B_p3_,      B_msk,      B_p3            ;[ 8,2]
||      LDW     .D2T1   *B_y++[2],  A_y10                       ;[ 5,3]
||      LDW     .D1T2   *A_y++[2],  B_y32                       ;[ 5,3]

  [ B_p]SUB     .L2     B_p,        1,          B_p             ;[12,1]
||[!B_p]STW     .D2T1   A_r10,      *B_r++[2]                   ;[12,1]
||[!B_p]STW     .D1T2   B_r32,      *A_r++[2]                   ;[12,1]
||      SHRU    .S1     A_p0_,      16,         A_p0            ;[ 9,2]
||      AND     .L1X    A_p1_,      B_msk,      A_p1            ;[ 9,2]
||      SHRU    .S2     B_p2_,      16,         B_p2            ;[ 9,2]
||      SMPY    .M1     A_x10,      A_m,        A_p0_           ;[ 6,3]
||      SMPYHL  .M2X    B_x32,      A_m,        B_p3_           ;[ 6,3]

* =========================== PIPE LOOP EPILOG ============================ *
; ===== 2 epilog stages collapsed
        ADD     .S1     A_p1,       A_p0,       A_p10           ;[10,4]
||      ADD     .L2     B_p3,       B_p2,       B_p32           ;[10,4]
||      B               B3

        ADD2    .S1     A_p10,      A_y10,      A_r10           ;[11,4]
||      ADD2    .S2     B_p32,      B_y32,      B_r32           ;[11,4]

        STW     .D2T1   A_r10,      *B_r                        ;[12,4]
||      STW     .D1T2   B_r32,      *A_r                        ;[12,4]

        NOP             3
;-
* ========================================================================= *
*   End of file:  dsp_w_vec.asm                                             *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *

fir_sym.asm/    1026312771  0     0     0       15228     `
;* ======================================================================== *;
;*  TEXAS INSTRUMENTS, INC.                                                 *;
;*                                                                          *;
;*  DSPLIB  DSP Signal Processing Library                                   *;
;*                                                                          *;
;*      Release:        Version 1.02                                        *;
;*      CVS Revision:   1.6     Tue Jul 09 18:26:35 2002 (UTC)              *;
;*      Snapshot date:  09-Jul-2002                                         *;
;*                                                                          *;
;*  This library contains proprietary intellectual property of Texas        *;
;*  Instruments, Inc.  The library and its source code are protected by     *;
;*  various copyrights, and portions may also be protected by patents or    *;
;*  other legal protections.                                                *;
;*                                                                          *;
;*  This software is licensed for use with Texas Instruments TMS320         *;
;*  family DSPs.  This license was provided to you prior to installing      *;
;*  the software.  You may review this license by consulting the file       *;
;*  TI_license.PDF which accompanies the files in this library.             *;
;* ------------------------------------------------------------------------ *;
;*          Copyright (C) 2002 Texas Instruments, Incorporated.             *;
;*                          All Rights Reserved.                            *;
;* ======================================================================== *;


* ========================================================================= *
*   TEXAS INSTRUMENTS, INC.                                                 *
*                                                                           *
*   NAME                                                                    *
*       DSP_fir_sym: Symmetric FIR Filter                                   *
*                                                                           *
*   USAGE                                                                   *
*       This routine is C-callable and can be called as:                    *
*                                                                           *
*       void DSP_fir_sym                                                    *
*       (                                                                   *
*           short *restrict x,                                              *
*           short *restrict h,                                              *
*           short *restrict r,                                              *
*           int nh,                                                         *
*           int nr,                                                         *
*           int s                                                           *
*       );                                                                  *
*                                                                           *
*       x[nr+2*nh] : Pointer to input array of size nr + 2*nh               *
*       h[nh+1]    : Pointer to coefficient array of size nh + 1            *
*      Must be word aligned.                                                *
*       r[nr]      : Pointer to output array of size nr                     *
*       nh         : Number of coefficients.                                *
*                    Must be multiple of 8.                                 *
*       nr         : Number of output samples.                              *
*                    Must be multiple of 2.                                 *
*       s          : Number of insignificant digits to truncate             *
*                                                                           *
*   DESCRIPTION                                                             *
*       This symmetric FIR filter assumes the number of filter              *
*       coefficients is 2*nh + 1. It operates on 16-bit data with a 40-bit  *
*       accumulation.  The filter computes nr output samples.               *
*                                                                           *
*   C CODE                                                                  *
*       void DSP_fir_sym                                                    *
*       (                                                                   *
*           short *restrict x,                                              *
*           short *restrict h,                                              *
*           short *restrict r,                                              *
*           int nh,                                                         *
*           int nr,                                                         *
*           int s                                                           *
*       )                                                                   *
*       {                                                                   *
*           int     i, j;                                                   *
*           long    y0;                                                     *
*           long    round = (long) 1 << (s - 1);                            *
*                                                                           *
*           for (j = 0; j < nr; j++)                                        *
*           {                                                               *
*               y0 = round;                                                 *
*                                                                           *
*               for (i = 0; i < nh; i++)                                    *
*                   y0 += (short) (x[j + i] + x[j + 2 * nh - i]) * h[i];    *
*                                                                           *
*               y0 += x[j + nh] * h[nh];                                    *
*               r[j] = (int) (y0 >> s);                                     *
*           }                                                               *
*       }                                                                   *
*                                                                           *
*   TECHNIQUES                                                              *
*       Load word instruction is used to simultaneously load two            *
*       values from h[] in a single clock cycle.                            *
*       The inner loop is unrolled eight times.                             *
*       The outer loop is unrolled eight times.                             *
*       Both the inner and outer loops are  software pipelined.             *
*                                                                           *
*   ASSUMPTIONS                                                             *
*       This code is Little Endian.                                         *
*       nh must be a multiple of 8 and >= 8.                                *
*       nr must be a multiple of 2.                                         *
*       h[] must be word-aligned.                                           *
*                                                                           *
*   MEMORY NOTE                                                             *
*       No memory bank hits under any conditions.                           *
*                                                                           *
*   CYCLES                                                                  *
*       (3 * nh/2 + 10) * nr/2 + 20                                         *
*       For nh=24, nr=42: 986 cycles                                        *
*                                                                           *
*   CODESIZE                                                                *
*       416 bytes                                                           *
*                                                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *


        .text
        .global _DSP_fir_sym
_DSP_fir_sym:
        STW     .D2  A15,*B15--[2]   ; push register (for c-callable func)
||      SUB     .L1X B15,4,A15       ; copy stack pointer to A reg file
||      B            NO_INT_1

        STW     .D2  B14,*B15--[2]   ; push register (for c-callable func)
||      STW     .D1  A14,*A15--[2]   ; push register (for c-callable func)

        STW     .D2  B13,*B15--[2]   ; push register (for c-callable func)
||      STW     .D1  A13,*A15--[2]   ; push register (for c-callable func)

        STW     .D2  B12,*B15--[2]   ; push register (for c-callable func)
||      STW     .D1  A12,*A15--[2]   ; push register (for c-callable func)

        MVK     .S2  1,B0               ; set output sync bit
||      SUB     .L2  B8,1,B7            ; s -= 1
||      SUB     .L1X B6,0,A2            ; set inner loop counter (= nh)
||      MPY     .M2  B6,2,B9            ; 2 * n
||      STW     .D2  B11,*B15--[2]      ; push register (for c-callable func)
||      STW     .D1  A11,*A15--[2]      ; push register (for c-callable func)
||      MPY     .M1  A1,0,A1            ; clear compare for outer loop branch

        SHL     .S2  B0,B7,B11:B10      ; y0 = round = (Long40) 1 << (s - 1)
||      B       .S1  loop
||      MV      .L2X A4,B5              ; *xa
||      SUB     .L1  A8,2,A8            ; set outer loop counter (=nr-2)
||      MPY     .M2  B0,1,B1            ; = 1
||      STW     .D2  B10,*B15--[2]      ; push register (for c-callable func)
||      STW     .D1  A10,*A15--[2]      ; push register (for c-callable func)

NO_INT_1
        ADD     .L1X B10,A1,A11:A10     ; y1 = round;
||      ADD     .S2  B9,1,B9            ; 2 * nh + 1
||      LDW     .D2  *B4,A3             ; h1_h0 = *h

        LDH     .D1  *A4,A9             ; x0a = *xa
||      LDH     .D2  *++B5[B9],B9       ; x1b = *xb, *xb -> x+2n
||      MVK     .S2  3,B2               ; set sync for r's counter (= 3)
||      ADD     .L1X B7,1,A14           ; s
||      ADD     .S1  A10,0,A5           ; round;

; outer loop repeat nr/2 times; and inner loop repeat nh/2+2 times.

loop:
   [A2] LDH     .D1  *++A4,B7           ;@@@ x1a = *++xa
|| [A2] LDH     .D2  *--B5,A7           ;@@@ x0b = *--xb
||      ADD     .L1  A9,A7,A12          ;@ x11 = x0a + x0b
||      ADD     .L2  B7,B9,B14          ;@ x01 = x1a + x1b
||      MPY     .M1  A12,A3,A13         ;@ p00 = x00 * h0
||      MPY     .M2X B14,A3,B13         ;@ p10 = x10 * h0
|| [A2] B       .S2  loop
||      MV      .S1  A3,A7              ; = h1_h0 (old)

   [A2] LDH     .D1  *++A4,A9           ;@@@ x0a = *++xa
|| [A2] LDH     .D2  *--B5,B9           ;@@@ x1b = *--xb
||      MPY     .M2X A12,B7,B13         ;@ p11 = x11 * h1_h0 (old)
||      MPYLH   .M1X B14,A7,A13         ;@ p01 = x01 * h1 (old)
||[!B2] ADD     .L1  A11:A10,A13,A11:A10        ; y0 += p01
||[!B2] ADD     .L2  B11:B10,B13,B11:B10        ; y1 += p11
|| [B2] SUB     .S2  B2,1,B2            ; decrement sync for r's
||[A1]  B       .S1  loop               ; outer loop branch

   [A2] LDW     .D2  *++B4,A3           ;@@@@ h1_h0 = *++h
||      ADD     .D1  A9,A7,A12          ;@@ x00 = x0a + x0b
||      ADD     .S2  B7,B9,B14          ;@@ x10 = x1a + x1b
||[!B2] ADD     .L1  A11:A10,A13,A11:A10        ;@ y0 += p00
||[!B2] ADD     .L2  B11:B10,B13,B11:B10        ;@ y1 += p10
|| [A2] SUB     .S1  A2,2,A2            ; inner_loop count -= 2
||[!A2] MPY     .M1  A8,1,A1            ; compare for outer loop branch
||      MPYHL   .M2X A3,B1,B7           ; = h1 (old)
        ; inner_loop_end

        MPY     .M1  A9,A3,A7           ;e p00 = x0a * h0
||      MPY     .M2X B9,A3,B7           ;e p10 = x1b * h0
||      SHR     .S2  B6,1,B14           ;p B14 = nh/2
||      ADD     .L1  A11:A10,A13,A3:A2  ;e (2) y0 += p01
||      SUB     .S1x B6,2,A9            ;p A9 = nh-2
||      ADD     .L2  B6,2,B9            ;p B9 = nh+2
||[!B0] STH     .D1  B12,*+A6[1]        ;e r[j+1]=(int) d_y1
||      ADD     .D2  B2,3,B2            ;p reset r's counter (= 3)

  [!B0] STH     .D1  A0,*A6++[2]        ;e r[j] = (int) d_y0
||      ADD     .L2  B11:B10,B13,B13:B12        ;e (2) y1 += p11
||      MV      .L1  A5,A10             ;p y0 = round;
||      SUB     .S1  A8,2,A8            ;o decrement outer loop counter (-=2)
|| [A1] B       .S2  loop
||      SUB     .D2  B0,B0,B0           ;o clear sync for output
||      MPY     .M2  B11,0,B11          ;p y1 = (H)round;
||      MPY     .M1  A11,0,A11          ;p y1 = (H)round;

        LDH     .D1  *--A4[A9],A9       ;o (2) x0a = *xa, xa->xa-=nh-2
||      LDH     .D2  *++B5[B9],B9       ;o (2) x1b = *xb, xb->xb+=nh+2
||      ADD     .L1  A3:A2,A7,A3:A2     ;e (final) y0 += p00
||      ADD     .L2  B13:B12,B7,B13:B12 ;e (final) y1 += p10
||      MV      .S2X A5,B10             ;p y0 = (L)round;
||      MPY     .M1X B6,1,A2            ;p set inner loop counter (=nh)

        LDW     .D2  *--B4[B14],A3      ;p h1_h0 = *h[1,0]
||      SHRU    .S1  A3:A2,A14,A1:A0    ;e d_y0 = y0 >> s
||      SHR     .S2  B13:B12,B8,B13:B12 ;e d_y1 = y1 >> s
        ; outer_loop_end

        STH     .D1  A0,*A6++           ;e r[j] = (int) d_y0

        STH     .D1  B12,*A6++          ;e r[j+1]=(int) d_y1

        LDW     .D1     *++A15[2],A10   ; pop register (for c-callable func)
||      LDW     .D2     *++B15[2],B10   ; pop register (for c-callable func)
||      B               NO_INT_2

        LDW     .D1     *++A15[2],A11   ; pop register (for c-callable func)
||      LDW     .D2     *++B15[2],B11   ; pop register (for c-callable func)

        LDW     .D1     *++A15[2],A12   ; pop register (for c-callable func)
||      LDW     .D2     *++B15[2],B12   ; pop register (for c-callable func)

        LDW     .D1     *++A15[2],A13   ; pop register (for c-callable func)
||      LDW     .D2     *++B15[2],B13   ; pop register (for c-callable func)

        LDW     .D1     *++A15[2],A14   ; pop register (for c-callable func)
||      LDW     .D2     *++B15[2],B14   ; pop register (for c-callable func)
||      B       .S2     B3              ; return

        LDW     .D2     *++B15[2],A15   ; pop register (for c-callable func)
NO_INT_2

        NOP 4

* ========================================================================= *
*   End of file:  dsp_fir_sym.asm                                           *
* ------------------------------------------------------------------------- *
*             Copyright (c) 2002 Texas Instruments, Incorporated.           *
*                            All Rights Reserved.                           *
* ========================================================================= *
