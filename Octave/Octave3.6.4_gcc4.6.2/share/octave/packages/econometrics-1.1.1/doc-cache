# Created by Octave 3.6.4, Sat Mar 30 10:04:54 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 28
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
delta_method


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
 Computes Delta method mean and covariance of a nonlinear
 transformation defined by "func"



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 Computes Delta method mean and covariance of a nonlinear
 transformation define



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
gmm_estimate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 927
 usage: [theta, obj_value, convergence, iters] =
           gmm_estimate(theta, data, weight, moments, momentargs, control, nslaves)

 inputs:
      theta: column vector initial parameters
       data: data matrix
     weight: the GMM weight matrix
    moments: name of function computes the moments
	      (should return nXg matrix of contributions)
 momentargs: (cell) additional inputs needed to compute moments.
 	      May be empty ("")
    control: (optional) BFGS or SA controls (see bfgsmin and samin).
             May be empty ("").
    nslaves: (optional) number of slaves if executed in parallel
             (requires MPITB)

 outputs:
 theta: GMM estimate of parameters
 obj_value: the value of the gmm obj. function
 convergence: return code from bfgsmin
              (1 means success, see bfgsmin for details)
 iters: number of BFGS iteration used

 please type "gmm_example" while in octave to see an example



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 usage: [theta, obj_value, convergence, iters] =
           gmm_estimate(theta, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
gmm_example


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
 GMM example file, shows initial consistent estimator,
 estimation of efficient weight, and second round
 efficient estimator



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 GMM example file, shows initial consistent estimator,
 estimation of efficient 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gmm_obj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 206
 The GMM objective function, for internal use by gmm_estimate
 This is scaled so that it converges to a finite number.
 To get the chi-square specification
 test you need to multiply by n (the sample size)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 The GMM objective function, for internal use by gmm_estimate
 This is scaled so



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
gmm_results


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1145
 usage: [theta, V, obj_value] =
  gmm_results(theta, data, weight, moments, momentargs, names, title, unscale, control, nslaves)

 inputs:
      theta: column vector initial parameters
       data: data matrix
     weight: the GMM weight matrix
    moments: name of function computes the moments
             (should return nXg matrix of contributions)
 momentargs: (cell) additional inputs needed to compute moments.
             May be empty ("")
      names: vector of parameter names
             e.g., names = char("param1", "param2");
      title: string, describes model estimated
    unscale: (optional) cell that holds means and std. dev. of data
             (see scale_data)
    control: (optional) BFGS or SA controls (see bfgsmin and samin). May be empty ("").
    nslaves: (optional) number of slaves if executed in parallel
             (requires MPITB)

 outputs:
 theta: GMM estimated parameters
 V: estimate of covariance of parameters. Assumes the weight matrix
    is optimal (inverse of covariance of moments)
 obj_value: the value of the GMM objective function

 please type "gmm_example" while in octave to see an example



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 usage: [theta, V, obj_value] =
  gmm_results(theta, data, weight, moments, mome



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
gmm_variance


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
 GMM variance, which assumes weights are optimal



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
 GMM variance, which assumes weights are optimal




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
gmm_variance_inefficient


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
 GMM variance, which assumes weights are not optimal



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
 GMM variance, which assumes weights are not optimal




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
kernel_density


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1338
 kernel_density: multivariate kernel density estimator

 usage:
       dens = kernel_density(eval_points, data, bandwidth)

 inputs:
       eval_points: PxK matrix of points at which to calculate the density
       data: NxK matrix of data points
       bandwidth: positive scalar, the smoothing parameter. The fit
               is more smooth as the bandwidth increases.
       kernel (optional): string. Name of the kernel function. Default is
               Gaussian kernel.
       prewhiten bool (optional): default false. If true, rotate data
               using Choleski decomposition of inverse of covariance,
               to approximate independence after the transformation, which
               makes a product kernel a reasonable choice.
       do_cv: bool (optional). default false. If true, calculate leave-1-out
                density for cross validation
       computenodes: int (optional, default 0).
               Number of compute nodes for parallel evaluation
       debug: bool (optional, default false). show results on compute nodes if doing
               a parallel run
 outputs:
       dens: Px1 vector: the fitted density value at each of the P evaluation points.

 References:
 Wand, M.P. and Jones, M.C. (1995), 'Kernel smoothing'.
 http://www.xplore-stat.de/ebooks/scripts/spm/html/spmhtmlframe73.html



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
 kernel_density: multivariate kernel density estimator




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
kernel_density_cvscore


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
 cvscore = kernel_density_cvscore(bandwidth, data, kernel)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
 cvscore = kernel_density_cvscore(bandwidth, data, kernel)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
kernel_example


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 161
 kernel_example: examples of how to use kernel density and regression functions
 requires the optim and plot packages from Octave Forge

 usage: kernel_example;



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 kernel_example: examples of how to use kernel density and regression functions




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
kernel_optimal_bandwidth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 341
 kernel_optimal_bandwidth: find optimal bandwith doing leave-one-out cross validation
 inputs:
      * data: data matrix
      * depvar: column vector or empty ("").
              If empty, do kernel density, orherwise, kernel regression
      * kernel (optional, string) the kernel function to use
 output:
      * h: the optimal bandwidth



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 kernel_optimal_bandwidth: find optimal bandwith doing leave-one-out cross valid



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
kernel_regression


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1248
 kernel_regression: kernel regression estimator

 usage:
      fit = kernel_regression(eval_points, depvar, condvars, bandwidth)

 inputs:
      eval_points: PxK matrix of points at which to calculate the density
      depvar: Nx1 vector of observations of the dependent variable
      condvars: NxK matrix of data points
      bandwidth (optional): positive scalar, the smoothing parameter.
              Default is N ^ (-1/(4+K))
      kernel (optional): string. Name of the kernel function. Default is
              Gaussian kernel.
      prewhiten bool (optional): default true. If true, rotate data
              using Choleski decomposition of inverse of covariance,
              to approximate independence after the transformation, which
              makes a product kernel a reasonable choice.
      do_cv: bool (optional). default false. If true, calculate leave-1-out
               fit to calculate the cross validation score
      computenodes: int (optional, default 0).
              Number of compute nodes for parallel evaluation
      debug: bool (optional, default false). show results on compute nodes if doing
              a parallel run
 outputs:
      fit: Px1 vector: the fitted value at each of the P evaluation points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
 kernel_regression: kernel regression estimator




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
kernel_regression_cvscore


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
 cvscore = kernel_regression_cvscore(bandwidth, data, depvar)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
 cvscore = kernel_regression_cvscore(bandwidth, data, depvar)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
mle_estimate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 758
 usage:
 [theta, obj_value, conv, iters] = mle_estimate(theta, data, model, modelargs, control, nslaves)

 inputs:
 theta: column vector of model parameters
 data: data matrix
 model: name of function that computes log-likelihood
 modelargs: (cell) additional inputs needed by model. May be empty ("")
 control: (optional) BFGS or SA controls (see bfgsmin and samin). May be empty ("").
 nslaves: (optional) number of slaves if executed in parallel (requires MPITB)

 outputs:
 theta: ML estimated value of parameters
 obj_value: the value of the log likelihood function at ML estimate
 conv: return code from bfgsmin (1 means success, see bfgsmin for details)
 iters: number of BFGS iteration used

 please see mle_example.m for examples of how to use this



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 usage:
 [theta, obj_value, conv, iters] = mle_estimate(theta, data, model, mode



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
mle_example


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
 Example to show how to use MLE functions



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
 Example to show how to use MLE functions




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
mle_obj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 178
 usage: [obj_value, score] = mle_obj(theta, data, model, modelargs, nslaves)

 Returns the average log-likelihood for a specified model
 This is for internal use by mle_estimate



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
 usage: [obj_value, score] = mle_obj(theta, data, model, modelargs, nslaves)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
mle_obj_nodes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
 contrib = mle_obj_nodes(theta, data, model, modelargs, nn)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
 contrib = mle_obj_nodes(theta, data, model, modelargs, nn)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
mle_results


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 978
 usage: [theta, V, obj_value, infocrit] =
    mle_results(theta, data, model, modelargs, names, title, unscale, control)

 inputs:
 theta: column vector of model parameters
 data: data matrix
 model: name of function that computes log-likelihood
 modelargs: (cell) additional inputs needed by model. May be empty ("")
 names: vector of parameter names, e.g., use names = char("param1", "param2");
 title: string, describes model estimated
 unscale: (optional) cell that holds means and std. dev. of data (see scale_data)
 control: (optional) BFGS or SA controls (see bfgsmin and samin). May be empty ("").
 nslaves: (optional) number of slaves if executed in parallel (requires MPITB)

 outputs:
 theta: ML estimated value of parameters
 obj_value: the value of the log likelihood function at ML estimate
 conv: return code from bfgsmin (1 means success, see bfgsmin for details)
 iters: number of BFGS iteration used

 Please see mle_example for information on how to use this



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 usage: [theta, V, obj_value, infocrit] =
    mle_results(theta, data, model, mo



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
nls_estimate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 780
 usage:
 [theta, obj_value, conv, iters] = nls_estimate(theta, data, model, modelargs, control, nslaves)

 inputs:
 theta: column vector of model parameters
 data: data matrix
 model: name of function that computes the vector of sums of squared errors
 modelargs: (cell) additional inputs needed by model. May be empty ("")
 control: (optional) BFGS or SA controls (see bfgsmin and samin). May be empty ("").
 nslaves: (optional) number of slaves if executed in parallel (requires MPITB)

 outputs:
 theta: NLS estimated value of parameters
 obj_value: the value of the sum of squared errors at NLS estimate
 conv: return code from bfgsmin (1 means success, see bfgsmin for details)
 iters: number of BFGS iteration used

 please see nls_example.m for examples of how to use this



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 usage:
 [theta, obj_value, conv, iters] = nls_estimate(theta, data, model, mode



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
nls_example


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56

 define arguments for nls_estimate #

 starting values



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38

 define arguments for nls_estimate #




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nls_obj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 185
 usage: [obj_value, score] = nls_obj(theta, data, model, modelargs, nslaves)

 Returns the average sum of squared errors for a specified model
 This is for internal use by nls_estimate



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
 usage: [obj_value, score] = nls_obj(theta, data, model, modelargs, nslaves)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
parameterize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 316
 usage: theta = parameterize(theta, otherargs)
 
 This is an empty function, provided so that
 delta_method will work as is. Replace it with
 the parameter transformations your models use.
 Note: you can let "otherargs" contain the model
 name so that this function can do parameterizations
 for a variety of models



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 usage: theta = parameterize(theta, otherargs)
 
 This is an empty function, pro



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
poisson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
 Example likelihood function (Poisson for count data) with score



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
 Example likelihood function (Poisson for count data) with score




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
poisson_moments


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
 the form a user-written moment function should take



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
 the form a user-written moment function should take




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
prettyprint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
 this prints matrices with row and column labels



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
 this prints matrices with row and column labels




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
prettyprint_c


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
 this prints matrices with column labels but no row labels



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
 this prints matrices with column labels but no row labels




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
scale_data


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
 Standardizes and normalizes data matrix,
 primarily for use by BFGS



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
 Standardizes and normalizes data matrix,
 primarily for use by BFGS




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
unscale_parameters


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
 Unscales parameters that were estimated using scaled data
 primarily for use by BFGS



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 Unscales parameters that were estimated using scaled data
 primarily for use by





