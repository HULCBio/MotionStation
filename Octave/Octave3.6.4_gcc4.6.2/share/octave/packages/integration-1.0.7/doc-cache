# Created by Octave 3.6.4, Sat Mar 30 09:40:17 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 25
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
Contents


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4756
 Numerical Integration Toolbox 

 MATLAB Toolbox for 1-D, 2-D, and n-D Numerical Integration

 Edited Version for OCTAVE
 
 The original 1-D routines were obtained from NETLIB and were 
 written by
          Howard Wilson
          Department of Engineering Mechanics
          University of Alabama
          Box 870278
          Tuscaloosa, Alabama 35487-0278
          Phone 205 348-1617
          Email address: HWILSON @ UA1VM.UA.EDU
 
 The rest of the routines were written by
          Bryce Gardner
          Ray W. Herrick Laboratories
          Purdue University
          West Lafayette, IN 47906
          Phone: 317-494-0231
          Fax:  317-494-0787
          Email:  gardner@ecn.purdue.edu

 Easy to use routines:  (these routines iteratively integrate with 
			  higher order quadratures until the integral has
			  converged--use these routine unless you want to
			  specify the order of integration quadrature that
			  is to be used)
	   quadg.m	-- High accuracy replacement for QUAD and QUAD8 (1-D)
	   quad2dg.m	-- 2-D integration over a rectangular region
	   quad2dggen.m	-- 2-D integration over a general region
	   quadndg.m	-- n-D integration over a n-D hyper-rectangular region
          README.nit	-- introductory readme file

 The 1-D routines:
          README	-- The original readme file by Howard Wilson
          gquad.m	-- Integrates a 1-D function with input Gauss 
			   points and weights (modified by Bryce Gardner to
			   handle an optional parameter in the function to be
			   integrated and also to calculate the Gauss points
			   and weights on the fly)
          gquad6.m	-- Integrates a 1-D function with a 6-point quadrature
          grule.m	-- Calculates the Gauss points and weights
          run.log	-- File with examples

    New 1-D routines:
	   quadg.m	-- High accuracy replacement for QUAD and QUAD8
	   quadc.m	-- 1-D Gauss-Chebyshev integration routine
          crule.m	-- Calculates the Gauss-Chebyshev points and weights
          ncrule.m	-- Calculates the Newton-Coates points and weights

 The 2-D routines:
	   quad2dg.m	-- 2-D integration over a rectangular region
	   quad2dc.m	-- 2-D integration over a rectangular region with
			   a 1/sqrt(1-x.^2)/sqrt(1-y.^2) sinqularity
          gquad2d.m	-- Integrates a 2-D function over a square region
          gquad2d6.m	-- Integrates a 2-D function over a square region with
			   a 6-point quadrature
	   quad2dggen.m	-- 2-D integration over a general region
	   quad2dcgen.m	-- 2-D integration over a general region with
			   a 1/sqrt(1-x.^2)/sqrt(1-y.^2) sinqularity
          gquad2dgen.m -- Integrates a 2-D function over a variable region
			   (That is the limits on the inner integration are
			   defined by a function of the variable of integration
			   of the outer integral.)
          grule2d.m	-- Calculates the Gauss points and weights for gquad2d.m
          grule2dgen.m -- Calculates the Gauss points and weights for 
			   gquad2dgen.m
          crule2d.m	-- Calculates the Gauss-Chebyshev points and weights 
			   for gquad2d.m
          crule2dgen.m -- Calculates the Gauss-Chebyshev points and weights 
			   for gquad2dgen.m

 The n-D routines:
          quadndg.m	-- n-D integration over an n-D hyper-rectangular region
          gquadnd.m    -- Integrates a n-D function over 
                          an n-D hyper-rectangular 
			   region using a Gauss quadrature
          cquadnd.m    -- Integrates a n-D function over 
                          an n-D hyper-rectangular 
			   region using a Gauss-Chebyshev quadrature
          innerfun.m   -- used internally to gquadnd.m and cquadnd.m

 Utility routines:
	   count.m	-- routine to count the number of function calls
	   zero_count.m	-- routine to report the number of function calls and
			   then to reset the counter

 Test scripts:
          run2dtests.m	-- 2-D examples and 1-D Gauss-Chebyshev examples
	   tests2d.log  -- output of run2dtests.m -- Matlab 4.1 on a Sparc 10
	   test_ncrule.m-- m-file to check the Newton-Coates quadrature
	   testsnc.log  -- output of test_ncrule.m -- Matlab 4.1 on a Sparc 10
	   test_quadg.m -- m-file to check the quadg routine
	   testsqg.log  -- output of test_quadg.m -- Matlab 4.1 on a Sparc 10

 Test functions:
          xsquar.m	-- xsquar(x)=x.^2
          xcubed.m	-- xcubed(x)=x.^3
          x25.m	-- x25(x)=x.^25
	   fxpow.m	-- fxpow(x,y)=x.^y
          hx.m         -- hx(x)=sum(x.^2)
          gxy.m	-- gxy(x,y)=x.^2+y.^2
          gxy1.m	-- gxy1(x,y)=ones(size(x))
          gxy2.m	-- gxy2(x,y)=sqrt(x.^2+y.^2)
          glimh.m	-- glimh(y)=3
          glimh2.m	-- glimh(y)=y
          gliml.m	-- gliml(y)=0
          lcrcl.m	-- lcrcl(y)=-sqrt(4-y.^2)
          lcrcu.m	-- lcrcu(y)=sqrt(4-y.^2)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
 Numerical Integration Toolbox 




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cquadnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 578
usage:  nvol = cquadnd (fun,lowerlim,upperlim,nquad);
	n	-- number of dimensions to integrate
	nvol	-- value of the n-dimensional integral
	fun	-- fun(x) (function to be integrated) in this case treat
                  all the different values of x as different variables
                  as opposed to different instances of the same variable
	x	-- n length vector of coordinates
	lowerlim-- n length vector of lower limits of integration
	upperlim-- n length vector of upper limits of integration
	nquad	-- n length vector of number of gauss points 
		   in each integration



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
usage:  nvol = cquadnd (fun,lowerlim,upperlim,nquad);
	n	-- number of dimensions



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
crule


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 823

usage:  [bp,wf]=crule(m)
  This function computes Gauss-Chebyshev base points and weight factors
  using the algorithm given by somebody in 'SomeBook',
  page 365, Academic Press, 1975, but modified by a change
  in index variables:  j=i+1 and m=n+1.
  The weights are all wf_j=pi/m
  and the base points are bp_j=cos((2j-1)*pi/2/m)

  m -- number of Gauss-Chebyshev points (integrates a (2m-1)th order
       polynomial exactly)

  The Gauss-Chebyshev Quadrature integrates an integral of the form
     1					     m
  Int ((1/sqrt(1-z^2)) f(z)) dz  =  pi/m Sum  (f(cos((2j-1)*pi/2/m)))
    -1					    j=1
  For compatability with the other Gauss Quadrature routines, I brought
  the weight factor into the summation as
     1					 m
  Int ((1/sqrt(1-z^2)) f(z)) dz  =   Sum  (pi/m * f(cos((2j-1)*pi/2/m)))
    -1					j=1



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

usage:  [bp,wf]=crule(m)
  This function computes Gauss-Chebyshev base points a



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
crule2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52

usage:  [bpx,bpy,wfxy] = crule2d (nquadx,nquady);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51

usage:  [bpx,bpy,wfxy] = crule2d (nquadx,nquady);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
crule2dgen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62

usage:  [bpxv,wfxv,bpyv,wfyv] = crule2dgen (nquadx,nquady);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61

usage:  [bpxv,wfxv,bpyv,wfyv] = crule2dgen (nquadx,nquady);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
gquad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1343

  area = gquad (fun,xlow,xhigh,mparts,bp,wf)
    or
  area = gquad (fun,xlow,xhigh,mparts,nquad)
    or
  area = gquad (fun,xlow,xhigh,mparts,bp,wf,y)
  This function evaluates the integral of an externally
  defined function fun(x) between limits xlow and xhigh. The
  numerical integration is performed using a composite Gauss
  integration rule.  The whole interval is divided into mparts
  subintervals and the integration over each subinterval
  is done with an nquad point Gauss formula which involves base
  points bp and weight factors wf.  The normalized interval
  of integration for the bp and wf constants is -1 to +1. The
  algorithm is described by the summation relation
  x=b                     j=n k=m
  integral( f(x)*dx ) = d1*sum sum( wf(j)*fun(a1+d*k+d1*bp(j)) )
  x=a                     j=1 k=1
         where bp are base points, wf are weight factors
         m = mparts, and n = length(bp) and
         d = (b-a)/m, d1 = d/2, a1 = a-d1
  The base points and weight factors must first be generated
  by a call to grule of the form [bp,wf] = grule(nquad)

  Optional argument, nquad, is used if the Gauss points and weights
  have not been previously calculated.

  Optional argument, y, is used if the function, fun is a function
  of x and y.  fun(x,y) will be integrated over the range in x for 
  the constant, y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

  area = gquad (fun,xlow,xhigh,mparts,bp,wf)
    or
  area = gquad (fun,xlow,xh



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gquad2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1538

usage:  vol = gquad2d(fun,xlow,xhigh,ylow,yhigh,bpx,bpy,wfxy)
 or
        vol = gquad2d(fun,xlow,xhigh,ylow,yhigh,nquadx,nquady)
  This function evaluates the integral of an externally
  defined function fun(x,y) between limits xlow and xhigh
  and ylow and yhigh. The numerical integration is performed 
  using a Gauss integration rule.  The integration 
  is done with an nquadx by nquady Gauss formula which involves base
  point matrices bpx and bpy and weight factor matrix wfxy.  The normalized 
  interval of integration for the bpx, bpy and wfxy constants is -1 to +1 
  (in x) and -1 to +1 (in y). The algorithm is described by the 
  summation relation
  x=b                     j=nx k=ny
  integral( f(x)*dx ) = J*sum sum( wfxy(j,k)*fun( x(j), y(k) ) )
  x=a                     j=1 k=1
         where wfxy are weight factors,
         nx = nquadx = number of Gauss points in the x-direction,
         ny = nquady = number of Gauss points in the y-direction,
         x = (xhigh-xlow)/2 * bpx + (xhigh+xlow)/2 = mapping function in x,
         y = (yhigh-ylow)/2 * bpy + (yhigh+ylow)/2 = mapping function in y,
         and J = (xhigh-xlow)*(yhigh-ylow)/4 = Jacobian of the mapping.
  The base points and weight factors must first be generated
  by a call to grule of the form [bpx,bpy,wfxy] = grule2d(nquadx,nquady)

 The first form of gquad2d is faster when used several times, because 
 the points and weights are only calculated once.

 The second form of gquad2d is usefull if it is only called once (or a 
 few times).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

usage:  vol = gquad2d(fun,xlow,xhigh,ylow,yhigh,bpx,bpy,wfxy)
 or
        vol =



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
gquad2d6


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 693

usage:  vol = gquad6(fun,xlow,xhigh,ylow,yhigh)

   ==== Six Point by Six Point Double Integral Gauss Formula ====

  This function determines the volume under an externally
  defined function fun(x,y) between limits xlow and xhigh and
  ylow and yhigh. The numerical integration is performed using 
  a gauss integration rule.  The integration is done with a 
  six point Gauss formula which involves base
  points bpx, bpy and weight factors wfxy.  The normalized interval
  of integration for the bp and wf constants is -1 to +1 (in x) and
  -1 to 1 (in y).  The algorithm is structured in terms of a 
  parameter nquad = 6 which can be changed to accommodate a different
  order formula.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49

usage:  vol = gquad6(fun,xlow,xhigh,ylow,yhigh)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
gquad2dgen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 941

usage: vol = gquad2dgen(funxy,limxlow,limxhigh,ylow,yhigh,bpxv,wfxv,bpyv,wfyv);
  or
usage: vol = gquad2dgen(funxy,limxlow,limxhigh,ylow,yhigh,nquadx,nquady);

 This function evaluates a general double integral.  The limits of the 
 inner integration may be functions of the outer integral's variable of 
 integration.  Such as
              yhigh    ghigh(y)
      Vol = Int     Int       f(x,y)  dx  dy
              ylow    glow(y)
 where
      funxy = f(x,y)
      limxlow = glow(y)
      limxhigh = ghigh(y)
 and the base points and weighting functions are found from
     [bpxv,wfxv,bpyv,wfyv]=grule2dgen(nquadx,nquady);
 where nquadx and nquady are the number of gauss points in the x- and
 y-directions, respectively.

 The first form of gquad2dgen is faster when used several times, because 
 the points and weights are only calculated once.

 The second form of gquad2dgen is usefull if it is only called once (or a 
 few times).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

usage: vol = gquad2dgen(funxy,limxlow,limxhigh,ylow,yhigh,bpxv,wfxv,bpyv,wfyv);



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gquad6


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1065


   ==== Six Point Composite Gauss Formula ====
   ====   With Weight Factors Included    ====

  area = gquad6(fun,xlow,xhigh,mparts)
  This function determines the area under an externally
  defined function fun(x) between limits xlow and xhigh. The
  numerical integration is performed using a composite gauss
  integration rule.  The whole interval is divided into mparts
  subintervals and the integration over each subinterval
  is done with a six point Gauss formula which involves base
  points bp and weight factors wf.  The normalized interval
  of integration for the bp and wf constants is -1 to +1.  the
  algorithm is structured in terms of a parameter mquad = 6 which
  can be changed along with bp and wf to accommodate a different
  order formula.  The composite algorithm is described by the
  following summation relation
  x=b                     j=n k=m
  integral( f(x)*dx ) = d1*sum sum( wf(j)*fun(a1+d*k+d1*bp(j)) )
  x=a                     j=1 k=1
        where d = (b-a)/m, d1 = d/2, a1 = a-d1,
              m = mparts, and n = nquad.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gquadnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 579

usage:  nvol = gquadnd (fun,lowerlim,upperlim,nquad);
	n	-- number of dimensions to integrate
	nvol	-- value of the n-dimensional integral
	fun	-- fun(x) (function to be integrated) in this case treat
                  all the different values of x as different variables
                  as opposed to different instances of the same variable
	x	-- n length vector of coordinates
	lowerlim-- n length vector of lower limits of integration
	upperlim-- n length vector of upper limits of integration
	nquad	-- n length vector of number of gauss points 
		   in each integration



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

usage:  nvol = gquadnd (fun,lowerlim,upperlim,nquad);
	n	-- number of dimension



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
grule


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 207

 [bp,wf]=grule(n)
  This function computes Gauss base points and weight factors
  using the algorithm given by Davis and Rabinowitz in 'Methods
  of Numerical Integration', page 365, Academic Press, 1975.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

 [bp,wf]=grule(n)
  This function computes Gauss base points and weight factors



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
grule2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52

usage:  [bpx,bpy,wfxy] = grule2d (nquadx,nquady);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51

usage:  [bpx,bpy,wfxy] = grule2d (nquadx,nquady);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
grule2dgen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62

usage:  [bpxv,wfxv,bpyv,wfyv] = grule2dgen (nquadx,nquady);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61

usage:  [bpxv,wfxv,bpyv,wfyv] = grule2dgen (nquadx,nquady);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
innerfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74

usage:  int = innerfun(fun,lowerlim,upperlim,nquad,n,level,x,quadrule);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73

usage:  int = innerfun(fun,lowerlim,upperlim,nquad,n,level,x,quadrule);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
integ1es


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2416
 -- Function File:  integrator(Y,X-LOWER,X-UPPER)
     Given a vector of evenly spaced y values on x-lower through
     x-upper, end points included, the numerical integral of y is
     returned.

     Unlike "Function" integrators, which need a function routine that
     the integrator can evaluate as it wishes, this is a "Data"
     integrator that enables the integration of the whatever values are
     provided without reference to any other information.  Since data
     usually comes in the form of evenly spaced values, this is the
     approach taken.  However, this can be used as a "Function"
     integrator as it is in the demo sited below.

     This uses a (up through, depending on the number of values
     furnished) ninth order polynomial approximation method and all the
     standard polynomial approximation rules apply hereto.

     This is "exact" for 8'th and 9'th orders in x if 9 or more values
     are supplied, 6'th and 7'th for 7 or more, 4'th and 5'th for 5 or
     more, and 2'nd and 3'rd for 3 or more.  For higher orders, the
     result will generally become usably accurate with enough data
     points.  For illustrations, please see the 'Demo Instructions'.

     The function need not be powers of x.  Any function that can be
     adequately represented by a ninth order power series will work,
     e.g. exp(-k*x), exp(-k*x^2), sin(k*x), etc.  See below.

     Demo Instructions:      To see how this works with a variety of
     functions, the included demo is run by entering 'demo integ1es',
     without the single quotation marks, at the command line.  When the
     source code display, has finished press 'q' to get out of it, and
     then follow the on screen directions.  Several test functions are
     available, both with and without experimental error.  Note that
     when experimental error, a tolerance of 1%, is included, the error
     in the result, usually in the tenths of a percent, is fairly
     independent of the number of points.

     This test serves the purpose, amongst others, of determining how
     many points need be provided to achieve the desired accuracy
     before the data is created.

     Beware of trying null value integrals since calculating the
     relative error results in a division by zero.  Also, the error for
     e^(ord*x^2) for positive 'ord' is reported as 'NaN' since there is
     no function for comparison.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given a vector of evenly spaced y values on x-lower through x-upper,
end points 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ncrule


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 266
usage:  [bp,wf]=ncrule(m);
  This function returns the Newton-Coates base points and weight factors
  up to an 8 point Newton-Coates formula.

  m -- number of Newton-Coates points (integrates an mth order
       polynomial exactly (or an (m+1)th order for even m))



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
usage:  [bp,wf]=ncrule(m);
  This function returns the Newton-Coates base points



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
quad2dc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 808

usage:  int = quad2dc('Fun',xlow,xhigh,ylow,yhigh)
or
        int = quad2dc('Fun',xlow,xhigh,ylow,yhigh,tol)

This function is similar to QUAD or QUAD8 for 2-dimensional integration,
but it uses a Gaussian-Chebyshev quadrature integration scheme.  
 	int     -- value of the integral
       Fun     -- Fun(x,y) (function to be integrated)
       xlow    -- lower x limit of integration  (should be -xhigh)
       xhigh   -- upper x limit of integration
       ylow    -- lower y limit of integration  (should be -yhigh)
       yhigh   -- upper y limit of integration
       tol     -- tolerance parameter (optional)
  The Gauss-Chebyshev Quadrature integrates an integral of the form
     yhigh                xhigh
  Int ((1/sqrt(1-y^2)) Int ((1/sqrt(1-x^2)) fun(x,y)) dx dy
    -yhigh               -xlow



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

usage:  int = quad2dc('Fun',xlow,xhigh,ylow,yhigh)
or
        int = quad2dc('Fu



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
quad2dcgen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 802

usage:  int = quad2dcgen('Fun','funxlow','funxhigh',ylow,yhigh)
or
        int = quad2dcgen('Fun','funxlow','funxhigh',ylow,yhigh,tol)

This function is similar to QUAD or QUAD8 for 2-dimensional integration
over a general 2-dimensional region, but it uses a Gauss-Chebyshev 
quadrature integration scheme.  
The integral is like:
               yhigh                   funxhigh(y)
      int = Int  (1/sqrt(1-y.^2))   Int  (1/sqrt(1-x.^2))  Fun(x,y)  dx  dy
               ylow                    funxlow(y)

 	int     -- value of the integral
       Fun     -- Fun(x,y) (function to be integrated)
       funxlow -- funxlow(y)
       funxhigh-- funxhigh(y)
       ylow    -- lower y limit of integration
       yhigh   -- upper y limit of integration
       tol     -- tolerance parameter (optional)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

usage:  int = quad2dcgen('Fun','funxlow','funxhigh',ylow,yhigh)
or
        int 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
quad2dg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 832

usage:  int = quad2dg('Fun',xlow,xhigh,ylow,yhigh)
or
        int = quad2dg('Fun',xlow,xhigh,ylow,yhigh,tol)

This function is similar to QUAD or QUAD8 for 2-dimensional integration,
but it uses a Gaussian quadrature integration scheme.  
 	int     -- value of the integral
       Fun     -- Fun(x,y) (function to be integrated)
       xlow    -- lower x limit of integration
       xhigh   -- upper x limit of integration
       ylow    -- lower y limit of integration
       yhigh   -- upper y limit of integration
       tol     -- tolerance parameter (optional)
Note that if there are discontinuities the region of integration 
should be broken up into separate pieces.  And if there are singularities,
a more appropriate integration quadrature should be used 
(such as the Gauss-Chebyshev for a specific type of singularity).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

usage:  int = quad2dg('Fun',xlow,xhigh,ylow,yhigh)
or
        int = quad2dg('Fu



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
quad2dggen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 997

usage:  int = quad2dggen('Fun','funxlow','funxhigh',ylow,yhigh)
or
        int = quad2dggen('Fun','funxlow','funxhigh',ylow,yhigh,tol)

This function is similar to QUAD or QUAD8 for 2-dimensional integration
over a general 2-dimensional region, but it uses a Gaussian quadrature 
integration scheme.  
The integral is like:
              yhigh   funxhigh(y)
      int = Int     Int       Fun(x,y)  dx  dy
              ylow    funxlow(y)

 	int     -- value of the integral
       Fun     -- Fun(x,y) (function to be integrated)
       funxlow -- funxlow(y)
       funxhigh-- funxhigh(y)
       ylow    -- lower y limit of integration
       yhigh   -- upper y limit of integration
       tol     -- tolerance parameter (optional)
Note that if there are discontinuities the region of integration 
should be broken up into separate pieces.  And if there are singularities,
a more appropriate integration quadrature should be used 
(such as the Gauss-Chebyshev for a specific type of singularity).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

usage:  int = quad2dggen('Fun','funxlow','funxhigh',ylow,yhigh)
or
        int 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
quadc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 403

usage:  int = quadc('Fun',xlow,xhigh)
or
        int = quadc('Fun',xlow,xhigh,tol)
or
        int = quadc('Fun',xlow,xhigh,tol,trace,p1,p2,....)

This function works just like QUAD or QUAD8 but uses a Gaussian-Chebyshev
quadrature integration scheme.

  The Gauss-Chebyshev Quadrature integrates an integral of the form
     xhigh
  Int ((1/sqrt(1-x^2)) fun(x)) dx
    -xhigh
This routine ignores xlow



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

usage:  int = quadc('Fun',xlow,xhigh)
or
        int = quadc('Fun',xlow,xhigh,t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
quadg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 970

usage:  int = quadg('Fun',xlow,xhigh)
or
        int = quadg('Fun',xlow,xhigh,tol)
or
        int = quadg('Fun',xlow,xhigh,tol,trace,p1,p2,....)

This function works just like QUAD or QUAD8 but uses a Gaussian quadrature
integration scheme.  Use this routine instead of QUAD or QUAD8:
	if higher accuracy is desired (this works best if the function, 
		'Fun', can be approximated by a power series) 
	or if many similar integrations are going to be done (I think less
		function evaluations will typically be done, but the 
		integration points and the weights must be calculated.
		These are saved between integrations so when QUADG
		is called again, the points and weights are all ready
		known.)
	or if the function evaluations are time consuming.
Note that if there are discontinuities the integral should be broken up into separate 
pieces.  And if there are singularities,  a more appropriate integration quadrature
should be used (such as the Gauss-Chebyshev).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

usage:  int = quadg('Fun',xlow,xhigh)
or
        int = quadg('Fun',xlow,xhigh,t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
quadndg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 962

usage:  int = quadndg('Fun',xlow,xhigh)
or
        int = quadndg('Fun',xlow,xhigh,tol)

This function is similar to QUAD or QUAD8 for n-dimensional integration,
but it uses a Gaussian quadrature integration scheme.  
 	int     -- value of the integral
       Fun     -- Fun(x) (function to be integrated) in this case treat
                  all the different values of x as different variables
                  as opposed to different instances of the same variable
       x       -- n length vector of coordinates
       xlow    -- n length vector of lower limits of integration
       xhigh   -- n length vector of upper limits of integration
       tol     -- tolerance parameter (optional)
Note that if there are discontinuities the region of integration 
should be broken up into separate pieces.  And if there are singularities,
a more appropriate integration quadrature should be used 
(such as the Gauss-Chebyshev for a specific type of singularity).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

usage:  int = quadndg('Fun',xlow,xhigh)
or
        int = quadndg('Fun',xlow,xhi



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
zero_count


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31

usage:  num_fxpow=zero_count




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30

usage:  num_fxpow=zero_count






