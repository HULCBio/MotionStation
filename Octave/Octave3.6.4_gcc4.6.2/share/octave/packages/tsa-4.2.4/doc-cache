# Created by Octave 3.6.4, Sat Mar 30 12:42:55 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 55
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
aar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2198
 Calculates adaptive autoregressive (AAR) and adaptive autoregressive moving average estimates (AARMA)
 of real-valued data series using Kalman filter algorithm.
 [a,e,REV] = aar(y, mode, MOP, UC, a0, A, W, V); 

 The AAR process is described as following  
       y(k) - a(k,1)*y(t-1) -...- a(k,p)*y(t-p) = e(k);
 The AARMA process is described as following  
       y(k) - a(k,1)*y(t-1) -...- a(k,p)*y(t-p) = e(k) + b(k,1)*e(t-1) + ... + b(k,q)*e(t-q);

 Input:
       y       Signal (AR-Process)
       Mode    is a two-element vector [aMode, vMode], 
               aMode determines 1 (out of 12) methods for updating the co-variance matrix (see also [1])
               vMode determines 1 (out of 7) methods for estimating the innovation variance (see also [1])
               aMode=1, vmode=2 is the RLS algorithm as used in [2]
               aMode=-1, LMS algorithm (signal normalized)
               aMode=-2, LMS algorithm with adaptive normalization  
                                     
       MOP     model order, default [10,0] 
               MOP=[p]         AAR(p) model. p AR parameters
               MOP=[p,q]       AARMA(p,q) model, p AR parameters and q MA coefficients
       UC      Update Coefficient, default 0
       a0      Initial AAR parameters [a(0,1), a(0,2), ..., a(0,p),b(0,1),b(0,2), ..., b(0,q)]
                (row vector with p+q elements, default zeros(1,p) )
       A       Initial Covariance matrix (positive definite pxp-matrix, default eye(p))
	W	system noise (required for aMode==0)
	V	observation noise (required for vMode==0)
      
 Output:
       a       AAR(MA) estimates [a(k,1), a(k,2), ..., a(k,p),b(k,1),b(k,2), ..., b(k,q]
       e       error process (Adaptively filtered process)
       REV     relative error variance MSE/MSY


 Hint:
 The mean square (prediction) error of different variants is useful for determining the free parameters (Mode, MOP, UC) 

 REFERENCE(S): 
 [1] A. Schloegl (2000), The electroencephalogram and the adaptive autoregressive model: theory and applications. 
     ISBN 3-8265-7640-3 Shaker Verlag, Aachen, Germany. 

 More references can be found at 
     http://www.dpmi.tu-graz.ac.at/~schloegl/publications/



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 Calculates adaptive autoregressive (AAR) and adaptive autoregressive moving ave



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
aarmam


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1372
 Estimating Adaptive AutoRegressive-Moving-Average-and-mean model (includes mean term) 

 !! This function is obsolete and is replaced by AMARMA

 [z,E,REV,ESU,V,Z,SPUR] = aarmam(y, mode, MOP, UC, z0, Z0, V0, W); 
 Estimates AAR parameters with Kalman filter algorithm
 	y(t) = sum_i(a_i(t)*y(t-i)) + m(t) + e(t) + sum_i(b_i(t)*e(t-i))

 State space model
	z(t) = G*z(t-1) + w(t)    w(t)=N(0,W) 
	y(t) = H*z(t)   + v(t)	  v(t)=N(0,V)	

 G = I, 
 z = [m(t),a_1(t-1),..,a_p(t-p),b_1(t-1),...,b_q(t-q)];
 H = [1,y(t-1),..,y(t-p),e(t-1),...,e(t-q)];
 W = E{(z(t)-G*z(t-1))*(z(t)-G*z(t-1))'}
 V = E{(y(t)-H*z(t-1))*(y(t)-H*z(t-1))'}


 Input:
       y	Signal (AR-Process)
       Mode	determines the type of algorithm

       MOP     Model order [m,p,q], default [0,10,0]
			m=1 includes the mean term, m=0 does not. 
			p and q must be positive integers
			it is recommended to set q=0. 
	UC	Update Coefficient, default 0
	z0	Initial state vector
	Z0	Initial Covariance matrix
      
 Output:
	z	AR-Parameter
	E	error process (Adaptively filtered process)
       REV     relative error variance MSE/MSY

 REFERENCE(S): 
 [1] A. Schloegl (2000), The electroencephalogram and the adaptive autoregressive model: theory and applications. 
     ISBN 3-8265-7640-3 Shaker Verlag, Aachen, Germany. 

 More references can be found at 
     http://pub.ist.ac.at/~schloegl/publications/



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 Estimating Adaptive AutoRegressive-Moving-Average-and-mean model (includes mean



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ac2poly


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
 converts the autocorrelation sequence into an AR polynomial
 [A,Efinal] = ac2poly(r)

 see also ACOVF ACORF AR2RC RC2AR DURLEV AC2POLY, POLY2RC, RC2POLY, RC2AC, AC2RC, POLY2AC
 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 converts the autocorrelation sequence into an AR polynomial
 [A,Efinal] = ac2po



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ac2rc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 182
 converts the autocorrelation function into reflection coefficients 
 [RC,r0] = ac2rc(r)

 see also ACOVF ACORF AR2RC RC2AR DURLEV AC2POLY, POLY2RC, RC2POLY, RC2AC, AC2RC, POLY2AC
 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 converts the autocorrelation function into reflection coefficients 
 [RC,r0] = 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acorf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1078
  Calculates autocorrelations for multiple data series.
  Missing values in Z (NaN) are considered. 
  Also calculates Ljung-Box Q stats and p-values.

    [AutoCorr,stderr,lpq,qpval] = acorf(Z,N);
  If mean should be removed use
    [AutoCorr,stderr,lpq,qpval] = acorf(detrend(Z',0)',N);
  If trend should be removed use
    [AutoCorr,stderr,lpq,qpval] = acorf(detrend(Z')',N);

 INPUT
  Z	is data series for which autocorrelations are required
       each in a row
  N	maximum lag

 OUTPUT
  AutoCorr nr x N matrix of autocorrelations
  stderr   nr x N matrix of (approx) std errors
  lpq      nr x M matrix of Ljung-Box Q stats
  qpval    nr x N matrix of p-values on Q stats
   
 All input and output parameters are organized in rows, one row 
 corresponds to one series

 REFERENCES:
  S. Haykin "Adaptive Filter Theory" 3ed. Prentice Hall, 1996.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.
  J.S. Bendat and A.G.Persol "Random Data: Analysis and Measurement procedures", Wiley, 1986.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
  Calculates autocorrelations for multiple data series.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acovf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 826
 ACOVF estimates autocovariance function (not normalized)
 NaN's are interpreted as missing values. 

 [ACF,NN] = acovf(Z,MAXLAG,Mode);

 Input:
  Z    Signal (one channel per row);
  MAXLAG  maximum lag
  Mode	'biased'  : normalizes with N [default]
	'unbiased': normalizes with N-lag
	'coeff'	  : normalizes such that lag 0 is 1	
        others	  : no normalization

 Output:
  ACF autocovariance function
  NN  number of valid elements 

 REFERENCES:
  A.V. Oppenheim and R.W. Schafer, Digital Signal Processing, Prentice-Hall, 1975.
  S. Haykin "Adaptive Filter Theory" 3ed. Prentice Hall, 1996.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.
  J.S. Bendat and A.G.Persol "Random Data: Analysis and Measurement procedures", Wiley, 1986.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 ACOVF estimates autocovariance function (not normalized)
 NaN's are interpreted



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
adim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 659
 ADIM adaptive information matrix. Estimates the inverse
   correlation matrix in an adaptive way. 

 [IR, CC] = adim(U, UC [, IR0 [, CC0]]); 
   U 	input data  
   UC 	update coefficient 0 < UC << 1
   IR0	initial information matrix
   CC0 initial correlation matrix
   IR	information matrix (inverse correlation matrix)
   CC  correlation matrix
 	
  The algorithm uses the Matrix Inversion Lemma, also known as 
     "Woodbury's identity", to obtain a recursive algorithm.  
     IR*CC - UC*I should be approx. zero. 

 Reference(s):
 [1] S. Haykin. Adaptive Filter Theory, Prentice Hall, Upper Saddle River, NJ, USA 
     pp. 565-567, Equ. (13.16), 1996.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
 ADIM adaptive information matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
amarma


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1501
 Adaptive Mean-AutoRegressive-Moving-Average model estimation
 [z,E,ESU,REV,V,Z,SPUR] = amarma(y, mode, MOP, UC, z0, Z0, V0, W); 
 Estimates AAR parameters with Kalman filter algorithm
 	y(t) = sum_i(a(i,t)*y(t-i)) + mu(t) + E(t)

 State space model:
	z(t)=G*z(t-1) + w(t)      w(t)=N(0,W) 
	y(t)=H*z(t)   + v(t)	  v(t)=N(0,V)	

 G = I, 
 z = [µ(t)/(1-sum_i(a(i,t))),a_1(t-1),..,a_p(t-p),b_1(t-1),...,b_q(t-q)];
 H = [1,y(t-1),..,y(t-p),e(t-1),...,e(t-q)];
 W = E{(z(t)-G*z(t-1))*(z(t)-G*z(t-1))'}
 V = E{(y(t)-H*z(t-1))*(y(t)-H*z(t-1))'}

 Input:
       y	Signal (AR-Process)
       Mode
	    [0,0] uses V0 and W  

       MOP     Model order [m,p,q], default [0,10,0] 
			m=1 includes the mean term, m=0 does not. 
			p and q must be positive integers
			it is recommended to set q=0. 
	UC	Update Coefficient, default 0
	z0	Initial state vector
	Z0	Initial Covariance matrix
      
 Output:
	z	AR-Parameter
	E	error process (Adaptively filtered process)
       REV     relative error variance MSE/MSY


 see also: AAR

 REFERENCE(S): 
 [1] A. Schloegl (2000), The electroencephalogram and the adaptive autoregressive model: theory and applications. 
     ISBN 3-8265-7640-3 Shaker Verlag, Aachen, Germany. 
 [2] Schlögl A, Lee FY, Bischof H, Pfurtscheller G
     Characterization of Four-Class Motor Imagery EEG Data for the BCI-Competition 2005.
     Journal of neural engineering 2 (2005) 4, S. L14-L22

 More references can be found at 
     http://www.dpmi.tu-graz.ac.at/~schloegl/publications/



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 Adaptive Mean-AutoRegressive-Moving-Average model estimation
 [z,E,ESU,REV,V,Z,



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ar2poly


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 603
 converts autoregressive parameters into AR polymials 
 Multiple polynomials can be converted. 
 function  [A] = ar2poly(AR);

  INPUT:
 AR     AR parameters, each row represents one set of AR parameters

  OUTPUT
 A     denominator polynom


 see also ACOVF ACORF DURLEV RC2AR FILTER FREQZ ZPLANE
 
 REFERENCES:
  P.J. Brockwell and R. A. Davis "Time Series: Theory and Methods", 2nd ed. Springer, 1991.
  S. Haykin "Adaptive Filter Theory" 3rd ed. Prentice Hall, 1996.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 converts autoregressive parameters into AR polymials 
 Multiple polynomials can



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ar2rc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1007
 converts autoregressive parameters into reflection coefficients 
 with the Durbin-Levinson recursion for multiple channels
 function  [AR,RC,PE] = ar2rc(AR);
 function  [MX,PE] = ar2rc(AR);

  INPUT:
 AR    autoregressive model parameter	

  OUTPUT
 AR    autoregressive model parameter	
 RC    reflection coefficients (= -PARCOR coefficients)
 PE    remaining error variance (relative to PE(1)=1)
 MX    transformation matrix between ARP and RC (Attention: needs O(p^2) memory)
        AR = MX(:,K*(K-1)/2+(1:K));
        RC = MX(:,(1:K).*(2:K+1)/2);

 All input and output parameters are organized in rows, one row 
 corresponds to the parameters of one channel

 see also ACOVF ACORF DURLEV RC2AR 
 
 REFERENCES:
  P.J. Brockwell and R. A. Davis "Time Series: Theory and Methods", 2nd ed. Springer, 1991.
  S. Haykin "Adaptive Filter Theory" 3rd ed. Prentice Hall, 1996.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 converts autoregressive parameters into reflection coefficients 
 with the Durb



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ar_spa


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1259
 AR_SPA decomposes an AR-spectrum into its compontents 
 [w,A,B,R,P,F,ip] = ar_spa(AR,fs,E);

  INPUT:
 AR   autoregressive parameters
 fs    sampling rate, provide w and B in [Hz], if not given the result is in radians 
 E     noise level (mean square),  gives A and F in units of E, if not given as relative amplitude

  OUTPUT
 w	center frequency
 A     Amplitude
 B     bandwidth
       - less important output parameters - 
 R	residual
 P	poles
 ip	number of complex conjugate poles
 real(F)     	power, absolute values are obtained by multiplying with noise variance E(p+1) 
 imag(F)	assymetry, - " -

 All input and output parameters are organized in rows, one row 
 corresponds to the parameters of one channel

 see also ACOVF ACORF DURLEV IDURLEV PARCOR YUWA 
 
 REFERENCES:
 [1] Zetterberg L.H. (1969) Estimation of parameter for linear difference equation with application to EEG analysis. Math. Biosci., 5, 227-275. 
 [2] Isaksson A. and Wennberg, A. (1975) Visual evaluation and computer analysis of the EEG - A comparison. Electroenceph. clin. Neurophysiol., 38: 79-86.
 [3] G. Florian and G. Pfurtscheller (1994) Autoregressive model based spectral analysis with application to EEG. IIG - Report Series, University of Technolgy Graz, Austria.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 AR_SPA decomposes an AR-spectrum into its compontents 
 [w,A,B,R,P,F,ip] = ar_s



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
arcext


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 738
 ARCEXT extracts AR and RC of order P from Matrix MX
 function  [AR,RC] = arcext(MX,P);

  INPUT:
 MX 	AR and RC matrix calculated by durlev 
 P 	model order (default maximum possible)

  OUTPUT
 AR    autoregressive model parameter	
 RC    reflection coefficients (= -PARCOR coefficients)

 All input and output parameters are organized in rows, one row 
 corresponds to the parameters of one channel

 see also ACOVF ACORF DURLEV 
 
 REFERENCES:
  P.J. Brockwell and R. A. Davis "Time Series: Theory and Methods", 2nd ed. Springer, 1991.
  S. Haykin "Adaptive Filter Theory" 3rd ed. Prentice Hall, 1996.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 ARCEXT extracts AR and RC of order P from Matrix MX
 function  [AR,RC] = arcext



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
arfit2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1227
 ARFIT2 estimates multivariate autoregressive parameters
 of the MVAR process Y

   Y(t,:)' = w' + A1*Y(t-1,:)' + ... + Ap*Y(t-p,:)' + x(t,:)'

 ARFIT2 uses the Nutall-Strand method (multivariate Burg algorithm) 
 which provides better estimates the ARFIT [1], and uses the 
 same arguments. Moreover, ARFIT2 is faster and can deal with 
 missing values encoded as NaNs. 

 [w, A, C, sbc, fpe] = arfit2(v, pmin, pmax, selector, no_const)

 INPUT: 
  v		data - each channel in a column
  pmin, pmax 	minimum and maximum model order
  selector	'fpe' or 'sbc' [default] 
  no_const	'zero' indicates no bias/offset need to be estimated 
		in this case is w = [0, 0, ..., 0]'; 

 OUTPUT: 
  w		mean of innovation noise
  A		[A1,A2,...,Ap] MVAR estimates	
  C		covariance matrix of innovation noise
  sbc, fpe	criteria for model order selection 

 see also: ARFIT, MVAR

 REFERENCES:
  [1] A. Schloegl, 2006, Comparison of Multivariate Autoregressive Estimators.
       Signal processing, p. 2426-9.
  [2] T. Schneider and A. Neumaier, 2001. 
	Algorithm 808: ARFIT-a Matlab package for the estimation of parameters and eigenmodes 
	of multivariate autoregressive models. ACM-Transactions on Mathematical Software. 27, (Mar.), 58-65.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 ARFIT2 estimates multivariate autoregressive parameters
 of the MVAR process Y




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
biacovf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 228
 BiAutoCovariance function 
 [BiACF] = biacovf(Z,N);

 Input:	Z    Signal
		N  # of coefficients
 Output:	BIACF bi-autocorrelation function (joint cumulant 3rd order
 Output:	ACF   covariance function (joint cumulant 2nd order)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
 BiAutoCovariance function 
 [BiACF] = biacovf(Z,N);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bisdemo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
 BISDEMO (script) Shows BISPECTRUM of eeg8s.mat



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
 BISDEMO (script) Shows BISPECTRUM of eeg8s.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bispec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 382
 Calculates Bispectrum 
 [BISPEC] = bispec(Z,N);

 Input:	Z    Signal
		N  # of coefficients
 Output:	BiACF  bi-autocorrelation function = 3rd order cumulant
		BISPEC Bi-spectrum 

 Reference(s):
 C.L. Nikias and A.P. Petropulu "Higher-Order Spectra Analysis" Prentice Hall, 1993.
 M.B. Priestley, "Non-linear and Non-stationary Time series Analysis", Academic Press, London, 1988.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
 Calculates Bispectrum 
 [BISPEC] = bispec(Z,N);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
content


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1809
 Time Series Analysis (Ver 3.10)
 Schloegl A. (1996-2003,2008) Time Series Analysis - A Toolbox for the use with Matlab. 
 WWW: http://hci.tugraz.at/~schloegl/matlab/tsa/

	$Id: content.m 5090 2008-06-05 08:12:04Z schloegl $
	Copyright (C) 1996-2003,2008 by Alois Schloegl <a.schloegl@ieee.org>

  Time Series Analysis - a toolbox for the use with Matlab
   aar		adaptive autoregressive estimator 
   acovf       (*) Autocovariance function
   acorf (acf)	(*) autocorrelation function	
   pacf	(*) partial autocorrelation function, includes signifcance test and confidence interval
   parcor	(*) partial autocorrelation function
   biacovf	biautocovariance function (3rd order cumulant)
   bispec	Bi-spectrum 
   durlev      (*) solves Yule-Walker equation - converts ACOVF into AR parameters
   lattice     (*) calcultes AR parameters with lattice method
   lpc		(*) calculates the prediction coefficients form a given time series
   invest0	(*) a prior investigation (used by invest1)
   invest1	(*) investigates signal (useful for 1st evaluation of the data)
   selmo	(*) Select Order of Autoregressive model using different criteria
   histo	(*) histogram
   hup     	(*) test Hurwitz polynomials
   ucp     	(*) test Unit Circle Polynomials   
   y2res	(*) computes mean, variance, skewness, kurtosis, entropy, etc. from data series 
   ar_spa	(*) spectral analysis based on the autoregressive model
   detrend 	(*) removes trend, can handle missing values, non-equidistant sampled data       
   flix	floating index, interpolates data for non-interger indices
   quantiles   calculates quantiles 

 Multivariate analysis (planned in future)
   mvar	multivariate (vector) autoregressive estimation 
   mvfilter	multivariate filter
   arfit2	provides compatibility to ARFIT [Schneider and Neumaier, 2001]



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
 Time Series Analysis (Ver 3.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
contents


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5874
 Time Series Analysis - A toolbox for the use with Matlab and Octave. 

 $Id: contents.m 5090 2008-06-05 08:12:04Z schloegl $
 Copyright (C) 1996-2004,2008 by Alois Schloegl <a.schloegl@ieee.org>
 WWW: http://hci.tugraz.at/~schloegl/matlab/tsa/

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 

  Time Series Analysis - a toolbox for the use with Matlab
   aar		adaptive autoregressive estimator 
   acovf       (*) Autocovariance function
   acorf (acf)	(*) autocorrelation function	
   pacf	(*) partial autocorrelation function, includes signifcance test and confidence interval
   parcor	(*) partial autocorrelation function
   biacovf	biautocovariance function (3rd order cumulant)
   bispec	Bi-spectrum 
   durlev      (*) solves Yule-Walker equation - converts ACOVF into AR parameters
   lattice     (*) calcultes AR parameters with lattice method
   lpc		(*) calculates the prediction coefficients form a given time series
   invest0	(*) a prior investigation (used by invest1)
   invest1	(*) investigates signal (useful for 1st evaluation of the data)
   rmle        AR estimation using recursive maximum likelihood function 
   selmo	(*) Select Order of Autoregressive model using different criteria
   histo	(*) histogram
   hup     	(*) test Hurwitz polynomials
   ucp     	(*) test Unit Circle Polynomials   
   y2res	(*) computes mean, variance, skewness, kurtosis, entropy, etc. from data series 
   ar_spa	(*) spectral analysis based on the autoregressive model
   detrend 	(*) removes trend, can handle missing values, non-equidistant sampled data       
   flix	floating index, interpolates data for non-interger indices


 Multivariate analysis 
   adim	adaptive information matrix (inverse correlation matrix) 
   mvar	multivariate (vector) autoregressive estimation 
   mvaar       multivariate adaptvie autoregressive estimation using Kalman filtering
   mvfilter	multivariate filter
   mvfreqz	multivariate spectra 	
   arfit2	provides compatibility to ARFIT [Schneider and Neumaier, 2001]

   	
  Conversions between Autocorrelation (AC), Autoregressive parameters (AR), 
             	prediction polynom (POLY) and Reflection coefficient (RC)  
   ac2poly 	(*) transforms autocorrelation into prediction polynom
   ac2rc   	(*) transforms autocorrelation into reflexion coefficients
   ar2rc	(*) transforms autoregressive parameters into reflection coefficients  
   rc2ar	(*) transforms reflection coefficients into autoregressive parameters
   poly2ac 	(*) transforms polynom to autocorrelation
   poly2ar 	(*) transforms polynom to AR 
   poly2rc 	(*) 
   rc2ac 	(*) 
   rc2poly 	(*) 
   ar2poly 	(*) 
   
 Utility functions 
   sinvest1	shows the parameter calculated by INVEST1

 Test suites
   tsademo		demonstrates INVEST1 on EEG data
   invfdemo		demonstration of matched, inverse filtering
   bisdemo		demonstrates bispectral estimation

 (*) indicates univariate analysis of multiple data series (each in a row) can be processed.
 (-) indicates that these functions will be removed in future 

 REFERENCES (sources):
  http://www.itl.nist.gov/
  http://mathworld.wolfram.com/
  P.J. Brockwell and R.A. Davis "Time Series: Theory and Methods", 2nd ed. Springer, 1991.
  O.   Foellinger "Lineare Abtastsysteme", Oldenburg Verlag, Muenchen, 1986.
  F.   Gausch "Systemtechnik", Textbook, University of Technology Graz, 1993. 
  M.S. Grewal and A.P. Andrews "Kalman Filtering" Prentice Hall, 1993. 
  S.   Haykin "Adaptive Filter Theory" 3ed. Prentice Hall, 1996.
  E.I. Jury "Theory and Application of the z-Transform Method", Robert E. Krieger Publishing Co., 1973. 
  M.S. Kay "Modern Spectal Estimation" Prentice Hall, 1988. 
  Ch.  Langraf and G. Schneider "Elemente der Regeltechnik", Springer Verlag, 1970.
  S.L. Marple "Digital Spetral Analysis with Applications" Prentice Hall, 1987.
  C.L. Nikias and A.P. Petropulu "Higher-Order Spectra Analysis" Prentice Hall, 1993.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  T. Schneider and A. Neumaier "Algorithm 808: ARFIT - a matlab package for the estimation of parameters and eigenmodes of multivariate autoregressive models" 
               ACM Transactions on Mathematical software, 27(Mar), 58-65.
  C.E. Shannon and W. Weaver "The mathematical theory of communication" University of Illinois Press, Urbana 1949 (reprint 1963).
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.
 
 
 REFERENCES (applications):
 [1] A. Schlögl, B. Kemp, T. Penzel, D. Kunz, S.-L. Himanen,A. Värri, G. Dorffner, G. Pfurtscheller.
     Quality Control of polysomnographic Sleep Data by Histogram and Entropy Analysis. 
     Clin. Neurophysiol. 1999, Dec; 110(12): 2165 - 2170.
 [2] Penzel T, Kemp B, Klösch G, Schlögl A, Hasan J, Varri A, Korhonen I.
     Acquisition of biomedical signals databases
     IEEE Engineering in Medicine and Biology Magazine 2001, 20(3): 25-32
 [3] Alois Schlögl (2000)
     The electroencephalogram and the adaptive autoregressive model: theory and applications
     Shaker Verlag, Aachen, Germany,(ISBN3-8265-7640-3). 

 Features:
 - Multiple Signal Processing
 - Efficient algorithms 
 - Model order selection tools
 - higher (3rd) order analysis
 - Maximum entropy spectral estimation
 - can deal with missing values (NaN's)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
 Time Series Analysis - A toolbox for the use with Matlab and Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
covm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1182
 COVM generates covariance matrix
 X and Y can contain missing values encoded with NaN.
 NaN's are skipped, NaN do not result in a NaN output. 
 The output gives NaN only if there are insufficient input data

 COVM(X,Mode);
      calculates the (auto-)correlation matrix of X
 COVM(X,Y,Mode);
      calculates the crosscorrelation between X and Y
 COVM(...,W);
	weighted crosscorrelation 

 Mode = 'M' minimum or standard mode [default]
 	C = X'*X; or X'*Y correlation matrix

 Mode = 'E' extended mode
 	C = [1 X]'*[1 X]; % l is a matching column of 1's
 	C is additive, i.e. it can be applied to subsequent blocks and summed up afterwards
 	the mean (or sum) is stored on the 1st row and column of C

 Mode = 'D' or 'D0' detrended mode
	the mean of X (and Y) is removed. If combined with extended mode (Mode='DE'), 
 	the mean (or sum) is stored in the 1st row and column of C. 
 	The default scaling is factor (N-1). 
 Mode = 'D1' is the same as 'D' but uses N for scaling. 

 C = covm(...); 
 	C is the scaled by N in Mode M and by (N-1) in mode D.
 [C,N] = covm(...);
	C is not scaled, provides the scaling factor N  
	C./N gives the scaled version. 

 see also: DECOVM, XCOVF



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 COVM generates covariance matrix
 X and Y can contain missing values encoded wi



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
detrend


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 837
 DETREND removes the trend from data, NaN's are considered as missing values
 
 DETREND is fully compatible to previous Matlab and Octave DETREND with the following features added:
 - handles NaN's by assuming that these are missing values
 - handles unequally spaced data
 - second output parameter gives the trend of the data
 - compatible to Matlab and Octave 

 [...]=detrend([t,] X [,p])
	removes trend for unequally spaced data
	t represents the time points
	X(i) is the value at time t(i)
	p must be a scalar

 [...]=detrend(X,0)
 [...]=detrend(X,'constant')
	removes the mean

 [...]=detrend(X,p)
	removes polynomial of order p (default p=1)

 [...]=detrend(X,1) - default
 [...]=detrend(X,'linear')
	removes linear trend 

 [X,T]=detrend(...) 

 X is the detrended data
 T is the removed trend
 
 see also: SUMSKIPNAN, ZSCORE		



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 DETREND removes the trend from data, NaN's are considered as missing values
 
 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
durlev


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1241
 function  [AR,RC,PE] = durlev(ACF);
 function  [MX,PE] = durlev(ACF);
 estimates AR(p) model parameter by solving the
 Yule-Walker with the Durbin-Levinson recursion
 for multiple channels
  INPUT:
 ACF	Autocorrelation function from lag=[0:p]

  OUTPUT
 AR    autoregressive model parameter	
 RC    reflection coefficients (= -PARCOR coefficients)
 PE    remaining error variance
 MX    transformation matrix between ARP and RC (Attention: needs O(p^2) memory)
        AR(:,K) = MX(:,K*(K-1)/2+(1:K));
        RC(:,K) = MX(:,(1:K).*(2:K+1)/2);

 All input and output parameters are organized in rows, one row 
 corresponds to the parameters of one channel

 see also ACOVF ACORF AR2RC RC2AR LATTICE
 
 REFERENCES:
  Levinson N. (1947) "The Wiener RMS(root-mean-square) error criterion in filter design and prediction." J. Math. Phys., 25, pp.261-278.
  Durbin J. (1960) "The fitting of time series models." Rev. Int. Stat. Inst. vol 28., pp 233-244.
  P.J. Brockwell and R. A. Davis "Time Series: Theory and Methods", 2nd ed. Springer, 1991.
  S. Haykin "Adaptive Filter Theory" 3rd ed. Prentice Hall, 1996.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 function  [AR,RC,PE] = durlev(ACF);
 function  [MX,PE] = durlev(ACF);
 estimate



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
flag_implicit_samplerate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
 The use of FLAG_IMPLICIT_SAMPLERATE is in experimental state. 
 FLAG_IMPLICIT_SAMPLERATE might even become obsolete.
 Do not use it. 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
 The use of FLAG_IMPLICIT_SAMPLERATE is in experimental state.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
flag_implicit_skip_nan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 934
 FLAG_IMPLICIT_SKIP_NAN sets and gets default mode for handling NaNs
	1 skips NaN's (the default mode if no mode is set)
 	0 NaNs are propagated; input NaN's give NaN's at the output
 
 FLAG = flag_implicit_skip_nan()
 	gets current mode

 flag_implicit_skip_nan(FLAG)
 sets mode 

 prevFLAG = flag_implicit_skip_nan(nextFLAG)
	gets previous set FLAG and sets FLAG for the future
 flag_implicit_skip_nan(prevFLAG)
	resets FLAG to previous mode

 It is used in: 
	SUMSKIPNAN, MEDIAN, QUANTILES, TRIMEAN
 and affects many other functions like: 
	CENTER, KURTOSIS, MAD, MEAN, MOMENT, RMS, SEM, SKEWNESS, 
	STATISTIC, STD, VAR, ZSCORE etc. 

 The mode is stored in the global variable FLAG_implicit_skip_nan
 It is recommended to use flag_implicit_skip_nan(1) as default and
 flag_implicit_skip_nan(0) should be used for exceptional cases only.
 This feature might disappear without further notice, so you should really not
 rely on it. 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 FLAG_IMPLICIT_SKIP_NAN sets and gets default mode for handling NaNs
	1 skips Na



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
flix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 603
 floating point index - interpolates data in case of non-integer indices

 Y=flix(D,x)
   FLIX returns Y=D(x) if x is an integer 
   otherwise D(x) is interpolated from the neighbors D(ceil(x)) and D(floor(x)) 
 
 Applications: 
 (1)  discrete Dataseries can be upsampled to higher sampling rate   
 (2)  transformation of non-equidistant samples to equidistant samples
 (3)  [Q]=flix(sort(D),q*(length(D)+1)) calculates the q-quantile of data series D   

 FLIX(D,x) is the same as INTERP1(D,X,'linear'); Therefore, FLIX might
 become obsolete in future. 

 see also: HIST2RES, Y2RES, PLOTCDF, INTERP1



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
 floating point index - interpolates data in case of non-integer indices




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
histo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 581
 HISTO calculates histogram for each column
 [H,X] = HISTO(Y,Mode)
 	   
   Mode 
	'rows' : frequency of each row
	'1x'   : single bin-values 
	'nx'   : separate bin-values for each column
   X  are the bin-values 
   H  is the frequency of occurence of value X 

 HISTO(Y) with no output arguments:
	plots the histogram bar(X,H)

 more histogram-based results can be obtained by HIST2RES2  

 see also:  HISTO, HISTO2, HISTO3, HISTO4

 REFERENCE(S):
  C.E. Shannon and W. Weaver "The mathematical theory of communication" University of Illinois Press, Urbana 1949 (reprint 1963).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 HISTO calculates histogram for each column
 [H,X] = HISTO(Y,Mode)
 	   
   Mode



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
histo2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1009
 HISTO2 calculates histogram for multiple columns with separate bin values 
    for each data column.

 R = HISTO2(Y)
 R = HISTO2(Y, W)
	Y	data
	W	weight vector containing weights of each sample, 
		number of rows of Y and W must match.
		default W=[] indicates that each sample is weighted with 1. 

 R = HISTO(...)            
 	R is 	a struct with th fields 
       R.X  	the bin-values, bin-values are computed separately for each 
		data column, thus R.X is a matrix, each column contains the 
		the bin values of for each data column, unused elements are indicated with NaN.
		In order to have common bin values, use HISTO3.  
       R.H  is the frequency of occurence of value X 
  	R.N  are the number of valid (not NaN) samples (i.e. sum of weights)

 more histogram-based results can be obtained by HIST2RES2  

 see also: HISTO, HISTO2, HISTO3, HISTO4

 REFERENCE(S):
  C.E. Shannon and W. Weaver "The mathematical theory of communication" University of Illinois Press, Urbana 1949 (reprint 1963).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 HISTO2 calculates histogram for multiple columns with separate bin values 
    



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
histo3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1266
 HISTO3 calculates histogram for multiple columns with common bin values 
    among all data columns, and can be useful for data compression. 

 R = HISTO3(Y)
 R = HISTO3(Y, W)
	Y	data
	W	weight vector containing weights of each sample, 
		number of rows of Y and W must match.
		default W=[] indicates that each sample is weighted with 1. 
 	R 	struct with these fields 
       R.X  	the bin-values, bin-values are equal for each channel
		thus R.X is a column vector. If bin values should 
		be computed separately for each data column, use HISTO2
       R.H  	is the frequency of occurence of value X 
  	R.N  	are the number of valid (not NaN) samples 

 Data compression can be performed in this way
   	[R,tix] = histo3(Y) 
      		is the compression step

	R.tix provides a compressed data representation. 
	R.compressionratio estimates the compression ratio

 	R.X(tix) and R.X(R.tix) 
		reconstruct the orginal signal (decompression) 

 The effort (in memory and speed) for compression is O(n*log(n)).
 The effort (in memory and speed) for decompression is O(n) only. 

 see also: HISTO, HISTO2, HISTO3, HISTO4

 REFERENCE(S):
  C.E. Shannon and W. Weaver "The mathematical theory of communication" University of Illinois Press, Urbana 1949 (reprint 1963).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 HISTO3 calculates histogram for multiple columns with common bin values 
    am



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
histo4


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 965
 HISTO4 calculates histogram of multidimensional data samples 
   and supports data compression

 R = HISTO4(Y)
 R = HISTO4(Y, W)
	Y    data: on sample per row, each sample has with size(Y,2) elements 
	W    weights of each sample (default: [])
	     W = [] indicates that each sample has equal weight	
 	R is a struct with these fields: 
       R.X  are the bin-values 
       R.H  is the frequency of occurence of value X (weighted with W)
  	R.N  are the total number of samples (or sum of W)

 HISTO4 might be useful for data compression, because
 [R,tix] = histo4(Y) 
     	is the compression step
 R.X(tix,:) 
  	is the decompression step

 The effort (in memory and speed) for compression is O(n*log(n))
 The effort (in memory and speed) for decompression is only O(n)
 
 see also: HISTO, HISTO2, HISTO3, HISTO4

 REFERENCE(S):
  C.E. Shannon and W. Weaver 'The mathematical theory of communication' University of Illinois Press, Urbana 1949 (reprint 1963).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 HISTO4 calculates histogram of multidimensional data samples 
   and supports d



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
hup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 588
HUP(C)	tests if the polynomial C is a Hurwitz-Polynomial.
	It tests if all roots lie in the left half of the complex
	plane 
       B=hup(C) is the same as 
       B=all(real(roots(c))<0) but much faster.
	The Algorithm is based on the Routh-Scheme.
	C are the elements of the Polynomial
	C(1)*X^N + ... + C(N)*X + C(N+1).

       HUP2 works also for multiple polynomials, 
       each row a poly - Yet not tested

 REFERENCES:
  F. Gausch "Systemtechnik", Textbook, University of Technology Graz, 1993. 
  Ch. Langraf and G. Schneider "Elemente der Regeltechnik", Springer Verlag, 1970.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
HUP(C)	tests if the polynomial C is a Hurwitz-Polynomial.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
invest0


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 842
 First Investigation of a signal (time series) - automated part
 [AutoCov,AutoCorr,ARPMX,E,ACFsd,NC]=invest0(Y,Pmax);

 [AutoCov,AutoCorr,ARPMX,E,ACFsd,NC]=invest0(AutoCov,Pmax,Mode);
 

 Y	time series
 Pmax	maximal order (optional)

 AutoCov	Autocorrelation 
 AutoCorr	normalized Autocorrelation
 PartACF	Partial Autocorrelation
 ARPMX     Autoregressive Parameter for order Pmax-1
 E	        Error function E(p)
 NC            Number of values (length-missing values)

 REFERENCES:
  P.J. Brockwell and R.A. Davis "Time Series: Theory and Methods", 2nd ed. Springer, 1991.
  M.S. Grewal and A.P. Andrews "Kalman Filtering" Prentice Hall, 1993. 
  S. Haykin "Adaptive Filter Theory" 3ed. Prentice Hall, 1996.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 First Investigation of a signal (time series) - automated part
 [AutoCov,AutoCo



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
invest1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1306
 First Investigation of a signal (time series) - interactive
 [AutoCov,AutoCorr,ARPMX,E,CRITERIA,MOPS]=invest1(Y,Pmax,show);

 Y	time series
 Pmax	maximal order (optional)
 show  optional; if given the parameters are shown

 AutoCov	Autocorrelation 
 AutoCorr	normalized Autocorrelation
 PartACF	Partial Autocorrelation
 E	Error function E(p)
 CRITERIA curves of the various (see below) criteria, 
 MOPS=[optFPE optAIC optBIC optSBC optMDL optCAT optPHI];
      optimal model order according to various criteria

 FPE	Final Prediction Error (Kay, 1987)
 AIC	Akaike Information Criterion (Marple, 1987)
 BIC	Bayesian Akaike Information Criterion (Wei, 1994)
 SBC	Schwartz's Bayesian Criterion (Wei, 1994)
 MDL	Minimal Description length Criterion (Marple, 1987)
 CAT	Parzen's CAT Criterion (Wei, 1994)
 PHI	Phi criterion (Pukkila et al. 1988)
 minE		order where E is minimal

 REFERENCES:
  P.J. Brockwell and R.A. Davis "Time Series: Theory and Methods", 2nd ed. Springer, 1991.
  S.   Haykin "Adaptive Filter Theory" 3ed. Prentice Hall, 1996.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  C.E. Shannon and W. Weaver "The mathematical theory of communication" University of Illinois Press, Urbana 1949 (reprint 1963).
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 First Investigation of a signal (time series) - interactive
 [AutoCov,AutoCorr,



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
invfdemo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
 invfdemo	demonstrates Inverse Filtering



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
 invfdemo	demonstrates Inverse Filtering




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
lattice


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1531
 Estimates AR(p) model parameter with lattice algorithm (Burg 1968) 
 for multiple channels. 
 If you have the NaN-tools, LATTICE.M can handle missing values (NaN), 

 [...] = lattice(y [,Pmax [,Mode]]);

 [AR,RC,PE] = lattice(...);
 [MX,PE] = lattice(...);

  INPUT:
 y	signal (one per row), can contain missing values (encoded as NaN)
 Pmax	max. model order (default size(y,2)-1))
 Mode  'BURG' (default) Burg algorithm
	'GEOL' geometric lattice

  OUTPUT
 AR    autoregressive model parameter	
 RC    reflection coefficients (= -PARCOR coefficients)
 PE    remaining error variance
 MX    transformation matrix between ARP and RC (Attention: needs O(p^2) memory)
        AR(:,K) = MX(:, K*(K-1)/2+(1:K)); = MX(:,sum(1:K-1)+(1:K)); 
        RC(:,K) = MX(:,cumsum(1:K));      = MX(:,(1:K).*(2:K+1)/2);

 All input and output parameters are organized in rows, one row 
 corresponds to the parameters of one channel

 see also ACOVF ACORF AR2RC RC2AR DURLEV SUMSKIPNAN 
 
 REFERENCE(S):
  J.P. Burg, "Maximum Entropy Spectral Analysis" Proc. 37th Meeting of the Society of Exp. Geophysiscists, Oklahoma City, OK 1967
  J.P. Burg, "Maximum Entropy Spectral Analysis" PhD-thesis, Dept. of Geophysics, Stanford University, Stanford, CA. 1975.
  P.J. Brockwell and R. A. Davis "Time Series: Theory and Methods", 2nd ed. Springer, 1991.
  S.   Haykin "Adaptive Filter Theory" 3rd ed. Prentice Hall, 1996.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 Estimates AR(p) model parameter with lattice algorithm (Burg 1968) 
 for multip



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
lpc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 759
 LPC Linear prediction coefficients 
 The Burg-method is used to estimate the prediction coefficients

 A = lpc(Y [,P]) finds the coefficients  A=[ 1 A(2) ... A(N+1) ],
     	of an Pth order forward linear predictor
     
 	 Xp(n) = -A(2)*X(n-1) - A(3)*X(n-2) - ... - A(N+1)*X(n-P)
	    
 	such that the sum of the squares of the errors
		
       err(n) = X(n) - Xp(n)
	       
	is minimized.  X can be a vector or a matrix.  If X is a matrix
       containing a separate signal in each column, LPC returns a model
	estimate for each column in the rows of A. N specifies the order
	of the polynomial A(z).
				       
	If you do not specify a value for P, LPC uses a default P = length(X)-1.


 see also ACOVF ACORF AR2POLY RC2AR DURLEV SUMSKIPNAN LATTICE 
 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 LPC Linear prediction coefficients 
 The Burg-method is used to estimate the pr



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
mvaar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 784
 Multivariate (Vector) adaptive AR estimation base on a multidimensional
 Kalman filer algorithm. A standard VAR model (A0=I) is implemented. The 
 state vector is defined as X=(A1|A2...|Ap) and x=vec(X')

 [x,e,Kalman,Q2] = mvaar(y,p,UC,mode,Kalman)

 The standard MVAR model is defined as:

		y(n)-A1(n)*y(n-1)-...-Ap(n)*y(n-p)=e(n)

	The dimension of y(n) equals s 
	
	Input Parameters:

 		y			Observed data or signal 
 		p			prescribed maximum model order (default 1)
		UC			update coefficient	(default 0.001)
		mode	 	update method of the process noise covariance matrix 0...4 ^
					correspond to S0...S4 (default 0)

	Output Parameters

		e			prediction error of dimension s
		x			state vector of dimension s*s*p
		Q2			measurement noise covariance matrix of dimension s x s




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 Multivariate (Vector) adaptive AR estimation base on a multidimensional
 Kalman



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
mvar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3018
 MVAR estimates parameters of the Multi-Variate AutoRegressive model 

    Y(t) = Y(t-1) * A1 + ... + Y(t-p) * Ap + X(t);  
 whereas
    Y(t) is a row vecter with M elements Y(t) = y(t,1:M) 

 Several estimation algorithms are implemented, all estimators 
 can handle data with missing values encoded as NaNs.  

 	[AR,RC,PE] = mvar(Y, p);
 	[AR,RC,PE] = mvar(Y, p, Mode);
 
 with 
       AR = [A1, ..., Ap];

 INPUT:
  Y	 Multivariate data series 
  p     Model order
  Mode	 determines estimation algorithm 

 OUTPUT:
  AR    multivariate autoregressive model parameter
  RC    reflection coefficients (= -PARCOR coefficients)
  PE    remaining error variances for increasing model order
	   PE(:,p*M+[1:M]) is the residual variance for model order p

 All input and output parameters are organized in columns, one column 
 corresponds to the parameters of one channel.

 Mode determines estimation algorithm. 
  1:  Correlation Function Estimation method using biased correlation function estimation method
   		also called the 'multichannel Yule-Walker' [1,2] 
  6:  Correlation Function Estimation method using unbiased correlation function estimation method

  2:  Partial Correlation Estimation: Vieira-Morf [2] using unbiased covariance estimates.
               In [1] this mode was used and (incorrectly) denominated as Nutall-Strand. 
		Its the DEFAULT mode; according to [1] it provides the most accurate estimates.
  5:  Partial Correlation Estimation: Vieira-Morf [2] using biased covariance estimates.
		Yields similar results than Mode=2;

  3:  buggy: Partial Correlation Estimation: Nutall-Strand [2] (biased correlation function)
  9:  Partial Correlation Estimation: Nutall-Strand [2] (biased correlation function)
  7:  Partial Correlation Estimation: Nutall-Strand [2] (unbiased correlation function)
  8:  Least Squares w/o nans in Y(t):Y(t-p)
 10:  ARFIT [3] 
 11:  BURGV [4] 
 13:  modified BURGV -  
 14:  modified BURGV [4] 
 15:  Least Squares based on correlation matrix
 22: Modified Partial Correlation Estimation: Vieira-Morf [2,5] using unbiased covariance estimates.
 25: Modified Partial Correlation Estimation: Vieira-Morf [2,5] using biased covariance estimates.

 90,91,96: Experimental versions 

    Imputation methods:
  100+Mode: 
  200+Mode: forward, past missing values are assumed zero
  300+Mode: backward, past missing values are assumed zero
  400+Mode: forward+backward, past missing values are assumed zero
 1200+Mode: forward, past missing values are replaced with predicted value
 1300+Mode: backward, 'past' missing values are replaced with predicted value
 1400+Mode: forward+backward, 'past' missing values are replaced with predicted value
 2200+Mode: forward, past missing values are replaced with predicted value + noise to prevent decaying
 2300+Mode: backward, past missing values are replaced with predicted value + noise to prevent decaying
 2400+Mode: forward+backward, past missing values are replaced with predicted value + noise to prevent decaying






# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
 MVAR estimates parameters of the Multi-Variate AutoRegressive model 




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
mvfilter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1028
 Multi-variate filter function

 Y = MVFILTER(B,A,X)
 [Y,Z] = MVFILTER(B,A,X,Z)

  Y = MVFILTER(B,A,X) filters the data in matrix X with the
    filter described by cell arrays A and B to create the filtered
    data Y.  The filter is a 'Direct Form II Transposed'
    implementation of the standard difference equation:
 
    a0*Y(n) = b0*X(:,n) + b1*X(:,n-1) + ... + bq*X(:,n-q)
                        - a1*Y(:,n-1) - ... - ap*Y(:,n-p)

  A=[a0,a1,a2,...,ap] and B=[b0,b1,b2,...,bq] must be matrices of
  size  Mx((p+1)*M) and Mx((q+1)*M), respectively. 
  a0,a1,...,ap, b0,b1,...,bq are matrices of size MxM
  a0 is usually the identity matrix I or must be invertible 
  X should be of size MxN, if X has size NxM a warning 
  is raised, and the output Y is also transposed. 

 A simulated MV-AR process can be generiated with 
	Y = mvfilter(eye(M), [eye(M),-AR],randn(M,N));

 A multivariate inverse filter can be realized with 
       [AR,RC,PE] = mvar(Y,P);
	E = mvfilter([eye(M),-AR],eye(M),Y);

 see also: MVAR, FILTER



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
 Multi-variate filter function




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
mvfreqz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3844
 MVFREQZ multivariate frequency response
 [S,h,PDC,COH,DTF,DC,pCOH,dDTF,ffDTF,pCOH2,PDCF,coh,GGC,Af,GPDC] = mvfreqz(B,A,C,f,Fs)
 [...]  = mvfreqz(B,A,C,N,Fs)
  
 INPUT: 
 ======= 
 A, B	multivariate polynomials defining the transfer function

    a0*Y(n) = b0*X(n) + b1*X(n-1) + ... + bq*X(n-q)
                          - a1*Y(n-1) - ... - ap*Y(:,n-p)

  A=[a0,a1,a2,...,ap] and B=[b0,b1,b2,...,bq] must be matrices of
  size  Mx((p+1)*M) and Mx((q+1)*M), respectively. 

  C is the covariance of the input noise X (i.e. D'*D if D is the mixing matrix)
  N if scalar, N is the number of frequencies 
    if N is a vector, N are the designated frequencies. 
  Fs sampling rate [default 2*pi]
 
  A,B,C and D can by obtained from a multivariate time series 
       through the following commands: 
  [AR,RC,PE] = mvar(Y,P);
       M = size(AR,1); % number of channels       
       A = [eye(M),-AR];
       B = eye(M); 
       C = PE(:,M*P+1:M*(P+1)); 

 Fs 	sampling rate in [Hz]
 (N 	number of frequencies for computing the spectrum, this will become OBSOLETE),  
 f	vector of frequencies (in [Hz])  


 OUTPUT: 
 ======= 
 S   	power spectrum
 h	transfer functions, abs(h.^2) is the non-normalized DTF [11]
 PDC 	partial directed coherence [2]
 DC  	directed coupling	
 COH 	coherency (complex coherence) [5]
 DTF 	directed transfer function
 pCOH 	partial coherence
 dDTF 	direct Directed Transfer function
 ffDTF full frequency Directed Transfer Function 
 pCOH2 partial coherence - alternative method 
 GGC	a modified version of Geweke's Granger Causality [Geweke 1982]
	   !!! it uses a Multivariate AR model, and computes the bivariate GGC as in [Bressler et al 2007]. 
	   This is not the same as using bivariate AR models and GGC as in [Bressler et al 2007]
 Af	Frequency transform of A(z), abs(Af.^2) is the non-normalized PDC [11]
 PDCF 	Partial Directed Coherence Factor [2]
 GPDC 	Generalized Partial Directed Coherence [9,10]

 see also: FREQZ, MVFILTER, MVAR
 
 REFERENCE(S):
 [1] H. Liang et al. Neurocomputing, 32-33, pp.891-896, 2000. 
 [2] L.A. Baccala and K. Samashima, Biol. Cybern. 84,463-474, 2001. 
 [3] A. Korzeniewska, et al. Journal of Neuroscience Methods, 125, 195-207, 2003. 
 [4] Piotr J. Franaszczuk, Ph.D. and Gregory K. Bergey, M.D.
 	Fast Algorithm for Computation of Partial Coherences From Vector Autoregressive Model Coefficients
	World Congress 2000, Chicago. 
 [5] Nolte G, Bai O, Wheaton L, Mari Z, Vorbach S, Hallett M.
	Identifying true brain interaction from EEG data using the imaginary part of coherency.
	Clin Neurophysiol. 2004 Oct;115(10):2292-307. 
 [6] Schlogl A., Supp G.
       Analyzing event-related EEG data with multivariate autoregressive parameters.
       (Eds.) C. Neuper and W. Klimesch, 
       Progress in Brain Research: Event-related Dynamics of Brain Oscillations. 
       Analysis of dynamics of brain oscillations: methodological advances. Elsevier. 
       Progress in Brain Research 159, 2006, p. 135 - 147
 [7] Bressler S.L., Richter C.G., Chen Y., Ding M. (2007)
	Cortical fuctional network organization from autoregressive modelling of loal field potential oscillations.
	Statistics in Medicine, doi: 10.1002/sim.2935 
 [8] Geweke J., 1982	
	J.Am.Stat.Assoc., 77, 304-313.
 [9] L.A. Baccala, D.Y. Takahashi, K. Sameshima. (2006) 
 	Generalized Partial Directed Coherence. 
	Submitted to XVI Congresso Brasileiro de Automatica, Salvador, Bahia.  
 [10] L.A. Baccala, D.Y. Takahashi, K. Sameshima. 
 	Computer Intensive Testing for the Influence Between Time Series, 
	Eds. B. Schelter, M. Winterhalder, J. Timmer: 
	Handbook of Time Series Analysis - Recent Theoretical Developments and Applications
	Wiley, p.413, 2006.
 [11] M. Eichler
	On the evaluation of informatino flow in multivariate systems by the directed transfer function
	Biol. Cybern. 94: 469-482, 2006. 	



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 MVFREQZ multivariate frequency response
 [S,h,PDC,COH,DTF,DC,pCOH,dDTF,ffDTF,pC



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pacf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
 Partial Autocorrelation function
 [parcor,sig,cil,ciu] = pacf(Z,N);

 Input:
	Z    Signal, each row is analysed
	N    # of coefficients



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
 Partial Autocorrelation function
 [parcor,sig,cil,ciu] = pacf(Z,N);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
parcor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1160
 estimates partial autocorrelation coefficients 
 Multiple channels can be used (one per row).

 [PARCOR, AR, PE] = parcor(AutoCov); % calculates Partial autocorrelation, autoregressive coefficients and residual error variance from the Autocorrelation function. 

 [PARCOR] = parcor(acovf(x,p)); % calculates the Partial Autocorrelation coefficients of the data series x up to order p

  INPUT:
 AutoCov	Autocorrelation function for lag=0:P

  OUTPUT
 AR	autoregressive model parameter	
 PARCOR partial correlation coefficients (= -reflection coefficients)
 PE    remaining error variance

 All input and output parameters are organized in rows, one row 
 corresponds to the parameters of one channel. 
 The PARCOR coefficients are the negative reflection coefficients. 
 A significance test is implemented in PACF.

 see also: PACF ACOVF ACORF DURLEV AC2RC 
 
 REFERENCES:
  P.J. Brockwell and R.A. Davis "Time Series: Theory and Methods", 2nd ed. Springer, 1991.
  S. Haykin "Adaptive Filter Theory" 3ed. Prentice Hall, 1996.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 estimates partial autocorrelation coefficients 
 Multiple channels can be used 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
poly2ac


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 converts an AR polynomial into an autocorrelation sequence
 [R] = poly2ac(a [,efinal] );

 see also ACOVF ACORF AR2RC RC2AR DURLEV AC2POLY, POLY2RC, RC2POLY, RC2AC, AC2RC, POLY2AC
 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 converts an AR polynomial into an autocorrelation sequence
 [R] = poly2ac(a [,e



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
poly2ar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 288
 Converts AR polymials into autoregressive parameters. 
 Multiple polynomials can be converted. 

 function  [AR] = poly2ar(A);

  INPUT:
 A     AR polynomial, each row represents one polynomial

  OUTPUT
 AR    autoregressive model parameter	

 see also ACOVF ACORF DURLEV RC2AR AR2POLY



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
 Converts AR polymials into autoregressive parameters.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
poly2rc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 434
 converts AR-polynomial into reflection coefficients
 [RC,R0] = poly2rc(A [,Efinal])

  INPUT:
 A     AR polynomial, each row represents one polynomial
 Efinal    is the final prediction error variance (default value 1)

  OUTPUT
 RC    reflection coefficients
 R0    is the variance (autocovariance at lag=0) based on the 
	prediction error


 see also ACOVF ACORF AR2RC RC2AR DURLEV AC2POLY, POLY2RC, RC2POLY, RC2AC, AC2RC, POLY2AC



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 converts AR-polynomial into reflection coefficients
 [RC,R0] = poly2rc(A [,Efin



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rc2ac


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
 converts reflection coefficients to autocorrelation sequence
 [R] = rc2ac(RC,R0);

 see also ACOVF ACORF AR2RC RC2AR DURLEV AC2POLY, POLY2RC, RC2POLY, RC2AC, AC2RC, POLY2AC
 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 converts reflection coefficients to autocorrelation sequence
 [R] = rc2ac(RC,R0



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rc2ar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1000
 converts reflection coefficients into autoregressive parameters
 uses the Durbin-Levinson recursion for multiple channels
 function  [AR,RC,PE,ACF] = rc2ar(RC);
 function  [MX,PE] = rc2ar(RC);

  INPUT:
 RC    reflection coefficients

  OUTPUT
 AR    autoregressive model parameter	
 RC    reflection coefficients (= -PARCOR coefficients)
 PE    remaining error variance (relative to PE(1)=1)
 MX    transformation matrix between ARP and RC (Attention: needs O(p^2) memory)
        arp=MX(:,K*(K-1)/2+(1:K));
        rc =MX(:,(1:K).*(2:K+1)/2);

 All input and output parameters are organized in rows, one row 
 corresponds to the parameters of one channel

 see also ACOVF ACORF DURLEV AR2RC 
 
 REFERENCES:
  P.J. Brockwell and R. A. Davis "Time Series: Theory and Methods", 2nd ed. Springer, 1991.
  S. Haykin "Adaptive Filter Theory" 3rd ed. Prentice Hall, 1996.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 converts reflection coefficients into autoregressive parameters
 uses the Durbi



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rc2poly


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 174
 converts reflection coefficients into an AR-polynomial
 [a,efinal] = rc2poly(K)

 see also ACOVF ACORF AR2RC RC2AR DURLEV AC2POLY, POLY2RC, RC2POLY, RC2AC, AC2RC, POLY2AC
 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 converts reflection coefficients into an AR-polynomial
 [a,efinal] = rc2poly(K)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rmle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 432
 RMLE estimates AR Parameters using the Recursive Maximum Likelihood 
 Estimator according to [1]
 
 Use: [a,VAR]=rmle(x,p)
 Input: 
 x is a column vector of data
 p is the model order
 Output:
 a is a vector with the AR parameters of the recursive MLE
 VAR is the excitation white noise variance estimate

 Reference(s):
 [1] Kay S.M., Modern Spectral Analysis - Theory and Applications. 
       Prentice Hall, p. 232-233, 1988. 




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 RMLE estimates AR Parameters using the Recursive Maximum Likelihood 
 Estimator



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
sbispec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
 SBISPEC show BISPECTRUM 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
 SBISPEC show BISPECTRUM 




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
selmo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2179
 Model order selection of an autoregrssive model
 [FPE,AIC,BIC,SBC,MDL,CAT,PHI,optFPE,optAIC,optBIC,optSBC,optMDL,optCAT,optPHI]=selmo(E,N);

 E	Error function E(p)
 N	length of the data set, that was used for calculating E(p)
 show  optional; if given the parameters are shown

 FPE	Final Prediction Error (Kay 1987, Wei 1990, Priestley 1981  -> Akaike 1969)
 AIC	Akaike Information Criterion (Marple 1987, Wei 1990, Priestley 1981 -> Akaike 1974)
 BIC	Bayesian Akaike Information Criterion (Wei 1990, Priestley 1981 -> Akaike 1978,1979)
 CAT	Parzen's CAT Criterion (Wei 1994 -> Parzen 1974)
 MDL	Minimal Description length Criterion (Marple 1987 -> Rissanen 1978,83)
 SBC	Schwartz's Bayesian Criterion (Wei 1994; Schwartz 1978)
 PHI	Phi criterion (Pukkila et al. 1988, Hannan 1980 -> Hannan & Quinn, 1979)
 HAR	Haring G. (1975)
 JEW	Jenkins and Watts (1968)

 optFPE 	order where FPE is minimal
 optAIC 	order where AIC is minimal
 optBIC 	order where BIC is minimal
 optSBC 	order where SBC is minimal
 optMDL 	order where MDL is minimal
 optCAT 	order where CAT is minimal
 optPHI 	order where PHI is minimal

 usually is 
 AIC > FPE > *MDL* > PHI > SBC > CAT ~ BIC

 REFERENCES:
  P.J. Brockwell and R.A. Davis "Time Series: Theory and Methods", 2nd ed. Springer, 1991.
  S. Haykin "Adaptive Filter Theory" 3ed. Prentice Hall, 1996.
  M.B. Priestley "Spectral Analysis and Time Series" Academic Press, 1981. 
  C.E. Shannon and W. Weaver "The mathematical theory of communication" University of Illinois Press, Urbana 1949 (reprint 1963).
  W.S. Wei "Time Series Analysis" Addison Wesley, 1990.
  Jenkins G.M. Watts D.G "Spectral Analysis and its applications", Holden-Day, 1968.
  G. Haring  "Über die Wahl der optimalen Modellordnung bei der Darstellung von stationären Zeitreihen mittels Autoregressivmodell als Basis der Analyse von EEG - Biosignalen mit Hilfe eines Digitalrechners", Habilitationschrift - Technische Universität Graz, Austria, 1975.
                  (1)"About selecting the optimal model at the representation of stationary time series by means of an autoregressive model as basis of the analysis of EEG - biosignals by means of a digital computer)"




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 Model order selection of an autoregrssive model
 [FPE,AIC,BIC,SBC,MDL,CAT,PHI,o



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
selmo2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 271
 SELMO2 - model order selection for univariate and multivariate 
   autoregressive models 
 
  X = selmo(y,Pmax); 
  
  y 	data series
  Pmax maximum model order 
  X.A, X.B, X.C parameters of AR model 
  X.OPT... various optimization criteria
 
 see also: SELMO, MVAR, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 SELMO2 - model order selection for univariate and multivariate 
   autoregressi



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
sinvest1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
SINVEST1 shows the parameters of a time series calculated by INVEST1
 only called by INVEST1



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
SINVEST1 shows the parameters of a time series calculated by INVEST1
 only calle



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
sumskipnan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1234
 SUMSKIPNAN adds all non-NaN values. 

 All NaN's are skipped; NaN's are considered as missing values. 
 SUMSKIPNAN of NaN's only  gives O; and the number of valid elements is return. 
 SUMSKIPNAN is also the elementary function for calculating 
 various statistics (e.g. MEAN, STD, VAR, RMS, MEANSQ, SKEWNESS, 
 KURTOSIS, MOMENT, STATISTIC etc.) from data with missing values.  
 SUMSKIPNAN implements the DIMENSION-argument for data with missing values.
 Also the second output argument return the number of valid elements (not NaNs) 
 
 Y = sumskipnan(x [,DIM])
 [Y,N,SSQ] = sumskipnan(x [,DIM])
 [...] = sumskipnan(x, DIM, W)
 
 x	input data 	
 DIM	dimension (default: [])
	empty DIM sets DIM to first non singleton dimension	
 W	weight vector for weighted sum, numel(W) must fit size(x,DIM)
 Y	resulting sum
 N	number of valid (not missing) elements
 SSQ	sum of squares

 the function FLAG_NANS_OCCURED() returns whether any value in x
  is a not-a-number (NaN)

 features:
 - can deal with NaN's (missing values)
 - implements dimension argument. 
 - computes weighted sum 
 - compatible with Matlab and Octave

 see also: FLAG_NANS_OCCURED, SUM, NANSUM, MEAN, STD, VAR, RMS, MEANSQ, 
      SSQ, MOMENT, SKEWNESS, KURTOSIS, SEM



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
 SUMSKIPNAN adds all non-NaN values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tsademo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
 TSADEMO	demonstrates INVEST1 on EEG data



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
 TSADEMO	demonstrates INVEST1 on EEG data




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
ucp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 476
 UCP(C) tests if the polynomial C is a Unit-Circle-Polynomial.
	It tests if all roots lie inside the unit circle like
       B=ucp(C) does the same as
	B=all(abs(roots(C))<1) but much faster.
	The Algorithm is based on the Jury-Scheme.
	C are the elements of the Polynomial
	C(1)*X^N + ... + C(N)*X + C(N+1).
 
 REFERENCES:
  O. Foellinger "Lineare Abtastsysteme", Oldenburg Verlag, Muenchen, 1986.
  F. Gausch "Systemtechnik", Textbook, University of Technology Graz, 1993. 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
 UCP(C) tests if the polynomial C is a Unit-Circle-Polynomial.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
y2res


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 534
 Y2RES evaluates basic statistics of a data series
 
 R = y2res(y)
	several statistics are estimated from each column of y
 
 OUTPUT:
   R.N     number of samples, NaNs are not counted 
   R.SUM   sum of samples
   R.MEAN  mean
   R.STD   standard deviation 
   R.VAR   variance
   R.Max   Maximum
   R.Min   Minimum 
   ...   and many more including:  
	MEDIAN, Quartiles, Variance, standard error of the mean (SEM), 
	Coefficient of Variation, Quantization (QUANT), TRIMEAN, SKEWNESS, 
	KURTOSIS, Root-Mean-Square (RMS), ENTROPY 
 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 Y2RES evaluates basic statistics of a data series
 
 R = y2res(y)
	several stat





