# Created by Octave 3.6.4, Sat Mar 30 09:32:21 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 88
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
anderson_darling_cdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2184
 -- Function File: P = anderson_darling_cdf (A, N)
     Return the CDF for the given Anderson-Darling coefficient A
     computed from N values sampled from a distribution. For a vector
     of random variables X of length N, compute the CDF of the values
     from the distribution from which they are drawn.  You can uses
     these values to compute A as follows:

          A = -N - sum( (2*i-1) .* (log(X) + log(1 - X(N:-1:1,:))) )/N;

     From the value A, `anderson_darling_cdf' returns the probability
     that A could be returned from a set of samples.

     The algorithm given in [1] claims to be an approximation for the
     Anderson-Darling CDF accurate to 6 decimal points.

     Demonstrate using:

          n = 300; reps = 10000;
          z = randn(n, reps);
          x = sort ((1 + erf (z/sqrt (2)))/2);
          i = [1:n]' * ones (1, size (x, 2));
          A = -n - sum ((2*i-1) .* (log (x) + log (1 - x (n:-1:1, :))))/n;
          p = anderson_darling_cdf (A, n);
          hist (100 * p, [1:100] - 0.5);

     You will see that the histogram is basically flat, which is to say
     that the probabilities returned by the Anderson-Darling CDF are
     distributed uniformly.

     You can easily determine the extreme values of P:

          [junk, idx] = sort (p);

     The histograms of various P aren't  very informative:

          histfit (z (:, idx (1)), linspace (-3, 3, 15));
          histfit (z (:, idx (end/2)), linspace (-3, 3, 15));
          histfit (z (:, idx (end)), linspace (-3, 3, 15));

     More telling is the qqplot:

          qqplot (z (:, idx (1))); hold on; plot ([-3, 3], [-3, 3], ';;'); hold off;
          qqplot (z (:, idx (end/2))); hold on; plot ([-3, 3], [-3, 3], ';;'); hold off;
          qqplot (z (:, idx (end))); hold on; plot ([-3, 3], [-3, 3], ';;'); hold off;

     Try a similarly analysis for Z uniform:

          z = rand (n, reps); x = sort(z);

     and for Z exponential:

          z = rande (n, reps); x = sort (1 - exp (-z));

     [1] Marsaglia, G; Marsaglia JCW; (2004) "Evaluating the Anderson
     Darling distribution", Journal of Statistical Software, 9(2).

     See also: anderson_darling_test





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the CDF for the given Anderson-Darling coefficient A computed
from N valu



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
anderson_darling_test


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1834
 -- Function File: [Q, ASQ, INFO] =  = anderson_darling_test (X,
          DISTRIBUTION)
     Test the hypothesis that X is selected from the given distribution
     using the Anderson-Darling test.  If the returned Q is small,
     reject the hypothesis at the Q*100% level.

     The Anderson-Darling A^2 statistic is calculated as follows:

                        n
          A^2_n = -n - SUM (2i-1)/n log(z_i (1 - z_{n-i+1}))
                       i=1

     where z_i is the ordered position of the X's in the CDF of the
     distribution.  Unlike the Kolmogorov-Smirnov statistic, the
     Anderson-Darling statistic is sensitive to the tails of the
     distribution.

     The DISTRIBUTION argument must be a either "uniform", "normal", or
     "exponential".

     For "normal"' and "exponential" distributions, estimate the
     distribution parameters from the data, convert the values to CDF
     values, and compare the result to tabluated critical values.  This
     includes an correction for small N which works well enough for N
     >= 8, but less so from smaller N.  The returned
     `info.Asq_corrected' contains the adjusted statistic.

     For "uniform", assume the values are uniformly distributed in
     (0,1), compute A^2 and return the corresponding p-value from
     `1-anderson_darling_cdf(A^2,n)'.

     If you are selecting from a known distribution, convert your
     values into CDF values for the distribution and use "uniform".  Do
     not use "uniform" if the distribution parameters are estimated
     from the data itself, as this sharply biases the A^2 statistic
     toward smaller values.

     [1] Stephens, MA; (1986), "Tests based on EDF statistics", in
     D'Agostino, RB; Stephens, MA; (eds.) Goodness-of-fit Techinques.
     New York: Dekker.

     See also: anderson_darling_cdf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Test the hypothesis that X is selected from the given distribution
using the And



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
anovan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1504
 -- Function File: [PVAL, F, DF_B, DF_E] = anovan (DATA, GRPS)
 -- Function File: [PVAL, F, DF_B, DF_E] = anovan (DATA, GRPS,
          'param1', VALUE1)
     Perform a multi-way analysis of variance (ANOVA).  The goal is to
     test whether the population means of data taken from K different
     groups are all equal.

     Data is a single vector DATA with groups specified by a
     corresponding matrix of group labels GRPS, where GRPS has the same
     number of rows as DATA. For example, if DATA = [1.1;1.2]; GRPS=
     [1,2,1; 1,5,2]; then data point 1.1 was measured under conditions
     1,2,1 and data point 1.2 was measured under conditions 1,5,2.
     Note that groups do not need to be sequentially numbered.

     By default, a 'linear' model is used, computing the N main effects
     with no interactions. this may be modified by param 'model'

     p= anovan(data,groups, 'model', modeltype) - modeltype = 'linear':
     compute N main effects - modeltype = 'interaction': compute N
     effects and                               N*(N-1) two-factor
     interactions - modeltype = 'full': compute interactions at all
     levels

     Under the null of constant means, the statistic F follows an F
     distribution with DF_B and DF_E degrees of freedom.

     The p-value (1 minus the CDF of this distribution at F) is
     returned in PVAL.

     If no output argument is given, the standard one-way ANOVA table is
     printed.

     BUG: DFE is incorrect for modeltypes != full




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Perform a multi-way analysis of variance (ANOVA).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
betastat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 993
 -- Function File: [M, V] = betastat (A, B)
     Compute mean and variance of the beta distribution.

Arguments
---------

        * A is the first parameter of the beta distribution. A must be
          positive

        * B is the second parameter of the beta distribution. B must be
          positive
     A and B must be of common size or one of them must be scalar

Return values
-------------

        * M is the mean of the beta distribution

        * V is the variance of the beta distribution

Examples
--------

          a = 1:6;
          b = 1:0.2:2;
          [m, v] = betastat (a, b)

          [m, v] = betastat (a, 1.5)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Compute mean and variance of the beta distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
binostat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1057
 -- Function File: [M, V] = binostat (N, P)
     Compute mean and variance of the binomial distribution.

Arguments
---------

        * N is the first parameter of the binomial distribution. The
          elements of N must be natural numbers

        * P is the second parameter of the binomial distribution. The
          elements of P must be probabilities
     N and P must be of common size or one of them must be scalar

Return values
-------------

        * M is the mean of the binomial distribution

        * V is the variance of the binomial distribution

Examples
--------

          n = 1:6;
          p = 0:0.2:1;
          [m, v] = binostat (n, p)

          [m, v] = binostat (n, 0.5)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Compute mean and variance of the binomial distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
boxplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2363
 -- Function File: S = boxplot (DATA, NOTCHED, SYMBOL, VERTICAL,
          MAXWHISKER, ...)
 -- Function File: [... H]= boxplot (...)
     Produce a box plot.

     The box plot is a graphical display that simultaneously describes
     several important features of a data set, such as center, spread,
     departure from symmetry, and identification of observations that
     lie unusually far from the bulk of the data.

     DATA is a matrix with one column for each data set, or data is a
     cell vector with one cell for each data set.

     NOTCHED = 1 produces a notched-box plot. Notches represent a robust
     estimate of the uncertainty about the median.

     NOTCHED = 0 (default) produces a rectangular box plot.

     NOTCHED in (0,1) produces a notch of the specified depth.  notched
     values outside (0,1) are amusing if not exactly practical.

     SYMBOL sets the symbol for the outlier values, default symbol for
     points that lie outside 3 times the interquartile range is 'o',
     default symbol for points between 1.5 and 3 times the interquartile
     range is '+'.

     SYMBOL = '.' points between 1.5 and 3 times the IQR is marked with
     '.' and points outside 3 times IQR with 'o'.

     SYMBOL = ['x','*'] points between 1.5 and 3 times the IQR is
     marked with 'x' and points outside 3 times IQR with '*'.

     VERTICAL = 0 makes the boxes horizontal, by default VERTICAL = 1.

     MAXWHISKER defines the length of the whiskers as a function of the
     IQR (default = 1.5). If MAXWHISKER = 0 then `boxplot' displays all
     data values outside the box using the plotting symbol for points
     that lie outside 3 times the IQR.

     Supplemental arguments are concatenated and passed to plot.

     The returned matrix S has one column for each data set as follows:

     1       Minimum
     2       1st quartile
     3       2nd quartile (median)
     4       3rd quartile
     5       Maximum
     6       Lower confidence limit for median
     7       Upper confidence limit for median

     The returned structure H has hanldes to the plot elements, allowing
     customization of the visualization using set/get functions.

     Example

          title ("Grade 3 heights");
          axis ([0,3]);
          tics ("x", 1:2, {"girls"; "boys"});
          boxplot ({randn(10,1)*5+140, randn(13,1)*8+135});





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Produce a box plot.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
caseread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 264
 -- Function File: NAMES = caseread (FILENAME)
     Read case names from an ascii file.

     Essentially, this reads all lines from a file as text and returns
     them in a string matrix.

     See also: casewrite, tblread, tblwrite, csv2cell, cell2csv, fopen





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Read case names from an ascii file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
casewrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 257
 -- Function File:  casewrite (STRMAT, FILENAME)
     Write case names to an ascii file.

     Essentially, this writes all lines from STRMAT to FILENAME (after
     deblanking them).

     See also: caseread, tblread, tblwrite, csv2cell, cell2csv, fopen





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Write case names to an ascii file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
chi2stat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 800
 -- Function File: [M, V] = chi2stat (N)
     Compute mean and variance of the chi-square distribution.

Arguments
---------

        * N is the parameter of the chi-square distribution. The
          elements of N must be positive

Return values
-------------

        * M is the mean of the chi-square distribution

        * V is the variance of the chi-square distribution

Example
-------

          n = 1:6;
          [m, v] = chi2stat (n)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Compute mean and variance of the chi-square distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
cl_multinom


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2978
 -- Function File: CL = cl_multinom (X, N, B, CALCULATION_TYPE ) -
          Confidence level of multinomial portions
     Returns confidence level of multinomial parameters estimated  p =
     x / sum(x)  with predefined confidence interval B.     Finite
     population is also considered.

     This function calculates the level of confidence at which the
     samples represent the true distribution given that there is a
     predefined tolerance (confidence interval).  This is the upside
     down case of the typical excercises at which we want to get the
     confidence interval given the confidence level (and the estimated
     parameters of the underlying distribution).  But once we accept
     (lets say at elections) that we have a standard predefined maximal
     acceptable error rate (e.g. B=0.02 ) in the estimation and we just
     want to know that how sure we can be that the measured proportions
     are the same as in the entire population (ie. the expected value
     and mean of the samples are roghly the same) we need to use this
     function.

Arguments
---------

        * X  : int vector  : sample frequencies bins

        * N  : int         : Population size that was sampled by x. If
          N<sum(x), infinite number assumed

        * B  : real, vector :  confidence interval            if
          vector, it should be the size of x containing confence
          interval for each cells            if scalar, each cell will
          have the same value of b unless it is zero or -1
          if value is 0, b=.02 is assumed which is standard choice at
          elections            otherwise it is calculated in a way that
          one sample in a cell alteration defines the confidence
          interval

        * CALCULATION_TYPE  : string    : (Optional), described below
                 "bromaghin"     (default) - do not change it unless
          you have a good reason to do so           "cochran"
          "agresti_cull"  this is not exactly the solution at reference
          given below but an adjustment of the solutions above

Returns
-------

     Confidence level.

Example
-------

     CL = cl_multinom( [27;43;19;11], 10000, 0.05 )     returns 0.69
confidence level.

References
----------

     "bromaghin" calculation type (default) is based on is based on the
article   Jeffrey F. Bromaghin, "Sample Size Determination for Interval
Estimation of Multinomial Probabilities", The American Statistician
vol 47, 1993, pp 203-206.

     "cochran" calculation type is based on article   Robert T.
Tortora, "A Note on Sample Size Estimation for Multinomial
Populations", The American Statistician, , Vol 32. 1978,  pp 100-102.

     "agresti_cull" calculation type is based on article in which
Quesenberry Hurst and Goodman result is combined   A. Agresti and B.A.
Coull, "Approximate is better than \"exact\" for interval estimation of
binomial portions", The American Statistician, Vol. 52, 1998, pp 119-126





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Returns confidence level of multinomial parameters estimated  p = x /
sum(x)  wi



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
combnk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
 -- Function File: C = combnk (DATA, K)
     Return all combinations of K elements in DATA.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Return all combinations of K elements in DATA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
copulacdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2148
 -- Function File: P = copulacdf (FAMILY, X, THETA)
 -- Function File:  copulacdf ('t', X, THETA, NU)
     Compute the cumulative distribution function of a copula family.

Arguments
---------

        * FAMILY is the copula family name. Currently, FAMILY can be
          `'Gaussian'' for the Gaussian family, `'t'' for the Student's
          t family, `'Clayton'' for the Clayton family, `'Gumbel'' for
          the Gumbel-Hougaard family, `'Frank'' for the Frank family,
          `'AMH'' for the Ali-Mikhail-Haq family, or `'FGM'' for the
          Farlie-Gumbel-Morgenstern family.

        * X is the support where each row corresponds to an observation.

        * THETA is the parameter of the copula. For the Gaussian and
          Student's t copula, THETA must be a correlation matrix. For
          bivariate copulas THETA can also be a correlation coefficient.
          For the Clayton family, the Gumbel-Hougaard family, the Frank
          family, and the Ali-Mikhail-Haq family, THETA must be a
          vector with the same number of elements as observations in X
          or be scalar. For the Farlie-Gumbel-Morgenstern family, THETA
          must be a matrix of coefficients for the
          Farlie-Gumbel-Morgenstern polynomial where each row
          corresponds to one set of coefficients for an observation in
          X. A single row is expanded. The coefficients are in binary
          order.

        * NU is the degrees of freedom for the Student's t family.  NU
          must be a vector with the same number of elements as
          observations in X or be scalar.

Return values
-------------

        * P is the cumulative distribution of the copula at each row of
          X and corresponding parameter THETA.

Examples
--------

          x = [0.2:0.2:0.6; 0.2:0.2:0.6];
          theta = [1; 2];
          p = copulacdf ("Clayton", x, theta)

          x = [0.2:0.2:0.6; 0.2:0.1:0.4];
          theta = [0.2, 0.1, 0.1, 0.05];
          p = copulacdf ("FGM", x, theta)

References
----------

       1. Roger B. Nelsen. `An Introduction to Copulas'. Springer, New
          York, second edition, 2006.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Compute the cumulative distribution function of a copula family.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
copulapdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1451
 -- Function File: P = copulapdf (FAMILY, X, THETA)
     Compute the probability density function of a copula family.

Arguments
---------

        * FAMILY is the copula family name. Currently, FAMILY can be
          `'Clayton'' for the Clayton family, `'Gumbel'' for the
          Gumbel-Hougaard family, `'Frank'' for the Frank family, or
          `'AMH'' for the Ali-Mikhail-Haq family.

        * X is the support where each row corresponds to an observation.

        * THETA is the parameter of the copula. The elements of THETA
          must be greater than or equal to `-1' for the Clayton family,
          greater than or equal to `1' for the Gumbel-Hougaard family,
          arbitrary for the Frank family, and greater than or equal to
          `-1' and lower than `1' for the Ali-Mikhail-Haq family.
          Moreover, THETA must be non-negative for dimensions greater
          than `2'. THETA must be a column vector with the same number
          of rows as X or be scalar.

Return values
-------------

        * P is the probability density of the copula at each row of X
          and corresponding parameter THETA.

Examples
--------

          x = [0.2:0.2:0.6; 0.2:0.2:0.6];
          theta = [1; 2];
          p = copulapdf ("Clayton", x, theta)

          p = copulapdf ("Gumbel", x, 2)

References
----------

       1. Roger B. Nelsen. `An Introduction to Copulas'. Springer, New
          York, second edition, 2006.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the probability density function of a copula family.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
copularnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1852
 -- Function File: X = copularnd (FAMILY, THETA, N)
 -- Function File:  copularnd (FAMILY, THETA, N, D)
 -- Function File:  copularnd ('t', THETA, NU, N)
     Generate random samples from a copula family.

Arguments
---------

        * FAMILY is the copula family name. Currently, FAMILY can be
          `'Gaussian'' for the Gaussian family, `'t'' for the Student's
          t family, or `'Clayton'' for the Clayton family.

        * THETA is the parameter of the copula. For the Gaussian and
          Student's t copula, THETA must be a correlation matrix. For
          bivariate copulas THETA can also be a correlation
          coefficient. For the Clayton family, THETA must be a vector
          with the same number of elements as samples to be generated
          or be scalar.

        * NU is the degrees of freedom for the Student's t family. NU
          must be a vector with the same number of elements as samples
          to be generated or be scalar.

        * N is the number of rows of the matrix to be generated. N must
          be a non-negative integer and corresponds to the number of
          samples to be generated.

        * D is the number of columns of the matrix to be generated. D
          must be a positive integer and corresponds to the dimension
          of the copula.

Return values
-------------

        * X is a matrix of random samples from the copula with N samples
          of distribution dimension D.

Examples
--------

          theta = 0.5;
          x = copularnd ("Gaussian", theta);

          theta = 0.5;
          nu = 2;
          x = copularnd ("t", theta, nu);

          theta = 0.5;
          n = 2;
          x = copularnd ("Clayton", theta, n);

References
----------

       1. Roger B. Nelsen. `An Introduction to Copulas'. Springer, New
          York, second edition, 2006.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Generate random samples from a copula family.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
dendogram


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 240
 -- Function File: P =  dendogram (TREE)
     Plots a dendogram using the output of function `linkage'.

     TODO: Return handle to lines to set properties TODO: Rescale the
     plot automatically base don data.

     See also: linkage





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Plots a dendogram using the output of function `linkage'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
expstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 802
 -- Function File: [M, V] = expstat (L)
     Compute mean and variance of the exponential distribution.

Arguments
---------

        * L is the parameter of the exponential distribution. The
          elements of L must be positive

Return values
-------------

        * M is the mean of the exponential distribution

        * V is the variance of the exponential distribution

Example
-------

          l = 1:6;
          [m, v] = expstat (l)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Compute mean and variance of the exponential distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ff2n


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 -- Function File: ff2n (N)
     Full-factor design with n binary terms.

     See also: fullfact





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Full-factor design with n binary terms.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1120
 -- Function File: [MN, V] = fstat (M, N)
     Compute mean and variance of the F distribution.

Arguments
---------

        * M is the first parameter of the F distribution. The elements
          of M must be positive

        * N is the second parameter of the F distribution. The elements
          of N must be positive
     M and N must be of common size or one of them must be scalar

Return values
-------------

        * MN is the mean of the F distribution. The mean is undefined
          for N not greater than 2

        * V is the variance of the F distribution. The variance is
          undefined for N not greater than 4

Examples
--------

          m = 1:6;
          n = 5:10;
          [mn, v] = fstat (m, n)

          [mn, v] = fstat (m, 5)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute mean and variance of the F distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fullfact


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 264
 -- Function File: fullfact (N)
     Full factorial design.

     If N is a scalar, return the full factorial design with N binary
     choices, 0 and 1.

     If N is a vector, return the full factorial design with choices 1
     through N_I for each factor I.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Full factorial design.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gamfit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 297
 -- Function File: MLE = gamfit (DATA)
     Calculate gamma distribution parameters.

     Find the maximum likelihood estimators (MLEs) of the Gamma
     distribution of DATA.  MLE is a two element vector with shape
     parameter A and scale B.

     See also: gampdf, gaminv, gamrnd, gamlike





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Calculate gamma distribution parameters.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gamlike


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 226
 -- Function File: X = gamlike ([A B], R)
     Calculates the negative log-likelihood function for the Gamma
     distribution over vector R, with the given parameters A and B.

     See also: gampdf, gaminv, gamrnd, gamfit





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Calculates the negative log-likelihood function for the Gamma
distribution over 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gamstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 995
 -- Function File: [M, V] = gamstat (A, B)
     Compute mean and variance of the gamma distribution.

Arguments
---------

        * A is the first parameter of the gamma distribution. A must be
          positive

        * B is the second parameter of the gamma distribution. B must be
          positive
     A and B must be of common size or one of them must be scalar

Return values
-------------

        * M is the mean of the gamma distribution

        * V is the variance of the gamma distribution

Examples
--------

          a = 1:6;
          b = 1:0.2:2;
          [m, v] = gamstat (a, b)

          [m, v] = gamstat (a, 1.5)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute mean and variance of the gamma distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
geomean


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 177
 -- Function File: geomean (X)
 -- Function File: geomean (X, DIM)
     Compute the geometric mean.

     This function does the same as `mean (x, "g")'.

     See also: mean





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Compute the geometric mean.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
geostat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 811
 -- Function File: [M, V] = geostat (P)
     Compute mean and variance of the geometric distribution.

Arguments
---------

        * P is the rate parameter of the geometric distribution. The
          elements of P must be probabilities

Return values
-------------

        * M is the mean of the geometric distribution

        * V is the variance of the geometric distribution

Example
-------

          p = 1 ./ (1:6);
          [m, v] = geostat (p)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Compute mean and variance of the geometric distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gevcdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1221
 -- Function File: P = gevcdf (X, K, SIGMA, MU)
     Compute the cumulative distribution function of the generalized
     extreme value (GEV) distribution.

Arguments
---------

        * X is the support.

        * K is the shape parameter of the GEV distribution. (Also
          denoted gamma or xi.)

        * SIGMA is the scale parameter of the GEV distribution. The
          elements of SIGMA must be positive.

        * MU is the location parameter of the GEV distribution.
     The inputs must be of common size, or some of them must be scalar.

Return values
-------------

        * P is the cumulative distribution of the GEV distribution at
          each element of X and corresponding parameter values.

Examples
--------

          x = 0:0.5:2.5;
          sigma = 1:6;
          k = 1;
          mu = 0;
          y = gevcdf (x, k, sigma, mu)

          y = gevcdf (x, k, 0.5, mu)

References
----------

       1. Rolf-Dieter Reiss and Michael Thomas. `Statistical Analysis
          of Extreme Values with Applications to Insurance, Finance,
          Hydrology and Other Fields'. Chapter 1, pages 16-17,
          Springer, 2007.


     See also: gevfit, gevinv, gevlike, gevpdf, gevrnd, gevstat





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the cumulative distribution function of the generalized extreme
value (G



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gevfit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1132
 -- Function File: PARAMHAT, PARAMCI = gevfit (DATA, PARMGUESS)
     Find the maximum likelihood estimator (PARAMHAT) of the
     generalized extreme value (GEV) distribution to fit DATA.

Arguments
---------

        * DATA is the vector of given values.

        * PARMGUESS is an initial guess for the maximum likelihood
          parameter vector. If not given, this defaults to [0; 1; 0].

Return values
-------------

        * PARMHAT is the 3-parameter maximum-likelihood parameter
          vector [K; SIGMA; MU], where K is the shape parameter of the
          GEV distribution, SIGMA is the scale parameter of the GEV
          distribution, and MU is the location parameter of the GEV
          distribution.

        * PARAMCI has the approximate 95% confidence intervals of the
          parameter values based on the Fisher information matrix at
          the maximum-likelihood position.


Examples
--------

          data = 1:50;
          [pfit, pci] = gevfit (data);
          p1 = gevcdf(data,pfit(1),pfit(2),pfit(3));
          plot(data, p1)

     See also: gevcdf, gevinv, gevlike, gevpdf, gevrnd, gevstat





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Find the maximum likelihood estimator (PARAMHAT) of the generalized
extreme valu



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
gevfit_lmom


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1157
 -- Function File: PARAMHAT, PARAMCI = gevfit_lmom (DATA)
     Find an estimator (PARAMHAT) of the generalized extreme value
     (GEV) distribution fitting DATA using the method of L-moments.

Arguments
---------

        * DATA is the vector of given values.

Return values
-------------

        * PARMHAT is the 3-parameter maximum-likelihood parameter
          vector [K; SIGMA; MU], where K is the shape parameter of the
          GEV distribution, SIGMA is the scale parameter of the GEV
          distribution, and MU is the location parameter of the GEV
          distribution.

        * PARAMCI has the approximate 95% confidence intervals of the
          parameter values (currently not implemented).


Examples
--------

          data = gevrnd (0.1, 1, 0, 100, 1);
          [pfit, pci] = gevfit_lmom (data);
          p1 = gevcdf (data,pfit(1),pfit(2),pfit(3));
          [f, x] = ecdf (data);
          plot(data, p1, 's', x, f)

     See also: gevfit

References
----------

       1. Ailliot, P.; Thompson, C. & Thomson, P. Mixed methods for
          fitting the GEV distribution, Water Resources Research, 2011,
          47, W05551





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Find an estimator (PARAMHAT) of the generalized extreme value (GEV)
distribution



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gevinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1183
 -- Function File: X = gevinv (P, K, SIGMA, MU)
     Compute a desired quantile (inverse CDF) of the generalized
     extreme value (GEV) distribution.

Arguments
---------

        * P is the desired quantile of the GEV distribution. (Between 0
          and 1.)

        * K is the shape parameter of the GEV distribution. (Also
          denoted gamma or xi.)

        * SIGMA is the scale parameter of the GEV distribution. The
          elements of SIGMA must be positive.

        * MU is the location parameter of the GEV distribution.
     The inputs must be of common size, or some of them must be scalar.

Return values
-------------

        * X is the value corresponding to each quantile of the GEV
          distribution

References
----------

       1. Rolf-Dieter Reiss and Michael Thomas. `Statistical Analysis
          of Extreme Values with Applications to Insurance, Finance,
          Hydrology and Other Fields'. Chapter 1, pages 16-17,
          Springer, 2007.

       2. J. R. M. Hosking (2012). `L-moments'. R package, version 1.6.
          URL: http://CRAN.R-project.org/package=lmom.


     See also: gevcdf, gevfit, gevlike, gevpdf, gevrnd, gevstat





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute a desired quantile (inverse CDF) of the generalized extreme
value (GEV) 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gevlike


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1385
 -- Function File: NLOGL, GRAD, ACOV = gevlike (PARAMS, DATA)
     Compute the negative log-likelihood of data under the generalized
     extreme value (GEV) distribution with given parameter values.

Arguments
---------

        * PARAMS is the 3-parameter vector [K, SIGMA, MU], where K is
          the shape parameter of the GEV distribution, SIGMA is the
          scale parameter of the GEV distribution, and MU is the
          location parameter of the GEV distribution.

        * DATA is the vector of given values.


Return values
-------------

        * NLOGL is the negative log-likelihood.

        * GRAD is the 3 by 1 gradient vector (first derivative of the
          negative log likelihood with respect to the parameter values)

        * ACOV is the 3 by 3 Fisher information matrix (second
          derivative of the negative log likelihood with respect to the
          parameter values)


Examples
--------

          x = -5:-1;
          k = -0.2;
          sigma = 0.3;
          mu = 0.5;
          [L, ~, C] = gevlike ([k sigma mu], x);

References
----------

       1. Rolf-Dieter Reiss and Michael Thomas. `Statistical Analysis
          of Extreme Values with Applications to Insurance, Finance,
          Hydrology and Other Fields'. Chapter 1, pages 16-17,
          Springer, 2007.


     See also: gevcdf, gevfit, gevinv, gevpdf, gevrnd, gevstat





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the negative log-likelihood of data under the generalized
extreme value 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gevpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1213
 -- Function File: Y = gevpdf (X, K, SIGMA, MU)
     Compute the probability density function of the generalized
     extreme value (GEV) distribution.

Arguments
---------

        * X is the support.

        * K is the shape parameter of the GEV distribution. (Also
          denoted gamma or xi.)

        * SIGMA is the scale parameter of the GEV distribution. The
          elements of SIGMA must be positive.

        * MU is the location parameter of the GEV distribution.
     The inputs must be of common size, or some of them must be scalar.

Return values
-------------

        * Y is the probability density of the GEV distribution at each
          element of X and corresponding parameter values.

Examples
--------

          x = 0:0.5:2.5;
          sigma = 1:6;
          k = 1;
          mu = 0;
          y = gevpdf (x, k, sigma, mu)

          y = gevpdf (x, k, 0.5, mu)

References
----------

       1. Rolf-Dieter Reiss and Michael Thomas. `Statistical Analysis
          of Extreme Values with Applications to Insurance, Finance,
          Hydrology and Other Fields'. Chapter 1, pages 16-17,
          Springer, 2007.


     See also: gevcdf, gevfit, gevinv, gevlike, gevrnd, gevstat





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the probability density function of the generalized extreme
value (GEV) 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gevrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 863
 -- Function File:  gevrnd (K, SIGMA, MU)
 -- Function File:  gevrnd (K, SIGMA, MU, R)
 -- Function File:  gevrnd (K, SIGMA, MU, R, C, ...)
 -- Function File:  gevrnd (K, SIGMA, MU, [SZ])
     Return a matrix of random samples from the generalized extreme
     value (GEV) distribution with parameters K, SIGMA, MU.

     When called with a single size argument, returns a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The size may also be specified with a vector
     SZ of dimensions.

     If no size arguments are given, then the result matrix is the
     common size of the input parameters.

     See also: gevcdf, gevfit, gevinv, gevlike, gevpdf, gevstat





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a matrix of random samples from the generalized extreme value
(GEV) distr



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gevstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 708
 -- Function File: Y = gevstat (K, SIGMA, MU)
     Compute the mean and variance of the generalized extreme value
     (GEV) distribution.

Arguments
---------

        * K is the shape parameter of the GEV distribution. (Also
          denoted gamma or xi.)

        * SIGMA is the scale parameter of the GEV distribution. The
          elements of SIGMA must be positive.

        * MU is the location parameter of the GEV distribution.
     The inputs must be of common size, or some of them must be scalar.

Return values
-------------

        * M is the mean of the GEV distribution

        * V is the variance of the GEV distribution

     See also: gevcdf, gevfit, gevinv, gevlike, gevpdf, gevrnd





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the mean and variance of the generalized extreme value (GEV)
distributio



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
harmmean


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 178
 -- Function File: harmmean (X)
 -- Function File: harmmean (X, DIM)
     Compute the harmonic mean.

     This function does the same as `mean (x, "h")'.

     See also: mean





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Compute the harmonic mean.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
histfit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 412
 -- Function File: histfit (DATA, NBINS)
     Plot histogram with superimposed fitted normal density.

     `histfit (DATA, NBINS)' plots a histogram of the values in the
     vector DATA using NBINS bars in the histogram. With one input
     argument, NBINS is set  to the square root of the number of
     elements in data.

     Example

          histfit (randn (100, 1))

     See also: bar, hist, pareto





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Plot histogram with superimposed fitted normal density.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
hmmestimate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4098
 -- Function File: [TRANSPROBEST, OUTPROBEST] = hmmestimate (SEQUENCE,
          STATES)
 -- Function File:  hmmestimate (..., 'statenames', STATENAMES)
 -- Function File:  hmmestimate (..., 'symbols', SYMBOLS)
 -- Function File:  hmmestimate (..., 'pseudotransitions',
          PSEUDOTRANSITIONS)
 -- Function File:  hmmestimate (..., 'pseudoemissions',
          PSEUDOEMISSIONS)
     Estimate the matrix of transition probabilities and the matrix of
     output probabilities of a given sequence of outputs and states
     generated by a hidden Markov model. The model assumes that the
     generation starts in state `1' at step `0' but does not include
     step `0' in the generated states and sequence.

Arguments
---------

        * SEQUENCE is a vector of a sequence of given outputs. The
          outputs must be integers ranging from `1' to the number of
          outputs of the hidden Markov model.

        * STATES is a vector of the same length as SEQUENCE of given
          states. The states must be integers ranging from `1' to the
          number of states of the hidden Markov model.

Return values
-------------

        * TRANSPROBEST is the matrix of the estimated transition
          probabilities of the states. `transprobest(i, j)' is the
          estimated probability of a transition to state `j' given
          state `i'.

        * OUTPROBEST is the matrix of the estimated output
          probabilities.  `outprobest(i, j)' is the estimated
          probability of generating output `j' given state `i'.

     If `'symbols'' is specified, then SEQUENCE is expected to be a
sequence of the elements of SYMBOLS instead of integers.  SYMBOLS can
be a cell array.

     If `'statenames'' is specified, then STATES is expected to be a
sequence of the elements of STATENAMES instead of integers.  STATENAMES
can be a cell array.

     If `'pseudotransitions'' is specified then the integer matrix
PSEUDOTRANSITIONS is used as an initial number of counted transitions.
`pseudotransitions(i, j)' is the initial number of counted transitions
from state `i' to state `j'.  TRANSPROBEST will have the same size as
PSEUDOTRANSITIONS.  Use this if you have transitions that are very
unlikely to occur.

     If `'pseudoemissions'' is specified then the integer matrix
PSEUDOEMISSIONS is used as an initial number of counted outputs.
`pseudoemissions(i, j)' is the initial number of counted outputs `j'
given state `i'. If `'pseudoemissions'' is also specified then the
number of rows of PSEUDOEMISSIONS must be the same as the number of
rows of PSEUDOTRANSITIONS. OUTPROBEST will have the same size as
PSEUDOEMISSIONS. Use this if you have outputs or states that are very
unlikely to occur.

Examples
--------

          transprob = [0.8, 0.2; 0.4, 0.6];
          outprob = [0.2, 0.4, 0.4; 0.7, 0.2, 0.1];
          [sequence, states] = hmmgenerate (25, transprob, outprob);
          [transprobest, outprobest] = hmmestimate (sequence, states)

          symbols = {'A', 'B', 'C'};
          statenames = {'One', 'Two'};
          [sequence, states] = hmmgenerate (25, transprob, outprob,
                               'symbols', symbols, 'statenames', statenames);
          [transprobest, outprobest] = hmmestimate (sequence, states,
                                       'symbols', symbols,
                                       'statenames', statenames)

          pseudotransitions = [8, 2; 4, 6];
          pseudoemissions = [2, 4, 4; 7, 2, 1];
          [sequence, states] = hmmgenerate (25, transprob, outprob);
          [transprobest, outprobest] = hmmestimate (sequence, states, 'pseudotransitions', pseudotransitions, 'pseudoemissions', pseudoemissions)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Lawrence R. Rabiner. A Tutorial on Hidden Markov Models and
          Selected Applications in Speech Recognition. `Proceedings of
          the IEEE', 77(2), pages 257-286, February 1989.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Estimate the matrix of transition probabilities and the matrix of output
probabi



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
hmmgenerate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2406
 -- Function File: [SEQUENCE, STATES] = hmmgenerate (LEN, TRANSPROB,
          OUTPROB)
 -- Function File:  hmmgenerate (..., 'symbols', SYMBOLS)
 -- Function File:  hmmgenerate (..., 'statenames', STATENAMES)
     Generate an output sequence and hidden states of a hidden Markov
     model.  The model starts in state `1' at step `0' but will not
     include step `0' in the generated states and sequence.

Arguments
---------

        * LEN is the number of steps to generate. SEQUENCE and STATES
          will have LEN entries each.

        * TRANSPROB is the matrix of transition probabilities of the
          states.  `transprob(i, j)' is the probability of a transition
          to state `j' given state `i'.

        * OUTPROB is the matrix of output probabilities.  `outprob(i,
          j)' is the probability of generating output `j' given state
          `i'.

Return values
-------------

        * SEQUENCE is a vector of length LEN of the generated outputs.
          The outputs are integers ranging from `1' to `columns
          (outprob)'.

        * STATES is a vector of length LEN of the generated hidden
          states. The states are integers ranging from `1' to `columns
          (transprob)'.

     If `'symbols'' is specified, then the elements of SYMBOLS are used
for the output sequence instead of integers ranging from `1' to
`columns (outprob)'. SYMBOLS can be a cell array.

     If `'statenames'' is specified, then the elements of STATENAMES
are used for the states instead of integers ranging from `1' to
`columns (transprob)'. STATENAMES can be a cell array.

Examples
--------

          transprob = [0.8, 0.2; 0.4, 0.6];
          outprob = [0.2, 0.4, 0.4; 0.7, 0.2, 0.1];
          [sequence, states] = hmmgenerate (25, transprob, outprob)

          symbols = {'A', 'B', 'C'};
          statenames = {'One', 'Two'};
          [sequence, states] = hmmgenerate (25, transprob, outprob,
                               'symbols', symbols, 'statenames', statenames)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Lawrence R. Rabiner. A Tutorial on Hidden Markov Models and
          Selected Applications in Speech Recognition. `Proceedings of
          the IEEE', 77(2), pages 257-286, February 1989.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Generate an output sequence and hidden states of a hidden Markov model.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
hmmviterbi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2559
 -- Function File: VPATH = hmmviterbi (SEQUENCE, TRANSPROB, OUTPROB)
 -- Function File:  hmmviterbi (..., 'symbols', SYMBOLS)
 -- Function File:  hmmviterbi (..., 'statenames', STATENAMES)
     Use the Viterbi algorithm to find the Viterbi path of a hidden
     Markov model given a sequence of outputs. The model assumes that
     the generation starts in state `1' at step `0' but does not
     include step `0' in the generated states and sequence.

Arguments
---------

        * SEQUENCE is the vector of length LEN of given outputs. The
          outputs must be integers ranging from `1' to `columns
          (outprob)'.

        * TRANSPROB is the matrix of transition probabilities of the
          states.  `transprob(i, j)' is the probability of a transition
          to state `j' given state `i'.

        * OUTPROB is the matrix of output probabilities.  `outprob(i,
          j)' is the probability of generating output `j' given state
          `i'.

Return values
-------------

        * VPATH is the vector of the same length as SEQUENCE of the
          estimated hidden states. The states are integers ranging from
          `1' to `columns (transprob)'.

     If `'symbols'' is specified, then SEQUENCE is expected to be a
sequence of the elements of SYMBOLS instead of integers ranging from
`1' to `columns (outprob)'. SYMBOLS can be a cell array.

     If `'statenames'' is specified, then the elements of STATENAMES
are used for the states in VPATH instead of integers ranging from `1'
to `columns (transprob)'.  STATENAMES can be a cell array.

Examples
--------

          transprob = [0.8, 0.2; 0.4, 0.6];
          outprob = [0.2, 0.4, 0.4; 0.7, 0.2, 0.1];
          [sequence, states] = hmmgenerate (25, transprob, outprob)
          vpath = hmmviterbi (sequence, transprob, outprob)

          symbols = {'A', 'B', 'C'};
          statenames = {'One', 'Two'};
          [sequence, states] = hmmgenerate (25, transprob, outprob,
                               'symbols', symbols, 'statenames', statenames)
          vpath = hmmviterbi (sequence, transprob, outprob,
                  'symbols', symbols, 'statenames', statenames)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Lawrence R. Rabiner. A Tutorial on Hidden Markov Models and
          Selected Applications in Speech Recognition. `Proceedings of
          the IEEE', 77(2), pages 257-286, February 1989.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Use the Viterbi algorithm to find the Viterbi path of a hidden Markov
model give



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
hygestat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1290
 -- Function File: [MN, V] = hygestat (T, M, N)
     Compute mean and variance of the hypergeometric distribution.

Arguments
---------

        * T is the total size of the population of the hypergeometric
          distribution. The elements of T must be positive natural
          numbers

        * M is the number of marked items of the hypergeometric
          distribution.  The elements of M must be natural numbers

        * N is the size of the drawn sample of the hypergeometric
          distribution. The elements of N must be positive natural
          numbers
     T, M, and N must be of common size or scalar

Return values
-------------

        * MN is the mean of the hypergeometric distribution

        * V is the variance of the hypergeometric distribution

Examples
--------

          t = 4:9;
          m = 0:5;
          n = 1:6;
          [mn, v] = hygestat (t, m, n)

          [mn, v] = hygestat (t, m, 2)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute mean and variance of the hypergeometric distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
jackknife


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2008
 -- Function File: JACKSTAT = jackknife (E, X, ...)
     Compute jackknife estimates of a parameter taking one or more
     given samples as parameters.  In particular, E is the estimator to
     be jackknifed as a function name, handle, or inline function, and
     X is the sample for which the estimate is to be taken.  The I-th
     entry of JACKSTAT will contain the value of the estimator on the
     sample X with its I-th row omitted.

          jackstat(I) = E(X(1 : I - 1, I + 1 : length(X)))

     Depending on the number of samples to be used, the estimator must
     have the appropriate form: If only one sample is used, then the
     estimator need not be concerned with cell arrays, for example
     jackknifing the standard deviation of a sample can be performed
     with `JACKSTAT = jackknife (@std, rand (100, 1))'.  If, however,
     more than one sample is to be used, the samples must all be of
     equal size, and the estimator must address them as elements of a
     cell-array, in which they are aggregated in their order of
     appearance:

          JACKSTAT = jackknife(@(x) std(x{1})/var(x{2}), rand (100, 1), randn (100, 1)

     If all goes well, a theoretical value P for the parameter is
     already known, N is the sample size, `T = N * E(X) - (N - 1) *
     mean(JACKSTAT)', and `V = sumsq(N * E(X) - (N - 1) * JACKSTAT - T)
     / (N * (N - 1))', then `(T-P)/sqrt(V)' should follow a
     t-distribution with N-1 degrees of freedom.

     Jackknifing is a well known method to reduce bias; further details
     can be found in:
        * Rupert G. Miller: The jackknife-a review; Biometrika (1974)
          61(1): 1-15; doi:10.1093/biomet/61.1.1

        * Rupert G. Miller: Jackknifing Variances; Ann. Math. Statist.
          Volume 39, Number 2 (1968), 567-582;
          doi:10.1214/aoms/1177698418

        * M. H. Quenouille: Notes on Bias in Estimation; Biometrika
          Vol. 43, No. 3/4 (Dec., 1956), pp. 353-360;
          doi:10.1093/biomet/43.3-4.353




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute jackknife estimates of a parameter taking one or more given
samples as p



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
jsucdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 263
 -- Function File:  jsucdf (X, ALPHA1, ALPHA2)
     For each element of X, compute the cumulative distribution
     function (CDF) at X of the Johnson SU distribution with shape
     parameters ALPHA1 and ALPHA2.

     Default values are ALPHA1 = 1, ALPHA2 = 1.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For each element of X, compute the cumulative distribution function
(CDF) at X o



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
jsupdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 259
 -- Function File:  jsupdf (X, ALPHA1, ALPHA2)
     For each element of X, compute the probability density function
     (PDF) at X of the Johnson SU distribution with shape parameters
     ALPHA1 and ALPHA2.

     Default values are ALPHA1 = 1, ALPHA2 = 1.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For each element of X, compute the probability density function (PDF)
at X of th



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
kmeans


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
 -- Function File: [IDX, CENTERS] = kmeans (DATA, K, PARAM1, VALUE1,
          ...)
     K-means clustering.

     See also: linkage





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
K-means clustering.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
linkage


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2941
 -- Function File: Y = linkage (D)
 -- Function File: Y = linkage (D, METHOD)
 -- Function File: Y = linkage (X, METHOD, METRIC)
 -- Function File: Y = linkage (X, METHOD, ARGLIST)
     Produce a hierarchical clustering dendrogram

     D is the dissimilarity matrix relative to n observations,
     formatted as a (n-1)*n/2x1 vector as produced by `pdist'.
     Alternatively, X contains data formatted for input to `pdist',
     METRIC is a metric for `pdist' and ARGLIST is a cell array
     containing arguments that are passed to `pdist'.

     `linkage' starts by putting each observation into a singleton
     cluster and numbering those from 1 to n.  Then it merges two
     clusters, chosen according to METHOD, to create a new cluster
     numbered n+1, and so on until all observations are grouped into a
     single cluster numbered 2(n-1).  Row k of the (m-1)x3 output
     matrix relates to cluster n+k: the first two columns are the
     numbers of the two component clusters and column 3 contains their
     distance.

     METHOD defines the way the distance between two clusters is
     computed and how they are recomputed when two clusters are merged:

    `"single" (default)'
          Distance between two clusters is the minimum distance between
          two elements belonging each to one cluster.  Produces a
          cluster tree known as minimum spanning tree.

    `"complete"'
          Furthest distance between two elements belonging each to one
          cluster.

    `"average"'
          Unweighted pair group method with averaging (UPGMA).  The
          mean distance between all pair of elements each belonging to
          one cluster.

    `"weighted"'
          Weighted pair group method with averaging (WPGMA).  When two
          clusters A and B are joined together, the new distance to a
          cluster C is the mean between distances A-C and B-C.

    `"centroid"'
          Unweighted Pair-Group Method using Centroids (UPGMC).
          Assumes Euclidean metric.  The distance between cluster
          centroids, each centroid being the center of mass of a
          cluster.

    `"median"'
          Weighted pair-group method using centroids (WPGMC).  Assumes
          Euclidean metric.  Distance between cluster centroids.  When
          two clusters are joined together, the new centroid is the
          midpoint between the joined centroids.

    `"ward"'
          Ward's sum of squared deviations about the group mean (ESS).
          Also known as minimum variance or inner squared distance.
          Assumes Euclidean metric.  How much the moment of inertia of
          the merged cluster exceeds the sum of those of the individual
          clusters.

     *Reference* Ward, J. H. Hierarchical Grouping to Optimize an
     Objective Function J. Am. Statist. Assoc. 1963, 58, 236-244,
     `http://iv.slis.indiana.edu/sw/data/ward.pdf'.

   See also: pdist, squareform




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Produce a hierarchical clustering dendrogram




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
lognstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1035
 -- Function File: [M, V] = lognstat (MU, SIGMA)
     Compute mean and variance of the lognormal distribution.

Arguments
---------

        * MU is the first parameter of the lognormal distribution

        * SIGMA is the second parameter of the lognormal distribution.
          SIGMA must be positive or zero
     MU and SIGMA must be of common size or one of them must be scalar

Return values
-------------

        * M is the mean of the lognormal distribution

        * V is the variance of the lognormal distribution

Examples
--------

          mu = 0:0.2:1;
          sigma = 0.2:0.2:1.2;
          [m, v] = lognstat (mu, sigma)

          [m, v] = lognstat (0, sigma)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Compute mean and variance of the lognormal distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
mad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 767
 -- Function File: mad (X)
 -- Function File: mad (X, FLAG)
 -- Function File: mad (X, FLAG, DIM)
     Compute the mean/median absolute deviation of X.

     The mean absolute deviation is computed as

          mean (abs (X - mean (X)))

     and the median absolute deviation is computed as

          median (abs (X - median (X)))

     Elements of X containing NaN or NA values are ignored during
     computations.

     If FLAG is 0, the absolute mean deviation is computed, and if FLAG
     is 1, the absolute median deviation is computed. By default FLAG
     is 0.

     This is done along the dimension DIM of X. If this variable is not
     given, the mean/median absolute deviation s computed along the
     smallest dimension of X.

     See also: std





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the mean/median absolute deviation of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
mnpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1643
 -- Function File: Y = mnpdf (X, P)
     Compute the probability density function of the multinomial
     distribution.

Arguments
---------

        * X is vector with a single sample of a multinomial
          distribution with parameter P or a matrix of random samples
          from multinomial distributions. In the latter case, each row
          of X is a sample from a multinomial distribution with the
          corresponding row of P being its parameter.

        * P is a vector with the probabilities of the categories or a
          matrix with each row containing the probabilities of a
          multinomial sample.

Return values
-------------

        * Y is a vector of probabilites of the random samples X from the
          multinomial distribution with corresponding parameter P. The
          parameter N of the multinomial distribution is the sum of the
          elements of each row of X. The length of Y is the number of
          columns of X.  If a row of P does not sum to `1', then the
          corresponding element of Y will be `NaN'.

Examples
--------

          x = [1, 4, 2];
          p = [0.2, 0.5, 0.3];
          y = mnpdf (x, p);

          x = [1, 4, 2; 1, 0, 9];
          p = [0.2, 0.5, 0.3; 0.1, 0.1, 0.8];
          y = mnpdf (x, p);

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Merran Evans, Nicholas Hastings and Brian Peacock.
          `Statistical Distributions'. pages 134-136, Wiley, New York,
          third edition, 2000.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Compute the probability density function of the multinomial
distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
mnrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2172
 -- Function File: X = mnrnd (N, P)
 -- Function File: X = mnrnd (N, P, S)
     Generate random samples from the multinomial distribution.

Arguments
---------

        * N is the first parameter of the multinomial distribution. N
          can be scalar or a vector containing the number of trials of
          each multinomial sample. The elements of N must be
          non-negative integers.

        * P is the second parameter of the multinomial distribution. P
          can be a vector with the probabilities of the categories or a
          matrix with each row containing the probabilities of a
          multinomial sample. If P has more than one row and N is
          non-scalar, then the number of rows of P must match the
          number of elements of N.

        * S is the number of multinomial samples to be generated. S must
          be a non-negative integer. If S is specified, then N must be
          scalar and P must be a vector.

Return values
-------------

        * X is a matrix of random samples from the multinomial
          distribution with corresponding parameters N and P. Each row
          corresponds to one multinomial sample. The number of columns,
          therefore, corresponds to the number of columns of P. If S is
          not specified, then the number of rows of X is the maximum of
          the number of elements of N and the number of rows of P. If a
          row of P does not sum to `1', then the corresponding row of X
          will contain only `NaN' values.

Examples
--------

          n = 10;
          p = [0.2, 0.5, 0.3];
          x = mnrnd (n, p);

          n = 10 * ones (3, 1);
          p = [0.2, 0.5, 0.3];
          x = mnrnd (n, p);

          n = (1:2)';
          p = [0.2, 0.5, 0.3; 0.1, 0.1, 0.8];
          x = mnrnd (n, p);

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Merran Evans, Nicholas Hastings and Brian Peacock.
          `Statistical Distributions'. pages 134-136, Wiley, New York,
          third edition, 2000.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Generate random samples from the multinomial distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
monotone_smooth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1745
 -- Function File: YY = monotone_smooth (X, Y, H)
     Produce a smooth monotone increasing approximation to a sampled
     functional dependence y(x) using a kernel method (an Epanechnikov
     smoothing kernel is applied to y(x); this is integrated to yield
     the monotone increasing form.  See Reference 1 for details.)

Arguments
---------

        * X is a vector of values of the independent variable.

        * Y is a vector of values of the dependent variable, of the
          same size as X. For best performance, it is recommended that
          the Y already be fairly smooth, e.g. by applying a kernel
          smoothing to the original values if they are noisy.

        * H is the kernel bandwidth to use. If H is not given, a
          "reasonable" value is computed.


Return values
-------------

        * YY is the vector of smooth monotone increasing function
          values at X.


Examples
--------

          x = 0:0.1:10;
          y = (x .^ 2) + 3 * randn(size(x)); %typically non-monotonic from the added noise
          ys = ([y(1) y(1:(end-1))] + y + [y(2:end) y(end)])/3; %crudely smoothed via
          moving average, but still typically non-monotonic
          yy = monotone_smooth(x, ys); %yy is monotone increasing in x
          plot(x, y, '+', x, ys, x, yy)

References
----------

       1. Holger Dette, Natalie Neumeyer and Kay F. Pilz (2006), A
          simple nonparametric estimator of a strictly monotone
          regression function, `Bernoulli', 12:469-490

       2. Regine Scheder (2007), R Package 'monoProc', Version 1.0-6,
          `http://cran.r-project.org/web/packages/monoProc/monoProc.pdf'
          (The implementation here is based on the monoProc function
          mono.1d)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Produce a smooth monotone increasing approximation to a sampled
functional depen



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mvncdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1188
 -- Function File: P = mvncdf (X, MU, SIGMA)
 -- Function File:  mvncdf (A, X, MU, SIGMA)
 -- Function File: [P, ERR] = mvncdf (...)
     Compute the cumulative distribution function of the multivariate
     normal distribution.

Arguments
---------

        * X is the upper limit for integration where each row
          corresponds to an observation.

        * MU is the mean.

        * SIGMA is the correlation matrix.

        * A is the lower limit for integration where each row
          corresponds to an observation. A must have the same size as X.

Return values
-------------

        * P is the cumulative distribution at each row of X and A.

        * ERR is the estimated error.

Examples
--------

          x = [1 2];
          mu = [0.5 1.5];
          sigma = [1.0 0.5; 0.5 1.0];
          p = mvncdf (x, mu, sigma)

          a = [-inf 0];
          p = mvncdf (a, x, mu, sigma)

References
----------

       1. Alan Genz and Frank Bretz. Numerical Computation of
          Multivariate t-Probabilities with Application to Power
          Calculation of Multiple Constrasts. `Journal of Statistical
          Computation and Simulation', 63, pages 361-378, 1999.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the cumulative distribution function of the multivariate normal
distribu



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mvnpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1600
 -- Function File: Y = mvnpdf (X)
 -- Function File: Y = mvnpdf (X, MU)
 -- Function File: Y = mvnpdf (X, MU, SIGMA)
     Compute multivariate normal pdf for X given mean MU and covariance
     matrix SIGMA.  The dimension of X is D x P, MU is 1 x P and SIGMA
     is P x P. The normal pdf is defined as

          1/Y^2 = (2 pi)^P |SIGMA| exp { (X-MU)' inv(SIGMA) (X-MU) }

     *References*

     NIST Engineering Statistics Handbook 6.5.4.2
     http://www.itl.nist.gov/div898/handbook/pmc/section5/pmc542.htm

     *Algorithm*

     Using Cholesky factorization on the positive definite covariance
     matrix:

          R = chol (SIGMA);

     where R'*R = SIGMA. Being upper triangular, the determinant of R
     is  trivially the product of the diagonal, and the determinant of
     SIGMA is the square of this:

          DET = prod (diag (R))^2;

     The formula asks for the square root of the determinant, so no
     need to square it.

     The exponential argument A = X' * inv (SIGMA) * X

          A = X' * inv (SIGMA) * X
            = X' * inv (R' * R) * X
            = X' * inv (R) * inv(R') * X

     Given that inv (R') == inv(R)', at least in theory if not
     numerically,

          A  = (X' / R) * (X'/R)' = sumsq (X'/R)

     The interface takes the parameters to the multivariate normal in
     columns rather than rows, so we are actually dealing with the
     transpose:

          A = sumsq (X/r)

     and the final result is:

          R = chol (SIGMA)
          Y = (2*pi)^(-P/2) * exp (-sumsq ((X-MU)/R, 2)/2) / prod (diag (R))

     See also: mvncdf, mvnrnd





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute multivariate normal pdf for X given mean MU and covariance
matrix SIGMA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mvnrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 535
 -- Function File: S = mvnrnd (MU, SIGMA)
 -- Function File: S = mvnrnd (MU, SIGMA, N)
 -- Function File: S = mvnrnd (..., TOL)
     Draw N random D-dimensional vectors from a multivariate Gaussian
     distribution with mean MU(NxD) and covariance matrix SIGMA(DxD).

     If N is given then MU can be a 1-by-D vector. If it is not given
     MU must be N-by-D.

     If the argument TOL is given the eigenvalues of SIGMA are checked
     for positivity against -100*tol. the default value of tol is
     `eps*norm (Sigma, "fro")'.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Draw N random D-dimensional vectors from a multivariate Gaussian
distribution wi



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mvtcdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1199
 -- Function File: P = mvtcdf (X, SIGMA, NU)
 -- Function File:  mvtcdf (A, X, SIGMA, NU)
 -- Function File: [P, ERR] = mvtcdf (...)
     Compute the cumulative distribution function of the multivariate
     Student's t distribution.

Arguments
---------

        * X is the upper limit for integration where each row
          corresponds to an observation.

        * SIGMA is the correlation matrix.

        * NU is the degrees of freedom.

        * A is the lower limit for integration where each row
          corresponds to an observation. A must have the same size as X.

Return values
-------------

        * P is the cumulative distribution at each row of X and A.

        * ERR is the estimated error.

Examples
--------

          x = [1 2];
          sigma = [1.0 0.5; 0.5 1.0];
          nu = 4;
          p = mvtcdf (x, sigma, nu)

          a = [-inf 0];
          p = mvtcdf (a, x, sigma, nu)

References
----------

       1. Alan Genz and Frank Bretz. Numerical Computation of
          Multivariate t-Probabilities with Application to Power
          Calculation of Multiple Constrasts. `Journal of Statistical
          Computation and Simulation', 63, pages 361-378, 1999.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the cumulative distribution function of the multivariate
Student's t dis



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mvtrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1977
 -- Function File: X = mvtrnd (SIGMA, NU)
 -- Function File: X = mvtrnd (SIGMA, NU, N)
     Generate random samples from the multivariate t-distribution.

Arguments
---------

        * SIGMA is the matrix of correlation coefficients. If there are
          any non-unit diagonal elements then SIGMA will be normalized,
          so that the resulting covariance of the obtained samples X
          follows: `cov (x) = nu/(nu-2) * sigma ./ (sqrt (diag (sigma)
          * diag (sigma)))'.  In order to obtain samples distributed
          according to a standard multivariate t-distribution, SIGMA
          must be equal to the identity matrix. To generate
          multivariate t-distribution samples X with arbitrary
          covariance matrix SIGMA, the following scaling might be used:
          `x = mvtrnd (sigma, nu, n) * diag (sqrt (diag (sigma)))'.

        * NU is the degrees of freedom for the multivariate
          t-distribution.  NU must be a vector with the same number of
          elements as samples to be generated or be scalar.

        * N is the number of rows of the matrix to be generated. N must
          be a non-negative integer and corresponds to the number of
          samples to be generated.

Return values
-------------

        * X is a matrix of random samples from the multivariate
          t-distribution with N row samples.

Examples
--------

          sigma = [1, 0.5; 0.5, 1];
          nu = 3;
          n = 10;
          x = mvtrnd (sigma, nu, n);

          sigma = [1, 0.5; 0.5, 1];
          nu = [2; 3];
          n = 2;
          x = mvtrnd (sigma, nu, 2);

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Samuel Kotz and Saralees Nadarajah. `Multivariate t
          Distributions and Their Applications'. Cambridge University
          Press, Cambridge, 2004.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Generate random samples from the multivariate t-distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
nanmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 379
 -- Function File: [V, IDX] = nanmax (X)
 -- Function File: [V, IDX] = nanmax (X, Y)
     Find the maximal element while ignoring NaN values.

     `nanmax' is identical to the `max' function except that NaN values
     are ignored.  If all values in a column are NaN, the maximum is
     returned as NaN rather than [].

     See also: max, nansum, nanmin, nanmean, nanmedian





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Find the maximal element while ignoring NaN values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nanmean


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 339
 -- Function File: V = nanmean (X)
 -- Function File: V = nanmean (X, DIM)
     Compute the mean value while ignoring NaN values.

     `nanmean' is identical to the `mean' function except that NaN
     values are ignored.  If all values are NaN, the mean is returned
     as NaN.

     See also: mean, nanmin, nanmax, nansum, nanmedian





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute the mean value while ignoring NaN values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
nanmedian


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 355
 -- Function File: V = nanmedian (X)
 -- Function File: V = nanmedian (X, DIM)
     Compute the median of data while ignoring NaN values.

     This function is identical to the `median' function except that
     NaN values are ignored.  If all values are NaN, the median is
     returned as NaN.

     See also: median, nanmin, nanmax, nansum, nanmean





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the median of data while ignoring NaN values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
nanmin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 379
 -- Function File: [V, IDX] = nanmin (X)
 -- Function File: [V, IDX] = nanmin (X, Y)
     Find the minimal element while ignoring NaN values.

     `nanmin' is identical to the `min' function except that NaN values
     are ignored.  If all values in a column are NaN, the minimum is
     returned as NaN rather than [].

     See also: min, nansum, nanmax, nanmean, nanmedian





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Find the minimal element while ignoring NaN values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
nanstd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 932
 -- Function File: V = nanstd (X)
 -- Function File: V = nanstd (X, OPT)
 -- Function File: V = nanstd (X, OPT, DIM)
     Compute the standard deviation while ignoring NaN values.

     `nanstd' is identical to the `std' function except that NaN values
     are ignored.  If all values are NaN, the standard deviation is
     returned as NaN.  If there is only a single non-NaN value, the
     deviation is returned as 0.

     The argument OPT determines the type of normalization to use.
     Valid values are

    0:
          normalizes with N-1, provides the square root of best
          unbiased estimator of   the variance [default]

    1:
          normalizes with N, this provides the square root of the
          second moment around   the mean

     The third argument DIM determines the dimension along which the
     standard deviation is calculated.

     See also: std, nanmin, nanmax, nansum, nanmedian, nanmean





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Compute the standard deviation while ignoring NaN values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
nansum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 345
 -- Function File: V = nansum (X)
 -- Function File: V = nansum (X, DIM)
     Compute the sum while ignoring NaN values.

     `nansum' is identical to the `sum' function except that NaN values
     are treated as 0 and so ignored.  If all values are NaN, the sum is
     returned as 0.

     See also: sum, nanmin, nanmax, nanmean, nanmedian





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Compute the sum while ignoring NaN values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
nanvar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 783
 -- Function File:  nanvar (X)
 -- Function File: V = nanvar (X, OPT)
 -- Function File: V = nanvar (X, OPT, DIM)
     Compute the variance while ignoring NaN values.

     For vector arguments, return the (real) variance of the values.
     For matrix arguments, return a row vector containing the variance
     for each column.

     The argument OPT determines the type of normalization to use.
     Valid values are

    0:
          Normalizes with N-1, provides the best unbiased estimator of
          the variance [default].

    1:
          Normalizes with N, this provides the second moment around the
          mean.

     The third argument DIM determines the dimension along which the
     variance is calculated.

     See also: var, nanmean, nanstd, nanmax, nanmin





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Compute the variance while ignoring NaN values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nbinstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1106
 -- Function File: [M, V] = nbinstat (N, P)
     Compute mean and variance of the negative binomial distribution.

Arguments
---------

        * N is the first parameter of the negative binomial
          distribution. The elements of N must be natural numbers

        * P is the second parameter of the negative binomial
          distribution. The elements of P must be probabilities
     N and P must be of common size or one of them must be scalar

Return values
-------------

        * M is the mean of the negative binomial distribution

        * V is the variance of the negative binomial distribution

Examples
--------

          n = 1:4;
          p = 0.2:0.2:0.8;
          [m, v] = nbinstat (n, p)

          [m, v] = nbinstat (n, 0.5)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Compute mean and variance of the negative binomial distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
normalise_distribution


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2097
 -- Function File: NORMALISED = normalise_distribution (DATA)
 -- Function File: NORMALISED = normalise_distribution (DATA,
          DISTRIBUTION)
 -- Function File: NORMALISED = normalise_distribution (DATA,
          DISTRIBUTION, DIMENSION)
     Transform a set of data so as to be N(0,1) distributed according
     to an idea by van Albada and Robinson.  This is achieved by first
     passing it through its own cumulative distribution function (CDF)
     in order to get a uniform distribution, and then mapping the
     uniform to a normal distribution.  The data must be passed as a
     vector or matrix in DATA.  If the CDF is unknown, then [] can be
     passed in DISTRIBUTION, and in this case the empirical CDF will be
     used.  Otherwise, if the CDFs for all data are known, they can be
     passed in DISTRIBUTION, either in the form of a single function
     name as a string, or a single function handle, or a cell array
     consisting of either all function names as strings, or all
     function handles.  In the latter case, the number of CDFs passed
     must match the number of rows, or columns respectively, to
     normalise.  If the data are passed as a matrix, then the
     transformation will operate either along the first non-singleton
     dimension, or along DIMENSION if present.

     Notes: The empirical CDF will map any two sets of data having the
     same size and their ties in the same places after sorting to some
     permutation of the same normalised data:
          `normalise_distribution([1 2 2 3 4])'
          => -1.28  0.00  0.00  0.52  1.28

          `normalise_distribution([1 10 100 10 1000])'
          => -1.28  0.00  0.52  0.00  1.28

     Original source: S.J. van Albada, P.A. Robinson "Transformation of
     arbitrary distributions to the normal distribution with
     application to EEG test-retest reliability" Journal of
     Neuroscience Methods, Volume 161, Issue 2, 15 April 2007, Pages
     205-211 ISSN 0165-0270, 10.1016/j.jneumeth.2006.11.004.
     (http://www.sciencedirect.com/science/article/pii/S0165027006005668)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Transform a set of data so as to be N(0,1) distributed according to an
idea by v



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
normplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 443
 -- Function File: normplot (X)
     Produce normal probability plot for each column of X.

     The line joing the 1st and 3rd quantile is drawn on the graph.  If
     the underlying distribution is normal, the points will cluster
     around this line.

     Note that this function sets the title, xlabel, ylabel, axis,
     grid, tics and hold properties of the graph.  These need to be
     cleared before subsequent graphs using 'clf'.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Produce normal probability plot for each column of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
normstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 967
 -- Function File: [MN, V] = normstat (M, S)
     Compute mean and variance of the normal distribution.

Arguments
---------

        * M is the mean of the normal distribution

        * S is the standard deviation of the normal distribution.  S
          must be positive
     M and S must be of common size or one of them must be scalar

Return values
-------------

        * MN is the mean of the normal distribution

        * V is the variance of the normal distribution

Examples
--------

          m = 1:6;
          s = 0:0.2:1;
          [mn, v] = normstat (m, s)

          [mn, v] = normstat (0, s)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute mean and variance of the normal distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
pdist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2477
 -- Function File: Y = pdist (X)
 -- Function File: Y = pdist (X, METRIC)
 -- Function File: Y = pdist (X, METRIC, METRICARG, ...)
     Return the distance between any two rows in X.

     X is the NxD matrix representing Q row vectors of size D.

     The output is a dissimilarity matrix formatted as a row vector Y,
     (n-1)*n/2 long, where the distances are in the order [(1, 2) (1,
     3) ... (2, 3) ... (n-1, n)].  You can use the `squareform'
     function to display the distances between the vectors arranged
     into an NxN matrix.

     `metric' is an optional argument specifying how the distance is
     computed. It can be any of the following ones, defaulting to
     "euclidean", or a user defined function that takes two arguments X
     and Y plus any number of optional arguments, where X is a row
     vector and and Y is a matrix having the same number of columns as
     X.  `metric' returns a column vector where row I is the distance
     between X and row I of Y. Any additional arguments after the
     `metric' are passed as metric (X, Y, METRICARG1, METRICARG2 ...).

     Predefined distance functions are:

    `"euclidean"'
          Euclidean distance (default).

    `"seuclidean"'
          Standardized Euclidean distance. Each coordinate in the sum of
          squares is inverse weighted by the sample variance of that
          coordinate.

    `"mahalanobis"'
          Mahalanobis distance: see the function mahalanobis.

    `"cityblock"'
          City Block metric, aka Manhattan distance.

    `"minkowski"'
          Minkowski metric.  Accepts a numeric parameter P: for P=1
          this is the same as the cityblock metric, with P=2 (default)
          it is equal to the euclidean metric.

    `"cosine"'
          One minus the cosine of the included angle between rows, seen
          as vectors.

    `"correlation"'
          One minus the sample correlation between points (treated as
          sequences of values).

    `"spearman"'
          One minus the sample Spearman's rank correlation between
          observations, treated as sequences of values.

    `"hamming"'
          Hamming distance: the quote of the number of coordinates that
          differ.

    `"jaccard"'
          One minus the Jaccard coefficient, the quote of nonzero
          coordinates that differ.

    `"chebychev"'
          Chebychev distance: the maximum coordinate difference.

     See also: linkage, mahalanobis, squareform





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Return the distance between any two rows in X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
plsregress


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 496
 -- Function File:
[XLOADINGS,YLOADINGS,XSCORES,YSCORES,COEFFICIENTS,FITTED] = ...
     plsregress(X, Y, NCOMP)
        * X: Matrix of observations

        * Y: Is a vector or matrix of responses

        * NCOMP: number of components used for modelling

        * X and Y will be mean centered to improve accuracy

References
----------

       1. SIMPLS: An alternative approach to partial least squares
          regression. Chemometrics and Intelligent Laboratory
          Systems (1993)





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
plsregress(X, Y, NCOMP)
   * X: Matrix of observations




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
poisstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 820
 -- Function File: [M, V] = poisstat (LAMBDA)
     Compute mean and variance of the Poisson distribution.

Arguments
---------

        * LAMBDA is the parameter of the Poisson distribution. The
          elements of LAMBDA must be positive

Return values
-------------

        * M is the mean of the Poisson distribution

        * V is the variance of the Poisson distribution

Example
-------

          lambda = 1 ./ (1:6);
          [m, v] = poisstat (lambda)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute mean and variance of the Poisson distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
princomp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 332
 -- Function File: [PC, Z, W, TSQ] = princomp (X)
     Compute principal components of X.

     The first output argument PC is the principal components of X.
     The second Z is the transformed data, and W is the eigenvalues of
     the covariance matrix of X. TSQ is the Hotelling's T^2 statistic
     for the transformed data.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Compute principal components of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
random


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3107
 -- Function File: R = random(NAME, ARG1)
 -- Function File: R = random(NAME, ARG1, ARG2)
 -- Function File: R = random(NAME, ARG1, ARG2, ARG3)
 -- Function File: R = random(NAME, ..., S1, ...)
     Generates pseudo-random numbers from a given one-, two-, or
     three-parameter distribution.

     The variable NAME must be a string that names the distribution from
     which to sample.  If this distribution is a one-parameter
     distribution ARG1 should be supplied, if it is a two-paramter
     distribution ARG2 must also be supplied, and if it is a
     three-parameter distribution ARG3 must also be present.  Any
     arguments following the distribution paramters will determine the
     size of the result.

     As an example, the following code generates a 10 by 20 matrix
     containing random numbers from a normal distribution with mean 5
     and standard deviation 2.
          R = random("normal", 5, 2, [10, 20]);

     The variable NAME can be one of the following strings

    "beta"
    "beta distribution"
          Samples are drawn from the Beta distribution.

    "bino"
    "binomial"
    "binomial distribution"
          Samples are drawn from the Binomial distribution.

    "chi2"
    "chi-square"
    "chi-square distribution"
          Samples are drawn from the Chi-Square distribution.

    "exp"
    "exponential"
    "exponential distribution"
          Samples are drawn from the Exponential distribution.

    "f"
    "f distribution"
          Samples are drawn from the F distribution.

    "gam"
    "gamma"
    "gamma distribution"
          Samples are drawn from the Gamma distribution.

    "geo"
    "geometric"
    "geometric distribution"
          Samples are drawn from the Geometric distribution.

    "hyge"
    "hypergeometric"
    "hypergeometric distribution"
          Samples are drawn from the Hypergeometric distribution.

    "logn"
    "lognormal"
    "lognormal distribution"
          Samples are drawn from the Log-Normal distribution.

    "nbin"
    "negative binomial"
    "negative binomial distribution"
          Samples are drawn from the Negative Binomial distribution.

    "norm"
    "normal"
    "normal distribution"
          Samples are drawn from the Normal distribution.

    "poiss"
    "poisson"
    "poisson distribution"
          Samples are drawn from the Poisson distribution.

    "rayl"
    "rayleigh"
    "rayleigh distribution"
          Samples are drawn from the Rayleigh distribution.

    "t"
    "t distribution"
          Samples are drawn from the T distribution.

    "unif"
    "uniform"
    "uniform distribution"
          Samples are drawn from the Uniform distribution.

    "unid"
    "discrete uniform"
    "discrete uniform distribution"
          Samples are drawn from the Uniform Discrete distribution.

    "wbl"
    "weibull"
    "weibull distribution"
          Samples are drawn from the Weibull distribution.

     See also: rand, betarnd, binornd, chi2rnd, exprnd, frnd, gamrnd,
     geornd, hygernd, lognrnd, nbinrnd, normrnd, poissrnd, raylrnd,
     trnd, unifrnd, unidrnd, wblrnd





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Generates pseudo-random numbers from a given one-, two-, or
three-parameter dist



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
raylcdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1076
 -- Function File: P = raylcdf (X, SIGMA)
     Compute the cumulative distribution function of the Rayleigh
     distribution.

Arguments
---------

        * X is the support. The elements of X must be non-negative.

        * SIGMA is the parameter of the Rayleigh distribution. The
          elements of SIGMA must be positive.
     X and SIGMA must be of common size or one of them must be scalar.

Return values
-------------

        * P is the cumulative distribution of the Rayleigh distribution
          at each element of X and corresponding parameter SIGMA.

Examples
--------

          x = 0:0.5:2.5;
          sigma = 1:6;
          p = raylcdf (x, sigma)

          p = raylcdf (x, 0.5)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. pages 104 and 148, McGraw-Hill, New
          York, second edition, 1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Compute the cumulative distribution function of the Rayleigh
distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
raylinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1133
 -- Function File: X = raylinv (P, SIGMA)
     Compute the quantile of the Rayleigh distribution. The quantile is
     the inverse of the cumulative distribution function.

Arguments
---------

        * P is the cumulative distribution. The elements of P must be
          probabilities.

        * SIGMA is the parameter of the Rayleigh distribution. The
          elements of SIGMA must be positive.
     P and SIGMA must be of common size or one of them must be scalar.

Return values
-------------

        * X is the quantile of the Rayleigh distribution at each
          element of P and corresponding parameter SIGMA.

Examples
--------

          p = 0:0.1:0.5;
          sigma = 1:6;
          x = raylinv (p, sigma)

          x = raylinv (p, 0.5)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. pages 104 and 148, McGraw-Hill, New
          York, second edition, 1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the quantile of the Rayleigh distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
raylpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1068
 -- Function File: Y = raylpdf (X, SIGMA)
     Compute the probability density function of the Rayleigh
     distribution.

Arguments
---------

        * X is the support. The elements of X must be non-negative.

        * SIGMA is the parameter of the Rayleigh distribution. The
          elements of SIGMA must be positive.
     X and SIGMA must be of common size or one of them must be scalar.

Return values
-------------

        * Y is the probability density of the Rayleigh distribution at
          each element of X and corresponding parameter SIGMA.

Examples
--------

          x = 0:0.5:2.5;
          sigma = 1:6;
          y = raylpdf (x, sigma)

          y = raylpdf (x, 0.5)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. pages 104 and 148, McGraw-Hill, New
          York, second edition, 1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Compute the probability density function of the Rayleigh distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
raylrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1489
 -- Function File: X = raylrnd (SIGMA)
 -- Function File: X = raylrnd (SIGMA, SZ)
 -- Function File: X = raylrnd (SIGMA, R, C)
     Generate a matrix of random samples from the Rayleigh distribution.

Arguments
---------

        * SIGMA is the parameter of the Rayleigh distribution. The
          elements of SIGMA must be positive.

        * SZ is the size of the matrix to be generated. SZ must be a
          vector of non-negative integers.

        * R is the number of rows of the matrix to be generated. R must
          be a non-negative integer.

        * C is the number of columns of the matrix to be generated. C
          must be a non-negative integer.

Return values
-------------

        * X is a matrix of random samples from the Rayleigh
          distribution with corresponding parameter SIGMA. If neither
          SZ nor R and C are specified, then X is of the same size as
          SIGMA.

Examples
--------

          sigma = 1:6;
          x = raylrnd (sigma)

          sz = [2, 3];
          x = raylrnd (0.5, sz)

          r = 2;
          c = 3;
          x = raylrnd (0.5, r, c)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. pages 104 and 148, McGraw-Hill, New
          York, second edition, 1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Generate a matrix of random samples from the Rayleigh distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
raylstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 815
 -- Function File: [M, V] = raylstat (SIGMA)
     Compute mean and variance of the Rayleigh distribution.

Arguments
---------

        * SIGMA is the parameter of the Rayleigh distribution. The
          elements of SIGMA must be positive.

Return values
-------------

        * M is the mean of the Rayleigh distribution.

        * V is the variance of the Rayleigh distribution.

Example
-------

          sigma = 1:6;
          [m, v] = raylstat (sigma)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Compute mean and variance of the Rayleigh distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
regress


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1333
 -- Function File: [B, BINT, R, RINT, STATS] = regress (Y, X, [ALPHA])
     Multiple Linear Regression using Least Squares Fit of Y on X with
     the model `y = X * beta + e'.

     Here,

        * `y' is a column vector of observed values

        * `X' is a matrix of regressors, with the first column filled
          with the constant value 1

        * `beta' is a column vector of regression parameters

        * `e' is a column vector of random errors

     Arguments are

        * Y is the `y' in the model

        * X is the `X' in the model

        * ALPHA is the significance level used to calculate the
          confidence intervals BINT and RINT (see `Return values'
          below). If not specified, ALPHA defaults to 0.05

     Return values are

        * B is the `beta' in the model

        * BINT is the confidence interval for B

        * R is a column vector of residuals

        * RINT is the confidence interval for R

        * STATS is a row vector containing:

             * The R^2 statistic

             * The F statistic

             * The p value for the full model

             * The estimated error variance

     R and RINT can be passed to `rcoplot' to visualize the residual
     intervals and identify outliers.

     NaN values in Y and X are removed before calculation begins.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Multiple Linear Regression using Least Squares Fit of Y on X with the
model `y =



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
regress_gp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1119
 -- Function File: [M, K] = regress_gp (X, Y, SP)
 -- Function File: [... YI DY] = sqp (..., XI)
     Linear scalar regression using gaussian processes.

     It estimates the model Y = X'*m for X R^D and Y in R.  The
     information about errors of the predictions
     (interpolation/extrapolation) is given by the covarianve matrix K.
     If D==1 the inputs must be column vectors, if D>1 then X is
     n-by-D, with n the number of data points. SP defines the prior
     covariance of M, it should be a (D+1)-by-(D+1) positive definite
     matrix, if it is empty, the default is `Sp = 100*eye(size(x,2)+1)'.

     If XI inputs are provided, the model is evaluated and returned in
     YI.  The estimation of the variation of YI are given in DY.

     Run `demo regress_gp' to see an examples.

     The function is a direc implementation of the formulae in pages
     11-12 of Gaussian Processes for Machine Learning. Carl Edward
     Rasmussen and  Christopher K. I. Williams. The MIT Press, 2006.
     ISBN 0-262-18253-X.  available online at
     `http://gaussianprocess.org/gpml/'.

     See also: regress





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Linear scalar regression using gaussian processes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
repanova


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 696
 -- Function File: [PVAL, TABLE, ST] = repanova (X, COND)
 -- Function File: [PVAL, TABLE, ST] = repanova (X, COND, ['string' |
          'cell'])
     Perform a repeated measures analysis of variance (Repeated ANOVA).
     X is formated such that each row is a subject and each column is a
     condition.

     condition is typically a point in time, say t=1 then t=2, etc
     condition can also be thought of as groups.

     The optional flag can be either 'cell' or 'string' and reflects
     the format of the table returned.  Cell is the default.

     NaNs are ignored using nanmean and nanstd.

     This fuction does not currently support multiple columns of the
     same condition!




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Perform a repeated measures analysis of variance (Repeated ANOVA).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
squareform


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 384
 -- Function File: Y = squareform (X)
 -- Function File: Y = squareform (X, "tovector")
 -- Function File: Y = squareform (X, "tomatrix")
     Convert a vector from the pdist function into a square matrix or
     from a square matrix back to the vector form.

     The second argument is used to specify the output type in case
     there is a single element.

     See also: pdist





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Convert a vector from the pdist function into a square matrix or from a
square m



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
tabulate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1886
 -- Function File: TABLE = tabulate (DATA, EDGES)
     Compute a frequency table.

     For vector data, the function counts the number of values in data
     that fall between the elements in the edges vector (which must
     contain monotonically non-decreasing values). TABLE is a matrix.
     The first column of TABLE is the number of bin, the second is the
     number of instances in each class (absolute frequency). The third
     column contains the percentage of each value (relative frequency)
     and the fourth column contains the cumulative frequency.

     If EDGES is missed the width of each class is unitary, if EDGES is
     a scalar then represent the number of classes, or you can define
     the width of each bin.  TABLE(K, 2) will count the value DATA (I)
     if EDGES (K) <= DATA (I) < EDGES (K+1).  The  last bin will count
     the value of DATA (I) if EDGES(K) <= DATA (I) <=  EDGES (K+1).
     Values outside the values in EDGES are not counted.  Use -inf and
     inf in EDGES to include all values.  Tabulate with no output
     arguments returns a formatted table in the command window.

     Example

          sphere_radius = [1:0.05:2.5];
          tabulate (sphere_radius)

     Tabulate returns 2 bins, the first contains the sphere with radius
     between 1 and 2 mm excluded, and the second one contains the
     sphere with radius between 2 and 3 mm.

          tabulate (sphere_radius, 10)

     Tabulate returns ten bins.

          tabulate (sphere_radius, [1, 1.5, 2, 2.5])

     Tabulate returns three bins, the first contains the sphere with
     radius between 1 and 1.5 mm excluded, the second one contains the
     sphere with radius between 1.5 and 2 mm excluded, and the third
     contains the sphere with radius between 2 and 2.5 mm.

          bar (table (:, 1), table (:, 2))

     draw histogram.

     See also: bar, pareto





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Compute a frequency table.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tblread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 776
 -- Function File: [DATA, VARNAMES, CASENAMES] = tblread (FILENAME)
 -- Function File: [DATA, VARNAMES, CASENAMES] = tblread (FILENAME,
          DELIMETER)
     Read tabular data from an ascii file.

     DATA is read from an ascii data file named FILENAME with an
     optional DELIMETER.  The delimeter may be any single character or
        * "space" " " (default)

        * "tab" "\t"

        * "comma" ","

        * "semi" ";"

        * "bar" "|"

     The DATA is read starting at cell (2,2) where the VARNAMES form a
     char matrix from the first row (starting at (1,2)) vertically
     concatenated, and the CASENAMES form a char matrix read from the
     first column (starting at (2,1)) vertically concatenated.

     See also: tblwrite, csv2cell, cell2csv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Read tabular data from an ascii file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
tblwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 765
 -- Function File:  tblwrite (DATA, VARNAMES, CASENAMES, FILENAME)
 -- Function File:  tblwrite (DATA, VARNAMES, CASENAMES, FILENAME,
          DELIMETER)
     Write tabular data to an ascii file.

     DATA is written to an ascii data file named FILENAME with an
     optional DELIMETER.  The delimeter may be any single character or
        * "space" " " (default)

        * "tab" "\t"

        * "comma" ","

        * "semi" ";"

        * "bar" "|"

     The DATA is written starting at cell (2,2) where the VARNAMES are
     a char matrix or cell vector written to the first row (starting at
     (1,2)), and the CASENAMES are a char matrix (or cell vector)
     written to the first column (starting at (2,1)).

     See also: tblread, csv2cell, cell2csv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Write tabular data to an ascii file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
trimmean


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 387
 -- Function File: A = trimmean (X, P)
     Compute the trimmed mean.

     The trimmed mean of X is defined as the mean of X excluding the
     highest and lowest P percent of the data.

     For example

          mean ([-inf, 1:9, inf])

     is NaN, while

          trimmean ([-inf, 1:9, inf], 10)

     excludes the infinite values, which make the result 5.

     See also: mean





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Compute the trimmed mean.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
tstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 798
 -- Function File: [M, V] = tstat (N)
     Compute mean and variance of the t (Student) distribution.

Arguments
---------

        * N is the parameter of the t (Student) distribution. The
          elements of N must be positive

Return values
-------------

        * M is the mean of the t (Student) distribution

        * V is the variance of the t (Student) distribution

Example
-------

          n = 3:8;
          [m, v] = tstat (n)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Compute mean and variance of the t (Student) distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
unidstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 840
 -- Function File: [M, V] = unidstat (N)
     Compute mean and variance of the discrete uniform distribution.

Arguments
---------

        * N is the parameter of the discrete uniform distribution. The
          elements of N must be positive natural numbers

Return values
-------------

        * M is the mean of the discrete uniform distribution

        * V is the variance of the discrete uniform distribution

Example
-------

          n = 1:6;
          [m, v] = unidstat (n)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Compute mean and variance of the discrete uniform distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
unifstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1047
 -- Function File: [M, V] = unifstat (A, B)
     Compute mean and variance of the continuous uniform distribution.

Arguments
---------

        * A is the first parameter of the continuous uniform
          distribution

        * B is the second parameter of the continuous uniform
          distribution
     A and B must be of common size or one of them must be scalar and A
must be less than B

Return values
-------------

        * M is the mean of the continuous uniform distribution

        * V is the variance of the continuous uniform distribution

Examples
--------

          a = 1:6;
          b = 2:2:12;
          [m, v] = unifstat (a, b)

          [m, v] = unifstat (a, 10)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Compute mean and variance of the continuous uniform distribution.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
vmpdf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 319
 -- Function File: THETA = vmpdf (X, MU, K)
     Evaluates the Von Mises probability density function.

     The Von Mises distribution has probability density function
          f (X) = exp (K * cos (X - MU)) / Z ,
     where Z is a normalisation constant. By default, MU is 0 and K is
     1.

     See also: vmrnd





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Evaluates the Von Mises probability density function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
vmrnd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 518
 -- Function File: THETA = vmrnd (MU, K)
 -- Function File: THETA = vmrnd (MU, K, SZ)
     Draw random angles from a Von Mises distribution with mean MU and
     concentration K.

     The Von Mises distribution has probability density function
          f (X) = exp (K * cos (X - MU)) / Z ,
     where Z is a normalisation constant.

     The output, THETA, is a matrix of size SZ containing random angles
     drawn from the given Von Mises distribution. By default, MU is 0
     and K is 1.

     See also: vmpdf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Draw random angles from a Von Mises distribution with mean MU and
concentration 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
wblstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1050
 -- Function File: [M, V] = wblstat (SCALE, SHAPE)
     Compute mean and variance of the Weibull distribution.

Arguments
---------

        * SCALE is the scale parameter of the Weibull distribution.
          SCALE must be positive

        * SHAPE is the shape parameter of the Weibull distribution.
          SHAPE must be positive
     SCALE and SHAPE must be of common size or one of them must be
scalar

Return values
-------------

        * M is the mean of the Weibull distribution

        * V is the variance of the Weibull distribution

Examples
--------

          scale = 3:8;
          shape = 1:6;
          [m, v] = wblstat (scale, shape)

          [m, v] = wblstat (6, shape)

References
----------

       1. Wendy L. Martinez and Angel R. Martinez. `Computational
          Statistics Handbook with MATLAB'. Appendix E, pages 547-557,
          Chapman & Hall/CRC, 2001.

       2. Athanasios Papoulis. `Probability, Random Variables, and
          Stochastic Processes'. McGraw-Hill, New York, second edition,
          1984.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute mean and variance of the Weibull distribution.





