# Created by Octave 3.6.4, Sat Mar 30 12:49:16 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 44
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
best_dir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1793
       [d,w,rx,cv,wx] = best_dir( x, [a , sx ] )

 Some points  x,  are observed and one assumes that they belong to
 parallel planes. There is an unknown direction  d  s.t. for each
 point  x(i,:), one has :

         x(i,:)*d == w(j(i)) + noise

 where j is known(given by the matrix  a ), but  w  is unknown.

 Under the assumption that the error on  x  are i.i.d. gaussian,
 best_dir() returns the maximum likelihood estimate of  d  and  w.

 This function is slower when cv is returned.

 INPUT :
 -------
 x  : D x P    P points. Each one is the sum of a point that belongs
               to a plane and a noise term.

 a  : P x W    0-1 matrix describing association of points (rows of 
               x) to planes :

           a(p,i) == 1 iff point x(p,:) belongs to the i'th plane.

                                                Default is ones(P,1)
 
 sx : P x 1    Covariance of x(i,:) is sx(i)*eye(D). 
                                                Default is ones(P,1)
 OUTPUT :
 --------
 d  : D x 1    All the planes have the same normal, d. d has unit
               norm.

 w  : W x 1    The i'th plane is { y | y*d = w(i) }.

 rx : P x 1    Residuals of projection of points to corresponding plane.


               Assuming that the covariance of  x  (i.e. sx) was known
               only up to a scale factor, an estimate of the
               covariance of  x  and  [w;d]  are

                 sx * mean(rx.^2)/mean(sx)       and
                 cv * mean(rx.^2)/mean(sx),  respectively.

 cv : (D+W)x(D+W) 
               Covariance of the estimator at [d,w] ( assuming that
               diag(covariance(vec(x))) == sx ). 

 wx : (D+W)x(D*P)
               Derivatives of [w;d] wrt to x.

 Author  : Etienne Grossmann <etienne@egdn.net>
 Created : March 2000




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
       [d,w,rx,cv,wx] = best_dir( x, [a , sx ] )




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
best_dir_cov


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 308
       [cv,wx] = best_dir_cov(x,a,sx,wd)
 
 x    D x P     : 
 a    P x W     : Same as in best_dir, but sx is compulsory.
 sx   P x 1     :
 
 wd (W+D) x 1   : ML estimate of [w;d]

 cv (W+D)x(W+D) : Covariance of the ML estimator at [w;d]

 wx (W+D)x(P*D) : derivatives of ML estimate wrt to observations




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
       [cv,wx] = best_dir_cov(x,a,sx,wd)
 
 x    D x P     : 
 a    P x W     : 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
bound_convex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
 y = bound_convex(d,h,x,pad=0) 

  y : 3xQ : Corners that define the convex hull of the projection of x
            in the plane d*y == v. The corners are sorted.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
 y = bound_convex(d,h,x,pad=0) 




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
checker_color


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
 col = checker_color (R,C, checker, col)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
 col = checker_color (R,C, checker, col)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
data2vrml


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 284
 s = data2vrml (typeStr, value) - Convert 'value' to VRML code of type typeStr

 TODO: Improve this function

 If typeStr is "SFBool",   then s is "TRUE" or "FALSE"
 If typeStr is "MFString", then s is sprintf ("%s", value)
 otherwise                      s is sprintf ("%f", value)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
 s = data2vrml (typeStr, value) - Convert 'value' to VRML code of type typeStr




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
proplan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 82
       x = proplan(x,d,v=1)

 orthogonally project x to the affine plane d*x == v



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
       x = proplan(x,d,v=1)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
save_vrml


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 404
 save_vrml(outname,[options],s1,...)    - Save vrml code
 
 Makes a vrml2 file from strings of vrml code. A "background" node is
 added.
 
 Options :
 "nobg"
 "nolight"
 
 Bugs :
 - "outname" should not contain the substring ".wrl" anywhere else
   than as a suffix.
 - "outname" should only contain the character ">" as ">>" at the
   beginning , to indicate append rather than overwriting the
   file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
 save_vrml(outname,[options],s1,.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
test_moving_surf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
key test_moving_surf

 Test vmesh.m



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
key test_moving_surf




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
test_vmesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
key test_vmesh

 Test vmesh.m



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
key test_vmesh




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
test_vrml_faces


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
 Test that vrml_faces works with "tex" option



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
 Test that vrml_faces works with "tex" option




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
vmesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2329
 s = vmesh (x, y, z [, options] ) - Visualize a 3D surface
 s = vmesh (z [, options] )

 Visualizes a 3D surface. Returns the VRML code.

 x : RxC or C  : X coordinates of the points on the surface
 y : RxC or R  : Y "                                      "
 z : RxC       : Z "                                      "

 s :   string  : The code

 If x and y are omitted, they are assumed to be linspace(-1,1,C or R).
 Points presenting one or more 'inf' or 'nan' coordinates are ignored.

 Options : (all options of vrml_surf may be used too)

 "col" , col  : 3      : RGB Color,                Default = [0.3,0.4,0.9]
             or 3x(R*C): Color of vertices (vrml colorPerVertex is TRUE).
             or 3x((R-1)*(C-1))
                       : Color of facets
             or 1      : Reflectivity (equivalent to [col,col,col] in RGB)
             or R x C  : Reflectivity of vertices
             or 1x(R*C)
             or (R-1)x(C-1)
             or (R-1)*(C-1)
                       : Reflectivity of facets.

        RGB and reflectivity values should be in the [0,1] interval.

 "checker", c : 1x2 : Color as a checker. If c(1) is positive, checker has
                      c(1) rows. If it is negative, each checker row is
                      c(1) facets high. c(2) does the same for columns.
             or 1x1 : Same as [c,c].

 "zgray"            : Color varies from black for lowest point to white
                      for highest.

 "zrb"              : Color varies from blue for lowest point to red for
                      highest.

 "zcol", zcol : Mx3 : Color is linearly interpolated between the RGB
                      values specified by the rows of zcol.

 "steps"            : Represent surface as a piecewise constant Z = f(X,Y)
                      function

 "bars"             : Represent surface as a bar plot
 "bwid"             : Bar width, relative to point separation. Default = 2/3

 "level", l   : 1xN : Display one or more horizontal translucent plane(s)

                        z == l(i)   (1 <= i <= length(l))
 
 "lcol", lc   : Nx3 : Color of the plane(s).          Default = [.7 .7 .7]
 "ltran",lt   : Nx1 : Transparency of the plane(s).   Default =        0.3
 "tex", texFile

 "normalize"  :       Normalize z to [-1,1]

 See also: vrml_surf(), vrml_faces(), demo("vmesh")



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 s = vmesh (x, y, z [, options] ) - Visualize a 3D surface
 s = vmesh (z [, opti



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
vrml_Background


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 610
  s = vrml_Background (...)   - Vrml Background node
  
  s is a string of the form :
  ------------------------------------------------------------------
  Background { 
    skyColor          [0 0 0]
    skyAngle          [0]   
    groundColor       [0 0 0]   
    groundangle       [0]   
    backUrl           ""
    bottomUrl         ""
    frontUrl          ""
    leftUrl           ""
    rightUrl          ""
    topUrl            ""
  }
  ------------------------------------------------------------------

 Options :
 All the fields of the node

 Example : s = vrml_Background ("skyColor",[0 0 1]);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
  s = vrml_Background (.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
vrml_Box


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 189
 s = vrml_Box (sz) - Box { ... } node

 If sz is not given, returns Box { }
 If sz has size 1, returns   Box { <sz> <sz> <sz> }
 If sz has size 3, returns   Box { <sz(1)> <sz(2)> <sz(3)> }



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
 s = vrml_Box (sz) - Box { .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
vrml_DirectionalLight


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 617
  s = vrml_DirectionalLight (...)   - Vrml DirectionalLight node

  s is a string of the form :
  ------------------------------------------------------------------
  DirectionalLight { 
    exposedField SFFloat ambientIntensity  0        # [0,1]
    exposedField SFColor color             1 1 1    # [0,1]
    exposedField SFVec3f direction         0 0 -1   # (-,)
    exposedField SFFloat intensity         1        # [0,1]
    exposedField SFBool  on                TRUE 
  }
  ------------------------------------------------------------------

 Options :
 All the fields of the node

 See also : vrml_PointLight



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
  s = vrml_DirectionalLight (.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
vrml_PointLight


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 791
  s = vrml_PointLight (...)   - Vrml PointLight node
  
  s is a string of the form :
  ------------------------------------------------------------------
  PointLight { 
    exposedField SFFloat ambientIntensity  0       ## [0,1]
    exposedField SFVec3f attenuation       1 0 0   ## [0,inf)
    exposedField SFColor color             1 1 1   ## [0,1]
    exposedField SFFloat intensity         1       ## [0,1]
    exposedField SFVec3f location          0 0 0   ## (-inf,inf)
    exposedField SFBool  on                TRUE 
    exposedField SFFloat radius            100     ## [0,inf)
  }
  ------------------------------------------------------------------

 Options :
 All the fields of the node

 Example : s = vrml_PointLight ("location",[0 0 1]);

 See also : vrml_DirectionalLight



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
  s = vrml_PointLight (.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
vrml_ROUTE


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
 vrml_ROUTE (eventout, eventin)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
 vrml_ROUTE (eventout, eventin)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
vrml_Sphere


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
 s = vrml_Sphere (radius) - VRML code for a sphere 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
 s = vrml_Sphere (radius) - VRML code for a sphere 




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
vrml_TimeSensor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 913
  s = vrml_TimeSensor (...)   - Low-level vrml TimeSensor node
  
  s is a vrml node with possible fields :
  ------------------------------------------------------------------
 TimeSensor { 
   exposedField SFTime   cycleInterval 1       # (0,inf)
   exposedField SFBool   enabled       TRUE
   exposedField SFBool   loop          FALSE
   exposedField SFTime   startTime     0       # (-inf,inf)
   exposedField SFTime   stopTime      0       # (-inf,inf)
   eventOut     SFTime   cycleTime
   eventOut     SFFloat  fraction_changed      # [0, 1]
   eventOut     SFBool   isActive
   eventOut     SFTime   time
 }
  ------------------------------------------------------------------

 Options :
 Beyond all the fields of the node, it is also possible to use the option

 "DEF", name : The created node will be preceded by 'DEF name ', so that
               it is further possible to refer to it.

 See also : 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
  s = vrml_TimeSensor (.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
vrml_Viewpoint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 765
  s = vrml_Viewpoint (...)   - Vrml Viewpoint node
  
  s is a string of the form :
  ------------------------------------------------------------------
 Viewpoint { 
    eventIn      SFBool     set_bind
    exposedField SFFloat    fieldOfView    0.785398  # (0,pi)
    exposedField SFBool     jump           TRUE
    exposedField SFRotation orientation    0 0 1 0   # [-1,1],(-pi,pi)
    exposedField SFVec3f    position       0 0 10    # (-,)
    field        SFString   description    ""
    eventOut     SFTime     bindTime
    eventOut     SFBool     isBound
  }
  ------------------------------------------------------------------

 Options :
 All the fields of the node

 Example : s = vrml_Viewpoint ("location",[0 0 1]);

 See also : vrml_DirectionalLight



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
  s = vrml_Viewpoint (.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
vrml_anim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 168
 s = vrml_anim (typ, val, eventin, time)

 Assemble 
 - an interpolator of type typ, with values val
 - a TimeSensor with period time
 and route the event to eventin
 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
 s = vrml_anim (typ, val, eventin, time)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
vrml_arrow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 827
 s = vrml_arrow (sz, col)     - Arrow pointing in "y" direction

 INPUT :
 -------
 Arguments are optional. NaN's are replaced by default values.
                                                         <default>
 sz = [len, alen, dc, dr] has size 1, 2, 3 or 4, where

   len  : total length                                   <1>
   alen : If positive: length of cone/total length       <1/4>
          If negative: -(length of cone)
   dc   : If positive: diameter of cone base/total len   <1/16>
          If negative: -(diameter of cone) 
   dr   : If positive: diameter of rod/total length      <min(dc, len/32)>
          If negative: -(diameter of rod) 

 col    : 3 or 3x2 : Color of body and cone              <[0.3 0.4 0.9]>

 OUTPUT :
 --------
 s      : string   : vrml representation of an arrow (a rod and a cone)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
 s = vrml_arrow (sz, col)     - Arrow pointing in "y" direction




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
vrml_browse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1134
  p = vrml_browse ([s])       - View vrml code s with FreeWRL
      vrml_browse ("-kill")   - Kill the browser

 s : string : VRML code, as returned by the vrml_XYZ functions. 
              If  s  is not specified, a sombrero is showed

 p : int    : pid of the current browser. If freewrl has not been started
              or has died, a new one is started. p is zero or negative in
              case of failure to start freewrl.

 Some keystrokes for FreeWRL (more in the freewrl manpage) :

 'e'   : Examine : mouse 1 and drag rotates the scene
                   mouse 3 and drag moves closer/farther          
 'w'   : Walk    : mouse 1 and drag moves for/backward, turns
                   mouse 3 and drag translates parallel to the screen
 's'   : Save a snapshot in files 'octave.snapshot.NNNN.ppm'
 'q'   : Quit
 
 WARNING : FreeWRL >0.25 (http://www.crc.ca/FreeWRL/) must be installed.

 BUG     : The vrml browser is not killed when octave exits. Sometimes the
           vrml browser does not get raised or gets raised improperly
           (shows the contents of the topmost window above it). Use
           "-kill".



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
  p = vrml_browse ([s])       - View vrml code s with FreeWRL
      vrml_browse 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
vrml_cyl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 698
       s = vrml_cyl(x,...) 

 Makes a cylinder that links x(:,1) to x(:,2) 
 
 Options : 

 "tran", transparency    : Transparency                  default = 0
 "col" , col             : Color           default = [ 0.3 0.4 0.9 ]
 "rad" , radius          : Radius of segments         default = 0.05
 "balls"                 : Add balls to extremities
 "brad"                  : Radius of balls             default = rad
 "emit", bool            : Use or not emissiveColor
 "noemit"                : Same as emit,0
 "arrow"                 : Last segment is an arrow 
 "hcol", hcol            : Set color of the head of the arrow.
                                                       default = col



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
       s = vrml_cyl(x,.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
vrml_demo_tutorial_1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
 Listing 1



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
 Listing 1




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
vrml_demo_tutorial_2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
 Listing 2



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
 Listing 2




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
vrml_demo_tutorial_3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
 Listing 3



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
 Listing 3




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
vrml_demo_tutorial_4


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
 Listing 4



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
 Listing 4




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
vrml_ellipsoid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 272
       v = vrml_ellipsoid (moment, col) - Ellipsoid 

 moment : 3x3 : Define elipsoid by x'*moment*x = 1
  or      3   :  use diag(moment)
  or      1   :  use diag(moment([1,1,1]))   default : eye(3)

 col    : 3   : Color                        default : [0.3 0.4 0.9]




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
       v = vrml_ellipsoid (moment, col) - Ellipsoid 




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
vrml_faces


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2071
 s = vrml_faces(x,f,...) - VRML facet object (IndexedFaceSet node)

 x : 3xP   : The 3D points
 f : 3xQ   : The indexes of the points forming the faces. Indexes
             should have values in 1:P.

 Returns a Shape -> IndexedFaceSet vrml node.

 No check is done on anything

 Options :
 
 "col" , col  : 3   : Color,                      default = [0.3,0.4,0.9]
             or 3xP : Color of vertices
             or 3xQ : Color of facets   (use "colorPerVertex" below to
                                         disambiguate the case P==Q).
 
 "emit", em   : 3   : Emissive color of the surface
              : 3XP : (same as color)
              : 3xQ :
              : 1   : Use color as emissive color too         default = 0

 "tran", tran : 1x1 : Transparency,                           default = 0

 "creaseAngle", a 
              :  1  : vrml creaseAngle value. The browser may smoothe the
                      crease between facets whose angle is less than a.
                                                              default = 0
 "tex", texfile 
              : string : Name of file containing texture.   default : none

 "imsz", sz   : 2   : Size of texture image 
                                       default is determined by imginfo()

 "tcoord", tcoord
              : 2x3Q : Coordinates of vertices in texture image. Each 2x3
                       block contains coords of one facet's corners. The
                       coordinates should be in [0,1], as in a VRML
                       TextureCoordinate node.
                                       default assumes faces are returned
                                       by extex()

 "smooth"           : same as "creaseAngle",pi.
 "convex"
 "colorPerVertex", c: If 1, col specifies color of vertices. If 0,
                       col specifies color of facets.         Default = 1

 "DEFcoord",n : string : DEF the coord VRML node with name n. Default = ''
 "DEFcol",  n : string : DEF the color VRML node with name n. Default = ''

 See also: vrml_surf(), vmesh(), test_vrml_faces()



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
 s = vrml_faces(x,f,.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
vrml_flatten


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 497
 s = vrml_flatten (x [, d, w, col]) - A planar surface containing x

 If the points  x  are not coplanar (or not in the affine plane {y|d'*y==w}),
 the surface will not contain the points, but rather their projections on
 the plane {y|d'*y==w}.
 
 x   : 3 x P  : 3D points
 d   : 3      : normal to plane    | Default : given by best_dir()
 w   : 1      : intercept of plane |
 col : 3      : RGB color            Default : [0.3,0.4,0.9]

 s   : string : vrml code representing the planar surface



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
 s = vrml_flatten (x [, d, w, col]) - A planar surface containing x




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
vrml_frame


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 608
       v = vrml_frame (t, r, ...)
  
 t : 3      Translation                          Default : [0,0,0]
 r : 3x3    Matrix, or                           Default : eye(3)
     3      Argument for rotv
 OPTIONS
  name   : size     : function                                   : default
 "scale" : 3 or 1   : Length of frame's branches (including cone)   <1>
 "diam"  : 3 or 1   : Diameter of cone's base
 "col"   : 3 or 3x3 : Color of branches (may be stacked vertically) <[3 4 9]/10>
 "hcol"  : 3 or 3x3 : Color of head     (may be stacked vertically) <col>
                                                  



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
       v = vrml_frame (t, r, .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
vrml_group


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
 v = vrml_group (s1, s2 ... ) - Form a group node with children s1,...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
 v = vrml_group (s1, s2 .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
vrml_interp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
 s = vrml_interp (typ, val,...)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
 s = vrml_interp (typ, val,.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
vrml_kill


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 190
  p = vrml_kill ()            - Kill the current vrml browser
 
 If a vrml browser has previously been launched with vrml_browse(), it
 will be sent a KILL signal.

 See also : vrml_browse.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
  p = vrml_kill ()            - Kill the current vrml browser
 
 If a vrml brows



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
vrml_lines


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 289
 s = vrml_lines(x,f,...)

 x : 3xP   : The 3D points
 f : 3xQ   : The indexes of the points forming the lines. Indexes
             should be in 1:P.

 Returns a Shape -> IndexedLineSet vrml node.

 No check is done on anything

 Options :
 
 "col" , col  : 3x1 : Color, default = [1,0,0]



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
 s = vrml_lines(x,f,.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
vrml_material


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 266
  s = vrml_material (dc,ec,tr) - Returns a "material" vrml node

 dc : 3x1 : diffuseColor
 ec : 3x1 : emissiveColor
   or 1x1 : use dc as emissiveColor if ec is true.             Default = 0
 tr : 1x1 : transparency                                       Default = 0



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
  s = vrml_material (dc,ec,tr) - Returns a "material" vrml node




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
vrml_newname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 n = vrml_newname (root)      - A name for a vrml node, starting by root
 
 vrml_newname ("-clear")



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 n = vrml_newname (root)      - A name for a vrml node, starting by root
 
 vrml



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
vrml_parallelepiped


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 321
 s = vrml_parallelogram (bnds,...)

 bnds = [xmin, ymin, zmin; xmax, ymax, zmax]

 OPTIONS :
 ---------
 col,   c : 3x1 : Color of surface
 emit,  e : 1   :
 tran,  t : 1   :

 border,b : 1   :
 bocol, c : 3   :
 boemit,e : 1   :
 borad, r : 1   :

 balls, b : 1   :
 bcol,  c : 3   :
 bemit, e : 1   :
 brad,  r : 1   :



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
 s = vrml_parallelogram (bnds,.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
vrml_parallelogram


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 371
 s = vrml_parallelogram (x,...)

 x : 3 x 3 : Each column is a 3D point. The fourth corner is 
               x(:,1)-x(:,2)+x(:,3)

 OPTIONS :
 ---------
 col,   c : 3x1 : Color of surface
 emit,  e : 1   :
 tran,  t : 1   :

 border,b : 1   :
 bocol, c : 3   :
 boemit,e : 1   :
 borad, r : 1   :

 balls, b : 1   :
 bcol,  c : 3   :
 bemit, e : 1   :
 brad,  r : 1   :



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
 s = vrml_parallelogram (x,.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
vrml_points


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1462
        s = vrml_points(x,options)
 
 x : 3xP  : 3D points

 Makes a vrml2 "point [ ... ]" node from a 3xP matrix x.
 
 OPTIONS (name and size/type, if applicable):
 ---------------------------------------
 "balls"      : Displays spheres rather than points. Overrides the
                "hide" options and no Coordinate node is defined;makes
                "name" ineffective.

 "boxes" or
 "cubes"      : Displays cubes rather than points. Overrides the "hide"
                options and no Coordinate node is defined;makes "name"
                ineffective. 

 "rad", 1 or P: Radius of balls/size of cubes.              default = 0.1

 "nums"       : Displays numbers rather than points. Overrides the
                "hide" options and no Coordinate node is defined;
                makes "name" ineffective.

       WARNING : This option seems to make freewrl 0.34 hang, so that it
                 is necessary to kill it (do vrml_browse ("-kill")). Other
                 browsers can can view the code produced by this option.

  "col", 3x1  : Points will have RGB col.          default = [0.3,0.4,0.9]
      or 3xP  : The color of each point.
  "tran", 1x1 : Transparency                                   default = 0
  "emit", e   : Use or not emissiveColor                       default = 1

 "name", str  : The Coordinate node will be called name
                (default="allpoints").
 "hide"       : The points will be defined, but not showed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
        s = vrml_points(x,options)
 
 x : 3xP  : 3D points




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
vrml_surf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2206
 s = vrml_surf (x, y, z [, options] ) - code for a VRML surface
 s = vrml_surf (z [, options] )

 Returns vrml97 code for a Shape -> IndexedFaceSet node representing a
 surface passing through the given points.

 x : RxC or C  : X coordinates of the points on the surface
 y : RxC or R  : Y "                                      "
 z : RxC       : Z "                                      "

 s :   string  : The code

 If x and y are omitted, they are assumed to be linspace(-1,1,C or R).
 Points presenting one or more 'inf' or 'nan' coordinates are ignored.

 Options :

 "col" , col  : 3      : RGB Color,                default = [0.3,0.4,0.9]
             or 3x(R*C): Color of vertices (vrml colorPerVertex is TRUE).
             or 3x((R-1)*(C-1))
                       : Color of facets
             or 1      : Reflectivity (equivalent to [col,col,col] in RGB)
             or R x C  : Reflectivity of vertices
             or 1x(R*C)
             or (R-1)x(C-1)
             or (R-1)*(C-1)
                       : Reflectivity of facets.

        RGB and reflectivity values should be in the [0,1] interval.

 "checker", c : 1x2 : Color as a checker. If c(1) is positive, checker has
            c(1) rows. If it is negative, each checker row is c(1) facets
            high c(2) likewise determines width of checker columns.
 "checker", c : 1x1 : Same as [c,c].

 "zcol", zc   : 3xN : Specify a colormap. The color of each vertex is
            interpolated according to its height (z).

 "zgray"      : Black-to-white colormap. Same as "zcol", [0 1;0 1;0 1].

 "zrb"        : Red-to-blue. Same as "zcol", [0 7 10;0 0 2;7 19 2]/10.

 "steps"      : Represent surface as a piecewise constant Z = f(X,Y) function

 "bars"       : Represent surface as a bar plot

 "tran", tran : 1x1    : Transparency,                        default = 0

 "creaseAngle", a
              : 1      : vrml creaseAngle The browser may smoothe the fold
                         between facets forming an angle less than a.
                                                              default = 0
 "smooth"           : same as "creaseAngle",pi.
 "tex", texFile 

 See also: vmesh(), vrml_faces(), test_moving_surf()



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 s = vrml_surf (x, y, z [, options] ) - code for a VRML surface
 s = vrml_surf (



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
vrml_text


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 533
       s = vrml_text(t,...) 

 Makes vrml Shape node representing string t
 
 Options : 

 "col" , col             : default = [ 0.3 0.4 0.9 ]
 "size" , size           : default = 1.0
 "family", family        : default = "SERIF". 
                           (could also be : "TYPEWRITER", "SANS")
 "style", style          : default = "PLAIN". 
                           (could also be : "BOLD", "ITALIC", "BOLDITALIC")
 "justify", justify      : default = "MIDDLE"
                           (could also be "FIRST", "BEGIN", "END")



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
       s = vrml_text(t,.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
vrml_thick_surf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1178
       s = vrml_thick_surf (x, y, z [, options] )
       s = vrml_thick_surf (z [, options] )

 Returns vrml97 code for a Shape -> IndexedFaceSet node representing a
 surface passing through the given points.

 The surface may look smoother than that returned by  vrml_surf,  but it
 has twice as many facets.

 x : RxC or C  : X coordinates of the points on the surface
 y : RxC or R  : Y "                                      "
 z : RxC       : Z "                                      "

 s :   string  : The code

 If x and y are omitted, they are assumed to be 1:C and 1:R, resp
 Points presenting one or more 'inf' or 'nan' coordinates are ignored.

 Options :

 "col" , col  : 3   : Color,                      default = [0.3,0.4,0.9]
             or 3xP : color of vertices (vrml colorPerVertex is TRUE).
 
 "tran", tran : 1x1 : Transparency,                           default = 0

 "creaseAngle", a 
              :  1  : vrml creaseAngle value. The browser may smoothe the
                      crease between facets whose angle is less than a.
                                                              default = 0
 "smooth"           : same as "creaseAngle",pi.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
       s = vrml_thick_surf (x, y, z [, options] )
       s = vrml_thick_surf (z 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
vrml_transfo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 483
       v = vrml_transfo(s,t,r,c,d)
  
 s : string of vrml code.
 t : 3      Translation                          default : [0,0,0]
 r : 3x3    Rotation matrix, or                  default : eye(3)
     3      Scaled rotation axis.
 c : 3 or 1 Scale                                default : 1
 d : string DEF name                             default : ''

 v : string v is s, enclosed in a Transform {} vrml node with
     rotation, translation and scale params given by r, t and c.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
       v = vrml_transfo(s,t,r,c,d)
  
 s : string of vrml code.





