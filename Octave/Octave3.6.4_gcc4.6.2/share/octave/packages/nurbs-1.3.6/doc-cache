# Created by Octave 3.6.4, Sat Mar 30 10:19:55 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 61
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
basisfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 722
 BASISFUN:  Basis function for B-Spline

 Calling Sequence:
 
   N = basisfun(iv,uv,p,U)
   
    INPUT:
   
      iv - knot span  ( from FindSpan() )
      uv - parametric points
      p  - spline degree
      U  - knot sequence
   
    OUTPUT:
   
      N - Basis functions vector(numel(uv)*(p+1))
   
    Adapted from Algorithm A2.2 from 'The NURBS BOOK' pg70.

 Copyright (C) 2000 Mark Spink
 Copyright (C) 2007 Daniel Claxton
 Copyright (C) 2009 Carlo de Falco

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
 BASISFUN:  Basis function for B-Spline




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
basisfunder


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 745
 BASISFUNDER:  B-Spline Basis function derivatives.

 Calling Sequence:
 
   ders = basisfunder (ii, pl, uu, k, nd)

    INPUT:
   
      ii  - knot span index (see findspan)
      pl  - degree of curve
      uu  - parametric points
      k   - knot vector
      nd  - number of derivatives to compute

    OUTPUT:
   
      ders - ders(n, i, :) (i-1)-th derivative at n-th point
   
    Adapted from Algorithm A2.3 from 'The NURBS BOOK' pg72.

    Copyright (C) 2009,2011 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
 BASISFUNDER:  B-Spline Basis function derivatives.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
bspdegelev


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 703
 BSPDEGELEV:  Degree elevate a univariate B-Spline. 
 
 Calling Sequence:
 
   [ic,ik] = bspdegelev(d,c,k,t)
 
   INPUT:
 
   d - Degree of the B-Spline.
   c - Control points, matrix of size (dim,nc).
   k - Knot sequence, row vector of size nk.
   t - Raise the B-Spline degree t times.
 
   OUTPUT:

   ic - Control points of the new B-Spline. 
   ik - Knot vector of the new B-Spline.
 
    Copyright (C) 2000 Mark Spink, 2007 Daniel Claxton

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
 BSPDEGELEV:  Degree elevate a univariate B-Spline.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bspderiv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 766
 BSPDERIV:  B-Spline derivative.
 
  MATLAB SYNTAX:
 
         [dc,dk] = bspderiv(d,c,k)
  
  INPUT:
 
    d - degree of the B-Spline
    c - control points          double  matrix(mc,nc)
    k - knot sequence           double  vector(nk)
 
  OUTPUT:
 
    dc - control points of the derivative     double  matrix(mc,nc)
    dk - knot sequence of the derivative      double  vector(nk)
 
  Modified version of Algorithm A3.3 from 'The NURBS BOOK' pg98.

    Copyright (C) 2000 Mark Spink, 2007 Daniel Claxton

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
 BSPDERIV:  B-Spline derivative.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bspeval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 713
 BSPEVAL:  Evaluate B-Spline at parametric points.
 
 Calling Sequence:
 
   p = bspeval(d,c,k,u)
 
    INPUT:
 
       d - Degree of the B-Spline.
       c - Control Points, matrix of size (dim,nc).
       k - Knot sequence, row vector of size nk.
       u - Parametric evaluation points, row vector of size nu.
 
    OUTPUT:

       p - Evaluated points, matrix of size (dim,nu)
 
    Copyright (C) 2000 Mark Spink, 2007 Daniel Claxton, 2010 C. de Falco

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
 BSPEVAL:  Evaluate B-Spline at parametric points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
bspkntins


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 855
 BSPKNTINS:  Insert knots into a B-Spline

 Calling Sequence:
 
   [ic,ik] = bspkntins(d,c,k,u)

  INPUT:
 
    d - spline degree             integer
    c - control points            double  matrix(mc,nc)      
    k - knot sequence             double  vector(nk) 
    u - new knots                 double  vector(nu)               
 
  OUTPUT:
 
    ic - new control points double  matrix(mc,nc+nu) 
    ik - new knot sequence  double  vector(nk+nu)
 
  Modified version of Algorithm A5.4 from 'The NURBS BOOK' pg164.
 
    Copyright (C) 2000 Mark Spink, 2007 Daniel Claxton, 2010 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
 BSPKNTINS:  Insert knots into a B-Spline




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
curvederivcpts


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 970
 Compute control points of n-th derivatives of a B-spline curve.
 
 usage: pk = curvederivcpts (n, p, U, P, d) 
        pk = curvederivcpts (n, p, U, P, d, r1, r2) 

 If r1, r2 are not given, all the control points are computed.

  INPUT:
         n+1 = number of control points
         p   = degree of the spline
         d   = maximum derivative order (d<=p)
         U   = knots
         P   = control points
         r1  = first control point to compute
         r2  = auxiliary index for the last control point to compute
  OUTPUT:
         pk(k,i) = i-th control point of (k-1)-th derivative, r1 <= i <= r2-k

 Adaptation of algorithm A3.3 from the NURBS book, pg98.

    Copyright (C) 2009 Carlo de Falco

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
 Compute control points of n-th derivatives of a B-spline curve.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
curvederiveval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 754

 CURVEDERIVEVAL: Compute the derivatives of a B-spline curve.
 
 usage: ck = curvederiveval (n, p, U, P, u, d) 

  INPUT: 

        n+1 = number of control points
        p   = spline order
        U   = knots
        P   = control points
        u   = evaluation point
        d   = derivative order

  OUTPUT:

        ck (k+1) =  curve differentiated k times

 Adaptation of algorithm A3.4 from the NURBS book, pg99

    Copyright (C) 2009 Carlo de Falco
    Copyright (C) 2010 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62

 CURVEDERIVEVAL: Compute the derivatives of a B-spline curve.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
deg2rad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 696
 DEG2RAD: Convert degrees to radians.
 
 Calling Sequence:
 
   rad = deg2rad(deg);
 
 INPUT:
 
   deg		: Angle in degrees.

 OUTPUT:
 
   rad		: Angle in radians. 
 
 Description:
 
   Convenient utility function for converting degrees to radians, which are
   often the required angular units for functions in the NURBS toolbox.
 
 Examples:
 
   // Convert 35 degrees to radians
   rad = deg2rad(35);

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
 DEG2RAD: Convert degrees to radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
findspan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 634
 FINDSPAN  Find the span of a B-Spline knot vector at a parametric point

 Calling Sequence:
 
   s = findspan(n,p,u,U)
 
  INPUT:
 
    n - number of control points - 1
    p - spline degree
    u - parametric point
    U - knot sequence
 
  OUTPUT:
 
    s - knot span index

  Modification of Algorithm A2.1 from 'The NURBS BOOK' pg68

    Copyright (C) 2010 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
 FINDSPAN  Find the span of a B-Spline knot vector at a parametric point




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
kntbrkdegmult


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 917
 KNTBRKDEGMULT: Construct an open knot vector by giving the sequence of
                knots, the degree and the multiplicity.

   knots = kntbrkdegreg (breaks, degree)
   knots = kntbrkdegreg (breaks, degree, mult)

 INPUT:

     breaks:  sequence of knots.
     degree:  polynomial degree of the splines associated to the knot vector.
     mult:    multiplicity of the knots.

 OUTPUT:

     knots:  knot vector.

 If MULT has as many entries as BREAKS, or as the number of interior
   knots, a different multiplicity will be assigned to each knot. If
   MULT is not present, it will be taken equal to 1.

 Copyright (C) 2010 Carlo de Falco, Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 KNTBRKDEGMULT: Construct an open knot vector by giving the sequence of
        



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
kntbrkdegreg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 939
 KNTBRKDEGREG: Construct an open knot vector by giving the sequence of
                knots, the degree and the regularity.

   knots = kntbrkdegreg (breaks, degree)
   knots = kntbrkdegreg (breaks, degree, regularity)

 INPUT:

     breaks:     sequence of knots.
     degree:     polynomial degree of the splines associated to the knot vector.
     regularity: splines regularity.

 OUTPUT:

     knots:  knot vector.

 If REGULARITY has as many entries as BREAKS, or as the number of interior
   knots, a different regularity will be assigned to each knot. If
   REGULARITY is not present, it will be taken equal to DEGREE-1.

 Copyright (C) 2010 Carlo de Falco, Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 KNTBRKDEGREG: Construct an open knot vector by giving the sequence of
         



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
kntrefine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1327
 KNTREFINE: Refine a given knot vector by dividing each interval uniformly,
             maintaining the continuity in previously existing knots.

   [rknots]                  = kntrefine (knots, n_sub, degree, regularity)
   [rknots, zeta]            = kntrefine (knots, n_sub, degree, regularity)
   [rknots, zeta, new_knots] = kntrefine (knots, n_sub, degree, regularity)

 INPUT:

     knots:      initial knot vector.
     n_sub:      number of new knots to be added in each interval.
     degree:     polynomial degree of the refined knot vector
     regularity: maximum global regularity 

 OUTPUT:

     rknots:    refined knot vector
     zeta:      refined knot vector without repetitions
     new_knots: new knots, to apply the knot insertion

 The regularity at the new inserted knots is the one given by the user.
 At previously existing knots, the regularity is the minimum
  between the previous regularity, and the one given by the user.
  This ensures optimal convergence rates in the context of IGA.

 Copyright (C) 2010 Carlo de Falco, Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 KNTREFINE: Refine a given knot vector by dividing each interval uniformly,
    



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
kntuniform


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 716
 KNTUNIFORM: generate uniform open knot vectors in the reference domain.

   [csi, zeta] = kntuniform (num, degree, regularity)

 INPUT:
     
     num:        number of breaks (in each direction)
     degree:     polynomial degree (in each direction)
     regularity: global regularity (in each direction)

 OUTPUT:

     csi:  knots
     zeta: breaks = knots without repetitions
 
 Copyright (C) 2009, 2010 Carlo de Falco
 Copyright (C) 2011 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
 KNTUNIFORM: generate uniform open knot vectors in the reference domain.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nrb4surf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1088
 
 NRB4SURF: Constructs a NURBS bilinear surface.
 
 Calling Sequence:
 
   srf = nrb4surf(p11,p12,p21,p22)
 
 INPUT:
 
   p11		: Cartesian coordinate of the lhs bottom corner point.
 
   p12		: Cartesian coordinate of the rhs bottom corner point.
 
   p21		: Cartesian coordinate of the lhs top corner point.
  
   p22		: Cartesian coordinate of the rhs top corner point.

 OUTPUT:
 
   srf		: NURBS bilinear surface, see nrbmak. 
 
 Description:
 
   Constructs a bilinear surface defined by four coordinates.
 
   The position of the corner points
 
          ^ V direction
          |
          ----------------
          |p21        p22|
          |              |
          |    SRF       |
          |              |
          |p11        p12|
          -------------------> U direction
 

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
 
 NRB4SURF: Constructs a NURBS bilinear surface.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
nrbbasisfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 974
 NRBBASISFUN: Basis functions for NURBS

 Calling Sequence:
 
    B     = nrbbasisfun (u, crv)
    B     = nrbbasisfun ({u, v}, srf)
   [B, N] = nrbbasisfun ({u, v}, srf)
   [B, N] = nrbbasisfun (p, srf)

    INPUT:
   
      u or p(1,:,:)  - parametric points along u direction
      v or p(2,:,:)  - parametric points along v direction
      crv - NURBS curve
      srf - NURBS surface
   
    OUTPUT:
   
      B - Value of the basis functions at the points
          size(B)=[numel(u),(p+1)] for curves
          or [numel(u)*numel(v), (p+1)*(q+1)] for surfaces

      N - Indices of the basis functions that are nonvanishing at each
          point. size(N) == size(B)
   

    Copyright (C) 2009 Carlo de Falco

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
 NRBBASISFUN: Basis functions for NURBS




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
nrbbasisfunder


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1227
 NRBBASISFUNDER:  NURBS basis functions derivatives

 Calling Sequence:
 
   Bu          = nrbbasisfunder (u, crv)
   [Bu, N]     = nrbbasisfunder (u, crv)
   [Bu, Bv]    = nrbbasisfunder ({u, v}, srf)
   [Bu, Bv, N] = nrbbasisfunder ({u, v}, srf)
   [Bu, Bv, N] = nrbbasisfunder (p, srf)

    INPUT:
   
      u or p(1,:,:)  - parametric points along u direction
      v or p(2,:,:)  - parametric points along v direction
      crv - NURBS curve
      srf - NURBS surface
   
    OUTPUT:
   
      Bu - Basis functions derivatives WRT direction u
           size(Bu)=[numel(u),(p+1)] for curves
           or [numel(u)*numel(v), (p+1)*(q+1)] for surfaces

      Bv - Basis functions derivatives WRT direction v
           size(Bv)=[numel(v),(p+1)] for curves
           or [numel(u)*numel(v), (p+1)*(q+1)] for surfaces

      N - Indices of the basis functions that are nonvanishing at each
          point. size(N) == size(B)
   
    Copyright (C) 2009 Carlo de Falco

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
 NRBBASISFUNDER:  NURBS basis functions derivatives




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nrbcirc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 999
 
 NRBCIRC: Construct a circular arc.
 
 Calling Sequence:
 
   crv = nrbcirc()
   crv = nrbcirc(radius)
   crv = nrbcirc(radius,center)
   crv = nrbcirc(radius,center,sang,eang)
 
 INPUT:
 
   radius	: Radius of the circle, default 1.0
 
   center	: Center of the circle, default (0,0,0)
 
   sang	: Start angle, default 0 radians (0 degrees)
 
   eang	: End angle, default 2*pi radians (360 degrees)
 
 OUTPUT:

   crv		: NURBS curve for a circular arc.
 
 Description:
 
   Constructs NURBS data structure for a circular arc in the x-y plane. If
   no rhs arguments are supplied a unit circle with center (0.0,0.0) is
   constructed. 
 
   Angles are defined as positive in the anti-clockwise direction.

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
 
 NRBCIRC: Construct a circular arc.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nrbcoons


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2143
 
 NRBCOONS: Construction of a Coons patch.
 
 Calling Sequence:
 
   srf = nrbcoons(ucrv1, ucrv2, vcrv1, vcrv2)
 
 INPUT:
 
   ucrv1	: NURBS curve defining the bottom U direction boundary of
 		the constructed NURBS surface.
 
   ucrv2	: NURBS curve defining the top U direction boundary of
 		the constructed NURBS surface.
 
   vcrv1	: NURBS curve defining the bottom V direction boundary of
 		the constructed NURBS surface.
 
   vcrv2	: NURBS curve defining the top V direction boundary of
 		the constructed NURBS surface.

 OUTPUT:
 
   srf		: Coons NURBS surface patch.
 
 Description:
 
   Construction of a bilinearly blended Coons surface patch from four NURBS
   curves that define the boundary.
 
   The orientation of the four NURBS boundary curves.
 
          ^ V direction
          |
          |     ucrv2
          ------->--------
          |              |
          |              |
    vcrv1 ^   Surface    ^ vcrv2
          |              |
          |              |
          ------->-----------> U direction
                ucrv1
 
 
 Examples:
 
   // Define four NURBS curves and construct a Coons surface patch.
   pnts = [ 0.0  3.0  4.5  6.5 8.0 10.0;
            0.0  0.0  0.0  0.0 0.0  0.0; 
            2.0  2.0  7.0  4.0 7.0  9.0];   
   crv1 = nrbmak(pnts, [0 0 0 1/3 0.5 2/3 1 1 1]);
 
   pnts= [ 0.0  3.0  5.0  8.0 10.0;
           10.0 10.0 10.0 10.0 10.0;
           3.0  5.0  8.0  6.0 10.0];
   crv2 = nrbmak(pnts, [0 0 0 1/3 2/3 1 1 1]);
 
   pnts= [ 0.0 0.0 0.0 0.0;
           0.0 3.0 8.0 10.0;
           2.0 0.0 5.0 3.0];
   crv3 = nrbmak(pnts, [0 0 0 0.5 1 1 1]);
 
   pnts= [ 10.0 10.0 10.0 10.0 10.0;
           0.0   3.0  5.0  8.0 10.0;
           9.0   7.0  7.0 10.0 10.0];
   crv4 = nrbmak(pnts, [0 0 0 0.25 0.75 1 1 1]);
 
   srf = nrbcoons(crv1, crv2, crv3, crv4);
   nrbplot(srf,[20 20],220,45);

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
 
 NRBCOONS: Construction of a Coons patch.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
nrbcrvderiveval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 753

 NRBCRVDERIVEVAL: Evaluate n-th order derivatives of a NURBS curve.

 usage: skl = nrbcrvderiveval (crv, u, d) 

   INPUT:

   crv : NURBS curve structure, see nrbmak

   u   : parametric coordinate of the points where we compute the derivatives

   d   : number of partial derivatives to compute


   OUTPUT: 

   ck (i, j, l) = i-th component derived j-1 times at the l-th point.

 Adaptation of algorithm A4.2 from the NURBS book, pg127

    Copyright (C) 2010 Carlo de Falco, Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68

 NRBCRVDERIVEVAL: Evaluate n-th order derivatives of a NURBS curve.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
nrbctrlplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 662
 NRBCTRLPLOT: Plot a NURBS entity along with its control points.
 
 Calling Sequence:
 
   nrbctrlplot (nurbs)
 
 INPUT:
 
   nurbs: NURBS curve or surface, see nrbmak.
 
 Example:

   Plot the test curve and test surface with their control polygon and
    control net, respectively

   nrbctrlplot(nrbtestcrv)
   nrbctrlplot(nrbtestsrf)

 See also:
 
   nrbkntplot

    Copyright (C) 2011 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
 NRBCTRLPLOT: Plot a NURBS entity along with its control points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
nrbcylind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 988
 
 NRBCYLIND: Construct a cylinder or cylindrical patch.
 
 Calling Sequence:
 
   srf = nrbcylind()
   srf = nrbcylind(height)
   srf = nrbcylind(height,radius)
   srf = nrbcylind(height,radius,center)
   srf = nrbcylind(height,radius,center,sang,eang)
 
 INPUT:
 
   height	: Height of the cylinder along the axis, default 1.0
 
   radius	: Radius of the cylinder, default 1.0
 
   center	: Center of the cylinder, default (0,0,0)
 
   sang	: Start angle relative to the origin, default 0.
 
   eang	: End angle relative to the origin, default 2*pi.

 OUTPUT: 

   srf     : cylindrical surface patch 
 
 Description:
 
   Construct a cylinder or cylindrical patch by extruding a circular arc.

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
 
 NRBCYLIND: Construct a cylinder or cylindrical patch.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
nrbdegelev


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1358
 
 NRBDEGELEV: Elevate the degree of the NURBS curve, surface or volume.
 
 Calling Sequence:
 
   ecrv = nrbdegelev(crv,utimes);
   esrf = nrbdegelev(srf,[utimes,vtimes]);
   evol = nrbdegelev(vol,[utimes,vtimes,wtimes]);
 
 INPUT:
 
   crv		: NURBS curve, see nrbmak.
 
   srf		: NURBS surface, see nrbmak.
 
   vol		: NURBS volume, see nrbmak.
 
   utimes	: Increase the degree along U direction utimes.
 
   vtimes	: Increase the degree along V direction vtimes.
 
   wtimes	: Increase the degree along W direction vtimes.

 OUTPUT:

   ecrv	: new NURBS structure for a curve with degree elevated.
 
   esrf	: new NURBS structure for a surface with degree elevated.
 
   evol	: new NURBS structure for a volume with degree elevated.
 
 
 Description:
 
   Degree elevates the NURBS curve or surface. This function uses the
   B-Spline function bspdegelev, which interface to an internal 'C'
   routine.
 
 Examples:
 
   Increase the NURBS surface twice along the V direction.
   esrf = nrbdegelev(srf, [0, 2]); 
 
 See also:
 
   bspdegelev

    Copyright (C) 2000 Mark Spink, 2010 Rafel Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
 
 NRBDEGELEV: Elevate the degree of the NURBS curve, surface or volume.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nrbderiv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1370
 
 NRBDERIV: Construct the first and second derivative representation of a
           NURBS curve, surface or volume.
 
 Calling Sequence:
 
   ders = nrbderiv (nrb);
   [ders, ders2] = nrbderiv (nrb);
 
 INPUT:
 
   nrb		: NURBS data structure, see nrbmak.

 OUTPUT:
 
   ders:  A data structure that represents the first
 		    derivatives of a NURBS curve, surface or volume.
   ders2: A data structure that represents the second
 		    derivatives of a NURBS curve, surface or volume.
 
 Description:
 
   The derivatives of a B-Spline are themselves a B-Spline of lower degree,
   giving an efficient means of evaluating multiple derivatives. However,
   although the same approach can be applied to NURBS, the situation for
   NURBS is more complex. We have followed in this function the same idea
   that was already used for the first derivative in the function nrbderiv.
   The second derivative data structure can be evaluated later with the
   function nrbdeval.
 
 See also:
 
       nrbdeval

 Copyright (C) 2000 Mark Spink
 Copyright (C) 2010 Carlo de Falco
 Copyright (C) 2010, 2011 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 
 NRBDERIV: Construct the first and second derivative representation of a
     



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nrbdeval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1418
 NRBDEVAL: Evaluation of the derivative and second derivatives of NURBS curve, surface or volume.

     [pnt, jac] = nrbdeval (crv, dcrv, tt)
     [pnt, jac] = nrbdeval (srf, dsrf, {tu tv})
     [pnt, jac] = nrbdeval (vol, dvol, {tu tv tw})
     [pnt, jac, hess] = nrbdeval (crv, dcrv, dcrv2, tt)
     [pnt, jac, hess] = nrbdeval (srf, dsrf, dsrf2, {tu tv})
     [pnt, jac, hess] = nrbdeval (vol, dvol, {tu tv tw})

 INPUTS:

   crv,   srf,   vol   - original NURBS curve, surface or volume.
   dcrv,  dsrf,  dvol  - NURBS derivative representation of crv, srf 
                          or vol (see nrbderiv2)
   dcrv2, dsrf2, dvol2 - NURBS second derivative representation of crv,
                          srf or vol (see nrbderiv2)
   tt     - parametric evaluation points
            If the nurbs is a surface or a volume then tt is a cell
            {tu, tv} or {tu, tv, tw} are the parametric coordinates

 OUTPUT:

   pnt  - evaluated points.
   jac  - evaluated first derivatives (Jacobian).
   hess - evaluated second derivatives (Hessian).

 Copyright (C) 2000 Mark Spink 
 Copyright (C) 2010 Carlo de Falco
 Copyright (C) 2010, 2011 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 NRBDEVAL: Evaluation of the derivative and second derivatives of NURBS curve, s



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nrbeval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1803
 
 NRBEVAL: Evaluate a NURBS at parametric points.
 
 Calling Sequences:
 
   [p,w] = nrbeval(crv,ut)
   [p,w] = nrbeval(srf,{ut,vt})
   [p,w] = nrbeval(vol,{ut,vt,wt})
   [p,w] = nrbeval(srf,pts)
 
 INPUT:
 
   crv		: NURBS curve, see nrbmak.
 
   srf		: NURBS surface, see nrbmak.

   vol		: NURBS volume, see nrbmak.
 
   ut		: Parametric evaluation points along U direction.

   vt		: Parametric evaluation points along V direction.
 
   wt		: Parametric evaluation points along W direction.

   pts     : Array of scattered points in parametric domain
 
 OUTPUT:

   p		: Evaluated points on the NURBS curve, surface or volume as 
 		Cartesian coordinates (x,y,z). If w is included on the lhs argument
 		list the points are returned as homogeneous coordinates (wx,wy,wz).
 
   w		: Weights of the homogeneous coordinates of the evaluated
 		points. Note inclusion of this argument changes the type 
 		of coordinates returned in p (see above).
 
 Description:
 
   Evaluation of NURBS curves, surfaces or volume at parametric points along  
   the U, V and W directions. Either homogeneous coordinates are returned
   if the weights are requested in the lhs arguments, or as Cartesian coordinates.
   This function utilises the 'C' interface bspeval.
 
 Examples:
 
   Evaluate the NURBS circle at twenty points from 0.0 to 1.0
 
   nrb = nrbcirc;
   ut = linspace(0.0,1.0,20);
   p = nrbeval(nrb,ut);
 
 See also:
  
     bspeval

 Copyright (C) 2000 Mark Spink 
 Copyright (C) 2010 Carlo de Falco
 Copyright (C) 2010, 2011 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
 
 NRBEVAL: Evaluate a NURBS at parametric points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
nrbexport


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 690

 NRBEXPORT: export NURBS geometries to a format compatible with the one used in GeoPDEs (version 0.6).
 
 Calling Sequence:
 
   nrbexport (nurbs, filename);
 
 INPUT:
 
   nurbs    : NURBS curve, surface or volume, see nrbmak.
   filename : name of the output file.
 
 
 Description:
 
   The data of the nurbs structure is written in the file, in a format 
     that can be read by GeoPDEs.

    Copyright (C) 2011 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

 NRBEXPORT: export NURBS geometries to a format compatible with the one used in



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
nrbextract


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1011

 NRBEXTRACT: construct NURBS curves by extracting the boundaries of a NURBS surface, or NURBS surfaces by extracting the boundary of a NURBS volume.
 
 Calling Sequence:
 
   crvs = nrbextract(surf);
 
 INPUT:
 
   surf        : NURBS surface or volume, see nrbmak.
 
 OUTPUT: 
 
   crvs        : array of NURBS curves or NURBS surfaces extracted.
 
 Description:
 
  Constructs either an array of four NURBS curves, by extracting the boundaries
  of a NURBS surface, or an array of six surfaces, by extracting the boundaries
  of a NURBS volume. The new entities are ordered in the following way

    1: U = 0
    2: U = 1
    3: V = 0
    4: V = 1
    5: W = 0 (only for volumes)
    6: W = 1 (only for volumes)

    Copyright (C) 2010 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

 NRBEXTRACT: construct NURBS curves by extracting the boundaries of a NURBS sur



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
nrbextrude


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1243

 NRBEXTRUDE: Construct a NURBS surface by extruding a NURBS curve, or 
  construct a NURBS volume by extruding a NURBS surface.
 
 Calling Sequence:
 
   srf = nrbextrude(crv,vec);
 
 INPUT:
 
   crv		: NURBS curve or surface to extrude, see nrbmak.
 
   vec		: Vector along which the entity is extruded.

 OUTPUT: 
 
   srf		: NURBS surface or volume constructed.
 
 Description:
 
   Constructs either a NURBS surface by extruding a NURBS curve along a  
   defined vector, or a NURBS volume by extruding a NURBS surface. In the 
   first case, the NURBS curve forms the U direction of the surface edge, and
   is extruded along the vector in the V direction. In the second case, the 
   original surface forms the U and V direction of the volume, and is extruded
   along the W direction.

 Examples:
 
   Form a hollow cylinder by extruding a circle along the z-axis.

   srf = nrbextrude(nrbcirc, [0,0,1]);

    Copyright (C) 2000 Mark Spink
    Copyright (C) 2010 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

 NRBEXTRUDE: Construct a NURBS surface by extruding a NURBS curve, or 
  constr



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
nrbkntins


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1961
 
 NRBKNTINS: Insert a single or multiple knots into a NURBS curve,
            surface or volume.
 
 Calling Sequence:
 
   icrv = nrbkntins(crv,iuknots);
   isrf = nrbkntins(srf,{iuknots ivknots});
   ivol = nrbkntins(vol,{iuknots ivknots iwknots});
 
 INPUT:
 
   crv		: NURBS curve, see nrbmak.
 
   srf		: NURBS surface, see nrbmak.
 
   srf		: NURBS volume, see nrbmak.
 
   iuknots	: Knots to be inserted along U direction.
 
   ivknots	: Knots to be inserted along V direction.
 
   iwknots	: Knots to be inserted along W direction.
 
 OUTPUT:
 
   icrv	: new NURBS structure for a curve with knots inserted.
 
   isrf	: new NURBS structure for a surface with knots inserted.
 
   ivol	: new NURBS structure for a volume with knots inserted.
 
 Description:
 
   Inserts knots into the NURBS data structure, these can be knots at
   new positions or at the location of existing knots to increase the
   multiplicity. Note that the knot multiplicity cannot be increased
   beyond the order of the spline. Knots along the V direction can only
   inserted into NURBS surfaces, not curve that are always defined along
   the U direction. This function use the B-Spline function bspkntins,
   which interfaces to an internal 'C' routine.
 
 Examples:
 
   Insert two knots into a curve, one at 0.3 and another
   twice at 0.4

   icrv = nrbkntins(crv, [0.3 0.4 0.4])
 
   Insert into a surface two knots as (1) into the U knot
   sequence and one knot into the V knot sequence at 0.5.

   isrf = nrbkntins(srf, {[0.3 0.4 0.4] [0.5]})
 
 See also:
 
   bspkntins

 Note:

   No knot multiplicity will be increased beyond the order of the spline.

    Copyright (C) 2000 Mark Spink, 2010 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 
 NRBKNTINS: Insert a single or multiple knots into a NURBS curve,
            



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
nrbkntplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 582
 NRBKNTPLOT: Plot a NURBS entity with the knots subdivision.
 
 Calling Sequence:
 
   nrbkntplot(nurbs)
 
 INPUT:
 
   nurbs: NURBS curve, surface or volume, see nrbmak.
 
 Example:

   Plot the test surface with its knot vector

   nrbkntplot(nrbtestsrf)

 See also:
 
   nrbctrlplot

    Copyright (C) 2011 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
 NRBKNTPLOT: Plot a NURBS entity with the knots subdivision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nrbline


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 762
 
 NRBLINE: Construct a straight line.
 
 Calling Sequence:
 
   crv = nrbline()
   crv = nrbline(p1,p2)
 
 INPUT:
 
 p1		: 2D or 3D cartesian coordinate of the start point.
 
 p2            : 2D or 3D cartesian coordinate of the end point.

 OUTPUT:
 
 crv		: NURBS curve for a straight line.
 
 Description:
 
   Constructs NURBS data structure for a straight line. If no rhs 
   coordinates are included the function returns a unit straight
   line along the x-axis.

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
 
 NRBLINE: Construct a straight line.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
nrbmak


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3867

 NRBMAK: Construct the NURBS structure given the control points
            and the knots.
 
 Calling Sequence:
 
   nurbs   = nrbmak(cntrl,knots);
 
 INPUT:
 
   cntrl       : Control points, these can be either Cartesian or
 		homogeneous coordinates.
 
 		For a curve the control points are represented by a
 		matrix of size (dim,nu), for a surface a multidimensional
 		array of size (dim,nu,nv), for a volume a multidimensional array
 		of size (dim,nu,nv,nw). Where nu is number of points along
 		the parametric U direction, nv the number of points along
 		the V direction and nw the number of points along the W direction. 
 		dim is the dimension. Valid options
 		are
 		2 .... (x,y)        2D Cartesian coordinates
 		3 .... (x,y,z)      3D Cartesian coordinates
 		4 .... (wx,wy,wz,w) 4D homogeneous coordinates
 
   knots	: Non-decreasing knot sequence spanning the interval
               [0.0,1.0]. It's assumed that the geometric entities
               are clamped to the start and end control points by knot
               multiplicities equal to the spline order (open knot vector).
               For curve knots form a vector and for surfaces (volumes)
               the knots are stored by two (three) vectors for U and V (and W)
               in a cell structure {uknots vknots} ({uknots vknots wknots}).
               
 OUTPUT:
 
   nurbs 	: Data structure for representing a NURBS entity
 
 NURBS Structure:
 
   Both curves and surfaces are represented by a structure that is
   compatible with the Spline Toolbox from Mathworks
 
 	nurbs.form   .... Type name 'B-NURBS'
 	nurbs.dim    .... Dimension of the control points
 	nurbs.number .... Number of Control points
       nurbs.coefs  .... Control Points
       nurbs.order  .... Order of the spline
       nurbs.knots  .... Knot sequence
 
   Note: the control points are always converted and stored within the
   NURBS structure as 4D homogeneous coordinates. A curve is always stored 
   along the U direction, and the vknots element is an empty matrix. For
   a surface the spline order is a vector [du,dv] containing the order
   along the U and V directions respectively. For a volume the order is
   a vector [du dv dw]. Recall that order = degree + 1.
 
 Description:
 
   This function is used as a convenient means of constructing the NURBS
   data structure. Many of the other functions in the toolbox rely on the 
   NURBS structure been correctly defined as shown above. The nrbmak not
   only constructs the proper structure, but also checks for consistency.
   The user is still free to build his own structure, in fact a few
   functions in the toolbox do this for convenience.
 
 Examples:
 
   Construct a 2D line from (0.0,0.0) to (1.5,3.0).
   For a straight line a spline of order 2 is required.
   Note that the knot sequence has a multiplicity of 2 at the
   start (0.0,0.0) and end (1.0 1.0) in order to clamp the ends.
 
   line = nrbmak([0.0 1.5; 0.0 3.0],[0.0 0.0 1.0 1.0]);
   nrbplot(line, 2);
 
   Construct a surface in the x-y plane i.e
     
     ^  (0.0,1.0) ------------ (1.0,1.0)
     |      |                      |
     | V    |                      |
     |      |      Surface         |
     |      |                      |
     |      |                      |
     |  (0.0,0.0) ------------ (1.0,0.0)
     |
     |------------------------------------>
                                       U 

   coefs = cat(3,[0 0; 0 1],[1 1; 0 1]);
   knots = {[0 0 1 1]  [0 0 1 1]}
   plane = nrbmak(coefs,knots);
   nrbplot(plane, [2 2]);

    Copyright (C) 2000 Mark Spink, 2010 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

 NRBMAK: Construct the NURBS structure given the control points
            and



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
nrbnumbasisfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 797

 NRBNUMBASISFUN:  Numbering of basis functions for NURBS

 Calling Sequence:
 
   N      = nrbnumbasisfun (u, crv)
   N      = nrbnumbasisfun ({u, v}, srf)
   N      = nrbnumbasisfun (p, srf)

    INPUT:
   
      u or p(1,:,:)  - parametric points along u direction
      v or p(2,:,:)  - parametric points along v direction
      crv - NURBS curve
      srf - NURBS surface
   
    OUTPUT:

      N - Indices of the basis functions that are nonvanishing at each
          point. size(N) == size(B)

    Copyright (C) 2009 Carlo de Falco

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58

 NRBNUMBASISFUN:  Numbering of basis functions for NURBS




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nrbplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1117
 
 NRBPLOT: Plot a NURBS curve or surface, or the boundary of a NURBS volume.
 
 Calling Sequence:
 
   nrbplot (nrb, subd)
   nrbplot (nrb, subd, p, v)
 
 INPUT:
 
   nrb		: NURBS curve, surface or volume, see nrbmak.
 
   npnts	: Number of evaluation points, for a surface or volume, a row 
       vector with the number of points along each direction.
 
   [p,v]       : property/value options

               Valid property/value pairs include:

               Property        Value/{Default}
               -----------------------------------
               light           {off} | on
               colormap        {'copper'}

 Example:

   Plot the test surface with 20 points along the U direction
   and 30 along the V direction

   nrbplot(nrbtestsrf, [20 30])

    Copyright (C) 2000 Mark Spink
    Copyright (C) 2010 Carlo de Falco, Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
 
 NRBPLOT: Plot a NURBS curve or surface, or the boundary of a NURBS volume.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nrbrect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 854
 
 NRBRECT: Construct NURBS representation of a rectangular curve.
 
 Calling Sequence:
 
   crv = nrbrect()
   crv = nrbrect(size)
   crv = nrbrect(width, height)
 
 INPUT:
 
   size	: Size of the square (width = height).
 
   width	: Width of the rectangle (along x-axis).
 
   height	: Height of the rectangle (along y-axis).

 OUTPUT:

   crv		: NURBS curve, see nrbmak. 
  
 
 Description:
 
   Construct a rectangle or square in the x-y plane with the bottom
   lhs corner at (0,0,0). If no rhs arguments provided the function
   constructs a unit square.

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
 
 NRBRECT: Construct NURBS representation of a rectangular curve.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
nrbreverse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 618

 NRBREVERSE: Reverse the evaluation direction of a NURBS curve or surface.
 
 Calling Sequence:
 
   rnrb = nrbreverse(nrb);
 
 INPUT:
 
   nrb		: NURBS data structure, see nrbmak.

 OUTPUT:
 
   rnrb	: Reversed NURBS.
 
 Description:
 
   Utility function to reverse the evaluation direction of a NURBS
   curve or surface.

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75

 NRBREVERSE: Reverse the evaluation direction of a NURBS curve or surface.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
nrbrevolve


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1710
 
 NRBREVOLVE: Construct a NURBS surface by revolving a NURBS curve, or
  construct a NURBS volume by revolving a NURBS surface.
 
 Calling Sequence:
 
   srf = nrbrevolve(crv,pnt,vec[,ang])
 
 INPUT:
 
   crv		: NURBS curve or surface to revolve, see nrbmak.
 
   pnt		: Coordinates of the point used to define the axis
               of rotation.
 
   vec		: Vector defining the direction of the rotation axis.
 
   ang		: Angle to revolve the curve, default 2*pi

 OUTPUT:

   srf		: constructed surface or volume
 
 Description:
 
   Construct a NURBS surface by revolving the profile NURBS curve around
   an axis defined by a point and vector.
 
 Examples:
 
   Construct a sphere by rotating a semicircle around a x-axis.

   crv = nrbcirc(1.0,[0 0 0],0,pi);
   srf = nrbrevolve(crv,[0 0 0],[1 0 0]);
   nrbplot(srf,[20 20]);

 NOTE:

   The algorithm:

     1) vectrans the point to the origin (0,0,0)
     2) rotate the vector into alignment with the z-axis

     for each control point along the curve

     3) determine the radius and angle of control
        point to the z-axis
     4) construct a circular arc in the x-y plane with 
        this radius and start angle and sweep angle theta 
     5) combine the arc and profile, coefs and weights.
  
     next control point

     6) rotate and vectrans the surface back into position
        by reversing 1 and 2.


    Copyright (C) 2000 Mark Spink
    Copyright (C) 2010 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 
 NRBREVOLVE: Construct a NURBS surface by revolving a NURBS curve, or
  constr



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nrbruled


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 892
 NRBRULED: Construct a ruled surface between two NURBS curves.
 
 Calling Sequence:
 
   srf = nrbruled(crv1, crv2)
 
 INPUT:
 
   crv1	: First NURBS curve, see nrbmak.
 
   crv2	: Second NURBS curve, see nrbmak.

 OUTPUT:
 
   srf		: Ruled NURBS surface.
 
 Description:
 
   Constructs a ruled surface between two NURBS curves. The ruled surface is
   ruled along the V direction.
 
 Examples:
 
   Construct a ruled surface between a semicircle and a straight line.
 
   cir = nrbcirc(1,[0 0 0],0,pi);
   line = nrbline([-1 0.5 1],[1 0.5 1]);
   srf = nrbruled(cir,line);
   nrbplot(srf,[20 20]);

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
 NRBRULED: Construct a ruled surface between two NURBS curves.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
nrbsurfderiveval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 772

 NRBSURFDERIVEVAL: Evaluate n-th order derivatives of a NURBS surface

 usage: skl = nrbsurfderiveval (srf, [u; v], d) 

   INPUT:

   srf   : NURBS surface structure, see nrbmak

   u, v  : parametric coordinates of the point where we compute the
      derivatives

   d     : number of partial derivatives to compute


   OUTPUT: 

   skl (i, j, k, l) = i-th component derived j-1,k-1 times at the
     l-th point.

 Adaptation of algorithm A4.4 from the NURBS book, pg137

    Copyright (C) 2009 Carlo de Falco

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71

 NRBSURFDERIVEVAL: Evaluate n-th order derivatives of a NURBS surface




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
nrbtestcrv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 338
 NRBTESTCRV: Constructs a simple test curve. 

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
 NRBTESTCRV: Constructs a simple test curve.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
nrbtestsrf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 339
 NRBTESTSRF: Constructs a simple test surface.

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
 NRBTESTSRF: Constructs a simple test surface.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nrbtform


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1287
 
 NRBTFORM: Apply transformation matrix to the NURBS.
 
 Calling Sequence:
 
   tnurbs = nrbtform(nurbs,tmatrix);
 
 INPUT:
 
   nurbs	: NURBS data structure (see nrbmak for details).
 
   tmatrix     : Transformation matrix, a matrix of size (4,4) defining
                 a single or multiple transformations.

 OUTPUT:

   tnurbs	: The return transformed NURBS data structure.
 
 Description:
 
   The NURBS is transform as defined a transformation matrix of size (4,4),
   such as a rotation, translation or change in scale. The transformation
   matrix can define a single transformation or multiple series of
   transformations. The matrix can be simple constructed by the functions
   vecscale, vectrans, vecrotx, vecroty, and vecrotz.
     
 Examples:
 
   Rotate a square by 45 degrees about the z axis.

   rsqr = nrbtform(nrbrect(), vecrotz(deg2rad(45)));
   nrbplot(rsqr, 1000);
 
 See also:
 
   vecscale, vectrans, vecrotx, vecroty, vecrotz

    Copyright (C) 2000 Mark Spink
    Copyright (C) 2010 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
 
 NRBTFORM: Apply transformation matrix to the NURBS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
nrbtransp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 673
 
 NRBTRANSP: Transpose a NURBS surface, by swapping U and V directions.
 
 Calling Sequence:
 
   tsrf = nrbtransp(srf)

 INPUT:
 
   srf		: NURBS surface, see nrbmak.

 OUTPUT:
 
   tsrf	: NURBS surface with U and V diretions transposed.
 
 Description:
 
   Utility function that transposes a NURBS surface, by swapping U and
   V directions. NURBS curves cannot be transposed.

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
 
 NRBTRANSP: Transpose a NURBS surface, by swapping U and V directions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
numbasisfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 626
 NUMBASISFUN:  List non-zero Basis functions for B-Spline in a given knot-span

 Calling Sequence:
 
   N = numbasisfun(i,u,p,U)
   
    INPUT:
   
      i - knot span  ( from FindSpan() )
      u - parametric point
      p - spline degree
      U - knot sequence
   
    OUTPUT:
   
      N - Basis functions (numel(u)x(p+1))
   
    Copyright (C) 2009 Carlo de Falco

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
 NUMBASISFUN:  List non-zero Basis functions for B-Spline in a given knot-span




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rad2deg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 697
 
 RAD2DEG: Convert radians to degrees.
 
 Calling Sequence:
 
   rad = rad2deg(deg);
 
 INPUT:
 
   rad		: Angle in radians.

 OUTPUT:

   deg		: Angle in degrees.
 
 Description:
 
   Convenient utility function for converting radians to degrees, which are
   often the required angular units for functions in the NURBS toolbox.
 
 Examples:
 
   Convert 0.3 radians to degrees
 
   rad = deg2rad(0.3);

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
 
 RAD2DEG: Convert radians to degrees.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
surfderivcpts


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 933

 SURFDERIVCPTS: Compute control points of n-th derivatives of a NURBS surface.
 
 usage: pkl = surfderivcpts (n, p, U, m, q, V, P, d) 

  INPUT: 

        n+1, m+1 = number of control points
        p, q     = spline order
        U, V     = knots
        P        = control points
        d        = derivative order

  OUTPUT:

        pkl (k+1, l+1, i+1, j+1) = i,jth control point
                                   of the surface differentiated k
                                   times in the u direction and l
                                   times in the v direction

 Adaptation of algorithm A3.7 from the NURBS book, pg114

    Copyright (C) 2009 Carlo de Falco

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79

 SURFDERIVCPTS: Compute control points of n-th derivatives of a NURBS surface.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
surfderiveval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 870

 SURFDERIVEVAL: Compute the derivatives of a B-spline surface
 
 usage: skl = surfderiveval (n, p, U, m, q, V, P, u, v, d) 

  INPUT: 

        n+1, m+1 = number of control points
        p, q     = spline order
        U, V     = knots
        P        = control points
        u,v      = evaluation points
        d        = derivative order

  OUTPUT:

        skl (k+1, l+1) =  surface differentiated k
                          times in the u direction and l
                          times in the v direction

 Adaptation of algorithm A3.8 from the NURBS book, pg115

    Copyright (C) 2009 Carlo de Falco

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

 SURFDERIVEVAL: Compute the derivatives of a B-spline surface
 
 usage: skl = s



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
tbasisfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 925

 TBASISFUN: Compute a B- or T-Spline basis function, and its derivatives, from its local knot vector.

 usage:

 [N, Nder] = tbasisfun (u, p, U)
 [N, Nder] = tbasisfun ([u; v], [p q], {U, V})
 [N, Nder] = tbasisfun ([u; v; w], [p q r], {U, V, W})
 
 INPUT:

  u or [u; v] : points in parameter space where the basis function is to be
  evaluated 
  
  U or {U, V} : local knot vector

 p or [p q] : polynomial order of the basis function

 OUTPUT:

  N    : basis function evaluated at the given parametric points 
  Nder : basis function gradient evaluated at the given parametric points 

    Copyright (C) 2009 Carlo de Falco
    Copyright (C) 2012 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

 TBASISFUN: Compute a B- or T-Spline basis function, and its derivatives, from 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
vecangle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 920
 
 VECANGLE: An alternative to atan, returning an arctangent in the 
             range 0 to 2*pi.
 
 Calling Sequence:
 
   ang = vecmag2(num,dum)
 
 INPUT:
 
   num		: Numerator, vector of size (1,nv).
   dem		: Denominator, vector of size (1,nv).

 OUTPUT:
   ang		: Arctangents, row vector of angles.
 
 Description:
 
   The components of the vector ang are the arctangent of the corresponding
   enties of num./dem. This function is an alternative for 
   atan, returning an angle in the range 0 to 2*pi.
 
 Examples:
 
   Find the atan(1.2,2.0) and atan(1.5,3.4) using vecangle
 
   ang = vecangle([1.2 1.5], [2.0 3.4]);

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 
 VECANGLE: An alternative to atan, returning an arctangent in the 
           



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
veccross


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 967
 
 VECCROSS: The cross product of two vectors.
 
 Calling Sequence:
 
   cross = veccross(vec1,vec2);
 
 INPUT:
 
   vec1	: An array of column vectors represented by a matrix of
   vec2	size (dim,nv), where is the dimension of the vector and
 		nv the number of vectors.

 OUTPUT:
 
   cross	: Array of column vectors, each element is corresponding
 		to the cross product of the respective components in vec1
 		and vec2.
 
 Description:
 
   Cross product of two vectors.
 
 Examples:
 
   Determine the cross products of:
   (2.3,3.4,5.6) and (1.2,4.5,1.2)
   (5.1,0.0,2.3) and (2.5,3.2,4.0)
 
   cross = veccross([2.3 5.1; 3.4 0.0; 5.6 2.3],[1.2 2.5; 4.5 3.2; 1.2 4.0]);

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
 
 VECCROSS: The cross product of two vectors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
vecdot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 946
 
 VECDOT: The dot product of two vectors.
 
 Calling Sequence:
 
   dot = vecdot(vec1,vec2);
 
 INPUT:
 
   vec1	: An array of column vectors represented by a matrix of
   vec2	size (dim,nv), where is the dimension of the vector and
 		nv the number of vectors.

 OUTPUT:

   dot		: Row vector of scalars, each element corresponding to
 		the dot product of the respective components in vec1 and
 		vec2.
 
 Description:
 
   Scalar dot product of two vectors.
 
 Examples:
 
   Determine the dot product of
   (2.3,3.4,5.6) and (1.2,4.5,1.2)
   (5.1,0.0,2.3) and (2.5,3.2,4.0)

   dot = vecdot([2.3 5.1; 3.4 0.0; 5.6 2.3],[1.2 2.5; 4.5 3.2; 1.2 4.0]);

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
 
 VECDOT: The dot product of two vectors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
vecmag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 807
 
 VECMAG: Magnitude of the vectors.
 
 Calling Sequence:
 
   mvec = vecmag(vec)
 
 INPUT:
 
   vec		: An array of column vectors represented by a matrix of
 		size (dim,nv), where is the dimension of the vector and
 		nv the number of vectors.

 OUTPUT:

   mvec	: Magnitude of the vectors, vector of size (1,nv).
 
 Description:
 
   Determines the magnitude of the vectors.
 
 Examples:
 
   Find the magnitude of the two vectors (0.0,2.0,1.3) and (1.5,3.4,2.3)
 
   mvec = vecmag([0.0 1.5; 2.0 3.4; 1.3 2.3]);

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
 
 VECMAG: Magnitude of the vectors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
vecmag2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 855
 
 VECMAG2: Squared magnitude of a set of vectors.
 
 Calling Sequence:
 
   mvec = vecmag2(vec)
 
 INPUT:
 
   vec		: An array of column vectors represented by a matrix of
 		size (dim,nv), where dim is the dimension of the vector and
 		nv the number of vectors.

 OUTPUT:
 
   mvec	: Squared magnitude of the vectors, vector of size (1,nv).
 
 Description:
 
   Determines the squared magnitude of the vectors.
 
 Examples:
 
   Find the squared magnitude of the two vectors (0.0,2.0,1.3)
   and (1.5,3.4,2.3)
 
   mvec = vecmag2([0.0 1.5; 2.0 3.4; 1.3 2.3]);

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
 
 VECMAG2: Squared magnitude of a set of vectors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
vecnorm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 817
 
 VECNORM: Normalise the vectors.
 
 Calling Sequence:
 
   nvec = vecnorn(vec);
 
 INPUT:
 
   vec		: An array of column vectors represented by a matrix of
 		size (dim,nv), where is the dimension of the vector and
 		nv the number of vectors.

 OUTPUT:
 
   nvec		: Normalised vectors, matrix the smae size as vec.
 
 Description:
 
   Normalises the array of vectors, returning the unit vectors.
 
 Examples:
 
   Normalise the two vectors (0.0,2.0,1.3) and (1.5,3.4,2.3)

   nvec = vecnorm([0.0 1.5; 2.0 3.4; 1.3 2.3]);

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
 
 VECNORM: Normalise the vectors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
vecrot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 737
 
 VECROT: Transformation matrix for a rotation around the axis given by a vector. 
 
 Calling Sequence:
 
   rx = vecrot (angle, vector);
 
 INPUT:
 
   angle		: rotation angle defined in radians
   vector		: vector defining the rotation axis

 OUTPUT:
 
   rx		: (4x4) Transformation matrix.
 
 
 Description:
 
   Return the (4x4) Transformation matrix for a rotation about the x axis
   by the defined angle.
 
 See also:
 
    nrbtform

    Copyright (C) 2011 Rafael Vazquez

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 
 VECROT: Transformation matrix for a rotation around the axis given by a vecto



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
vecrotx


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1098
 
 VECROTX: Transformation matrix for a rotation around the x axis. 
 
 Calling Sequence:
 
   rx = vecrotx(angle);
 
 INPUT:
 
   angle		: rotation angle defined in radians

 OUTPUT:
 
   rx		: (4x4) Transformation matrix.
 
 
 Description:
 
   Return the (4x4) Transformation matrix for a rotation about the x axis
   by the defined angle.
 
   The matrix is:
 
         [ 1         0            0          0]
         [ 0     cos(angle)  -sin(angle)     0]
         [ 0     sin(angle)   cos(angle)     0]
         [ 0         0            0          1]
 
 Examples:
 
    Rotate the NURBS line (0.0 0.0 0.0) - (3.0 3.0 3.0) by 45 degrees
    around the x-axis
 
    line = nrbline([0.0 0.0 0.0],[3.0 3.0 3.0]);
    trans = vecrotx(%pi/4);
    rline = nrbtform(line, trans);
 
 See also:
 
    nrbtform

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
 
 VECROTX: Transformation matrix for a rotation around the x axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
vecroty


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1138
 
 VECROTY: Transformation matrix for a rotation around the y axis. 
 
 Calling Sequence:
 
   ry = vecroty(angle);
 
 INPUT:
 
   angle		: rotation angle defined in radians
 
 OUTPUT:

   ry		: (4x4) Transformation matrix.
 
 
 Description:
 
   Return the (4x4) Transformation matrix for a rotation about the y axis
   by the defined angle.
 
   The matrix is:
 
         [  cos(angle)       0        sin(angle)       0]
         [      0            1            0            0]
         [ -sin(angle)       0        cos(angle)       0]
         [      0            0            0            1]
 
 Examples:
 
    Rotate the NURBS line (0.0 0.0 0.0) - (3.0 3.0 3.0) by 45 degrees
    around the y-axis
 
    line = nrbline([0.0 0.0 0.0],[3.0 3.0 3.0]);
    trans = vecroty(%pi/4);
    rline = nrbtform(line, trans);
 
 See also:
 
    nrbtform

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
 
 VECROTY: Transformation matrix for a rotation around the y axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
vecrotz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1125
 
 VECROTZ: Transformation matrix for a rotation around the z axis. 
 
 Calling Sequence:
 
   rz = vecrotz(angle);
 
 INPUT:
 
   angle	: rotation angle defined in radians

 OUTPUT:
 
   rz		: (4x4) Transformation matrix.
 
 
 Description:
 
   Return the (4x4) Transformation matrix for a rotation about the z axis
   by the defined angle.
 
   The matrix is:
 
         [  cos(angle)  -sin(angle)       0          0]
         [ -sin(angle)   cos(angle)       0          0]
         [      0            0            1          0]
         [      0            0            0          1]
 
 Examples:
 
  Rotate the NURBS line (0.0 0.0 0.0) - (3.0 3.0 3.0) by 45 degrees
  around the z-axis
 
    line = nrbline([0.0 0.0 0.0],[3.0 3.0 3.0]);
    trans = vecrotz(%pi/4);
    rline = nrbtform(line, trans);
 
 See also:
 
    nrbtform

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
 
 VECROTZ: Transformation matrix for a rotation around the z axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
vecscale


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1061

 VECSCALE: Transformation matrix for a scaling.
 
 Calling Sequence:
 
   ss = vecscale(svec)
 
 INPUT:
 
   svec    : A vectors defining the scaling along the x,y and z axes.
             i.e. [sx, sy, sy]

 OUTPUT:
 
   ss	    : Scaling Transformation Matrix
 
 Description:
 
   Returns a (4x4) Transformation matrix for scaling.
 
   The matrix is:
 
         [ sx  0   0   0]
         [ 0   sy  0   0]
         [ 0   0   sz  0]
         [ 0   0   0   1]
 
 Example:
 
   Scale up the NURBS line (0.0,0.0,0.0) - (1.0,1.0,1.0) by 3 along
   the x-axis, 2 along the y-axis and 4 along the z-axis.
 
   line = nrbline([0.0 0.0 0.0],[1.0 1.0 1.0]);
   trans = vecscale([3.0 2.0 4.0]);
   sline = nrbtform(line, trans);
 
 See also:
 
    nrbtform

    Copyright (C) 2000 Mark Spink, 2007 Daniel Claxton

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48

 VECSCALE: Transformation matrix for a scaling.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
vectrans


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1066
 
 VECTRANS: Transformation matrix for a translation.
 
 Calling Sequence:
 
   st = vectrans(tvec)
 
 INPUT:
 
   tvec	: A vectors defining the translation along the x,y and
                   z axes. i.e. [tx, ty, ty]

 OUTPUT:
 
   st		: Translation Transformation Matrix
 
 Description:
 
   Returns a (4x4) Transformation matrix for translation.
 
   The matrix is:
 
         [ 1   0   0   tx ]
         [ 0   1   0   ty ]
         [ 0   0   1   tz ]
         [ 0   0   0   1  ]
 
 Examples:
 
   Translate the NURBS line (0.0,0.0,0.0) - (1.0,1.0,1.0) by 3 along
   the x-axis, 2 along the y-axis and 4 along the z-axis.

   line = nrbline([0.0 0.0 0.0],[1.0 1.0 1.0]);
   trans = vectrans([3.0 2.0 4.0]);
   tline = nrbtform(line, trans);
 
 See also:
 
    nrbtform

    Copyright (C) 2000 Mark Spink

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
 
 VECTRANS: Transformation matrix for a translation.





