## Copyright (C) 2010 Johan Beke
##
## This software is free software; you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 3 of the License, or (at
## your option) any later version.
##
## This software is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; see the file COPYING.  If not, see
## <http://www.gnu.org/licenses/>.

function [ K_ff, K_sf, K_ss, K_fs  ] = GlobalStiffnessMatrixRegrouped (joints, members,free,supported)
	%% Returns the components of the global stiffness matrix regrouped as in the following equation:
	%% { P_f }   [ K_ff   K_fs ]   { Delta_f }
	%% {     } = [             ] . {         }
	%% { P_s }   [ K_sf   K_ss ]   { Delta_s }
	
	%% joints: [x, y, constraints; ...] 1= fixed
	%% members [nodeN, nodeF, E, I, A; ...]
	%% free: vector with the free code numbers
	%% supported: vector with the supported (fixed) code numbers
	
	%zeros(row,col)
	
	%number of free en supported joints
	
	%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	%TODO: for large systems this function is still slow
	% due to the indexof!
	%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
	f=columns(free);
	s=columns(supported);
	
	K_ff=spalloc(f,f);
	K_ss=spalloc(s,s);
	K_sf=spalloc(s,f);
	K_fs=spalloc(f,s);
	for member=1:rows(members)
		N=members(member,1);
		F=members(member,2);
		xN=joints(N,1);
		yN=joints(N,2);
		xF=joints(F,1);
		yF=joints(F,2);
		T=TransformationMatrix(xN,yN,xF,yF);
		k=transpose(T)*MemberStiffnessMatrix(sqrt((xN-xF)**2+(yN-yF)**2),members(member,3),members(member,4),members(member,5))*T;%global coords.
		c=[node2code(N),node2code(F)];%code numbers of the near and far nodes of the current member
		
		for i=1:rows(k)
			for j=1:columns(k)
				if (k(i,j)!=0)
					c_row=c(i);
					c_col=c(j);
					
					%K_ff
					row=indexof(free,c_row);
					col=indexof(free,c_col);
					if (row!=-1 && col!=-1)
						K_ff(row,col)=K_ff(row,col)+k(i,j);
					end
					
					%K_sf
					row=indexof(supported,c_row);
					col=indexof(free,c_col);
					if (row!=-1 && col!=-1)
						K_sf(row,col)=K_sf(row,col)+k(i,j);
					end
					
					
					%K_ss
					if (nargout>=3)
						row=indexof(supported,c_row);
						col=indexof(supported,c_col);
						if (row!=-1 && col!=-1)
							K_ss(row,col)=K_ss(row,col)+k(i,j);
						end
					end
					
					%K_fs
					if (nargout==4)
						row=indexof(free,c_row);
						col=indexof(supported,c_col);
						if (row!=-1 && col!=-1)
							K_fs(row,col)=K_fs(row,col)+k(i,j);
						end
					end
				end
			end
		end
		
	end
end
