# Created by Octave 3.6.4, Sat Mar 30 12:51:41 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 116
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
angle2Points


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 411
 -- Function File: ALPHA = angle2Points (P1, P2)
     Compute horizontal angle between 2 points

     P1 and P2 are either [1x2] arrays, or [Nx2] arrays, in this case
     ALPHA is a [Nx1] array. The angle computed is the horizontal angle
     of the line (P1,P2).

     Result is always given in radians, between 0 and 2*pi.

     See also: points2d, angles2d, angle3points, normalizeAngle,
     vectorAngle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Compute horizontal angle between 2 points




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
angle3Points


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 410
 -- Function File: ALPHA = angle3Points (P1, P2, P3)
     Computes the angle between the points P1, P2 and P3.

     P1, P2 and P3 are either [1x2] arrays, or [Nx2] arrays, in this
     case ALPHA is a [Nx1] array. The angle computed is the directed
     angle between line (P2P1) and line (P2P3).

     Result is always given in radians, between 0 and 2*pi.

     See also: points2d, angles2d, angle2points





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Computes the angle between the points P1, P2 and P3.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
angleAbsDiff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 323
 -- Function File: DIF = angleAbsDiff (ANGLE1, ANGLE2)
     Computes the absolute angular difference between two angles in
     radians.  The result is comprised between 0 and pi.

              A = angleAbsDiff(pi/2, pi/3)
              A =
                  0.5236   # equal to pi/6

     See also: angles2d, angleDiff





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Computes the absolute angular difference between two angles in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
angleDiff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 421
 -- Function File: DIF = angleDiff (ANGLE1, ANGLE2)
     Difference between two angles

     Computes the signed angular difference between two angles in
     radians.    The result is comprised between -PI and +PI.

     Example     A = angleDiff(-pi/4, pi/4)     A =         1.5708    #
     equal to pi/2     A = angleDiff(pi/4, -pi/4)     A =
     -1.5708    # equal to -pi/2

     See also: angles2d, angleAbsDiff





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Difference between two angles




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
angleSort


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 665
 -- Function File: varargout = angleSort (PTS, varargin)
     Sort points in the plane according to their angle to origin

     PTS2 = angleSort(PTS);   Computes angle of points with origin, and
     sort points with increasing   angles in Counter-Clockwise
     direction.

     PTS2 = angleSort(PTS, PTS0);   Computes angles between each point
     of PTS and PT0, which can be   different from origin.

     PTS2 = angleSort(..., THETA0);   Specifies the starting angle for
     sorting.

     [PTS2, I] = angleSort(...);   Also returns in I the indices of
     PTS, such that PTS2 = PTS(I, :);

     See also: points2d, angles2d, angle2points, normalizeAngle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Sort points in the plane according to their angle to origin




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
angles2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 620
 -- Function File: angles2d ()
     Description of functions for manipulating angles

     Angles are normalized in an interval of width 2*PI. Most geom2d
     functions return results in the [0 2*pi] interval, but it can be
     convenient to consider the [-pi pi] interval as well. See the
     normalizeAngle function to switch between conventions.

     Angles are usually oriented. The default orientation is the CCW
     (Counter-Clockwise) orientation.

     See also: angle2Points, angle3Points, angleAbsDiff,
     normalizeAngle, vectorAngle, angleDiff, angleSort, lineAngle,
     edgeAngle, deg2rad, rad2deg





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Description of functions for manipulating angles




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
beltproblem


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1316
 -- Function File: [TANGENT,INNER] =  beltproblem (C, R)
     Finds the four lines tangent to two circles with given centers and
     radii.

     The function solves the belt problem in 2D for circles with center
     C and radii R.

     *INPUT*
    C
          2-by-2 matrix containig coordinates of the centers of the
          circles; one row per circle.

    R
          2-by-1 vector with the radii of the circles.

     *OUPUT*
    TANGENT
          4-by-4 matrix with the points of tangency. Each row describes
          a segment(edge).

    INNER
          4-by-2 vector with the point of intersection of the inner
          tangents (crossed belts) with the segment that joins the
          centers of the two circles. If the i-th edge is not an inner
          tangent then `inner(i,:)=[NaN,NaN]'.

     Example:

          c         = [0 0;1 3];
          r         = [1 0.5];
          [T inner] = beltproblem(c,r)
          => T =
           -0.68516   0.72839   1.34258   2.63581
            0.98516   0.17161   0.50742   2.91419
            0.98675  -0.16225   1.49338   2.91888
           -0.88675   0.46225   0.55663   3.23112

          => inner =
            0.66667   2.00000
            0.66667   2.00000
                NaN       NaN
                NaN       NaN

     See also: edges2d





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Finds the four lines tangent to two circles with given centers and
radii.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bisector


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 474
 -- Function File: RAY =  bisector (LINE1, LINE2)
 -- Function File: RAY =  bisector (P1, P2, P3)
     Return the bisector of two lines, or 3 points.

     Creates the bisector of the two lines, given as [x0 y0 dx dy].

     create the bisector of lines (P2 P1) and (P2 P3).

     The result has the form [x0 y0 dx dy], with [x0 y0] being the
     origin   point ans [dx dy] being the direction vector, normalized
     to have unit   norm.

     See also: lines2d, rays2d





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Return the bisector of two lines, or 3 points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
boxes2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 401
 -- Function File: boxes2d ()
     Description of functions operating on bounding boxes.

     A box is represented as a set of limits in each direction:
          BOX = [XMIN XMAX YMIN YMAX].
     Boxes are used as result of computation for bounding boxes, and to
     clip shapes.

     See also: clipPoints, clipLine, clipEdge, clipRay, mergeBoxes,
     intersectBoxes, randomPointInBox, drawBox





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Description of functions operating on bounding boxes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
cartesianLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 234
 -- Function File: LINE =  cartesianLine (A, B,C)
     Create a straight line from cartesian equation coefficients.

     Create a line verifying the Cartesian equation:   A*x + B*x + C =
     0;

     See also: lines2d, createLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Create a straight line from cartesian equation coefficients.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
cbezier2poly


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1281
 -- Function File: PP = cbezier2poly (POINTS)
 -- Function File: [X Y] = cbezier2poly (POINTS,T)
     Returns the polynomial representation of the cubic Bezier defined
     by the control points POINTS.

     With only one input argument, calculates the polynomial PP of the
     cubic Bezier curve defined by the 4 control points stored in
     POINTS. The first point is the inital point of the curve. The
     segment joining the first point with the second point (first
     center) defines the tangent of the curve at the initial point.
     The segment that joints the third point (second center) with the
     fourth defines the tanget at the end-point of the curve, which is
     defined in the fourth point.  POINTS is either a 4-by-2 array
     (vertical concatenation of point coordinates), or a 1-by-8 array
     (horizotnal concatenation of point coordinates). PP is a 2-by-3
     array, 1st row is the polynomial for the x-coordinate and the 2nd
     row for the y-coordinate. Each row can be evaluated with
     `polyval'. The polynomial PP(t) is defined for t in [0,1].

     When called with a second input argument T, it returns the
     coordinates X and Y corresponding to the polynomial evaluated at T
     in [0,1].

     See also: drawBezierCurve, polyval





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Returns the polynomial representation of the cubic Bezier defined by
the control



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
centroid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 889
 -- Function File: C =  centroid (POINTS)
 -- Function File: C =  centroid (PX, PY)
 -- Function File: C =  centroid (..., MASS)
     Compute centroid (center of mass) of a set of points.

     Computes the ND-dimensional centroid of a set of points.    POINTS
     is an array with as many rows as the number of points, and as
     many columns as the number of dimensions.    PX and PY are two
     column vectors containing coordinates of the   2-dimensional
     points.    The result C is a row vector with ND columns.

     If MASS is given, computes center of mass of POINTS, weighted by
     coefficient MASS.    POINTS is a Np-by-Nd array, MASS is Np-by-1
     array, and PX and PY are   also both Np-by-1 arrays.

     Example:

            pts = [2 2;6 1;6 5;2 4];
            centroid(pts)
            ans =
                 4     3

     See also: points2d, polygonCentroid





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute centroid (center of mass) of a set of points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
circleArcAsCurve


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 783
 -- Function File: P =  circleArcAsCurve (ARC, N)
     Convert a circle arc into a series of points

     P = circleArcAsCurve(ARC, N);   convert the circle ARC into a
     series of N points.    ARC is given in the format: [XC YC R THETA1
     DTHETA]   where XC and YC define the center of the circle, R its
     radius, THETA1   is the start of the arc and DTHETA is the angle
     extent of the arc. Both   angles are given in degrees.    N is the
     number of vertices of the resulting polyline, default is 65.

     The result is a N-by-2 array containing coordinates of the N
     points.

     [X Y] = circleArcAsCurve(ARC, N);   Return the result in two
     separate arrays with N lines and 1 column.

     See also: circles2d, circleAsPolygon, drawCircle, drawPolygon





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convert a circle arc into a series of points




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
circleAsPolygon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 572
 -- Function File: P =  circleAsPolygon (CIRCLE, N)
     Convert a circle into a series of points

     P = circleAsPolygon(CIRCLE, N);   convert circle given as [x0 y0
     r], where x0 and y0 are coordinate of   center, and r is the
     radius, into an array of  [(N+1)x2] double,   containing x and y
     values of points.    The polygon is closed

     P = circleAsPolygon(CIRCLE);   uses a default value of N=64 points

     Example   circle = circleAsPolygon([10 0 5], 16);   figure;
     drawPolygon(circle);

     See also: circles2d, polygons2d, createCircle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Convert a circle into a series of points




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
circles2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 925
 -- Function File: circles2d ()
     Description of functions operating on circles

     Circles are represented by their center and their radius:   C =
     [xc yc r];   One sometimes considers orientation of circle, by
     adding an extra   boolean value in 4-th position, with value TRUE
     for direct (i.e.    turning Counter-clockwise) circles.

     Circle arcs are represented by their center, their radius, the
     starting   angle and the angle extent, both in degrees:   CA = [xc
     yc r theta0 dtheta];

     Ellipses are represented by their center, their 2 semi-axis
     length, and   their angle (in degrees) with Ox direction.    E =
     [xc yc A B theta];

     See also: ellipses2d, createCircle, createDirectedCircle,
     enclosingCircle   isPointInCircle, isPointOnCircle
     intersectLineCircle, intersectCircles, radicalAxis
     circleAsPolygon, circleArcAsCurve   drawCircle, drawCircleArc





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Description of functions operating on circles




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
clipEdge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 408
 -- Function File: EDGE2 = clipEdge (EDGE, BOX)
     Clip an edge with a rectangular box.

     EDGE: [x1 y1 x2 y2],   BOX : [xmin xmax ; ymin ymax] or [xmin xmax
     ymin ymax];   return :   EDGE2 = [xc1 yc1 xc2 yc2];

     If clipping is null, return [0 0 0 0];

     if EDGE is a [nx4] array, return an [nx4] array, corresponding to
     each   clipped edge.

     See also: edges2d, boxes2d, clipLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Clip an edge with a rectangular box.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
clipLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 910
 -- Function File: EDGE = clipLine (LINE, BOX)
     Clip a line with a box.

     LINE is a straight line given as a 4 element row vector: [x0 y0 dx
     dy],   with (x0 y0) being a point of the line and (dx dy) a
     direction vector,   BOX is the clipping box, given by its extreme
     coordinates:   [xmin xmax ymin ymax].    The result is given as an
     edge, defined by the coordinates of its 2   extreme points: [x1 y1
     x2 y2].    If line does not intersect the box, [NaN NaN NaN NaN]
     is returned.

     Function works also if LINE is a Nx4 array, if BOX is a Nx4 array,
     or   if both LINE and BOX are Nx4 arrays. In these cases, EDGE is
     a Nx4   array.

     Example:

            line = [30 40 10 0];
            box = [0 100 0 100];
            res = clipLine(line, box)
            res =
                0 40 100 40

     See also: lines2d, boxes2d, edges2d, clipEdge, clipRay





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Clip a line with a box.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
clipPoints


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 218
 -- Function File: POINTS2 = clipPoints (POINTS, BOX)
     Clip a set of points by a box.

     Returns the set POINTS2 which are located inside of the box BOX.

     See also: points2d, boxes2d, clipLine, drawPoint





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Clip a set of points by a box.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
clipRay


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 752
 -- Function File: [EDGE INSIDE] = clipRay (RAY, BOX)
     Clip a ray with a box.

     RAY is a straight ray given as a 4 element row vector: [x0 y0 dx
     dy],   with (x0 y0) being the origin of the ray and (dx dy) its
     direction   vector, BOX is the clipping box, given by its extreme
     coordinates:   [xmin xmax ymin ymax].    The result is given as an
     edge, defined by the coordinates of its 2   extreme points: [x1 y1
     x2 y2].    If the ray does not intersect the box, [NaN NaN NaN
     NaN] is returned.

     Function works also if RAY is a Nx4 array, if BOX is a Nx4 array,
     or   if both RAY and BOX are Nx4 arrays. In these cases, EDGE is a
     Nx4   array.

     See also: rays2d, boxes2d, edges2d, clipLine, drawRay





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Clip a ray with a box.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
closed_path


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 173
 -- Function File: Y = polygon (X)
     Returns a simple closed path that passes through all the points in
     X.  X is a vector containing 2D coordinates of the points.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Returns a simple closed path that passes through all the points in X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
cov2ellipse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 686
 -- Function File: ELLIPSE =  cov2ellipse (K)
 -- Function File: [RA RB THETA] =  cov2ellipse (K)
 -- Function File: ... =  cov2ellipse (..., `tol',TOL)
     Calculates ellipse parameters from covariance matrix.

     K must be symmetric positive (semi)definite. The optional argument
     `tol' sets the tolerance for the verification of the
     positive-(semi)definiteness of the matrix K (see `isdefinite').

     If only one output argument is supplied a vector defining a
     ellipse is returned as defined in `ellipses2d'. Otherwise the
     angle THETA is given in radians.

     Run `demo cov2ellipse' to see an example.

     See also: ellipses2d, cov2ellipse, drawEllipse





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Calculates ellipse parameters from covariance matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
crackPattern


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 909
 -- Function File: E =  crackPattern (BOX, POINTS, ALPHA)
     Create a (bounded) crack pattern tessellation

     E = crackPattern2(BOX, POINTS, ALPHA)   create a crack propagation
     pattern wit following parameters :   - pattern is bounded by area
     BOX which is a polygon.    - each crack originates from points
     given in POINTS   - directions of each crack is given by a [NxM]
     array ALPHA, where M is   the number of rays emanating from each
     seed/   - a crack stop when it reaches another already created
     crack.    - all cracks stop when they reach the border of the
     frame, given by box   (a serie of 4 points).    The result is a
     collection of edges, in the form [x1 y1 x2 y2].

     E = crackPattern2(BOX, POINTS, ALPHA, SPEED)   Also specify speed
     of propagation of each crack.

     See the result with :     figure;     drawEdge(E);

     See also: drawEdge





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Create a (bounded) crack pattern tessellation




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
crackPattern2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 910
 -- Function File: E =  crackPattern2 (BOX, POINTS, ALPHA)
     Create a (bounded) crack pattern tessellation

     E = crackPattern2(BOX, POINTS, ALPHA)   create a crack propagation
     pattern wit following parameters :   - pattern is bounded by area
     BOX which is a polygon.    - each crack originates from points
     given in POINTS   - directions of each crack is given by a [NxM]
     array ALPHA, where M is   the number of rays emanating from each
     seed/   - a crack stop when it reaches another already created
     crack.    - all cracks stop when they reach the border of the
     frame, given by box   (a serie of 4 points).    The result is a
     collection of edges, in the form [x1 y1 x2 y2].

     E = crackPattern2(BOX, POINTS, ALPHA, SPEED)   Also specify speed
     of propagation of each crack.

     See the result with :     figure;     drawEdge(E);

     See also: drawEdge





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Create a (bounded) crack pattern tessellation




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
createBasisTransform


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1405
 -- Function File: T =  createBasisTransfrom (TARGET)
 -- Function File: T =  createBasisTransfrom (SOURCE, TARGET)
     Compute matrix for transforming a basis into another basis

     With only one input arguemnt, assumes the SOURCE is the standard
     (Oij) basis, with origin at (0,0),   first direction vector equal
     to (1,0) and second direction  vector   equal to (0,1). Otherwise
     SOURCE specifies the SOURCE basis.

     Both SOURCE and TARGET represent basis, in the following form:
     [x0 y0  ex1 ey1  ex2 ey2]   [y0 y0] is the origin of the basis,
     [ex1 ey1] is the first direction   vector, and [ex2 ey2] is the
     second direction vector.

     The result T is a 3-by-3 matrix such that a point expressed with
     coordinates of the first basis will be represented by new
     coordinates   `P2 = transformPoint(P1, T)' in the TARGET basis.

     Example
              # standard basis transform
              src = [0 0   1 0   0 1];
              # TARGET transform, just a rotation by atan(2/3) followed by a scaling
              tgt = [0 0   .75 .5   -.5 .75];
              # compute transform
              trans = createBasisTransform(src, tgt);
              # transform the point (.25,1.25) into the point (1,1)
              p1 = [.25 1.25];
              p2 = transformPoint(p1, trans)
              ans =
                  1   1

     See also: transforms2d





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute matrix for transforming a basis into another basis




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
createCircle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 881
 -- Function File: CIRCLE =  createCircle (P1, P2, P3)
 -- Function File: CIRCLE =  createCircle (P1, P2)
     Create a circle from 2 or 3 points.

     Creates the circle passing through the 3 given points.    C is a
     1x3 array of the form: [XC YX R].

     When two points are given, creates the circle whith center P1 and
     passing throuh the point P2.

     Works also when input are point arrays the same size, in this case
     the   result has as many lines as the point arrays.

     Example

            # Draw a circle passing through 3 points.
              p1 = [10 15];
              p2 = [15 20];
              p3 = [10 25];
              circle = createCircle(p1, p2, p3);
              figure; hold on; axis equal; axis([0 50 0 50]);
              drawPoint([p1 ; p2; p3]);
              drawCircle(circle);

     See also: circles2d, createDirectedCircle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Create a circle from 2 or 3 points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
createDirectedCircle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 569
 -- Function File: CIRCLE =  createDirectedCircle (P1, P2, P3)
 -- Function File: CIRCLE =  createDirectedCircle (P1, P2)
     Create a circle from 2 or 3 points.

     Creates the circle passing through the 3 given points.    C is a
     1x4 array of the form: [XC YX R INV].

     When two points are given, creates the circle whith center P1 and
     passing throuh the point P2.

     Works also when input are point arrays the same size, in this case
     the   result has as many lines as the point arrays.

     Example

     See also: circles2d, createCircle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Create a circle from 2 or 3 points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
createEdge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1092
 -- Function File: EDGE =  createEdge (P1, P2)
 -- Function File: EDGE =  createEdge (X0, Y0, DX, DY)
 -- Function File: EDGE =  createEdge (PARAM)
 -- Function File: EDGE =  createEdge (LINE, D)
     Create an edge between two points, or from a line.

     The internal format for edge representation is given by
     coordinates of   two points : [x1 y1 x2 y2].    This function can
     serve as a line to edge converter.

     Returns the edge between the two given points P1 and P2.

     Returns the edge going through point (X0, Y0) and with direction
     vector (DX,DY).

     When PARAM is an array of 4 values, creates the edge going through
     the   point (param(1) param(2)), and with direction vector given by
      (param(3) param(4)).

     When LINE is given, creates the edge contained in LINE, with same
     direction and start point, but with length given by D.

     Note: in all cases, parameters can be vertical arrays of the same
     dimension. The result is then an array of edges, of dimensions
     [N*4].

     See also: edges2d, lines2d, drawEdge, clipEdge





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Create an edge between two points, or from a line.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
createHomothecy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 245
 -- Function File: T =  createHomothecy (POINT, RATIO)
     Create the the 3x3 matrix of an homothetic transform.

     POINT is the center of the homothecy, RATIO is its factor.

     See also: transforms2d, transformPoint, createTranslation





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Create the the 3x3 matrix of an homothetic transform.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
createLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2358
 -- Function File: LINE = createLine(varargin)
     Create a straight line from 2 points, or from other inputs

     Line is represented in a parametric form : [x0 y0 dx dy]   x = x0
     + t*dx   y = y0 + t*dy;

     L = createLine(p1, p2);   Returns the line going through the two
     given points.

     L = createLine(x0, y0, dx, dy);   Returns the line going through
     point (x0, y0) and with direction   vector(dx, dy).

     L = createLine(LINE);   where LINE is an array of 4 values,
     creates the line going through the   point (LINE(1) LINE(2)), and
     with direction given by vector (LINE(3)   LINE(4)).

     L = createLine(THETA);   Create a polar line originated at (0,0)
     and with angle THETA.

     L = createLine(RHO, THETA);   Create a polar line with normal
     theta, and with min distance to origin   equal to rho. rho can be
     negative, in this case, the line is the same   as with
     CREATELINE(-rho, theta+pi), but the orientation is different.

     Note: in all cases, parameters can be vertical arrays of the same
     dimension. The result is then an array of lines, of dimensions
     [N*4].

     NOTE : A line can also be represented with a 1*5 array :   [x0 y0
     dx dy t].    whith 't' being one of the following :   - t=0 : line
     is a singleton (x0,y0)   - t=1 : line is an edge segment, between
     points (x0,y0) and (x0+dx,   y0+dy).    - t=Inf : line is a Ray,
     originated from (x0,y0) and going to infinity   in the
     direction(dx,dy).    - t=-Inf : line is a Ray, originated from
     (x0,y0) and going to infinity   in the direction(-dx,-dy).    -
     t=NaN : line is a real straight line, and contains all points
     verifying the above equation.    This seems us a convenient way to
     represent uniformly all kind of lines   (including edges, rays,
     and even point).

     NOTE2 : Any line object can be represented using a 1x6 array :
     [x0 y0 dx dy t0 t1]   the first 4 parameters define the supporting
     line,   t0 represent the position of the first point on the line,
     and t1 the position of the last point.    * for edges : t0 = 0,
     and t1=1   * for straight lines : t0 = -inf, t1=inf   * for rays :
     t0=0, t1=inf (or t0=-inf,t1=0 for inverted ray).    I propose to
     call these objects 'lineArc'

     See also: lines2d, createEdge, createRay





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Create a straight line from 2 points, or from other inputs




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
createLineReflection


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 332
 -- Function File: T =  function_name (LINE)
     Create the the 3x3 matrix of a line reflection.

     Where LINE is given as [x0 y0 dx dy], return the affine tansform
     corresponding to the desired line reflection.

     See also: lines2d, transforms2d, transformPoint,
     createTranslation, createHomothecy, createScaling





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Create the the 3x3 matrix of a line reflection.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
createRay


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 877
 -- Function File:  RAY =  createRay (POINT, ANGLE)
 -- Function File:  RAY =  createRay (X0,Y0, ANGLE)
 -- Function File:  RAY =  createRay (P1, P2)
     Create a ray (half-line), from various inputs.

     A Ray is represented in a parametric form: [x0 y0 dx dy].    x =
     x0 + t*dx   y = y0 + t*dy;   for all t>0.

     POINT is a Nx2 array giving the starting point of the ray, and
     ANGLE is the   orientation of the ray respect to the positive
     x-axis. The ray origin can be specified with 2 input arguments
     X0,Y0.

     If two points P1, P2 are given, creates a ray starting from point
     P1 and going in the direction of point   P2.

     Example
            origin  = [3 4];
            theta   = pi/6;
            ray = createRay(origin, theta);
            axis([0 10 0 10]);
            drawRay(ray);

     See also: rays2d, createLine, points2d





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Create a ray (half-line), from various inputs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
createRotation


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 651
 -- Function File: T =  createRotation (THETA)
 -- Function File: T =  createRotation (POINT, THETA)
 -- Function File: T =  createRotation (X0, Y0, THETA)
     Create the 3*3 matrix of a rotation.

     Returns the rotation corresponding to angle THETA (in radians)
     The returned matrix has the form :   [cos(theta) -sin(theta)  0]
     [sin(theta)  cos(theta)  0]   [0           0           1]

     POINT or (X0,Y0), specifies origin of rotation. The result is
     similar as performing   translation(-X0,-Y0), rotation(THETA), and
     translation(X0,Y0).

     See also: transforms2d, transformPoint, createTranslation,
     createScaling





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Create the 3*3 matrix of a rotation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
createScaling


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 473
 -- Function File: T =  createScaling (S)
 -- Function File: T =  createScaling (SX, SY)
     Create the 3x3 matrix of a scaling in 2 dimensions.

     Assume scaling S is equal n all directions unless SX and SY are
     given.    Returns the matrix corresponding to scaling in the 2
     main directions.    The returned matrix has the form:   [SX  0  0]
      [0  SY  0]   [0   0  1]

     See also: transforms2d, transformPoint, createTranslation,
     createRotation





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Create the 3x3 matrix of a scaling in 2 dimensions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
createTranslation


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 438
 -- Function File: T =  createTranslation (VECTOR)
 -- Function File: T =  createTranslation (DX,DY)
     Create the 3*3 matrix of a translation.

     Returns the matrix corresponding to a translation by the vector
     [DX DY].    The components can be given as two arguments.    The
     returned matrix has the form :   [1 0 TX]   [0 1 TY]   [0 0  1]

     See also: transforms2d, transformPoint, createRotation,
     createScaling





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Create the 3*3 matrix of a translation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
createVector


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 560
 -- Function File: VECT =  createVector (P1, P2)
     Create a vector from two points.

     V12 = createVector(P1, P2)   Creates the vector V12, defined as
     the difference between coordinates   of points P1 and P2.    P1
     and P2 are row vectors with ND elements, ND being the space
     dimension.

     If one of the inputs is a N-by-Nd array, the other input is
     automatically repeated, and the result is N-by-Nd.

     If both inputs have the same size, the result also have the same
     size.

     See also: vectors2d, vectors3d, points2d





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Create a vector from two points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
deg2rad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 325
 -- Function File: RAD = deg2rad(DEG)
     Convert angle from degrees to radians

     Usage:   R = deg2rad(D)   convert an angle in degrees to an angle
     in radians.

     Example   deg2rad(180)    # gives pi   ans =       3.1416
     deg2rad(60)     # gives pi/3   ans =       1.0472

     See also: angles2d, rad2deg





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Convert angle from degrees to radians




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
distancePointEdge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1248
 -- Function File: DIST =  distancePointEdge (POINT, EDGE)
 -- Function File: DIST =  distancePointEdge (..., OPT)
 -- Function File: [DIST POS]=  distancePointEdge (...)
     Minimum distance between a point and an edge

     Return the euclidean distance between edge EDGE and point POINT.
     EDGE has the form: [x1 y1 x2 y2], and POINT is [x y].  If EDGE is
     Ne-by-4 and POINT is Np-by-2, then DIST is Np-by-Ne, where each
     row contains the distance of each point to all the edges.

     If OPT is true (or equivalent), the optput is cmpatible with the
     original function:
    `1'
          If POINT is 1-by-2 array, the result is Ne-by-1 array
          computed for each edge.

    `2'
          If EDGE is a 1-by-4 array, the result is Np-by-1 computed for
          each point.

    `3'
          If both POINT and EDGE are array, they must have the same
          number of rows, and the result is computed for each couple
          `POINT(i,:),EDGE(i,:)'.

     If the the second output argument POS is requested, the function
     also returns the position of closest point on the edge. POS is
     comprised between 0 (first point) and 1 (last point).

     See also: edges2d, points2d, distancePoints, distancePointLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Minimum distance between a point and an edge




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
distancePointLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 615
 -- Function File: DIST =  distancePointLine (POINT, LINE)
     Minimum distance between a point and a line

     D = distancePointLine(POINT, LINE)   Return the euclidean distance
     between line LINE and point POINT.

     LINE has the form : [x0 y0 dx dy], and POINT is [x y].

     If LINE is N-by-4 array, result is N-by-1 array computes for each
     line.

     If POINT is N-by-2, then result is computed for each point.

     If both POINT and LINE are array, result is N-by-1, computed for
     each   corresponding point and line.

     See also: lines2d, points2d, distancePoints, distancePointEdge





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Minimum distance between a point and a line




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
drawArrow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 686
 -- Function File: H =  drawArrow (X1, Y1, X2, Y2)
 -- Function File: H =  drawArrow ([ X1  Y1 X2 Y2])
 -- Function File: H =  drawArrow (..., L, W)
 -- Function File: H =  drawArrow (..., L, W,TYPE)
     Draw an arrow on the current axis.

     draw an arrow between the points (X1 Y1) and (X2 Y2).  The points
     can be given as a single array. L, W specify length and width of
     the arrow.

     Also specify arrow type. TYPE can be one of the following :   0:
     draw only two strokes   1: fill a triangle   .5: draw a half arrow
     (try it to see ...)

     Arguments can be single values or array of size [N*1]. In this
     case,   the function draws multiple arrows.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Draw an arrow on the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
drawBezierCurve


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1041
 -- Function File: drawBezierCurve (POINTS)
 -- Function File: drawBezierCurve (PP)
 -- Function File: drawBezierCurve (..., PARAM, VALUE, ...)
 -- Function File: H = drawBezierCurve (...)
     Draw a cubic bezier curve defined by the control points POINTS.

     With only one input argument, draws the Bezier curve defined by
     the 4 control points stored in POINTS. POINTS is either a 4-by-2
     array (vertical concatenation of point coordinates), or a 1-by-8
     array (horizotnal concatenation of point coordinates). The curve
     could be described by its polynomial (output of `cbezier2poly')
     PP, which should be a 2-by-4 array.

     The optional PARAM, VALUE pairs specify additional drawing
     parameters, see the `plot' function for details. The specific
     parameter 'discretization' with an integer associated value
     defines the amount of points used to plot the curve. If the output
     is requiered, the function returns the handle to the created
     graphic object.

     See also: cbezier2poly, plot





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Draw a cubic bezier curve defined by the control points POINTS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
drawBox


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 388
 -- Function File: H = drawBox (BOX)
 -- Function File: H = drawBox (BOX, PARAM, VALUE, ...)
     Draw a box defined by coordinate extents

     Draws a box defined by its extent: BOX = [XMIN XMAX YMIN YMAX].
     Addtional arguments are passed to function `plot'. If requested,
     it returns the handle to the graphics object created.

     See also: drawOrientedBox, drawRect, plot





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Draw a box defined by coordinate extents




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
drawCenteredEdge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1333
 -- Function File: H = drawCenteredEdge (CENTER, L, THETA)
 -- Function File: H = drawCenteredEdge (EDGE)
 -- Function File: H = drawCenteredEdge (..., NAME,VALUE)
     Draw an edge centered on a point.

     drawCenteredEdge(CENTER, L, THETA)   Draws an edge centered on
     point CENTER, with length L, and orientation   THETA (given in
     degrees). Input arguments can also be arrays, that must   all have
     the same number odf rows.

     drawCenteredEdge(EDGE)   Concatenates edge parameters into a
     single N-by-4 array, containing:   [XC YV L THETA].

     drawCenteredEdge(..., NAME, VALUE)   Also specifies drawing
     options by using one or several parameter name -   value pairs
     (see doc of plot function for details).

     H = drawCenteredEdge(...)    Returns handle(s) to the created
     edges(s).

              # Draw an ellipse with its two axes
              figure(1); clf;
              center = [50 40];
              r1 = 30; r2 = 10;
              theta = 20;
              elli = [center r1 r2 theta];
              drawEllipse(elli, 'linewidth', 2);
              axis([0 100 0 100]); axis equal;
              hold on;
              edges = [center 2*r1 theta ; center 2*r2 theta+90];
              drawCenteredEdge(edges, 'linewidth', 2, 'color', 'g');

     See also: edges2d, drawEdge





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Draw an edge centered on a point.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
drawCircle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1142
 -- Function File: H =  drawCircle (X0, Y0, R)
 -- Function File: H =  drawCircle (CIRCLE)
 -- Function File: H =  drawCircle (CENTER, RADIUS)
 -- Function File: H =  drawCircle (..., NSTEP)
 -- Function File: H =  drawCircle (..., NAME, VALUE)
     Draw a circle on the current axis

     drawCircle(X0, Y0, R);   Draw the circle with center (X0,Y0) and
     the radius R. If X0, Y0 and R   are column vectors of the same
     length, draw each circle successively.

     drawCircle(CIRCLE);   Concatenate all parameters in a Nx3 array,
     where N is the number of   circles to draw.

     drawCircle(CENTER, RADIUS);   Specify CENTER as Nx2 array, and
     radius as a Nx1 array.

     drawCircle(..., NSTEP);   Specify the number of edges that will be
     used to draw the circle.    Default value is 72, creating an
     approximation of one point for each 5   degrees.

     drawCircle(..., NAME, VALUE);   Specifies plotting options as pair
     of parameters name/value. See plot   documentation for details.

     H = drawCircle(...);   return handles to each created curve.

     See also: circles2d, drawCircleArc, drawEllipse





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Draw a circle on the current axis




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
drawCircleArc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1004
 -- Function File: H =  drawCircleArc (XC, YC, R, START, END)
 -- Function File: H =  drawCircleArc (ARC)
 -- Function File: H =  drawCircleArc (..., PARAM, VALUE)
     Draw a circle arc on the current axis

     drawCircleArc(XC, YC, R, START, EXTENT);   Draws circle with
     center (XC, YC), with radius R, starting from angle   START, and
     with angular extent given by EXTENT. START and EXTENT angles   are
     given in degrees.

     drawCircleArc(ARC);   Puts all parameters into one single array.

     drawCircleArc(..., PARAM, VALUE);   specifies plot properties by
     using one or several parameter name-value   pairs.

     H = drawCircleArc(...);   Returns a handle to the created line
     object.

              # Draw a red thick circle arc
              arc = [10 20 30 -120 240];
              figure;
              axis([-50 100 -50 100]);
              hold on
              drawCircleArc(arc, 'LineWidth', 3, 'Color', 'r')

     See also: circles2d, drawCircle, drawEllipse





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Draw a circle arc on the current axis




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
drawEdge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 902
 -- Function File: H =  drawEdge (X1, Y1, X2, Y2)
 -- Function File: H =  drawEdge ([X1 Y1 X2 Y2])
 -- Function File: H =  drawEdge ([X1 Y1], [X2 Y2])
 -- Function File: H =  drawEdge (X1, Y1, Z1, X2, Y2, Z2)
 -- Function File: H =  drawEdge ([X1 Y1 Z1 X2 Y2 Z2])
 -- Function File: H =  drawEdge ([X1 Y1 Z1], [X2 Y2 Z2])
 -- Function File: H =  drawEdge (..., OPT)
     Draw an edge given by 2 points.

     Draw an edge between the points (x1 y1) and  (x2 y2). Data can be
     bundled as an edge.    The function supports 3D edges.
     Arguments can be single values or array of size [Nx1]. In this
     case,   the function draws multiple edges.    OPT, being a set of
     pairwise options, can   specify color, line width and so on. These
     are passed to function `line'.    The function returns handle(s)
     to created edges(s).

     See also: edges2d, drawCenteredEdge, drawLine, line





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Draw an edge given by 2 points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
drawEllipse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1330
 -- Function File: H =  drawEllipse (ELLI)
 -- Function File: H =  drawEllipse (XC, YC, RA, RB)
 -- Function File: H =  drawEllipse (XC, YC, RA, RB, THETA)
 -- Function File: H =  drawEllipse (..., PARAM, VALUE)
     Draw an ellipse on the current axis.

     drawEllipse(ELLI);   Draws the ellipse ELLI in the form [XC YC RA
     RB THETA], with center   (XC, YC), with main axis of half-length
     RA and RB, and orientation   THETA in degrees counted
     counter-clockwise.    Puts all parameters into one single array.

     drawEllipse(XC, YC, RA, RB);   drawEllipse(XC, YC, RA, RB, THETA);
      Specifies ellipse parameters as separate arguments (old syntax).

     drawEllipse(..., NAME, VALUE);   Specifies drawing style of
     ellipse, see the help of plot function.

     H = drawEllipse(...);   Also returns handles to the created line
     objects.

     -> Parameters can also be arrays. In this case, all arrays are
     supposed   to have the same size.

     Example:
            # Draw an ellipse centered in [50 50], with semi major axis length of
            # 40, semi minor axis length of 20, and rotated by 30 degrees.
              figure(1); clf; hold on;
              drawEllipse([50 50 40 20 30]);
              axis equal;

     See also: ellipses2d, drawCircle, drawEllipseArc, ellipseAsPolygon





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Draw an ellipse on the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
drawEllipseArc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1338
 -- Function File: H =  drawEllipseArc (ARC)
     Draw an ellipse arc on the current axis.

     drawEllipseArc(ARC)   draw ellipse arc specified by ARC. ARC has
     the format:     ARC = [XC YC A B THETA T1 T2]   or:     ARC = [XC
     YC A B T1 T2] (isothetic ellipse)   with center (XC, YC), main
     axis of half-length A, second axis of   half-length B, and ellipse
     arc running from t1 to t2 (both in degrees,   in Counter-Clockwise
     orientation).

     Parameters can also be arrays. In this case, all arrays are
     suposed to   have the same size...

              # draw an ellipse arc: center = [10 20], radii = 50 and 30, theta = 45
              arc = [10 20 50 30 45 -90 270];
              figure;
              axis([-50 100 -50 100]); axis equal;
              hold on
              drawEllipseArc(arc, 'color', 'r')

              # draw another ellipse arc, between angles -60 and 70
              arc = [10 20 50 30 45 -60 (60+70)];
              figure;
              axis([-50 100 -50 100]); axis equal;
              hold on
              drawEllipseArc(arc, 'LineWidth', 2);
              ray1 = createRay([10 20], deg2rad(-60+45));
              drawRay(ray1)
              ray2 = createRay([10 20], deg2rad(70+45));
              drawRay(ray2)

     See also: ellipses2d, drawEllipse, drawCircleArc





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Draw an ellipse arc on the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
drawLabels


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 673
 -- Function File: drawLabels (X, Y, LBL)
 -- Function File: drawLabels (POS, LBL)
 -- Function File: drawLabels (..., NUMBERS, FORMAT)
     Draw labels at specified positions.

     DRAWLABELS(X, Y, LBL) draw labels LBL at position X and Y.    LBL
     can be either a string array, or a number array. In this case,
     string are created by using sprintf function, with '#.2f' mask.

     DRAWLABELS(POS, LBL) draw labels LBL at position specified by POS,
      where POS is a N*2 int array.

     DRAWLABELS(..., NUMBERS, FORMAT) create labels using sprintf
     function,   with the mask given by FORMAT (e. g. '#03d' or
     '5.3f'), and the   corresponding values.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Draw labels at specified positions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
drawLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 662
 -- Function File: H = drawLine (LINE)
 -- Function File: H = drawLine (LINE, PARAM,VALUE)
     Draw the line on the current axis.

     Draws the line LINE on the current axis, by using current axis to
     clip   the line. Extra PARAM,VALUE pairs are passed to the `line'
     function.    Returns a handle to the created line object. If
     clipped line is not   contained in the axis, the function returns
     -1.

     Example

            figure; hold on; axis equal;
            axis([0 100 0 100]);
            drawLine([30 40 10 20]);
            drawLine([30 40 20 -10], 'color', 'm', 'linewidth', 2);

     See also: lines2d, createLine, drawEdge





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Draw the line on the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
drawOrientedBox


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 819
 -- Function File: HB =  drawOrientedBox (BOX)
 -- Function File: HB =  drawOrientedBox (..., PARAM, VALUE)
     Draw centered oriented rectangle.

     Syntax   drawOrientedBox(BOX)   drawOrientedBox(BOX,
     'PropertyName', propertyvalue, ...)

     Description   drawOrientedBox(OBOX)   Draws an oriented rectangle
     (or bounding box) on the current axis.    OBOX is a 1-by-5 row
     vector containing box center, dimension (length   and width) and
     orientation (in degrees):   OBOX = [CX CY LENGTH WIDTH THETA].

     When OBOX is a N-by-5 array, the N boxes are drawn.

     HB = drawOrientedBox(...)    Returns a handle to the created
     graphic object(s). Object style can be   modified using syntaw
     like:   set(HB, 'color', 'g', 'linewidth', 2);

     See also: drawPolygon, drawRect, drawBox





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Draw centered oriented rectangle.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
drawParabola


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1510
 -- Function File: H =  drawParabola (PARABOLA)
 -- Function File: H =  drawParabola (PARABOLA, T)
 -- Function File: H =  drawParabola (..., PARAM, VALUE)
     Draw a parabola on the current axis.

     drawParabola(PARABOLA);   Draws a vertical parabola, defined by
     its vertex and its parameter.    Such a parabola admits a vertical
     axis of symetry.

     The algebraic equation of parabola is given by:      (Y - YV) = A
     * (X - VX)^2   Where XV and YV are vertex coordinates and A is
     parabola parameter.

     A parametric equation of parabola is given by:      x(t) = t + VX;
         y(t) = A * t^2 + VY;

     PARABOLA can also be defined by [XV YV A THETA], with theta being
     the   angle of rotation of the parabola (in degrees and
     Counter-Clockwise).

     drawParabola(PARABOLA, T);   Specifies which range of 't' are used
     for drawing parabola. If T is an   array with only two values, the
     first and the last values are used as   interval bounds, and
     several values are distributed within this   interval.

     drawParabola(..., NAME, VALUE);   Can specify one or several
     graphical options using parameter name-value   pairs.

     H = drawParabola(...);   Returns an handle to the created
     graphical object.

     Example:
            figure(1); clf; hold on;
            drawParabola([50 50 .2 30]);
            drawParabola([50 50 .2 30], [-1 1], 'color', 'r', 'linewidth', 2);
            axis equal;

     See also: drawCircle, drawEllipse





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Draw a parabola on the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
drawPoint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 429
 -- Function File: H =  drawPoint (X, Y)
 -- Function File: H =  drawPoint (COORD)
 -- Function File: H =  drawPoint (..., OPT)
     Draw the point on the axis.

     Draws points defined by coordinates X and YY.    X and Y should be
     array the same size. Coordinates can be   packed coordinates in a
     single [N*2] array COORD. Options OPT   are passed to the `plot'
     function.

     See also: points2d, clipPoints





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Draw the point on the axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
drawRay


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 396
 -- Function File: H =  drawRay (RAY)
 -- Function File: H =  drawRay (RAY, PARAM, VALUE)
     Draw a ray on the current axis.

     With RAY having the syntax: [x0 y0 dx dy], draws the ray starting
     from  point (x0 y0) and going to direction (dx dy), clipped with
     the current  window axis. PARAM, VALUE pairs are passed to
     function `line'.

     See also: rays2d, drawLine, line





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Draw a ray on the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
drawRect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 673
 -- Function File: R =  drawRect (X, Y, W, H)
 -- Function File: R =  drawRect (X, Y, W, H, THETA)
 -- Function File: R =  drawRect (COORD)
     Draw rectangle on the current axis.

     r = DRAWRECT(x, y, w, h) draw rectangle with width W and height H,
     at   position (X, Y).    the four corners of rectangle are then :
     (X, Y), (X+W, Y), (X, Y+H), (X+W, Y+H).

     r = DRAWRECT(x, y, w, h, theta) also specifies orientation for
     rectangle. Theta is given in degrees.

     r = DRAWRECT(coord) is the same as DRAWRECT(X,Y,W,H), but all
     parameters are packed into one array, whose dimensions is 4*1 or
     5*1.

     See also: drawBox, drawOrientedBox





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Draw rectangle on the current axis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
drawShape


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 823
 -- Function File: drawShape (TYPE, PARAM)
 -- Function File: drawShape (..., OPTION)
     Draw various types of shapes (circles, polygons...).

     drawShape(TYPE, PARAM)   Draw the shape of type TYPE, specified by
     given parameter PARAM. TYPE   can be one of 'circle', 'ellipse',
     'rect', 'polygon', 'curve'   PARAM depend on the type. For
     example, if TYPE is 'circle', PARAM will   contain [x0 y0 R].

     Examples :
            drawShape('circle', [20 10 30]);
            Draw circle centered on [20 10] with radius 10.
            drawShape('rect', [20 20 40 10 pi/3]);
            Draw rectangle centered on [20 20] with length 40 and width 10, and
            oriented pi/3 wrt axis Ox.

     drawShape(..., OPTION)   also specifies drawing options. OPTION
     can be 'draw' (default) or   'fill'.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Draw various types of shapes (circles, polygons.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
edgeAngle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 520
 -- Function File: THETA = edgeAngle(EDGE)
     Return angle of edge

     A = edgeAngle(EDGE)   Returns the angle between horizontal,
     right-axis and the edge EDGE.    Angle is given in radians,
     between 0 and 2*pi, in counter-clockwise   direction.    Notation
     for edge is [x1 y1 x2 y2] (coordinates of starting and ending
     points).

     Example   p1 = [10 20];   p2 = [30 40];   rad2deg(edgeAngle([p1
     p2]))   ans =       45

     See also: edges2d, angles2d, edgeAngle, lineAngle, edgeLength





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Return angle of edge




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
edgeLength


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 436
 -- Function File: LEN =  edgeLength (EDGE)
     Return length of an edge

     L = edgeLength(EDGE);   Returns the length of an edge, with
     parametric representation:   [x1 y1 x2 y2].

     The function also works for several edges, in this case input is a
      [N*4] array, containing parametric representation of each edge,
     and   output is a [N*1] array containing length of each edge.

     See also: edges2d, edgeAngle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Return length of an edge




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
edgePosition


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1194
 -- Function File: D =  edgePosition (POINT, EDGE)
     Return position of a point on an edge

     POS = edgePosition(POINT, EDGE);   Computes position of point
     POINT on the edge EDGE, relative to the   position of edge
     vertices.    EDGE has the form [x1 y1 x2 y2],   POINT has the form
     [x y], and is assumed to belong to edge.    The position POS has
     meaning:     POS<0:    POINT is located before the first vertex
     POS=0:    POINT is located on the first vertex     0<POS<1:  POINT
     is located between the 2 vertices (on the edge)     POS=1:
     POINT is located on the second vertex     POS<0:    POINT is
     located after the second vertex

     POS = edgePosition(POINT, EDGES);   If EDGES is an array of NL
     edges, return NL positions, corresponding to   each edge.

     POS = edgePosition(POINTS, EDGE);   If POINTS is an array of NP
     points, return NP positions, corresponding   to each point.

     POS = edgePosition(POINTS, EDGES);   If POINTS is an array of NP
     points and edgeS is an array of NL edges,   return an array of [NP
     NL] position, corresponding to each couple   point-edge.

     See also: edges2d, createEdge, onEdge





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return position of a point on an edge




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
edgeToLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 392
 -- Function File: LINE =  edgeToLine (EDGE)
     Convert an edge to a straight line

     LINE = edgeToLine(EDGE);   Returns the line containing the edge
     EDGE.

     Example       edge = [2 3 4 5];       line = edgeToLine(edge);
      figure(1); hold on; axis([0 10 0 10]);       drawLine(line,
     'color', 'g')       drawEdge(edge, 'linewidth', 2)

     See also: edges2d, lines2d





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Convert an edge to a straight line




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
edges2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 492
 -- Function File: edges2d ()
     Description of functions operating on planar edges

     An edge is represented by the corodinate of its end points:   EDGE
     = [X1 Y1 X2 Y2];

     A set of edges is represented by a N*4 array, each row
     representing an   edge.

     See also: lines2d, rays2d, points2d   createEdge, edgeAngle,
     edgeLength, edgeToLine, midPoint   intersectEdges,
     intersectLineEdge, isPointOnEdge   clipEdge, transformEdge
     drawEdge, drawCenteredEdge





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Description of functions operating on planar edges




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
ellipse2cov


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 672
 -- Function File: K =  ellipse2cov (ELLI)
 -- Function File: K =  ellipse2cov (RA, RB)
 -- Function File: K =  ellipse2cov (..., THETA)
     Calculates covariance matrix from ellipse.

     If only one input is given, ELLI must define an ellipse as
     described in `ellipses2d'.  If two inputs are given, RA and RB
     define the half-lenght of the axes.  If a third input is given,
     THETA must be the angle of rotation of the ellipse in radians, and
     in counter-clockwise direction.

     The output K contains the covariance matrix define by the ellipse.

     Run `demo ellipse2cov' to see an example.

     See also: ellipses2d, cov2ellipse, drawEllipse





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Calculates covariance matrix from ellipse.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
ellipseAsPolygon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 731
 -- Function File: P =  ellipseAsPolygon (ELL, N)
     Convert an ellipse into a series of points

     P = ellipseAsPolygon(ELL, N);   converts ELL given as [x0 y0 a b]
     or [x0 y0 a b theta] into a polygon   with N edges. The result P
     is (N+1)-by-2 array containing coordinates   of the N+1 vertices
     of the polygon.    The resulting polygon is closed, i.e. the last
     point is the same as the   first one.

     P = ellipseAsPolygon(ELL);   Use a default number of edges equal
     to 72. This result in one piont for   each 5 degrees.

     [X Y] = ellipseAsPolygon(...);   Return the coordinates o
     fvertices in two separate arrays.

     See also: ellipses2d, circleAsPolygon, rectAsPolygon, drawEllipse





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Convert an ellipse into a series of points




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
ellipses2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 377
 -- Function File: ellipses2d ()
     Description of functions operating on ellipses.

     Ellipses are represented by their center, the length of their 2
     semi-axes length, and their angle from the Ox direction (in
     degrees).    E = [XC YC A B THETA];

     See also: circles2d, inertiaEllipse, isPointInEllipse,
     ellipseAsPolygon   drawEllipse, drawEllipseArc





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Description of functions operating on ellipses.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
enclosingCircle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 462
 -- Function File: CIRCLE =  enclosingCircle (PTS)
     Find the minimum circle enclosing a set of points.

     CIRCLE = enclosingCircle(POINTS);   compute cirlce CIRCLE=[xc yc
     r] which enclose all points POINTS given   as an [Nx2] array.

     Rewritten from a file from           Yazan Ahed   which was
     rewritten from a Java applet by Shripad Thite :
     `http://heyoka.cs.uiuc.edu/~thite/mincircle/'

     See also: circles2d, points2d, boxes2d





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Find the minimum circle enclosing a set of points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
fitAffineTransform2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 397
 -- Function File: T =  fitAffineTransform2d (PTS1, PTS2)
     Fit an affine transform using two point sets.

     Example

            N = 10;
            pts = rand(N, 2)*10;
            trans = createRotation(3, 4, pi/4);
            pts2 = transformPoint(pts, trans);
            pts3 = pts2 + randn(N, 2)*2;
            fitted = fitAffineTransform2d(pts, pts2)

     See also: transforms2d





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Fit an affine transform using two point sets.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
geom2d_Contents


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8910
 -- Function File: geom2d_Contents ()
     Geometry 2D Toolbox Version 1.2.0 21-Oct-2011 .

     	Library to handle and visualize geometric primitives such as
     points, 	lines, circles and ellipses, polygons...

     The goal is to provide a low-level library for manipulating
     geometrical   primitives, making easier the development of more
     complex geometric   algorithms.

     Most functions works for planar shapes, but some ones have been
     extended to 3D or to any dimension.

     Points   points2d             - Description of functions operating
     on points   clipPoints           - Clip a set of points by a box
     centroid             - Compute centroid (center of mass) of a set
     of points   midPoint             - Middle point of two points or
     of an edge   isCounterClockwise   - Compute relative orientation
     of 3 points   polarPoint           - Create a point from polar
     coordinates (rho + theta)   angle2Points         - Compute
     horizontal angle between 2 points   angle3Points         - Compute
     oriented angle made by 3 points   angleSort            - Sort
     points in the plane according to their angle to origin
     distancePoints       - Compute distance between two points
     minDistancePoints    - Minimal distance between several points
     transformPoint       - Transform a point with an affine transform
     drawPoint            - Draw the point on the axis.

     Vectors   vectors2d            - Description of functions
     operating on plane vectors   createVector         - Create a
     vector from two points   vectorNorm           - Compute norm of a
     vector, or of a set of vectors   vectorAngle          - Angle of a
     vector, or between 2 vectors   normalizeVector      - Normalize a
     vector to have norm equal to 1   isPerpendicular      - Check
     orthogonality of two vectors   isParallel           - Check
     parallelism of two vectors   transformVector      - Transform a
     vector with an affine transform   rotateVector         - Rotate a
     vector by a given angle

     Straight lines   lines2d              - Description of functions
     operating on planar lines   createLine           - Create a
     straight line from 2 points, or from other inputs   medianLine
          - Create a median line between two points   cartesianLine
       - Create a straight line from cartesian equation coefficients
     orthogonalLine       - Create a line orthogonal to another one.
     parallelLine         - Create a line parallel to another one.
     intersectLines       - Return all intersection points of N lines
     in 2D   lineAngle            - Computes angle between two straight
     lines   linePosition         - Position of a point on a line
     lineFit              - Fit a straight line to a set of points
     clipLine             - Clip a line with a box   reverseLine
      - Return same line but with opposite orientation   transformLine
          - Transform a line with an affine transform   drawLine
         - Draw the line on the current axis

     Edges (line segments between 2 points)   edges2d              -
     Description of functions operating on planar edges   createEdge
           - Create an edge between two points, or from a line
     edgeToLine           - Convert an edge to a straight line
     edgeAngle            - Return angle of edge   edgeLength
     - Return length of an edge   midPoint             - Middle point
     of two points or of an edge   edgePosition         - Return
     position of a point on an edge   clipEdge             - Clip an
     edge with a rectangular box   reverseEdge          - Intervert the
     source and target vertices of edge   intersectEdges       - Return
     all intersections between two set of edges   intersectLineEdge
     - Return intersection between a line and an edge   transformEdge
         - Transform an edge with an affine transform   drawEdge
         - Draw an edge given by 2 points   drawCenteredEdge     - Draw
     an edge centered on a point

     Rays   rays2d               - Description of functions operating
     on planar rays   createRay            - Create a ray (half-line),
     from various inputs   bisector             - Return the bisector
     of two lines, or 3 points   clipRay              - Clip a ray with
     a box   drawRay              - Draw a ray on the current axis

     Relations between points and lines   distancePointEdge    -
     Minimum distance between a point and an edge   distancePointLine
     - Minimum distance between a point and a line   projPointOnLine
      - Project of a point orthogonally onto a line   pointOnLine
       - Create a point on a line at a given position on the line
     isPointOnLine        - Test if a point belongs to a line
     isPointOnEdge        - Test if a point belongs to an edge
     isPointOnRay         - Test if a point belongs to a ray
     isLeftOriented       - Test if a point is on the left side of a
     line

     Circles   circles2d            - Description of functions
     operating on circles   createCircle         - Create a circle from
     2 or 3 points   createDirectedCircle - Create a directed circle
     intersectCircles     - Intersection points of two circles
     intersectLineCircle  - Intersection point(s) of a line and a circle
      circleAsPolygon      - Convert a circle into a series of points
     circleArcAsCurve     - Convert a circle arc into a series of points
      isPointInCircle      - Test if a point is located inside a given
     circle   isPointOnCircle      - Test if a point is located on a
     given circle.    enclosingCircle      - Find the minimum circle
     enclosing a set of points.    radicalAxis          - Compute the
     radical axis (or radical line) of 2 circles   drawCircle
     - Draw a circle on the current axis   drawCircleArc        - Draw
     a circle arc on the current axis

     Ellipses   ellipses2d           - Description of functions
     operating on ellipses   inertiaEllipse       - Inertia ellipse of
     a set of points   isPointInEllipse     - Check if a point is
     located inside a given ellipse   ellipseAsPolygon     - Convert an
     ellipse into a series of points   drawEllipse          - Draw an
     ellipse on the current axis   drawEllipseArc       - Draw an
     ellipse arc on the current axis

     Geometric transforms   transforms2d         - Description of
     functions operating on transforms   createTranslation    - Create
     the 3*3 matrix of a translation   createRotation       - Create
     the 3*3 matrix of a rotation   createScaling        - Create the
     3*3 matrix of a scaling in 2 dimensions   createHomothecy      -
     Create the the 3x3 matrix of an homothetic transform
     createBasisTransform - Compute matrix for transforming a basis
     into another basis   createLineReflection - Create the the 3x3
     matrix of a line reflection   fitAffineTransform2d - Fit an affine
     transform using two point sets

     Angles   angles2d             - Description of functions for
     manipulating angles   normalizeAngle       - Normalize an angle
     value within a 2*PI interval   angleAbsDiff         - Absolute
     difference between two angles   angleDiff            - Difference
     between two angles   deg2rad              - Convert angle from
     degrees to radians   rad2deg              - Convert angle from
     radians to degrees

     Boxes   boxes2d              - Description of functions operating
     on bounding boxes   intersectBoxes       - Intersection of two
     bounding boxes   mergeBoxes           - Merge two boxes, by
     computing their greatest extent   randomPointInBox     - Generate
     random point within a box   drawBox              - Draw a box
     defined by coordinate extents

     Various drawing functions   drawBezierCurve      - Draw a cubic
     bezier curve defined by 4 control points   drawParabola         -
     Draw a parabola on the current axis   drawOrientedBox      - Draw
     centered oriented rectangle   drawRect             - Draw
     rectangle on the current axis   drawArrow            - Draw an
     arrow on the current axis   drawLabels           - Draw labels at
     specified positions   drawShape            - Draw various types of
     shapes (circles, polygons...)

     Other shapes   squareGrid           - Generate equally spaces
     points in plane.    hexagonalGrid        - Generate hexagonal grid
     of points in the plane.    triangleGrid         - Generate
     triangular grid of points in the plane.    crackPattern         -
     Create a (bounded) crack pattern tessellation   crackPattern2
      - Create a (bounded) crack pattern tessellation

     Credits:   * function 'enclosingCircle' rewritten from a file from
     Yazan Ahed    , available on Matlab File Exchange





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Geometry 2D Toolbox Version 1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
hexagonalGrid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 458
 -- Function File: PTS =  hexagonalGrid (BOUNDS, ORIGIN, SIZE)
     Generate hexagonal grid of points in the plane.

     usage   PTS = hexagonalGrid(BOUNDS, ORIGIN, SIZE)   generate
     points, lying in the window defined by BOUNDS (=[xmin ymin   xmax
     ymax]), starting from origin with a constant step equal to size.
     SIZE is constant and is equals to the length of the sides of each
     hexagon.

     TODO: add possibility to use rotated grid




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Generate hexagonal grid of points in the plane.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
inertiaEllipse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1098
 -- Function File: ELL =  inertiaEllipse (PTS)
     Inertia ellipse of a set of points

     ELL = inertiaEllipse(PTS);   where PTS is a N*2 array containing
     coordinates of N points, computes   the inertia ellispe of the set
     of points.

     The result has the form:   ELL = [XC YC A B THETA],   with XC and
     YC being the center of mass of the point set, A and B are   the
     lengths of the inertia ellipse (see below), and THETA is the angle
      of the main inertia axis with the horizontal (counted in degrees
     between 0 and 180).    A and B are the standard deviations of the
     point coordinates when   ellipse is aligned with the inertia axes.

            pts = randn(100, 2);
            pts = transformPoint(pts, createScaling(5, 2));
            pts = transformPoint(pts, createRotation(pi/6));
            pts = transformPoint(pts, createTranslation(3, 4));
            ell = inertiaEllipse(pts);
            figure(1); clf; hold on;
            drawPoint(pts);
            drawEllipse(ell, 'linewidth', 2, 'color', 'r');

     See also: ellipses2d, drawEllipse





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Inertia ellipse of a set of points




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
intersectBoxes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 303
 -- Function File: BOX = intersectBoxes (BOX1, BOX2)
     Intersection of two bounding boxes.

     Example

            box1 = [5 20 5 30];
            box2 = [0 15 0 15];
            intersectBoxes(box1, box2)
            ans =
                5 15 5 15

     See also: boxes2d, drawBox, mergeBoxes





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Intersection of two bounding boxes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
intersectCircles


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1236
 -- Function File: POINTS =  intersectCircles (CIRCLE1, CIRCLE2)
     Intersection points of two circles.

     POINTS = intersectCircles(CIRCLE1, CIRCLE2)   Computes the
     intersetion point of the two circles CIRCLE1 and CIRCLE1.    Both
     circles are given with format: [XC YC R], with (XC,YC) being the
     coordinates of the center and R being the radius.    POINTS is a
     2-by-2 array, containing coordinate of an intersection   point on
     each row.    In the case of tangent circles, the intersection is
     returned twice. It   can be simplified by using the 'unique'
     function.

     Example     # intersection points of two distant circles     c1 =
     [0  0 10];     c2 = [10 0 10];     pts = intersectCircles(c1, c2)
       pts =         5   -8.6603         5    8.6603

     # intersection points of two tangent circles     c1 = [0  0 10];
      c2 = [20 0 10];     pts = intersectCircles(c1, c2)     pts =
       10    0         10    0     pts2 = unique(pts, 'rows')     pts2 =
            10    0

     References
     http://local.wasp.uwa.edu.au/~pbourke/geometry/2circle/
     http://mathworld.wolfram.com/Circle-CircleIntersection.html

     See also: circles2d, intersectLineCircle, radicalAxis





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Intersection points of two circles.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
intersectEdges


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 739
 -- Function File: POINT =  intersectEdges (EDGE1, EDGE2)
     Return all intersections between two set of edges

     P = intersectEdges(E1, E2);   returns the intersection point of
     lines L1 and L2. E1 and E2 are 1-by-4   arrays, containing
     parametric representation of each edge (in the form   [x1 y1 x2
     y2], see 'createEdge' for details).

     In case of colinear edges, returns [Inf Inf].    In case of
     parallel but not colinear edges, returns [NaN NaN].

     If each input is [N*4] array, the result is a [N*2] array
     containing   intersections of each couple of edges.    If one of
     the input has N rows and the other 1 row, the result is a   [N*2]
     array.

     See also: edges2d, intersectLines





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return all intersections between two set of edges




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
intersectLineCircle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 772
 -- Function File: POINTS =  intersectLineCircle (LINE, CIRCLE)
     Intersection point(s) of a line and a circle

     INTERS = intersectLineCircle(LINE, CIRCLE);   Returns a 2-by-2
     array, containing on each row the coordinates of an   intersection
     point. If the line and circle do not intersect, the result   is
     filled with NaN.

     Example   # base point   center = [10 0];   # create vertical line
      l1 = [center 0 1];   # circle   c1 = [center 5];   pts =
     intersectLineCircle(l1, c1)   pts =       10   -5       10    5
     # draw the result   figure; clf; hold on;   axis([0 20 -10 10]);
     drawLine(l1);   drawCircle(c1);   drawPoint(pts, 'rx');   axis
     equal;

     See also: lines2d, circles2d, intersectLines, intersectCircles





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Intersection point(s) of a line and a circle




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
intersectLineEdge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 868
 -- Function File: POINT =  intersecLineEdge (LINE, EDGE)
     Return intersection between a line and an edge.

     Returns the intersection point of lines LINE and edge EDGE.
     LINE is a 1x4 array containing parametric representation of the
     line   (in the form [x0 y0 dx dy], see `createLine' for details).
      EDGE is a 1x4 array containing coordinates of first and second
     point   (in the form [x1 y1 x2 y2], see `createEdge' for details).

     In case of colinear line and edge, returns [Inf Inf].    If line
     does not intersect edge, returns [NaN NaN].

     If each input is [N*4] array, the result is a [N*2] array
     containing   intersections for each couple of edge and line.    If
     one of the input has N rows and the other 1 row, the result is a
     [N*2] array.

     See also: lines2d, edges2d, intersectEdges, intersectLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return intersection between a line and an edge.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
intersectLines


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1143
 -- Function File: POINT = intersectLines (LINE1, LINE2)
 -- Function File: POINT = intersectLines (LINE1, LINE2,EPS)
     Return all intersection points of N lines in 2D.

     Returns the intersection point of lines LINE1 and LINE2.  LINE1
     and LINE2 are [1*4]   arrays, containing parametric representation
     of each line (in the form   [x0 y0 dx dy], see `createLine' for
     details).

     In case of colinear lines, returns [Inf Inf].    In case of
     parallel but not colinear lines, returns [NaN NaN].

     If each input is [N*4] array, the result is a [N*2] array
     containing   intersections of each couple of lines.    If one of
     the input has N rows and the other 1 row, the result is a   [N*2]
     array.

     A third input argument specifies the tolerance for detecting
     parallel lines.  Default is 1e-14.

     Example

            line1 = createLine([0 0], [10 10]);
            line2 = createLine([0 10], [10 0]);
            point = intersectLines(line1, line2)
            point =
                5   5

     See also: lines2d, edges2d, intersectEdges, intersectLineEdge,
     intersectLineCircle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return all intersection points of N lines in 2D.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
isCounterClockwise


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1212
 -- Function File: CCW =  isCounterClockwise (P1, P2, P3)
 -- Function File: CCW =  isCounterClockwise (P1, P2, P3,TOL)
     Compute relative orientation of 3 points

     Computes the orientation of the 3 points. The returns is:   +1 if
     the path  P1-> P2-> P3 turns Counter-Clockwise (i.e., the point  P3
          is located "on the left" of the line  P1- P2)   -1 if the
     path turns Clockwise (i.e., the point  P3 lies "on the right"
     of the line  P1- P2)   0  if the point  P3 is located on the line
     segment [ P1  P2].

     This function can be used in more complicated algorithms:
     detection of   line segment intersections, convex hulls, point in
     triangle...

     CCW = isCounterClockwise( P1,  P2,  P3, EPS);   Specifies the
     threshold used for detecting colinearity of the 3 points.
     Default value is 1e-12 (absolute).

     Example

            isCounterClockwise([0 0], [10 0], [10 10])
            ans =
                1
            isCounterClockwise([0 0], [0 10], [10 10])
            ans =
                -1
            isCounterClockwise([0 0], [10 0], [5 0])
            ans =
                0

     See also: points2d, isPointOnLine, isPointInTriangle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Compute relative orientation of 3 points




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
isLeftOriented


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 343
 -- Function File: B =  isLeftOriented (POINT, LINE)
     Test if a point is on the left side of a line

     B = isLeftOriented(POINT, LINE);   Returns TRUE if the point lies
     on the left side of the line with   respect to the line direction.

     See also: lines2d, points2d, isCounterClockwise, isPointOnLine,
     distancePointLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Test if a point is on the left side of a line




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
isParallel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 757
 -- Function File: B =  isParallel (V1, V2)
 -- Function File: B =  isParallel (V1, V2,TOL)
     Check parallelism of two vectors

     V1 and V2 are 2 row vectors of length Nd, Nd being the dimension,
     returns `true' if the vectors are parallel, and `false' otherwise.

     Also works when V1 and V2 are two [NxNd] arrays with same number of
      rows. In this case, return a [Nx1] array containing `true' at the
     positions   of parallel vectors.

     TOL specifies the accuracy of numerical computation. Default value
     is 1e-14.

     Example

            isParallel([1 2], [2 4])
            ans =
              1
            isParallel([1 2], [1 3])
            ans =
              0

     See also: vectors2d, isPerpendicular, lines2d





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Check parallelism of two vectors




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
isPerpendicular


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 791
 -- Function File: B =  isPerpendicular (V1, V2)
 -- Function File: B =  isPerpendicula (V1, V2,TOL)
     heck orthogonality of two vectors.

     V1 and V2 are 2 row vectors of length Nd, Nd being the dimension,
     returns `true' if the vectors are perpendicular, and `false'
     otherwise.

     Also works when V1 and V2 are two [NxNd] arrays with same number of
      rows. In this case, return a [Nx1] array containing `true' at the
     positions   of parallel vectors.

     TOL specifies the accuracy of numerical computation. Default value
     is 1e-14.

     Example

            isPerpendicular([1 2 0], [0 0 2])
            ans =
              1
            isPerpendicular([1 2 1], [1 3 2])
            ans =
              0

     See also: vectors2d, isParallel, lines2d





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
heck orthogonality of two vectors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
isPointInCircle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 578
 -- Function File: B =  isPointInCircle (POINT, CIRCLE)
     Test if a point is located inside a given circle

     B = isPointInCircle(POINT, CIRCLE)   Returns true if point is
     located inside the circle, i.e. if distance to   circle center is
     lower than the circle radius.

     B = isPointInCircle(POINT, CIRCLE, TOL)   Specifies the tolerance
     value

     Example:   isPointInCircle([1 0], [0 0 1])   isPointInCircle([0
     0], [0 0 1])   returns true, whereas   isPointInCircle([1 1], [0 0
     1])   return false

     See also: circles2d, isPointOnCircle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Test if a point is located inside a given circle




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
isPointInEllipse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 599
 -- Function File: B =  isPointInellipse (POINT, ELLIPSE)
     Check if a point is located inside a given ellipse

     B = isPointInEllipse(POINT, ELLIPSE)   Returns true if point is
     located inside the given ellipse.

     B = isPointInEllipse(POINT, ELLIPSE, TOL)   Specifies the
     tolerance value

     Example:   isPointInEllipse([1 0], [0 0 2 1 0])   ans =       1
     isPointInEllipse([0 0], [0 0 2 1 0])   ans =       1
     isPointInEllipse([1 1], [0 0 2 1 0])   ans =       0
     isPointInEllipse([1 1], [0 0 2 1 30])   ans =       1

     See also: ellipses2d, isPointInCircle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Check if a point is located inside a given ellipse




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
isPointOnCircle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 548
 -- Function File: B =  isPointOnCircle (POINT, CIRCLE)
     Test if a point is located on a given circle.

     B = isPointOnCircle(POINT, CIRCLE)   return true if point is
     located on the circle, i.e. if the distance to   the circle center
     equals the radius up to an epsilon value.

     B = isPointOnCircle(POINT, CIRCLE, TOL)   Specifies the tolerance
     value.

     Example:   isPointOnCircle([1 0], [0 0 1])   returns true, whereas
      isPointOnCircle([1 1], [0 0 1])   return false

     See also: circles2d, isPointInCircle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Test if a point is located on a given circle.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
isPointOnEdge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1084
 -- Function File: B =  isPointOnEdge (POINT, EDGE)
 -- Function File: B =  isPointOnEdge (POINT, EDGE, TOL)
 -- Function File: B =  isPointOnEdge (POINT, EDGEARRAY)
 -- Function File: B =  isPointOnEdge (POINTARRAY, EDGEARRAY)
     Test if a point belongs to an edge.

     with POINT being [xp yp], and EDGE being [x1 y1 x2 y2], returns
     TRUE if   the point is located on the edge, and FALSE otherwise.

     Specify an optilonal tolerance value TOL. The tolerance is given
     as a   fraction of the norm of the edge direction vector. Default
     is 1e-14.

     When one of the inputs has several rows, return the result of the
     test   for each element of the array tested against the single
     parameter.

     When both POINTARRAY and EDGEARRAY have the same number of rows,
     returns a column vector with the same number of rows.    When the
     number of rows are different and both greater than 1, returns   a
     Np-by-Ne matrix of booleans, containing the result for each couple
     of   point and edge.

     See also: edges2d, points2d, isPointOnLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Test if a point belongs to an edge.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
isPointOnLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 473
 -- Function File: B =  isPointOnLine (POINT, LINE)
     Test if a point belongs to a line

     B = isPointOnLine(POINT, LINE)   with POINT being [xp yp], and
     LINE being [x0 y0 dx dy].    Returns 1 if point lies on the line,
     0 otherwise.

     If POINT is an N*2 array of points, B is a N*1 array of booleans.

     If LINE is a N*4 array of line, B is a 1*N array of booleans.

     See also: lines2d, points2d, isPointOnEdge, isPointOnRay,
     angle3Points





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Test if a point belongs to a line




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
isPointOnRay


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 393
 -- Function File: B =  isPointOnRay (POINT, RAY)
 -- Function File: B =  isPointOnRay (POINT, RAY, TOL)
     Test if a point belongs to a ray

     B = isPointOnRay(POINT, RAY);  Returns `true' if point POINT
     belongs to the ray RAY.   POINT is given by [x y] and RAY by [x0
     y0 dx dy]. TOL gives the  tolerance for the calculations.

     See also: rays2d, points2d, isPointOnLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Test if a point belongs to a ray




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
lineAngle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 527
 -- Function File: THETA = lineAngle(varargin)
     Computes angle between two straight lines

     A = lineAngle(LINE);   Returns the angle between horizontal,
     right-axis and the given line.    Angle is fiven in radians,
     between 0 and 2*pi, in counter-clockwise   direction.

     A = lineAngle(LINE1, LINE2);   Returns the directed angle between
     the two lines. Angle is given in   radians between 0 and 2*pi, in
     counter-clockwise direction.

     See also: lines2d, angles2d, createLine, normalizeAngle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Computes angle between two straight lines




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
linePosition


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 890
 -- Function File: POS = linePosition (POINT, LINE)
     Position of a point on a line.

     Computes position of point POINT on the line LINE, relative to
     origin   point and direction vector of the line.    LINE has the
     form [x0 y0 dx dy],   POINT has the form [x y], and is assumed to
     belong to line.

     If LINE is an array of NL lines, return NL positions,
     corresponding to   each line.

     If POINT is an array of NP points, return NP positions,
     corresponding   to each point.

     If POINT is an array of NP points and LINES is an array of NL
     lines,   return an array of [NP NL] position, corresponding to
     each couple   point-line.

     Example

            line = createLine([10 30], [30 90]);
            linePosition([20 60], line)
            ans =
                .5

     See also: lines2d, createLine, projPointOnLine, isPointOnLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Position of a point on a line.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
lines2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 996
 -- Function File: lines2d ()
     Description of functions operating on planar lines.

     The term 'line' refers to a planar straight line, which is an
     unbounded   curve. Line segments defined between 2 points, which
     are bounded, are   called 'edge', and are presented in file
     'edges2d'.

     A straight line is defined by a point (its origin), and a vector
     (its   direction). The different parameters are bundled into a row
     vector:   LINE = [x0 y0 dx dy];

     A line contains all points (x,y) such that:       x = x0 + t*dx
       y = y0 + t*dy;   for all t between -infinity and +infinity.

     See also: points2d, vectors2d, edges2d, rays2d   createLine,
     cartesianLine, medianLine, edgeToLine   orthogonalLine,
     parallelLine, bisector, radicalAxis   lineAngle, linePosition,
     projPointOnLine   isPointOnLine, distancePointLine, isLeftOriented
      intersectLines, intersectLineEdge, clipLine   invertLine,
     transformLine, drawLine   lineFit





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Description of functions operating on planar lines.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
medianLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1284
 -- Function File: LINE =  medianLine (P1, P2)
 -- Function File: LINE =  medianLine (PTS)
 -- Function File: LINE =  medianLine (EDGE)
     Create a median line between two points.

     Create the median line of points P1 and P2, that is the line
     containing   all points located at equal distance of P1 and P2.

     Creates the median line of 2 points, given as a 2*2 array PTS.
     Array has   the form:   [ [ x1 y1 ] ; [ x2 y2 ] ]

     Creates the median of the EDGE. EDGE is a 1*4 array, containing
     [X1 Y1]   coordinates of first point, and [X2 Y2], the coordinates
     of the second   point.

     Example

            # Draw the median line of two points
              P1 = [10 20];
              P2 = [30 50];
              med = medianLine(P1, P2);
              figure; axis square; axis([0 100 0 100]);
              drawEdge([P1 P2], 'linewidth', 2, 'color', 'k');
              drawLine(med)

            # Draw the median line of an edge
              P1 = [50 60];
              P2 = [80 30];
              edge = createEdge(P1, P2);
              figure; axis square; axis([0 100 0 100]);
              drawEdge(edge, 'linewidth', 2)
              med = medianLine(edge);
              drawLine(med)

     See also: lines2d, createLine, orthogonalLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Create a median line between two points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
mergeBoxes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 316
 -- Function File: BOX = mergeBoxes (BOX1, BOX2)
     Merge two boxes, by computing their greatest extent.

     Example

            box1 = [5 20 5 30];
            box2 = [0 15 0 15];
            mergeBoxes(box1, box2)
            ans =
                0 20 0 30

     See also: boxes2d, drawBox, intersectBoxes





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Merge two boxes, by computing their greatest extent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
midPoint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 868
 -- Function File: MID =  midPoint (P1, P2)
 -- Function File: MID =  midPoint (EDGE)
 -- Function File: [MIDX, MIDY] =  midPoint (EDGE)
     Middle point of two points or of an edge

     Computes the middle point of the two points P1 and P2.

     If an edge is given, computes the middle point of the edge given
     by EDGE.    EDGE has the format: [X1 Y1 X2 Y2], and MID has the
     format [XMID YMID],   with XMID = (X1+X2)/2, and YMID = (Y1+Y2)/2.

     If two output arguments are given, it returns the result as two
     separate variables or arrays.

     Works also when EDGE is a N-by-4 array, in this case the result is
     a   N-by-2 array containing the midpoint of each edge.

     Example

            p1 = [10 20];
            p2 = [30 40];
            midPoint([p1 p2])
            ans =
                20  30

     See also: edges2d, points2d





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Middle point of two points or of an edge




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
minDistancePoints


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2407
 -- Function File: DIST =  minDistancePoints (PTS)
 -- Function File: DIST =  minDistancePoints (PTS1,PTS2)
 -- Function File: DIST =  minDistancePoints (...,NORM)
 -- Function File: [DIST I J] =  minDistancePoints (PTS1, PTS2, ...)
 -- Function File: [DIST J] =  minDistancePoints (PTS1, PTS2, ...)
     Minimal distance between several points.

     Returns the minimum distance between all couple of points in PTS.
     PTS is   an array of [NxND] values, N being the number of points
     and ND the   dimension of the points.

     Computes for each point in PTS1 the minimal distance to every
     point of   PTS2. PTS1 and PTS2 are [NxD] arrays, where N is the
     number of points,   and D is the dimension. Dimension must be the
     same for both arrays, but   number of points can be different.
     The result is an array the same length as PTS1.

     When NORM is provided, it uses a user-specified norm. NORM=2 means
     euclidean norm (the default),   NORM=1 is the Manhattan (or
     "taxi-driver") distance.    Increasing NORM growing up reduces the
     minimal distance, with a limit   to the biggest coordinate
     difference among dimensions.

     Returns indices I and J of the 2 points which are the closest. DIST
      verifies relation:   DIST = distancePoints(PTS(I,:), PTS(J,:));

     If only 2 output arguments are given, it returns the indices of
     points which are the closest. J has the   same size as DIST. for
     each I It verifies the relation :   DIST(I) =
     distancePoints(PTS1(I,:), PTS2(J,:));

     Examples:

            # minimal distance between random planar points
                points = rand(20,2)*100;
                minDist = minDistancePoints(points);

            # minimal distance between random space points
                points = rand(30,3)*100;
                [minDist ind1 ind2] = minDistancePoints(points);
                minDist
                distancePoints(points(ind1, :), points(ind2, :))
            # results should be the same

            # minimal distance between 2 sets of points
                points1 = rand(30,2)*100;
                points2 = rand(30,2)*100;
                [minDists inds] = minDistancePoints(points1, points2);
                minDists(10)
                distancePoints(points1(10, :), points2(inds(10), :))
            # results should be the same

     See also: points2d, distancePoints





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Minimal distance between several points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
normalizeAngle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 884
 -- Function File: ALPHA2 = normalizeAngle (ALPHA)
 -- Function File: ALPHA2 = normalizeAngle (ALPHA, CENTER)
     Normalize an angle value within a 2*PI interval

     ALPHA2 = normalizeAngle(ALPHA);   ALPHA2 is the same as ALPHA
     modulo 2*PI and is positive.

     ALPHA2 = normalizeAngle(ALPHA, CENTER);   Specifies the center of
     the angle interval.    If CENTER==0, the interval is [-pi ; +pi]
     If CENTER==PI, the interval is [0 ; 2*pi] (default).

     Example:   # normalization between 0 and 2*pi (default)
     normalizeAngle(5*pi)   ans =       3.1416

     # normalization between -pi and +pi   normalizeAngle(7*pi/2, 0)
     ans =       -1.5708

     References   Follows the same convention as apache commons
     library, see:
     http://commons.apache.org/math/api-2.2/org/apache/commons/math/util/MathUtils.html##

     See also: vectorAngle, lineAngle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Normalize an angle value within a 2*PI interval




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
normalizeVector


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 503
 -- Function File: VN =  normalizeVector (V)
     Normalize a vector to have norm equal to 1

     Returns the normalization of vector V, such that ||V|| = 1.  V can
     be either a row or a column vector.

     When V is a MxN array, normalization is performed for each row of
     the array.

     Example:

            vn = normalizeVector([3 4])
            vn =
                0.6000   0.8000
            vectorNorm(vn)
            ans =
                1

     See also: vectors2d, vectorNorm





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Normalize a vector to have norm equal to 1




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
orthogonalLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 343
 -- Function File: PERP =  orthogonalLine (LINE, POINT)
     Create a line orthogonal to another one.

     Returns the line orthogonal to the line LINE and going through the
      point given by POINT. Directed angle from LINE to PERP is pi/2.
     LINE is given as [x0 y0 dx dy] and POINT is [xp yp].

     See also: lines2d, parallelLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Create a line orthogonal to another one.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
parallelLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 565
 -- Function File: RES =  parallelLine (LINE, POINT)
 -- Function File: RES =  parallelLine (LINE, DIST)
     Create a line parallel to another one.

     Returns the line with same direction vector than LINE and going
     through   the point given by POINT.    LINE is given as [x0 y0 dx
     dy] and POINT is [xp yp].

     Uses relative distance to specify position. The new line will be
     located at distance DIST, counted positive in the right side of
     LINE   and negative in the left side.

     See also: lines2d, orthogonalLine, distancePointLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Create a line parallel to another one.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
pointOnLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 451
 -- Function File: POINT =  pointOnLine (LINE, D)
     Create a point on a line at a given position on the line.

     Creates the point belonging to the line LINE, and located at the
     distance D from the line origin.    LINE has the form [x0 y0 dx
     dy].    LINE and D should have the same number N of rows. The
     result will have   N rows and 2 column (x and y positions).

     See also: lines2d, points2d, onLine, onLine, linePosition





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Create a point on a line at a given position on the line.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
points2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 591
 -- Function File: points2d ()
     Description of functions operating on points.

     A point is defined by its two cartesian coordinate, put into a row
      vector of 2 elements:   P = [x y];

     Several points are stores in a matrix with two columns, one for the
      x-coordinate, one for the y-coordinate.    PTS = [x1 y1 ; x2 y2 ;
     x3 y3];

     Example   P = [5 6];

     See also: centroid, midPoint, polarPoint, pointOnLine
     isCounterClockwise, angle2Points, angle3Points, angleSort
     distancePoints, minDistancePoints   transformPoint, clipPoints,
     drawPoint





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Description of functions operating on points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
polarPoint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 760
 -- Function File: POINT =  polarPoint (RHO, THETA)
 -- Function File: POINT =  polarPoint (THETA)
 -- Function File: POINT =  polarPoint (POINT, RHO, THETA)
 -- Function File: POINT =  polarPoint (X0, Y0, RHO, THETA)
     Create a point from polar coordinates (rho + theta)

     Creates a point using polar coordinate. THETA is angle with
     horizontal   (counted counter-clockwise, and in radians), and RHO
     is the distance to   origin. If only angle is given radius RHO is
     assumed to be 1.

     If a point is given, adds the coordinate of the point to the
     coordinate of the specified   point. For example, creating a point
     with :     P = polarPoint([10 20], 30, pi/2);   will give a result
     of [40 20].

     See also: points2d





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Create a point from polar coordinates (rho + theta)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
projPointOnLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 566
 -- Function File: POINT =  projPointOnLine (PT1, LINE)
     Project of a point orthogonally onto a line

     Computes the (orthogonal) projection of point PT1 onto the line
     LINE.

     Function works also for multiple points and lines. In this case, it
      returns multiple points.    Point PT1 is a [N*2] array, and LINE
     is a [N*4] array (see createLine   for details). Result POINT is a
     [N*2] array, containing coordinates of   orthogonal projections of
     PT1 onto lines LINE.

     See also: lines2d, points2d, isPointOnLine, linePosition





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Project of a point orthogonally onto a line




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rad2deg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 284
 -- Function File: DEG = rad2deg(RAD)
     Convert angle from radians to degrees

     Usage:   R = rad2deg(D)   convert an angle in radians to angle in
     degrees

     Example:   rad2deg(pi)   ans =       180   rad2deg(pi/3)   ans =
        60

     See also: angles2d, deg2rad





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Convert angle from radians to degrees




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
radicalAxis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 522
 -- Function File: LINE =  radicalAxis (CIRCLE1, CIRCLE2)
     Compute the radical axis (or radical line) of 2 circles

     L = radicalAxis(C1, C2)   Computes the radical axis of 2 circles.

     Example   C1 = [10 10 5];   C2 = [60 50 30];   L = radicalAxis(C1,
     C2);   hold on; axis equal;axis([0 100 0 100]);
     drawCircle(C1);drawCircle(C2);drawLine(L);

     Ref:   http://mathworld.wolfram.com/RadicalLine.html
     http://en.wikipedia.org/wiki/Radical_axis

     See also: lines2d, circles2d, createCircle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Compute the radical axis (or radical line) of 2 circles




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
randomPointInBox


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 658
 -- Function File: POINTS = randomPointInBox (BOX)
 -- Function File: POINTS = randomPointInBox (BOX, N)
     Generate random points within a box.

     Generate a random point within the box BOX. The result is a 1-by-2
     row vector. If N is given, generates N points. The result is a
     N-by-2 array.

     Example

              # draw points within a box
              box = [10 80 20 60];
              pts =  randomPointInBox(box, 500);
              figure(1); clf; hold on;
              drawBox(box);
              drawPoint(pts, '.');
              axis('equal');
              axis([0 100 0 100]);

     See also: edges2d, boxes2d, clipLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Generate random points within a box.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rays2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 722
 -- Function File: rays2d ()
     Description of functions operating on planar rays

     A ray is defined by a point (its origin), and a vector (its
     direction). The different parameters are bundled into a row vector:
      `RAY = [x0 y0 dx dy];'

     The ray contains all the points (x,y) such that:   x = x0 + t*dx
     y = y0 + t*dy;   for all t>0

     Contrary to a (straight) line, the points located before the
     origin do   not belong to the ray.    However, as rays and lines
     have the same representation, some functions   working on lines
     are also working on rays (like `transformLine').

     See also: points2d, vectors2d, lines2d, createRay, bisector,
     isPointOnRay, clipRay, drawRay





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Description of functions operating on planar rays




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
reverseEdge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 312
 -- Function File: RES =  reverseEdge (EDGE)
     Intervert the source and target vertices of edge

     REV = reverseEdge(EDGE);   Returns the opposite edge of EDGE.
     EDGE has the format [X1 Y1 X2 Y2]. The resulting edge REV has value
      [X2 Y2 X1 Y1];

     See also: edges2d, createEdge, reverseLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Intervert the source and target vertices of edge




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
reverseLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 318
 -- Function File: LINE =  reverseLine (LINE)
     Return same line but with opposite orientation

     INVLINE = reverseLine(LINE);   Returns the opposite line of LINE.
      LINE has the format [x0 y0 dx dy], then INVLINE will have
     following   parameters: [x0 y0 -dx -dy].

     See also: lines2d, createLine





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return same line but with opposite orientation




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
rotateVector


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 304
 -- Function File: VR =  rotateVector (V, THETA)
     Rotate a vector by a given angle

     Rotate the vector V by an angle THETA, given in radians.

     Example

            rotateVector([1 0], pi/2)
            ans =
                0   1

     See also: vectors2d, transformVector, createRotation





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Rotate a vector by a given angle




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
squareGrid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 494
 -- Function File: PTS =  squaregrid (BOUNDS, ORIGIN, SIZE)
     Generate equally spaces points in plane.

     usage   PTS = squareGrid(BOUNDS, ORIGIN, SIZE)   generate points,
     lying in the window defined by BOUNDS (=[xmin ymin   xmax ymax]),
     starting from origin with a constant step equal to size.

     Example   PTS = squareGrid([0 0 10 10], [3 3], [4 2])   will
     return points :   [3 1;7 1;3 3;7 3;3 5;7 5;3 7;7 7;3 9;7 9];

     TODO: add possibility to use rotated grid





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Generate equally spaces points in plane.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
transformEdge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 587
 -- Function File: EDGE2 =  transformEdge (EDGE1, T)
     Transform an edge with an affine transform.

     Where EDGE1 has the form [x1 y1 x2 y1], and T is a transformation
     matrix, return the edge transformed with affine transform T.

     Format of TRANS can be one of :   [a b]   ,   [a b c] , or [a b c]
      [d e]       [d e f]      [d e f]                            [0 0
     1]

     Also works when EDGE1 is a [Nx4] array of double. In this case,
     EDGE2   has the same size as EDGE1.

     See also: edges2d, transforms2d, transformPoint, translation,
     rotation





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Transform an edge with an affine transform.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
transformLine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 554
 -- Function File: LINE2 =  transformLine (LINE1, T)
     Transform a line with an affine transform.

     Returns the line LINE1 transformed with affine transform T.
     LINE1 has the form [x0 y0 dx dy], and T is a transformation
     matrix.

     Format of T can be one of :   [a b]   ,   [a b c] , or [a b c]
     [d e]       [d e f]      [d e f]                            [0 0 1]

     Also works when LINE1 is a [Nx4] array of double. In this case,
     LINE2   has the same size as LINE1.

     See also: lines2d, transforms2d, transformPoint





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Transform a line with an affine transform.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
transformPoint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 849
 -- Function File: PT2 =  transformPoint (PT1, TRANS)
 -- Function File: [PX2 PY2]=  transformPoint (PX1, PY1, TRANS)
     Transform a point with an affine transform.

     where PT1 has the form [xp yp], and TRANS is a [2x2], [2x3] or
     [3x3]   matrix, returns the point transformed with affine
     transform TRANS.

     Format of TRANS can be one of :   [a b]   ,   [a b c] , or [a b c]
      [d e]       [d e f]      [d e f]                            [0 0
     1]

     Also works when PT1 is a [Nx2] array of double. In this case, PT2
     has   the same size as PT1.

     Also works when PX1 and PY1 are arrays the same size. The function
      transform each couple of (PX1, PY1), and return the result in
     (PX2, PY2), which is the same size as (PX1 PY1).

     See also: points2d, transforms2d, createTranslation, createRotation





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Transform a point with an affine transform.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
transformVector


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 786
 -- Function File: V2 =  transformVector (V, T)
 -- Function File: [X2 Y2] =  transformVector (X,Y, T)
     Transform a vector with an affine transform

     V has the form [xv yv], and T is a [2x2], [2x3] or [3x3]   matrix,
     returns the vector transformed with affine transform T.

     Format of T can be one of :
     [a b]   ,   [a b c] , or [a b c]   [d e]       [d e f]      [d e f]
                               [0 0 1]

     Also works when V is a [Nx2] array of double. In this case, V2 has
      the same size as V.

     Also works when X and Y are arrays the same size. The function
     transform each couple of (X, Y), and return the result in   (X2,
     Y2), which is the same size as (X, Y).

     See also: vectors2d, transforms2d, rotateVector, transformPoint





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Transform a vector with an affine transform




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
transforms2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 675
 -- Function File: transforms2d ()
     Description of functions operating on transforms

     By 'transform' we mean an affine transform. A planar affine
     transform   can be represented by a 3x3 matrix.

     Example

            # create a translation by the vector [10 20]:
            T = createTranslation([10 20])
            T =
                 1     0    10
                 0     1    20
                 0     0     1

     See also: createTranslation, createRotation, createScaling,
     createBasisTransform, createHomothecy, createLineReflection,
     fitAffineTransform2d, transformPoint, transformVector,
     transformLine, transformEdge, rotateVector





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Description of functions operating on transforms




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
triangleGrid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 477
 -- Function File: PTS =  triangleGrid (BOUNDS, ORIGIN, SIZE)
     Generate triangular grid of points in the plane.

     usage   PTS = triangleGrid(BOUNDS, ORIGIN, SIZE)   generate
     points, lying in the window defined by BOUNDS, given in form
     [xmin ymin xmax ymax], starting from origin with a constant step
     equal   to size.    SIZE is constant and is equals to the length
     of the sides of each   triangles.

     TODO: add possibility to use rotated grid





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Generate triangular grid of points in the plane.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
vectorAngle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 932
 -- Function File: ALPHA = vectorAngle (V1)
     Angle of a vector, or between 2 vectors

     A = vectorAngle(V);   Returns angle between Ox axis and vector
     direction, in Counter   clockwise orientation.    The result is
     normalised between 0 and 2*PI.

     A = vectorAngle(V1, V2);   Returns the angle from vector V1 to
     vector V2, in counter-clockwise   order, and in radians.

     A = vectorAngle(..., 'cutAngle', CUTANGLE);   A = vectorAngle(...,
     CUTANGLE); # (deprecated syntax)   Specifies convention for angle
     interval. CUTANGLE is the center of the   2*PI interval containing
     the result. See <a href="matlab:doc
     ('normalizeAngle')">normalizeAngle</a> for details.

     Example:   rad2deg(vectorAngle([2 2]))   ans =       45
     rad2deg(vectorAngle([1 sqrt(3)]))   ans =       60
     rad2deg(vectorAngle([0 -1]))   ans =       270

     See also: vectors2d, angles2d, normalizeAngle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Angle of a vector, or between 2 vectors




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
vectorNorm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 751
 -- Function File: NM =  vectorNorm (V)
 -- Function File: NM =  vectorNorm (V,N)
     Compute norm of a vector, or of a set of vectors

     Without extra arguments, returns the euclidean norm of vector V.
     Optional argument N specifies the norm to use. N can be any value
     greater than 0.
    `N=1'
          City lock norm.

    `N=2'
          Euclidean norm.

    `N=inf'
          Compute max coord.

     When V is a MxN array, compute norm for each vector of the array.
      Vector are given as rows. Result is then a Mx1 array.

     Example

            n1 = vectorNorm([3 4])
            n1 =
                5

            n2 = vectorNorm([1, 10], inf)
            n2 =
                10

     See also: vectors2d, vectorAngle





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute norm of a vector, or of a set of vectors




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
vectors2d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 502
 -- Function File: vectors2d ()
     Description of functions operating on plane vectors

     A vector is defined by its two cartesian coordinates, put into a
     row   vector of 2 elements:   `V = [vx vy];'

     Several vectors are stored in a matrix with two columns, one for
     the   x-coordinate, one for the y-coordinate.    `VS = [vx1 vy1 ;
     vx2 vy2 ; vx3 vy3];'

     See also: vectorNorm, vectorAngle, isPerpendicular, isParallel,
     normalizeVector, transformVector, rotateVector





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Description of functions operating on plane vectors






