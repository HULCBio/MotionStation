<html lang="en">
<head>
<title>queueing</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="User manual for the queueing toolbox, a GNU Octave package for queueing networks and Markov chains analysis. This package supports single-station queueing systems, queueing networks and Markov chains. The queueing toolbox implements, among others, the Mean Value Analysis (MVA) and convolution algorithms for product-form queueing networks. Transient and steady-state analysis of Markov chains is also implemented.">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
Copyright &copy; 2008, 2009, 2010, 2011, 2012, 2013 Moreno Marzolla.

   <p>Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   <p>Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

   <p>Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for
modified versions.

<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">queueing</a>
<li><a name="toc_Summary" href="#Summary">1 Summary</a>
<ul>
<li><a href="#About-the-Queueing-Toolbox">1.1 About the Queueing Toolbox</a>
<li><a href="#Contributing-Guidelines">1.2 Contributing Guidelines</a>
<li><a href="#Acknowledgements">1.3 Acknowledgements</a>
</li></ul>
<li><a name="toc_Installation-and-Getting-Started" href="#Installation-and-Getting-Started">2 Installation and Getting Started</a>
<ul>
<li><a href="#Installation-through-Octave-package-management-system">2.1 Installation through Octave package management system</a>
<li><a href="#Manual-installation">2.2 Manual installation</a>
<li><a href="#Development-sources">2.3 Development sources</a>
<li><a href="#Naming-Conventions">2.4 Naming Conventions</a>
<li><a href="#Quickstart-Guide">2.5 Quickstart Guide</a>
</li></ul>
<li><a name="toc_Markov-Chains" href="#Markov-Chains">3 Markov Chains</a>
<ul>
<li><a href="#Discrete_002dTime-Markov-Chains">3.1 Discrete-Time Markov Chains</a>
<ul>
<li><a href="#State-occupancy-probabilities-_0028DTMC_0029">3.1.1 State occupancy probabilities</a>
<li><a href="#Birth_002ddeath-process-_0028DTMC_0029">3.1.2 Birth-death process</a>
<li><a href="#Expected-number-of-visits-_0028DTMC_0029">3.1.3 Expected Number of Visits</a>
<li><a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">3.1.4 Time-averaged expected sojourn times</a>
<li><a href="#Mean-time-to-absorption-_0028DTMC_0029">3.1.5 Mean Time to Absorption</a>
<li><a href="#First-passage-times-_0028DTMC_0029">3.1.6 First Passage Times</a>
</li></ul>
<li><a href="#Continuous_002dTime-Markov-Chains">3.2 Continuous-Time Markov Chains</a>
<ul>
<li><a href="#State-occupancy-probabilities-_0028CTMC_0029">3.2.1 State occupancy probabilities</a>
<li><a href="#Birth_002ddeath-process-_0028CTMC_0029">3.2.2 Birth-Death Process</a>
<li><a href="#Expected-sojourn-times-_0028CTMC_0029">3.2.3 Expected Sojourn Times</a>
<li><a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">3.2.4 Time-Averaged Expected Sojourn Times</a>
<li><a href="#Mean-time-to-absorption-_0028CTMC_0029">3.2.5 Mean Time to Absorption</a>
<li><a href="#First-passage-times-_0028CTMC_0029">3.2.6 First Passage Times</a>
</li></ul>
</li></ul>
<li><a name="toc_Single-Station-Queueing-Systems" href="#Single-Station-Queueing-Systems">4 Single Station Queueing Systems</a>
<ul>
<li><a href="#The-M_002fM_002f1-System">4.1 The M/M/1 System</a>
<li><a href="#The-M_002fM_002fm-System">4.2 The M/M/m System</a>
<li><a href="#The-M_002fM_002finf-System">4.3 The M/M/inf System</a>
<li><a href="#The-M_002fM_002f1_002fK-System">4.4 The M/M/1/K System</a>
<li><a href="#The-M_002fM_002fm_002fK-System">4.5 The M/M/m/K System</a>
<li><a href="#The-Asymmetric-M_002fM_002fm-System">4.6 The Asymmetric M/M/m System</a>
<li><a href="#The-M_002fG_002f1-System">4.7 The M/G/1 System</a>
<li><a href="#The-M_002fHm_002f1-System">4.8 The M/H_m/1 System</a>
</li></ul>
<li><a name="toc_Queueing-Networks" href="#Queueing-Networks">5 Queueing Networks</a>
<ul>
<li><a href="#Introduction-to-QNs">5.1 Introduction to QNs</a>
<li><a href="#Single-Class-Models">5.2 Single Class Models</a>
<ul>
<li><a href="#Single-Class-Models">5.2.1 Open Networks</a>
<li><a href="#Single-Class-Models">5.2.2 Closed Networks</a>
<li><a href="#Single-Class-Models">5.2.3 Non Product-Form QNs</a>
</li></ul>
<li><a href="#Multiple-Class-Models">5.3 Multiple Class Models</a>
<ul>
<li><a href="#Multiple-Class-Models">5.3.1 Open Networks</a>
<li><a href="#Multiple-Class-Models">5.3.2 Closed Networks</a>
<li><a href="#Multiple-Class-Models">5.3.3 Mixed Networks</a>
</li></ul>
<li><a href="#Generic-Algorithms">5.4 Generic Algorithms</a>
<li><a href="#Bounds-Analysis">5.5 Bounds Analysis</a>
<li><a href="#QN-Analysis-Examples">5.6 QN Analysis Examples</a>
<ul>
<li><a href="#QN-Analysis-Examples">5.6.1 Closed, Single Class Network</a>
<li><a href="#QN-Analysis-Examples">5.6.2 Open, Single Class Network</a>
<li><a href="#QN-Analysis-Examples">5.6.3 Closed Multiclass Network/1</a>
<li><a href="#QN-Analysis-Examples">5.6.4 Closed Multiclass Network/2</a>
<li><a href="#QN-Analysis-Examples">5.6.5 Closed Multiclass Network/3</a>
</li></ul>
</li></ul>
<li><a name="toc_References" href="#References">6 References</a>
<li><a name="toc_Copying" href="#Copying">Appendix A GNU GENERAL PUBLIC LICENSE</a>
<li><a name="toc_Concept-Index" href="#Concept-Index">Concept Index</a>
<li><a name="toc_Function-Index" href="#Function-Index">Function Index</a>
<li><a name="toc_Author-Index" href="#Author-Index">Author Index</a>
</li></ul>
</div>

<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Summary">Summary</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">queueing</h2>

<p>This manual documents how to install and run the Queueing Toolbox. 
It corresponds to version 1.2.1 of the package.

<!--  -->
<ul class="menu">
<li><a accesskey="1" href="#Summary">Summary</a>
<li><a accesskey="2" href="#Installation-and-Getting-Started">Installation and Getting Started</a>:  Installation of the queueing toolbox. 
<li><a accesskey="3" href="#Markov-Chains">Markov Chains</a>:                Functions for Markov Chains. 
<li><a accesskey="4" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>:  Functions for single-station queueing systems. 
<li><a accesskey="5" href="#Queueing-Networks">Queueing Networks</a>:            Functions for queueing networks. 
<li><a accesskey="6" href="#References">References</a>:                   References
<li><a accesskey="7" href="#Copying">Copying</a>:                      The GNU General Public License. 
<li><a accesskey="8" href="#Concept-Index">Concept Index</a>:                An item for each concept. 
<li><a accesskey="9" href="#Function-Index">Function Index</a>:               An item for each function. 
<li><a href="#Author-Index">Author Index</a>:                 An item for each author. 
</ul>

<!--  -->
<!-- This file has been automatically generated from summary.txi -->
<!-- by proc.m. Do not edit this file, all changes will be lost -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Summary"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installation-and-Getting-Started">Installation and Getting Started</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Summary</h2>

<ul class="menu">
<li><a accesskey="1" href="#About-the-Queueing-Toolbox">About the Queueing Toolbox</a>:           What is the Queueing Toolbox
<li><a accesskey="2" href="#Contributing-Guidelines">Contributing Guidelines</a>:              How to contribute
<li><a accesskey="3" href="#Acknowledgements">Acknowledgements</a>
</ul>

<div class="node">
<a name="About-the-Queueing-Toolbox"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Contributing-Guidelines">Contributing Guidelines</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Summary">Summary</a>

</div>

<h3 class="section">1.1 About the Queueing Toolbox</h3>

<p>This document describes the <code>queueing</code> toolbox for GNU Octave
(<code>queueing</code> in short). The <code>queueing</code> toolbox, previously
known as <code>qnetworks</code>, is a collection of functions written in GNU
Octave for analyzing queueing networks and Markov
chains. Specifically, <code>queueing</code> contains functions for analyzing
Jackson networks, open, closed or mixed product-form BCMP networks,
and computation of performance bounds. The following algorithms have
been implemented

     <ul>
<li>Convolution for closed, single-class product-form networks
with load-dependent service centers;

     <li>Exact and approximate Mean Value Analysis (MVA) for single and
multiple class product-form closed networks;

     <li>MVA for mixed, multiple class product-form networks
with load-independent service centers;

     <li>Approximate MVA for closed, single-class networks with blocking
(MVABLO algorithm by F. Akyildiz);

     <li>Asymptotic Bounds, Balanced System Bounds and Geometric Bounds;

   </ul>

<p class="noindent"><code>queueing</code>
provides functions for analyzing the following kind of single-station
queueing systems:

     <ul>
<li>M/M/1
<li>M/M/m
<li>M/M/\infty
<li>M/M/1/k single-server, finite capacity system
<li>M/M/m/k multiple-server, finite capacity system
<li>Asymmetric M/M/m
<li>M/G/1 (general service time distribution)
<li>M/H_m/1 (Hyperexponential service time distribution)
</ul>

   <p>Functions for Markov chain analysis are also provided:

     <ul>
<li>Birth-death process;
<li>Transient and steady-state occupancy probabilities;
<li>Mean times to absorption;
<li>Expected sojourn times and time-averaged sojourn times;
<li>Mean first passage times;

   </ul>

   <p>The <code>queueing</code> toolbox is distributed under the terms of the GNU
General Public License (GPL), version 3 or later
(see <a href="#Copying">Copying</a>). You are encouraged to share this software with
others, and make this package more useful by contributing additional
functions and reporting problems. See <a href="#Contributing-Guidelines">Contributing Guidelines</a>.

   <p>If you use the <code>queueing</code> toolbox in a technical paper, please
cite it as:

   <blockquote>
Moreno Marzolla, <em>The qnetworks Toolbox: A Software Package for
Queueing Networks Analysis</em>. Khalid Al-Begain, Dieter Fiems and
William J. Knottenbelt, Editors, Proceedings 17th International
Conference on Analytical and Stochastic Modeling Techniques and
Applications (ASMTA 2010) Cardiff, UK, June 14&ndash;16, 2010, volume 6148
of Lecture Notes in Computer Science, Springer, pp. 102&ndash;116, ISBN
978-3-642-13567-5
</blockquote>

   <p>If you use BibTeX, this is the citation block:

<pre class="verbatim">@inproceedings{queueing,
  author    = {Moreno Marzolla},
  title     = {The qnetworks Toolbox: A Software Package for Queueing 
               Networks Analysis},
  booktitle = {Analytical and Stochastic Modeling Techniques and 
               Applications, 17th International Conference, 
               ASMTA 2010, Cardiff, UK, June 14-16, 2010. Proceedings},
  editor    = {Khalid Al-Begain and Dieter Fiems and William J. Knottenbelt},
  year      = {2010},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  volume    = {6148},
  pages     = {102--116},
  ee        = {http://dx.doi.org/10.1007/978-3-642-13568-2_8},
  isbn      = {978-3-642-13567-5}
}
</pre>

   <p>An early draft of the paper above is available as Technical Report
<a href="http://www.informatica.unibo.it/ricerca/ublcs/2010/UBLCS-2010-04">UBLCS-2010-04</a>, February 2010, Department of Computer Science,
University of Bologna, Italy.

<div class="node">
<a name="Contributing-Guidelines"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Acknowledgements">Acknowledgements</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#About-the-Queueing-Toolbox">About the Queueing Toolbox</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Summary">Summary</a>

</div>

<h3 class="section">1.2 Contributing Guidelines</h3>

<p>Contributions and bug reports are <em>always</em> welcome. If you want
to contribute to the <code>queueing</code> package, here are some
guidelines:

     <ul>
<li>If you are contributing a new function, please embed proper
documentation within the function itself. The documentation must be in
<code>texinfo</code> format, so that it can be extracted and formatted into
the printable manual. See the existing functions of the
<code>queueing</code> package for the documentation style.

     <li>Make sure that each new function
properly checks the validity of its input parameters. For example,
each function accepting vectors should check whether the dimensions
match.

     <li>Provide bibliographic references for each new algorithm you
contribute. If your implementation differs in some way from the
reference you give, please describe how and why your implementation
differs. Add references to the <samp><span class="file">doc/references.txi</span></samp> file.

     <li>Include test and demo blocks with your code. 
Test blocks are particularly important, since most algorithms tend to
be quite tricky to implement correctly. If appropriate, test blocks
should also verify that the function fails on incorrect input
parameters.

   </ul>

   <p>Send your contribution to Moreno Marzolla
(<a href="mailto:marzolla@cs.unibo.it">marzolla@cs.unibo.it</a>). If you are just a user of this
package and find it useful, let me know by dropping me a line. Thanks.

<div class="node">
<a name="Acknowledgements"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Contributing-Guidelines">Contributing Guidelines</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Summary">Summary</a>

</div>

<h3 class="section">1.3 Acknowledgements</h3>

<p>The following people (listed in alphabetical order) contributed to the
<code>queueing</code> package, either by providing feedback, reporting bugs
or contributing code: Philip Carinhas, Phil Colbourn, Diego Didona,
Yves Durand, Marco Guazzone, Michele Mazzucco, Dmitry Kolesnikov.

<!-- This file has been automatically generated from installation.txi -->
<!-- by proc.m. Do not edit this file, all changes will be lost -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Installation-and-Getting-Started"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Markov-Chains">Markov Chains</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Summary">Summary</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Installation and Getting Started</h2>

<ul class="menu">
<li><a accesskey="1" href="#Installation-through-Octave-package-management-system">Installation through Octave package management system</a>
<li><a accesskey="2" href="#Manual-installation">Manual installation</a>
<li><a accesskey="3" href="#Development-sources">Development sources</a>
<li><a accesskey="4" href="#Naming-Conventions">Naming Conventions</a>
<li><a accesskey="5" href="#Quickstart-Guide">Quickstart Guide</a>
</ul>

<div class="node">
<a name="Installation-through-Octave-package-management-system"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Manual-installation">Manual installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation-and-Getting-Started">Installation and Getting Started</a>

</div>

<h3 class="section">2.1 Installation through Octave package management system</h3>

<p>The most recent version of <code>queueing</code> is 1.2.1 and can
be downloaded from Octave-Forge

   <p><a href="http://octave.sourceforge.net/queueing/">http://octave.sourceforge.net/queueing/</a>

   <p>Additional information can be found at

   <p><a href="http://www.moreno.marzolla.name/software/queueing/">http://www.moreno.marzolla.name/software/queueing/</a>

   <p>To install <code>queueing</code>, follow these steps:

     <ol type=1 start=1>

     <li>If you have a recent version of GNU Octave and a network connection,
you can install <code>queueing</code> directly from Octave command prompt
using this command:

     <pre class="example">          octave:1&gt; <kbd>pkg install -forge queueing</kbd>
</pre>
     <p>The command above will automaticall download and install the latest
version of the queueing toolbox from Octave Forge, and install it on
your machine.

     <p>If you do not have root access, you can do a local install using:

     <pre class="example">          octave:1&gt; <kbd>pkg install -local -forge queueing</kbd>
</pre>
     <p>This will install <code>queueing</code> within your home directory, and the
package will be available to your user only.

     <li>Alternatively, you can first download <code>queueing</code> from
Octave-Forge; then, to install the package in the system-wide
location issue this command at the Octave prompt:

     <pre class="example">          octave:1&gt; <kbd>pkg install </kbd><em>queueing-1.2.1.tar.gz</em>
</pre>
     <p class="noindent">(you may need to start Octave as root in order to allow the
installation to copy the files to the target locations). After this,
all functions will be readily available each time Octave starts,
without the need to tweak the search path.

     <p>If you do not have root access, you can do a local install using:

     <pre class="example">          octave:1&gt; <kbd>pkg install -local queueing-1.2.1.tar.gz</kbd>
</pre>
     <blockquote>
<b>Note:</b> Octave version 3.2.3 as shipped with Ubuntu 10.04 LTS seems to ignore
<samp><span class="option">-local</span></samp> and always tries to install the package on the system
directory. 
</blockquote>

     <li>Verify that the package is indeed installed using the <kbd>pkg list</kbd>
command at the Octave prompt; after succesfull installation you should
see something like that:

     <pre class="example">          octave:1&gt;<kbd>pkg list queueing</kbd>
          Package Name  | Version | Installation directory
          --------------+---------+-----------------------
              queueing  |   1.2.1 | /home/moreno/octave/queueing-1.2.1
</pre>
     <li>Starting from version 1.1.1, <code>queueing</code> is no longer
automatically loaded on Octave startup. To make the functions
available for use, you need to issue the command

     <pre class="example">          octave:1&gt;<kbd>pkg load queueing</kbd>
</pre>
     <p class="noindent">at the Octave prompt. To automatically load <code>queueing</code> each time
Octave starts, you can add the command above to the startup script
(usually, <samp><span class="file">~/.octaverc</span></samp> on Unix systems).

     <li>To completely remove <code>queueing</code> from your system, use the
<kbd>pkg uninstall</kbd> command:

     <pre class="example">          octave:1&gt; <kbd>pkg uninstall queueing</kbd>
</pre>
        </ol>

<div class="node">
<a name="Manual-installation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Development-sources">Development sources</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installation-through-Octave-package-management-system">Installation through Octave package management system</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation-and-Getting-Started">Installation and Getting Started</a>

</div>

<h3 class="section">2.2 Manual installation</h3>

<p>If you want to manually install <code>queueing</code> in a custom location,
you can download the tarball and unpack it somewhere:

<pre class="example">     <kbd>tar xvfz queueing-1.2.1.tar.gz</kbd>
     <kbd>cd queueing-1.2.1/queueing/</kbd>
</pre>
   <p>Copy all <code>.m</code> files from the <samp><span class="file">inst/</span></samp> directory to some
target location. Then, start Octave with the <samp><span class="option">-p</span></samp> option to add
the target location to the search path, so that Octave will find all
<code>queueing</code> functions automatically:

<pre class="example">     <kbd>octave -p </kbd><em>/path/to/queueing</em>
</pre>
   <p>For example, if all <code>queueing</code> m-files are in
<samp><span class="file">/usr/local/queueing</span></samp>, you can start Octave as follows:

<pre class="example">     <kbd>octave -p </kbd><em>/usr/local/queueing</em>
</pre>
   <p>If you want, you can add the following line to <samp><span class="file">~/.octaverc</span></samp>:

<pre class="example">     <kbd>addpath("</kbd><em>/path/to/queueing</em><kbd>");</kbd>
</pre>
   <p class="noindent">so that the path <samp><span class="file">/path/to/queueing</span></samp> is automatically
added to the search path each time Octave is started, and you no
longer need to specify the <samp><span class="option">-p</span></samp> option on the command line.

<!-- The following will not appear in the INSTALL text file -->
<div class="node">
<a name="Development-sources"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Naming-Conventions">Naming Conventions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Manual-installation">Manual installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation-and-Getting-Started">Installation and Getting Started</a>

</div>

<h3 class="section">2.3 Development sources</h3>

<p>The source code of the <code>queueing</code> package can be found in the
Subversion repository at the URL:

   <p><a href="http://octave.svn.sourceforge.net/viewvc/octave/trunk/octave-forge/main/queueing/">http://octave.svn.sourceforge.net/viewvc/octave/trunk/octave-forge/main/queueing/</a>

   <p>The source distribution contains additional development files which
are not present in the installation tarball. This section briefly
describes the content of the source tree. This is only relevant for
developers who want to modify the code or documentation; normal users
of the <code>queueing</code> package don't need

   <p>The source distribution contains the following directories:

     <dl>
<dt><samp><span class="file">doc/</span></samp><dd>Documentation source. Most of the documentation is extracted from the
comment blocks of individual function files from the <samp><span class="file">inst/</span></samp>
directory.

     <br><dt><samp><span class="file">inst/</span></samp><dd>This directory contains the <tt>m</tt>-files which implement the
various Queueing Network algorithms provided by <code>queueing</code>. As a
notational convention, the names of source files containing functions
for Queueing Networks start with the &lsquo;<samp><span class="samp">qn</span></samp>&rsquo; prefix; the name of
source files containing functions for Continuous-Time Markov Chains
(CTMSs) start with the &lsquo;<samp><span class="samp">ctmc</span></samp>&rsquo; prefix, and the names of files
containing functions for Discrete-Time Markov Chains (DTMCs) start
with the &lsquo;<samp><span class="samp">dtmc</span></samp>&rsquo; prefix.

     <br><dt><samp><span class="file">test/</span></samp><dd>This directory contains the test functions used to invoke all tests on
all function files.

     <br><dt><samp><span class="file">devel/</span></samp><dd>This directory contains function files which are either not working
properly, or need additional testing before they are moved to the
<samp><span class="file">inst/</span></samp> directory.

   </dl>

   <p>The <code>queueing</code> package ships with a Makefile which can be used
to produce the documentation (in PDF and HTML format), and
automatically execute all function tests. Specifically, the following
targets are defined:

     <dl>
<dt><code>all</code><dd>Running &lsquo;<samp><span class="samp">make</span></samp>&rsquo; (or &lsquo;<samp><span class="samp">make all</span></samp>&rsquo;) on the top-level directory
builds the programs used to extract the documentation from the
comments embedded in the <tt>m</tt>-files, and then produce the
documentation in PDF and HTML format (<samp><span class="file">doc/queueing.pdf</span></samp> and
<samp><span class="file">doc/queueing.html</span></samp>, respectively).

     <br><dt><code>check</code><dd>Running &lsquo;<samp><span class="samp">make check</span></samp>&rsquo; will execute all tests contained in the
<tt>m</tt>-files. If you modify the code of any function in the
<samp><span class="file">inst/</span></samp> directory, you should run the tests to ensure that no
errors have been introduced. You are also encouraged to contribute new
tests, especially for functions which are not adequately validated.

     <br><dt><code>clean</code><dt><code>distclean</code><dt><code>dist</code><dd>The &lsquo;<samp><span class="samp">make clean</span></samp>&rsquo;, &lsquo;<samp><span class="samp">make distclean</span></samp>&rsquo; and &lsquo;<samp><span class="samp">make dist</span></samp>&rsquo;
commands are used to clean up the source directory and prepare the
distribution archive in compressed tar format.

   </dl>

<div class="node">
<a name="Naming-Conventions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Quickstart-Guide">Quickstart Guide</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Development-sources">Development sources</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation-and-Getting-Started">Installation and Getting Started</a>

</div>

<h3 class="section">2.4 Naming Conventions</h3>

<p>Most of the functions in the <code>queueing</code> package obey a common
naming convention. Function names are made of several parts; the first
part is a prefix which indicates the class of problems the function
addresses:

     <dl>
<dt><strong>ctmc-</strong><dd>Functions for continuous-time Markov chains

     <br><dt><strong>dtmc-</strong><dd>Functions for discrete-time Markov chains

     <br><dt><strong>qs-</strong><dd>Functions for analyzing queueing systems (individual service centers)

     <br><dt><strong>qn-</strong><dd>Functions for analyzing queueing networks

   </dl>

   <p>Functions dealing with Markov chains start with either the <code>ctmc</code>
or <code>dtmc</code> prefix; the prefix is optionally followed by an
additional string which hints at what the function does:

     <dl>
<dt><strong>-bd</strong><dd>Birth-Death process

     <br><dt><strong>-mtta</strong><dd>Mean Time to Absorption

     <br><dt><strong>-fpt</strong><dd>First Passage Times

     <br><dt><strong>-exps</strong><dd>Expected Sojourn Times

     <br><dt><strong>-taexps</strong><dd>Time-Averaged Expected Sojourn Times

   </dl>

   <p>For example, function <code>ctmcbd</code> returns the infinitesimal
generator matrix for a continuous birth-death process, while
<code>dtmcbd</code> returns the transition probability matrix for a discrete
birth-death process. Note that there exist functions <code>ctmc</code> and
<code>dtmc</code> (without any suffix) that compute steady-state and
transient state occupancy probabilities for CTMCs and DTMCs,
respectively. See <a href="#Markov-Chains">Markov Chains</a>.

   <p>Functions whose name starts with <code>qs-</code> deal with single station
queueing systems. The suffix describes the type of system, e.g.,
<code>qsmm1</code> for M/M/1, <code>qnmmm</code> for M/M/m and so
on. See <a href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>.

   <p>Finally, functions whose name starts with <code>qn-</code> deal with
queueing networks. The character that follows indicates whether the
function handles open (<code>'o'</code>) or closed (<code>'c'</code>) networks,
and whether there is a single customer class (<code>'s'</code>) or multiple
classes (<code>'m'</code>). The string <code>mix</code> indicates that the
function supports mixed networks with both open and closed customer
classes.

     <dl>
<dt><strong>-os-</strong><dd>Open, single-class network: open network with a single class of customers

     <br><dt><strong>-om-</strong><dd>Open, multiclass network: open network with multiple job classes

     <br><dt><strong>-cs-</strong><dd>Closed, single-class network

     <br><dt><strong>-cm-</strong><dd>Closed, multiclass network

     <br><dt><strong>-mix-</strong><dd>Mixed network with open and closed classes of customers

   </dl>

   <p>The last part of the function name indicates the algorithm implemented
by the function. See <a href="#Queueing-Networks">Queueing Networks</a>.

     <dl>
<dt><strong>-aba</strong><dd>Asymptotic Bounds Analysis

     <br><dt><strong>-bsb</strong><dd>Balanced System Bounds

     <br><dt><strong>-gb</strong><dd>Geometric Bounds

     <br><dt><strong>-pb</strong><dd>PB Bounds

     <br><dt><strong>-cb</strong><dd>Composite Bounds (CB)

     <br><dt><strong>-mva</strong><dd>Mean Value Analysis (MVA) algorithm

     <br><dt><strong>-cmva</strong><dd>Conditional MVA

     <br><dt><strong>-mvald</strong><dd>MVA with general load-dependent servers

     <br><dt><strong>-mvaap</strong><dd>Approximate MVA

     <br><dt><strong>-mvablo</strong><dd>MVABLO approximation for blocking queueing networks

     <br><dt><strong>-conv</strong><dd>Convolution algorithm

     <br><dt><strong>-convld</strong><dd>Convolution algorithm with general load-dependent servers

   </dl>

   <p><a name="index-deprecated-functions-1"></a>
The current version (1.2.1) of the <code>queueing</code> package
still supports the old function names (although they are no longer
documented and will disappear in future releases). However, calling
one of the deprecated functions results in a warning message being
displayed; the message appears only one time per session:

<pre class="example">     octave:1&gt; <kbd>qnclosedab(10,[1 2 3])</kbd>
         -| warning: qnclosedab is deprecated. Please use qncsaba instead
         &rArr; ans =  0.16667
</pre>
   <p>Therefore, your legacy code should run unmodified with the current
version of the <code>queueing</code> package. You can turn off all warning
messages with the following command:

<pre class="example">     octave:1&gt; <kbd>warning ("off", "qn:deprecated-function");</kbd>
</pre>
   <p>However, it is recommended to update to the new API and not ignore the
warnings above. To help you catch usages of deprecated functions, even
with applications which produce a lot of console output, you can
transform warnings into errors so that your application will stop
immediately:

<pre class="example">     octave:1&gt; <kbd>warning ("error", "qn:deprecated-function");</kbd>
</pre>
   <div class="node">
<a name="Quickstart-Guide"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Naming-Conventions">Naming Conventions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Installation-and-Getting-Started">Installation and Getting Started</a>

</div>

<h3 class="section">2.5 Quickstart Guide</h3>

<p>You can use all functions by simply invoking their name with the
appropriate parameters; the <code>queueing</code> package should display an
error message in case of missing/wrong parameters. Extensive
documentation is provided for each function, and can be displayed with
the <samp><span class="command">help</span></samp> command. For example:

<pre class="example">     octave:2&gt; <kbd>help qncsmvablo</kbd>
</pre>
   <p class="noindent">prints the documentation for the <samp><span class="command">qncsmvablo</span></samp> function. 
Additional information can be found in the <code>queueing</code> manual,
which is available in PDF format in <samp><span class="file">doc/queueing.pdf</span></samp> and in
HTML format in <samp><span class="file">doc/queueing.html</span></samp>.

   <p>Many functions have demo blocks containing code snippets which
illustrate how that function can be used. For example, to execute the
demos for the <samp><span class="command">qnclosed</span></samp> function, use the <samp><span class="command">demo</span></samp>
command as follows:

<pre class="example">     octave:4&gt; <kbd>demo qnclosed</kbd>
</pre>
   <p>Here we illustrate some basic usage of the <code>queueing</code> package by
considering a few examples.

<p class="noindent"><strong>Example 1</strong>
Compute the stationary state occupancy probabilities of a continuous-time
Markov chain with infinitesimal generator matrix

<pre class="example">         / -0.8   0.6   0.2 \
     Q = |  0.3  -0.7   0.4 |
         \  0.2   0.2  -0.4 /
</pre>
   <pre class="example">     Q = [ -0.8  0.6  0.2; \
            0.3 -0.7  0.4; \
            0.2  0.2 -0.4 ];
     q = ctmc(Q)
         &rArr; q = 0.23256   0.32558   0.44186
</pre>
   <p class="noindent"><strong>Example 2</strong>
Compute the transient state occupancy probability after n=3
transitions of a three state discrete time birth-death process, with
birth probabilities \lambda_01 = 0.3 and \lambda_12 =
0.5 and death probabilities \mu_10 = 0.5 and \mu_21
= 0.7, assuming that the system is initially in state zero (i.e., the
initial state occupancy probabilities are (1, 0, 0)).

<pre class="example">     n = 3;
     p0 = [1 0 0];
     P = dtmcbd( [0.3 0.5], [0.5 0.7] );
     p = dtmc(P,n,p0)
         &rArr; p = 0.55300   0.29700   0.15000
</pre>
   <p class="noindent"><strong>Example 3</strong>
Compute server utilization, response time, mean number of requests and
throughput of a closed queueing network with N=4 requests and
three M/M/1&ndash;FCFS queues with mean service times \bf S
= (1.0, 0.8, 1.4) and average number of visits \bf V = (1.0,
0.8, 0.8)

<pre class="example">     S = [1.0 0.8 1.4];
     V = [1.0 0.8 0.8];
     N = 4;
     [U R Q X] = qncsmva(N, S, V)
         &rArr;
          U = 0.70064   0.44841   0.78471
          R = 2.1030    1.2642    3.2433
          Q = 1.47346   0.70862   1.81792
          X = 0.70064   0.56051   0.56051
</pre>
   <p class="noindent"><strong>Example 4</strong>
Compute server utilization, response time, mean number of requests and
throughput of an open queueing network with three M/M/1&ndash;FCFS
queues with mean service times \bf S = (1.0, 0.8, 1.4) and
average number of visits \bf V = (1.0, 0.8, 0.8). The overall
arrival rate is \lambda = 0.8 req/s

<pre class="example">     S = [1.0 0.8 1.4];
     V = [1.0 0.8 0.8];
     lambda = 0.8;
     [U R Q X] = qnos(lambda, S, V)
         &rArr;
          U = 0.80000   0.51200   0.89600
          R = 5.0000    1.6393   13.4615
          Q = 4.0000    1.0492    8.6154
          X = 0.80000   0.64000   0.64000
</pre>
   <!-- This file has been automatically generated from markovchains.txi -->
<!-- by proc.m. Do not edit this file, all changes will be lost -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Markov-Chains"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installation-and-Getting-Started">Installation and Getting Started</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Markov Chains</h2>

<ul class="menu">
<li><a accesskey="1" href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a>
<li><a accesskey="2" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>
</ul>

<div class="node">
<a name="Discrete-Time-Markov-Chains"></a>
<a name="Discrete_002dTime-Markov-Chains"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Markov-Chains">Markov Chains</a>

</div>

<h3 class="section">3.1 Discrete-Time Markov Chains</h3>

<p>Let X_0, X_1, <small class="dots">...</small>, X_n, <small class="dots">...</small>  be a sequence of random
variables defined over a discete state space 1, 2,
<small class="dots">...</small>. The sequence X_0, X_1, <small class="dots">...</small>, X_n, <small class="dots">...</small>  is a
<em>stochastic process</em> with discrete time 0, 1, 2,
<small class="dots">...</small>. A <em>Markov chain</em> is a stochastic process {X_n,
n=0, 1, 2, <small class="dots">...</small>} which satisfies the following Markov property:

   <p>P(X_n+1 = x_n+1 | X_n = x_n, X_n-1 = x_n-1, ..., X_0 = x_0) = P(X_n+1 = x_n+1 | X_n = x_n)

<p class="noindent">which basically means that the probability that the system is in
a particular state at time n+1 only depends on the state the
system was at time n.

   <p>The evolution of a Markov chain with finite state space {1, 2,
<small class="dots">...</small>, N} can be fully described by a stochastic matrix \bf
P(n) = [ P_i,j(n) ] such that P_i, j(n) = P( X_n+1 = j\
|\ X_n = i ).  If the Markov chain is homogeneous (that is, the
transition probability matrix \bf P(n) is time-independent),
we can write \bf P = [P_i, j], where P_i, j = P(
X_n+1 = j\ |\ X_n = i ) for all n=0, 1, <small class="dots">...</small>.

   <p>The transition probability matrix \bf P must satisfy the
following two properties: (1) P_i, j &ge; 0 for all
i, j, and (2) \sum_j=1^N P_i,j = 1 for all i

   <p><a name="doc_002ddtmcchkP"></a>

<div class="defun">
&mdash; Function File: [<var>r</var> <var>err</var>] = <b>dtmcchkP</b> (<var>P</var>)<var><a name="index-dtmcchkP-2"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-discrete-time-3"></a><a name="index-DTMC-4"></a><a name="index-discrete-time-Markov-chain-5"></a>
Check whether <var>P</var> is a valid transition probability matrix.

        <p>If <var>P</var> is valid, <var>r</var> is the size (number of rows or columns)
of <var>P</var>. If <var>P</var> is not a transition probability matrix,
<var>r</var> is set to zero, and <var>err</var> to an appropriate error string.

        </blockquote></div>

<ul class="menu">
<li><a accesskey="1" href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a>
<li><a accesskey="2" href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a>
<li><a accesskey="3" href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a>
<li><a accesskey="4" href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a>
<li><a accesskey="5" href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a>
<li><a accesskey="6" href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a>
</ul>

<div class="node">
<a name="State-occupancy-probabilities-(DTMC)"></a>
<a name="State-occupancy-probabilities-_0028DTMC_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a>

</div>

<h4 class="subsection">3.1.1 State occupancy probabilities</h4>

<p>Given a discrete-time Markov chain with state spate {1, 2,
<small class="dots">...</small>, N}, we denote with \bf \pi(n) = \left(\pi_1(n),
\pi_2(n), <small class="dots">...</small>, \pi_N(n) \right) the <em>state occupancy
probability vector</em> at step n, n = 0, 1, <small class="dots">...</small>. 
\pi_i(n) denotes the probability that the system is in state
i after n transitions.

   <p>Given the transition probability matrix \bf P and the initial
state occupancy probability vector \bf \pi(0) =
\left(\pi_1(0), \pi_2(0), <small class="dots">...</small>, \pi_N(0)\right), \bf
\pi(n) can be computed as:

<pre class="example">     \pi(n) = \pi(0) P^n
</pre>
   <p>Under certain conditions, there exists a <em>stationary state
occupancy probability</em> \bf \pi = \lim_n \rightarrow +\infty
\bf \pi(n), which is independent from \bf \pi(0). The
stationary vector \bf \pi is the solution of the following
linear system:

<pre class="example">     /
     | \pi P   = \pi
     | \pi 1^T = 1
     \
</pre>
   <p class="noindent">where \bf 1 is the row vector of ones, and ( \cdot )^T
the transpose operator.

   <p><a name="doc_002ddtmc"></a>

<div class="defun">
&mdash; Function File: <var>p</var> = <b>dtmc</b> (<var>P</var>)<var><a name="index-dtmc-6"></a></var><br>
&mdash; Function File: <var>p</var> = <b>dtmc</b> (<var>P, n, p0</var>)<var><a name="index-dtmc-7"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-discrete-time-8"></a><a name="index-discrete-time-Markov-chain-9"></a><a name="index-DTMC-10"></a><a name="index-Markov-chain_002c-stationary-probabilities-11"></a><a name="index-Markov-chain_002c-transient-probabilities-12"></a>
Compute stationary or transient state occupancy probabilities for a discrete-time Markov chain.

        <p>With a single argument, compute the stationary state occupancy
probability vector <var>p</var><code>(1), ..., </code><var>p</var><code>(N)</code> for a
discrete-time Markov chain with state space {1, 2, <small class="dots">...</small>,
N} and with N \times N transition probability matrix
<var>P</var>. With three arguments, compute the transient state occupancy
vector <var>p</var><code>(1), ..., </code><var>p</var><code>(N)</code> that the system is in
state i after <var>n</var> steps, given initial occupancy
probabilities <var>p0</var>(1), <small class="dots">...</small>, <var>p0</var>(N).

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>P</var><dd><var>P</var><code>(i,j)</code> is the transition probability from state i
to state j. <var>P</var> must be an irreducible stochastic matrix,
which means that the sum of each row must be 1 (\sum_j=1^N
P_i, j = 1), and the rank of <var>P</var> must be equal to its
dimension.

          <br><dt><var>n</var><dd>Number of transitions after which compute the state occupancy probabilities
(n=0, 1, <small class="dots">...</small>)

          <br><dt><var>p0</var><dd><var>p0</var><code>(i)</code> is the probability that at step 0 the system
is in state i.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>p</var><dd>If this function is called with a single argument, <var>p</var><code>(i)</code>
is the steady-state probability that the system is in state i. 
If this function is called with three arguments, <var>p</var><code>(i)</code>
is the probability that the system is in state i
after <var>n</var> transitions, given the initial probabilities
<var>p0</var><code>(i)</code> that the initial state is i.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> ctmc.

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

   <p>This example is from <a href="#GrSn97">GrSn97</a>. Let us consider a maze with nine
rooms, as shown in the following figure

<pre class="example">     +-----+-----+-----+
     |     |     |     |
     |  1     2     3  |
     |     |     |     |
     +-   -+-   -+-   -+
     |     |     |     |
     |  4     5     6  |
     |     |     |     |
     +-   -+-   -+-   -+
     |     |     |     |
     |  7     8     9  |
     |     |     |     |
     +-----+-----+-----+
</pre>
   <p>A mouse is placed in one of the rooms and can wander around. At each
step, the mouse moves from the current room to a neighboring one with
equal probability: if it is in room 1, it can move to room 2 and 4
with probability 1/2, respectively. If the mouse is in room 8, it can
move to either 7, 5 or 9 with probability 1/3.

   <p>The transition probability \bf P from room i to room
j is the following:

<pre class="example">             / 0     1/2   0     1/2   0     0     0     0     0   \
             | 1/3   0     1/3   0     1/3   0     0     0     0   |
             | 0     1/2   0     0     0     1/2   0     0     0   |
             | 1/3   0     0     0     1/3   0     1/3   0     0   |
         P = | 0     1/4   0     1/4   0     1/4   0     1/4   0   |
             | 0     0     1/3   0     1/3   0     0     0     1/3 |
             | 0     0     0     1/2   0     0     0     1/2   0   |
             | 0     0     0     0     1/3   0     1/3   0     1/3 |
             \ 0     0     0     0     0     1/2   0     1/2   0   /
</pre>
   <p>The stationary state occupancy probability vector can be computed
using the following code:

<pre class="example"><pre class="verbatim">      P = zeros(9,9);
      P(1,[2 4]    ) = 1/2;
      P(2,[1 5 3]  ) = 1/3;
      P(3,[2 6]    ) = 1/2;
      P(4,[1 5 7]  ) = 1/3;
      P(5,[2 4 6 8]) = 1/4;
      P(6,[3 5 9]  ) = 1/3;
      P(7,[4 8]    ) = 1/2;
      P(8,[7 5 9]  ) = 1/3;
      P(9,[6 8]    ) = 1/2;
      p = dtmc(P);
      disp(p)
</pre>
         &rArr; 0.083333   0.125000   0.083333   0.125000
            0.166667   0.125000   0.083333   0.125000
            0.083333
</pre>
   <div class="node">
<a name="Birth-death-process-(DTMC)"></a>
<a name="Birth_002ddeath-process-_0028DTMC_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a>

</div>

<h4 class="subsection">3.1.2 Birth-death process</h4>

<p><a name="doc_002ddtmcbd"></a>

<div class="defun">
&mdash; Function File: <var>P</var> = <b>dtmcbd</b> (<var>b, d</var>)<var><a name="index-dtmcbd-13"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-discrete-time-14"></a><a name="index-DTMC-15"></a><a name="index-discrete-time-Markov-chain-16"></a><a name="index-birth_002ddeath-process_002c-DTMC-17"></a>
Returns the transition probability matrix P for a discrete
birth-death process over state space 1, 2, <small class="dots">...</small>, N. 
<var>b</var><code>(i)</code> is the transition probability from state
i to i+1, and <var>d</var><code>(i)</code> is the transition
probability from state i+1 to state i, i=1, 2,
<small class="dots">...</small>, N-1.

        <p>Matrix \bf P is therefore defined as:

     <pre class="example">          /                                                             \
          | 1-b(1)     b(1)                                             |
          |  d(1)  (1-d(1)-b(2))     b(2)                               |
          |            d(2)      (1-d(2)-b(3))     b(3)                 |
          |                                                             |
          |                 ...           ...          ...              |
          |                                                             |
          |                         d(N-2)   (1-d(N-2)-b(N-1))  b(N-1)  |
          |                                        d(N-1)      1-d(N-1) |
          \                                                             /
</pre>
        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> ctmcbd.

        </blockquote></div>

<div class="node">
<a name="Expected-number-of-visits-(DTMC)"></a>
<a name="Expected-number-of-visits-_0028DTMC_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a>

</div>

<h4 class="subsection">3.1.3 Expected Number of Visits</h4>

<p>Given a N state discrete-time Markov chain with transition
matrix \bf P and an integer n &ge; 0, we let
L_i(n) be the the expected number of visits to state i
during the first n transitions. The vector \bf L(n) =
( L_1(n), L_2(n), <small class="dots">...</small>, L_N(n) ) is defined as

<pre class="example">              n            n
             ___          ___
            \            \           i
     L(n) =  &gt;   pi(i) =  &gt;   pi(0) P
            /___         /___
             i=0          i=0
</pre>
   <p class="noindent">where \bf \pi(i) = \bf \pi(0)\bf P^i is the state
occupancy probability after i transitions.

   <p>If \bf P is absorbing, i.e., the stochastic process eventually
reaches a state with no outgoing transitions with probability 1, then
we can compute the expected number of visits until absorption
\bf L. To do so, we first rearrange the states to rewrite
matrix \bf P as:

<pre class="example">         / Q | R \
     P = |---+---|
         \ 0 | I /
</pre>
   <p class="noindent">where the first t states are transient
and the last r states are absorbing (t+r = N). The
matrix \bf N = (\bf I - \bf Q)^-1 is called the
<em>fundamental matrix</em>; N_i,j is the expected number of
times that the process is in the j-th transient state if it
started in the i-th transient state. If we reshape \bf N
to the size of \bf P (filling missing entries with zeros), we
have that, for absorbing chains \bf L = \bf \pi(0)\bf N.

   <p><a name="doc_002ddtmcexps"></a>

<div class="defun">
&mdash; Function File: <var>L</var> = <b>dtmcexps</b> (<var>P, n, p0</var>)<var><a name="index-dtmcexps-18"></a></var><br>
&mdash; Function File: <var>L</var> = <b>dtmcexps</b> (<var>P, p0</var>)<var><a name="index-dtmcexps-19"></a></var><br>
<blockquote>
        <p><a name="index-expected-sojourn-times_002c-DTMC-20"></a><a name="index-DTMC-21"></a><a name="index-discrete-time-Markov-chain-22"></a><a name="index-Markov-chain_002c-discrete-time-23"></a>
Compute the expected number of visits to each state during the first
<var>n</var> transitions, or until abrosption.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>P</var><dd>N \times N transition probability matrix.

          <br><dt><var>n</var><dd>Number of steps during which the expected number of visits are
computed (<var>n</var> &ge; 0). If <var>n</var><code>=0</code>, returns
<var>p0</var>. If <var>n</var><code> &gt; 0</code>, returns the expected number of
visits after exactly <var>n</var> transitions.

          <br><dt><var>p0</var><dd>Initial state occupancy probability.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>L</var><dd>When called with two arguments, <var>L</var><code>(i)</code> is the expected
number of visits to transient state i before absorption. When
called with three arguments, <var>L</var><code>(i)</code> is the expected number
of visits to state i during the first <var>n</var> transitions,
given initial occupancy probability <var>p0</var>.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> ctmcexps.

        </blockquote></div>

<div class="node">
<a name="Time-averaged-expected-sojourn-times-(DTMC)"></a>
<a name="Time_002daveraged-expected-sojourn-times-_0028DTMC_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a>

</div>

<h4 class="subsection">3.1.4 Time-averaged expected sojourn times</h4>

<p><a name="doc_002ddtmctaexps"></a>

<div class="defun">
&mdash; Function File: <var>L</var> = <b>dtmctaexps</b> (<var>P, n, p0</var>)<var><a name="index-dtmctaexps-24"></a></var><br>
&mdash; Function File: <var>L</var> = <b>dtmctaexps</b> (<var>P, p0</var>)<var><a name="index-dtmctaexps-25"></a></var><br>
<blockquote>
        <p><a name="index-time_002dalveraged-sojourn-time_002c-DTMC-26"></a><a name="index-discrete-time-Markov-chain-27"></a><a name="index-Markov-chain_002c-discrete-time-28"></a><a name="index-DTMC-29"></a>
Compute the <em>time-averaged sojourn time</em> <var>M</var><code>(i)</code>,
defined as the fraction of time steps {0, 1, <small class="dots">...</small>, n} (or
until absorption) spent in state i, assuming that the state
occupancy probabilities at time 0 are <var>p0</var>.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>P</var><dd>N \times N transition probability matrix.

          <br><dt><var>n</var><dd>Number of transitions during which the time-averaged expected sojourn times
are computed (<var>n</var> &ge; 0). if <var>n</var> = 0,
returns <var>p0</var>.

          <br><dt><var>p0</var><dd>Initial state occupancy probabilities.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>M</var><dd>If this function is called with three arguments, <var>M</var><code>(i)</code> is
the expected fraction of steps {0, 1, <small class="dots">...</small>, n} spent in
state i, assuming that the state occupancy probabilities at
time zero are <var>p0</var>. If this function is called with two
arguments, <var>M</var><code>(i)</code> is the expected fraction of steps spent
in state i until absorption.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> ctmctaexps.

        </blockquote></div>

<div class="node">
<a name="Mean-time-to-absorption-(DTMC)"></a>
<a name="Mean-time-to-absorption-_0028DTMC_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a>

</div>

<h4 class="subsection">3.1.5 Mean Time to Absorption</h4>

<p>The <em>mean time to absorption</em> is defined as the average number of
transitions which are required to reach an absorbing state, starting
from a transient state (or given an initial state occupancy
probability vector \bf \pi(0)).

   <p>Let \bf t_i be the expected number of transitions before
being absorbed in any absorbing state, starting from state i. 
Vector \bf t can be computed from the fundamental matrix
\bf N (see <a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a>) as

<pre class="example">     t = 1 N
</pre>
   <p>Let \bf B = [ B_i, j ] be a matrix where B_i, j is
the probability of being absorbed in state j, starting from
transient state i. Again, using matrices \bf N and
\bf R (see <a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a>) we can write

<pre class="example">     B = N R
</pre>
   <p><a name="doc_002ddtmcmtta"></a>

<div class="defun">
&mdash; Function File: [<var>t</var> <var>N</var> <var>B</var>] = <b>dtmcmtta</b> (<var>P</var>)<var><a name="index-dtmcmtta-30"></a></var><br>
&mdash; Function File: [<var>t</var> <var>N</var> <var>B</var>] = <b>dtmcmtta</b> (<var>P, p0</var>)<var><a name="index-dtmcmtta-31"></a></var><br>
<blockquote>
        <p><a name="index-mean-time-to-absorption_002c-DTMC-32"></a><a name="index-absorption-probabilities_002c-DTMC-33"></a><a name="index-fundamental-matrix-34"></a><a name="index-DTMC-35"></a><a name="index-discrete-time-Markov-chain-36"></a><a name="index-Markov-chain_002c-discrete-time-37"></a>
Compute the expected number of steps before absorption for a
DTMC with N \times N transition probability matrix <var>P</var>;
compute also the fundamental matrix <var>N</var> for <var>P</var>.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>P</var><dd>N \times N transition probability matrix.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>t</var><dd>When called with a single argument, <var>t</var> is a vector of size
N such that <var>t</var><code>(i)</code> is the expected number of steps
before being absorbed in any absorbing state, starting from state
i; if i is absorbing, <var>t</var><code>(i) = 0</code>. When
called with two arguments, <var>t</var> is a scalar, and represents the
expected number of steps before absorption, starting from the initial
state occupancy probability <var>p0</var>.

          <br><dt><var>N</var><dd>When called with a single argument, <var>N</var> is the N \times N
fundamental matrix for <var>P</var>. <var>N</var><code>(i,j)</code> is the expected
number of visits to transient state <var>j</var> before absorption, if it
is started in transient state <var>i</var>. The initial state is counted
if i = j. When called with two arguments, <var>N</var> is a vector
of size N such that <var>N</var><code>(j)</code> is the expected number
of visits to transient state <var>j</var> before absorption, given initial
state occupancy probability <var>P0</var>.

          <br><dt><var>B</var><dd>When called with a single argument, <var>B</var> is a N \times N
matrix where <var>B</var><code>(i,j)</code> is the probability of being absorbed
in state j, starting from transient state i; if
j is not absorbing, <var>B</var><code>(i,j) = 0</code>; if i
is absorbing, <var>B</var><code>(i,i) = 1</code> and
<var>B</var><code>(i,j) = 0</code> for all j \neq j. When called with
two arguments, <var>B</var> is a vector of size N where
<var>B</var><code>(j)</code> is the probability of being absorbed in state
<var>j</var>, given initial state occupancy probabilities <var>p0</var>.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> ctmcmtta.

        </blockquote></div>

<div class="node">
<a name="First-passage-times-(DTMC)"></a>
<a name="First-passage-times-_0028DTMC_0029"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a>

</div>

<h4 class="subsection">3.1.6 First Passage Times</h4>

<p>The First Passage Time M_i, j is the average number of
transitions needed to visit state j for the first time,
starting from state i. Matrix \bf M satisfies the
property that

<pre class="example">                ___
               \
     M_ij = 1 + &gt;   P_ij * M_kj
               /___
               k!=j
</pre>
   <p>To compute \bf M = [ M_i, j] a different formulation is
used.  Let \bf W be the N \times N matrix having each
row equal to the stationary state occupancy probability vector
\bf \pi for \bf P; let \bf I be the N
\times N identity matrix. Define \bf Z as follows:

<pre class="example">                    -1
     Z = (I - P + W)
</pre>
   <p class="noindent">Then, we have that

<pre class="example">            Z_jj - Z_ij
     M_ij = -----------
               \pi_j
</pre>
   <p>According to the definition above, M_i,i = 0. We arbitrarily
let M_i,i to be the <em>mean recurrence time</em> r_i
for state i, that is the average number of transitions needed
to return to state i starting from it. r_i is:

<pre class="example">             1
     r_i = -----
           \pi_i
</pre>
   <p><a name="doc_002ddtmcfpt"></a>

<div class="defun">
&mdash; Function File: <var>M</var> = <b>dtmcfpt</b> (<var>P</var>)<var><a name="index-dtmcfpt-38"></a></var><br>
<blockquote>
        <p><a name="index-first-passage-times-39"></a><a name="index-mean-recurrence-times-40"></a><a name="index-discrete-time-Markov-chain-41"></a><a name="index-Markov-chain_002c-discrete-time-42"></a><a name="index-DTMC-43"></a>
Compute mean first passage times and mean recurrence times
for an irreducible discrete-time Markov chain.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>P</var><dd><var>P</var><code>(i,j)</code> is the transition probability from state i
to state j. <var>P</var> must be an irreducible stochastic matrix,
which means that the sum of each row must be 1 (\sum_j=1^N
P_i j = 1), and the rank of <var>P</var> must be equal to its
dimension.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>M</var><dd>For all i \neq j, <var>M</var><code>(i,j)</code> is the average number of
transitions before state <var>j</var> is reached for the first time,
starting from state <var>i</var>. <var>M</var><code>(i,i)</code> is the <em>mean
recurrence time</em> of state i, and represents the average time
needed to return to state <var>i</var>.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> ctmcfpt.

        </blockquote></div>

<div class="node">
<a name="Continuous-Time-Markov-Chains"></a>
<a name="Continuous_002dTime-Markov-Chains"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Markov-Chains">Markov Chains</a>

</div>

<h3 class="section">3.2 Continuous-Time Markov Chains</h3>

<p>A stochastic process {X(t), t &ge; 0} is a continuous-time
Markov chain if, for all integers n, and for any sequence
t_0, t_1 , \ldots, t_n, t_n+1 such that t_0 &lt; t_1 &lt;
\ldots &lt; t_n &lt; t_n+1, we have

   <p>P(X_n+1 = x_n+1 | X_n = x_n, X_n-1 = x_n-1, ..., X_0 = x_0) = P(X_n+1 = x_n+1 | X_n = x_n)

   <p>A continuous-time Markov chain is defined according to an
<em>infinitesimal generator matrix</em> \bf Q = [Q_i,j],
where for each i \neq j, Q_i, j is the transition rate
from state i to state j. The matrix \bf Q must
satisfy the property that, for all i, \sum_j=1^N Q_i,
j = 0.

   <p><a name="doc_002dctmcchkQ"></a>

<div class="defun">
&mdash; Function File: [<var>result</var> <var>err</var>] = <b>ctmcchkQ</b> (<var>Q</var>)<var><a name="index-ctmcchkQ-44"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-continuous-time-45"></a>
If <var>Q</var> is a valid infinitesimal generator matrix, return
the size (number of rows or columns) of <var>Q</var>. If <var>Q</var> is not
an infinitesimal generator matrix, set <var>result</var> to zero, and
<var>err</var> to an appropriate error string.

        </blockquote></div>

<ul class="menu">
<li><a accesskey="1" href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a>
<li><a accesskey="2" href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a>
<li><a accesskey="3" href="#Expected-sojourn-times-_0028CTMC_0029">Expected sojourn times (CTMC)</a>
<li><a accesskey="4" href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a>
<li><a accesskey="5" href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a>
<li><a accesskey="6" href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a>
</ul>

<div class="node">
<a name="State-occupancy-probabilities-(CTMC)"></a>
<a name="State-occupancy-probabilities-_0028CTMC_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>

</div>

<h4 class="subsection">3.2.1 State occupancy probabilities</h4>

<p>Similarly to the discrete case, we denote with \bf \pi(t) =
(\pi_1(t), \pi_2(t), <small class="dots">...</small>, \pi_N(t) ) the <em>state occupancy
probability vector</em> at time t. \pi_i(t) is the
probability that the system is in state i at time t
&ge; 0.

   <p>Given the infinitesimal generator matrix \bf Q and the initial
state occupancy probabilities \bf \pi(0) = (\pi_1(0),
\pi_2(0), <small class="dots">...</small>, \pi_N(0)), the state occupancy probabilities
\bf \pi(t) at time t can be computed as:

<pre class="example">     \pi(t) = \pi(0) exp(Qt)
</pre>
   <p class="noindent">where \exp( \bf Q t ) is the matrix exponential
of \bf Q t. Under certain conditions, there exists a
<em>stationary state occupancy probability</em> \bf \pi =
\lim_t \rightarrow +\infty \bf \pi(t), which is independent from
\bf \pi(0).  \bf \pi is the solution of the following
linear system:

<pre class="example">     /
     | \pi Q   = 0
     | \pi 1^T = 1
     \
</pre>
   <p><a name="doc_002dctmc"></a>

<div class="defun">
&mdash; Function File: <var>p</var> = <b>ctmc</b> (<var>Q</var>)<var><a name="index-ctmc-46"></a></var><br>
&mdash; Function File: <var>p</var> = <b>ctmc</b> (<var>Q, t. p0</var>)<var><a name="index-ctmc-47"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-continuous-time-48"></a><a name="index-continuous-time-Markov-chain-49"></a><a name="index-Markov-chain_002c-state-occupancy-probabilities-50"></a><a name="index-stationary-probabilities-51"></a><a name="index-CTMC-52"></a>
Compute stationary or transient state occupancy probabilities for a continuous-time Markov chain.

        <p>With a single argument, compute the stationary state occupancy
probability vector <var>p</var>(1), <small class="dots">...</small>, <var>p</var>(N) for a
continuous-time Markov chain with state space {1, 2, <small class="dots">...</small>,
N} and N \times N infinitesimal generator matrix <var>Q</var>. 
With three arguments, compute the state occupancy probabilities
<var>p</var>(1), <small class="dots">...</small>, <var>p</var>(N) that the system is in state i
at time <var>t</var>, given initial state occupancy probabilities
<var>p0</var>(1), <small class="dots">...</small>, <var>p0</var>(N) at time 0.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>Q</var><dd>Infinitesimal generator matrix. <var>Q</var> is a N \times N square
matrix where <var>Q</var><code>(i,j)</code> is the transition rate from state
i to state j, for 1 &le; i \neq j &le; N. 
#varQ must satisfy the property that \sum_j=1^N Q_i, j =
0

          <br><dt><var>t</var><dd>Time at which to compute the transient probability (t &ge;
0). If omitted, the function computes the steady state occupancy
probability vector.

          <br><dt><var>p0</var><dd><var>p0</var><code>(i)</code> is the probability that the system
is in state i at time 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>p</var><dd>If this function is invoked with a single argument, <var>p</var><code>(i)</code>
is the steady-state probability that the system is in state i,
i = 1, <small class="dots">...</small>, N. If this function is invoked with three
arguments, <var>p</var><code>(i)</code> is the probability that the system is in
state i at time <var>t</var>, given the initial occupancy
probabilities <var>p0</var>(1), <small class="dots">...</small>, <var>p0</var>(N).

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> dtmc.

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

   <p>Consider a two-state CTMC such that transition rates between states
are equal to 1. This can be solved as follows:

<pre class="example"><pre class="verbatim">      Q = [ -1  1; \
             1 -1  ];
      q = ctmc(Q)
</pre>
         &rArr; q = 0.50000   0.50000
</pre>
   <div class="node">
<a name="Birth-death-process-(CTMC)"></a>
<a name="Birth_002ddeath-process-_0028CTMC_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Expected-sojourn-times-_0028CTMC_0029">Expected sojourn times (CTMC)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>

</div>

<h4 class="subsection">3.2.2 Birth-Death Process</h4>

<p><a name="doc_002dctmcbd"></a>

<div class="defun">
&mdash; Function File: <var>Q</var> = <b>ctmcbd</b> (<var>b, d</var>)<var><a name="index-ctmcbd-53"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-continuous-time-54"></a><a name="index-continuous-time-Markov-chain-55"></a><a name="index-CTMC-56"></a><a name="index-birth_002ddeath-process_002c-CTMC-57"></a>
Returns the infinitesimal generator matrix Q for a continuous
birth-death process over state space 1, 2, <small class="dots">...</small>, N. 
<var>b</var><code>(i)</code> is the transition rate from state i to
i+1, and <var>d</var><code>(i)</code> is the transition rate from state
i+1 to state i, i=1, 2, <small class="dots">...</small>, N-1.

        <p>Matrix \bf Q is therefore defined as:

     <pre class="example">          /                                                          \
          | -b(1)     b(1)                                           |
          |  d(1) -(d(1)+b(2))     b(2)                              |
          |           d(2)     -(d(2)+b(3))        b(3)              |
          |                                                          |
          |                ...           ...          ...            |
          |                                                          |
          |                       d(N-2)    -(d(N-2)+b(N-1))  b(N-1) |
          |                                       d(N-1)     -d(N-1) |
          \                                                          /
</pre>
        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> dtmcbd.

        </blockquote></div>

<div class="node">
<a name="Expected-sojourn-times-(CTMC)"></a>
<a name="Expected-sojourn-times-_0028CTMC_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>

</div>

<h4 class="subsection">3.2.3 Expected Sojourn Times</h4>

<p>Given a N state continuous-time Markov Chain with infinitesimal
generator matrix \bf Q, we define the vector \bf L(t) =
(L_1(t), L_2(t), \ldots, L_N(t)) such that L_i(t) is the
expected sojourn time in state i during the interval
[0,t), assuming that the initial occupancy probability at time
0 was \bf \pi(0). \bf L(t) can be expressed as the
solution of the following differential equation:

<pre class="example">      dL
      --(t) = L(t) Q + pi(0),    L(0) = 0
      dt
</pre>
   <p>Alternatively, \bf L(t) can also be expressed in integral
form as:

<pre class="example">            / t
     L(t) = |   pi(u) du
            / 0
</pre>
   <p class="noindent">where \bf \pi(t) = \bf \pi(0) \exp(\bf Qt) is
the state occupancy probability at time t; \exp(\bf Qt)
is the matrix exponential of \bf Qt.

   <p>If there are absorbing states, we can define the vector <em>expected
sojourn times until absorption</em> \bf L(\infty), where for each
transient state i, L_i(\infty) is the expected total
time spent in state i until absorption, assuming that the
system started with a given state occupancy probability vector
\bf \pi(0). Let \tau be the set of transient (i.e.,
non absorbing) states; let \bf Q_\tau be the restriction of
\bf Q to the transient substates only. Similarly, let
\bf \pi_\tau(0) be the restriction of the initial probability
vector \bf \pi(0) to transient states \tau.

   <p>The expected time to absorption \bf L_\tau(\infty) is defined as
the solution of the following equation:

<pre class="example">     L_T( inf ) Q_T = -pi_T(0)
</pre>
   <p><a name="doc_002dctmcexps"></a>

<div class="defun">
&mdash; Function File: <var>L</var> = <b>ctmcexps</b> (<var>Q, t, p </var>)<var><a name="index-ctmcexps-58"></a></var><br>
&mdash; Function File: <var>L</var> = <b>ctmcexps</b> (<var>Q, p</var>)<var><a name="index-ctmcexps-59"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-continuous-time-60"></a><a name="index-expected-sojourn-time_002c-CTMC-61"></a>
With three arguments, compute the expected times <var>L</var><code>(i)</code>
spent in each state i during the time interval [0,t],
assuming that the initial occupancy vector is <var>p</var>. With two
arguments, compute the expected time <var>L</var><code>(i)</code> spent in each
transient state i until absorption.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>Q</var><dd>N \times N infinitesimal generator matrix. <var>Q</var><code>(i,j)</code>
is the transition rate from state i to state j, 1
&le; i \neq j &le; N. The matrix <var>Q</var> must also satisfy the
condition \sum_j=1^N Q_ij = 0.

          <br><dt><var>t</var><dd>If given, compute the expected sojourn times in [0,t]

          <br><dt><var>p</var><dd>Initial occupancy probability vector; <var>p</var><code>(i)</code> is the
probability the system is in state i at time 0, i = 1,
<small class="dots">...</small>, N

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>L</var><dd>If this function is called with three arguments, <var>L</var><code>(i)</code> is
the expected time spent in state i during the interval
[0,t]. If this function is called with two arguments
<var>L</var><code>(i)</code> is the expected time spent in transient state
i until absorption; if state i is absorbing,
<var>L</var><code>(i)</code> is zero.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> dtmcexps.

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

   <p>Let us consider a pure-birth, 4-states CTMC such that the transition
rate from state i to state i+1 is \lambda_i = i
\lambda (i=1, 2, 3), with \lambda = 0.5. The following
code computes the expected sojourn time in state i,
given the initial occupancy probability \bf \pi_0=(1,0,0,0).

<pre class="example"><pre class="verbatim">      lambda = 0.5;
      N = 4;
      b = lambda*[1:N-1];
      d = zeros(size(b));
      Q = ctmcbd(b,d);
      t = linspace(0,10,100);
      p0 = zeros(1,N); p0(1)=1;
      L = zeros(length(t),N);
      for i=1:length(t)
        L(i,:) = ctmcexps(Q,t(i),p0);
      endfor
      plot( t, L(:,1), ";State 1;", "linewidth", 2, \
            t, L(:,2), ";State 2;", "linewidth", 2, \
            t, L(:,3), ";State 3;", "linewidth", 2, \
            t, L(:,4), ";State 4;", "linewidth", 2 );
      legend("location","northwest");
      xlabel("Time");
      ylabel("Expected sojourn time");
</pre>
</pre>
   <div class="node">
<a name="Time-averaged-expected-sojourn-times-(CTMC)"></a>
<a name="Time_002daveraged-expected-sojourn-times-_0028CTMC_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Expected-sojourn-times-_0028CTMC_0029">Expected sojourn times (CTMC)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>

</div>

<h4 class="subsection">3.2.4 Time-Averaged Expected Sojourn Times</h4>

<p><a name="doc_002dctmctaexps"></a>

<div class="defun">
&mdash; Function File: <var>M</var> = <b>ctmctaexps</b> (<var>Q, t, p</var>)<var><a name="index-ctmctaexps-62"></a></var><br>
&mdash; Function File: <var>M</var> = <b>ctmctaexps</b> (<var>Q, p</var>)<var><a name="index-ctmctaexps-63"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-continuous-time-64"></a><a name="index-time_002dalveraged-sojourn-time_002c-CTMC-65"></a><a name="index-continuous-time-Markov-chain-66"></a><a name="index-CTMC-67"></a>
Compute the <em>time-averaged sojourn time</em> <var>M</var><code>(i)</code>,
defined as the fraction of the time interval [0,t] (or until
absorption) spent in state i, assuming that the state
occupancy probabilities at time 0 are <var>p</var>.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>Q</var><dd>Infinitesimal generator matrix. <var>Q</var><code>(i,j)</code> is the transition
rate from state i to state j,
1 &le; i \neq j &le; N. The
matrix <var>Q</var> must also satisfy the condition \sum_j=1^N Q_ij = 0

          <br><dt><var>t</var><dd>Time. If omitted, the results are computed until absorption.

          <br><dt><var>p</var><dd><var>p</var><code>(i)</code> is the probability that, at time 0, the system was in
state i, for all i = 1, <small class="dots">...</small>, N

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>M</var><dd>When called with three arguments, <var>M</var><code>(i)</code> is the expected
fraction of the interval [0,t] spent in state i
assuming that the state occupancy probability at time zero is
<var>p</var>. When called with two arguments, <var>M</var><code>(i)</code> is the
expected fraction of time until absorption spent in state i;
in this case the mean time to absorption is <code>sum(</code><var>M</var><code>)</code>.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> dtmctaexps.

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

<pre class="example"><pre class="verbatim">      lambda = 0.5;
      N = 4;
      birth = lambda*linspace(1,N-1,N-1);
      death = zeros(1,N-1);
      Q = diag(birth,1)+diag(death,-1);
      Q -= diag(sum(Q,2));
      t = linspace(1e-5,30,100);
      p = zeros(1,N); p(1)=1;
      M = zeros(length(t),N);
      for i=1:length(t)
        M(i,:) = ctmctaexps(Q,t(i),p);
      endfor
      clf;
      plot(t, M(:,1), ";State 1;", "linewidth", 2, \
           t, M(:,2), ";State 2;", "linewidth", 2, \
           t, M(:,3), ";State 3;", "linewidth", 2, \
           t, M(:,4), ";State 4 (absorbing);", "linewidth", 2 );
      legend("location","east");
      xlabel("Time");
      ylabel("Time-averaged Expected sojourn time");
</pre>
</pre>
   <div class="node">
<a name="Mean-time-to-absorption-(CTMC)"></a>
<a name="Mean-time-to-absorption-_0028CTMC_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>

</div>

<h4 class="subsection">3.2.5 Mean Time to Absorption</h4>

<p><a name="doc_002dctmcmtta"></a>

<div class="defun">
&mdash; Function File: <var>t</var> = <b>ctmcmtta</b> (<var>Q, p</var>)<var><a name="index-ctmcmtta-68"></a></var><br>
<blockquote>
        <p><a name="index-Markov-chain_002c-continuous-time-69"></a><a name="index-continuous-time-Markov-chain-70"></a><a name="index-CTMC-71"></a><a name="index-mean-time-to-absorption_002c-CTMC-72"></a>
Compute the Mean-Time to Absorption (MTTA) of the CTMC described by
the infinitesimal generator matrix <var>Q</var>, starting from initial
occupancy probabilities <var>p</var>. If there are no absorbing states, this
function fails with an error.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>Q</var><dd>N \times N infinitesimal generator matrix. <var>Q</var><code>(i,j)</code>
is the transition rate from state i to state j, i
\neq j. The matrix <var>Q</var> must satisfy the condition
\sum_j=1^N Q_i j = 0

          <br><dt><var>p</var><dd><var>p</var><code>(i)</code> is the probability that the system is in state i
at time 0, for each i=1, <small class="dots">...</small>, N

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>t</var><dd>Mean time to absorption of the process represented by matrix <var>Q</var>. 
If there are no absorbing states, this function fails.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> dtmcmtta.

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

   <p>Let us consider a simple model of a redundant disk array. We assume
that the array is made of 5 independent disks, such that the array can
tolerate up to 2 disk failures without losing data. If three or more
disks break, the array is dead and unrecoverable. We want to estimate
the Mean-Time-To-Failure (MTTF) of the disk array.

   <p>We model this system as a 4 states Markov chain with state space
\ 2, 3, 4, 5 \. State i denotes the fact that exactly
i disks are active; state 2 is absorbing. Let \mu
be the failure rate of a single disk. The system starts in state
5 (all disks are operational). We use a pure death process,
with death rate from state i to state i-1 is \mu
i, for i = 3, 4, 5).

   <p>The MTTF of the disk array is the MTTA of the Markov Chain, and can be
computed with the following expression:

<pre class="example"><pre class="verbatim">      mu = 0.01;
      death = [ 3 4 5 ] * mu;
      birth = 0*death;
      Q = ctmcbd(birth,death);
      t = ctmcmtta(Q,[0 0 0 1])
</pre>
         &rArr; t = 78.333
</pre>
   <p class="noindent"><strong>REFERENCES</strong>

   <p>G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998.

   <p><a name="index-Bolch_002c-G_002e-73"></a><a name="index-Greiner_002c-S_002e-74"></a><a name="index-de-Meer_002c-H_002e-75"></a><a name="index-Trivedi_002c-K_002e-76"></a>
<div class="node">
<a name="First-passage-times-(CTMC)"></a>
<a name="First-passage-times-_0028CTMC_0029"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a>

</div>

<h4 class="subsection">3.2.6 First Passage Times</h4>

<p><a name="doc_002dctmcfpt"></a>

<div class="defun">
&mdash; Function File: <var>M</var> = <b>ctmcfpt</b> (<var>Q</var>)<var><a name="index-ctmcfpt-77"></a></var><br>
&mdash; Function File: <var>m</var> = <b>ctmcfpt</b> (<var>Q, i, j</var>)<var><a name="index-ctmcfpt-78"></a></var><br>
<blockquote>
        <p><a name="index-first-passage-times_002c-CTMC-79"></a><a name="index-CTMC-80"></a><a name="index-continuous-time-Markov-chain-81"></a><a name="index-Markov-chain_002c-continuous-time-82"></a>
Compute mean first passage times for an irreducible continuous-time
Markov chain.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>Q</var><dd>Infinitesimal generator matrix. <var>Q</var> is a N \times N square
matrix where <var>Q</var><code>(i,j)</code> is the transition rate from state
i to state j, for 1 &le; i \neq j &le; N. 
Transition rates must be nonnegative, and \sum_j=1^N Q_i j = 0

          <br><dt><var>i</var><dd>Initial state.

          <br><dt><var>j</var><dd>Destination state.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>M</var><dd><var>M</var><code>(i,j)</code> is the average time before state
<var>j</var> is visited for the first time, starting from state <var>i</var>. 
We set <var>M</var><code>(i,i) = 0</code>.

          <br><dt><var>m</var><dd><var>m</var> is the average time before state <var>j</var> is visited for the first
time, starting from state <var>i</var>.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> dtmcfpt.

        </blockquote></div>

<!-- This file has been automatically generated from singlestation.txi -->
<!-- by proc.m. Do not edit this file, all changes will be lost -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Single-Station-Queueing-Systems"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Queueing-Networks">Queueing Networks</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Markov-Chains">Markov Chains</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Single Station Queueing Systems</h2>

<p>Single Station Queueing Systems contain a single station, and are thus
quite easy to analyze. The <code>queueing</code> package contains functions
for handling the following types of queues:

<ul class="menu">
<li><a accesskey="1" href="#The-M_002fM_002f1-System">The M/M/1 System</a>:     Single-server queueing station. 
<li><a accesskey="2" href="#The-M_002fM_002fm-System">The M/M/m System</a>:     Multiple-server queueing station. 
<li><a accesskey="3" href="#The-M_002fM_002finf-System">The M/M/inf System</a>:   Infinite-server (delay center) station. 
<li><a accesskey="4" href="#The-M_002fM_002f1_002fK-System">The M/M/1/K System</a>:   Single-server, finite-capacity queueing station. 
<li><a accesskey="5" href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a>:   Multiple-server, finite-capacity queueing station. 
<li><a accesskey="6" href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a>:   Asymmetric multiple-server queueing station. 
<li><a accesskey="7" href="#The-M_002fG_002f1-System">The M/G/1 System</a>:  Single-server with general service time distribution. 
<li><a accesskey="8" href="#The-M_002fHm_002f1-System">The M/Hm/1 System</a>:  Single-server with hyperexponential service time distribution. 
</ul>

<!-- M/M/1 -->
<div class="node">
<a name="The-M%2fM%2f1-System"></a>
<a name="The-M_002fM_002f1-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-M_002fM_002fm-System">The M/M/m System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">4.1 The M/M/1 System</h3>

<p>The M/M/1 system is made of a single server connected to an
unlimited FCFS queue. Requests arrive according to a Poisson process
with rate \lambda; the service time is exponentially
distributed with average service rate \mu. The system is stable
if \lambda &lt; \mu.

   <p><a name="doc_002dqsmm1"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>] = <b>qsmm1</b> (<var>lambda, mu</var>)<var><a name="index-qsmm1-83"></a></var><br>
<blockquote>
        <p><a name="index-g_t_0040math_007bM_002fM_002f1_007d-system-84"></a>
Compute utilization, response time, average number of requests and throughput for a M/M/1 queue.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate (<var>lambda</var><code> &gt; 0</code>).

          <br><dt><var>mu</var><dd>Service rate (<var>mu</var><code> &gt; </code><var>lambda</var>).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Server utilization

          <br><dt><var>R</var><dd>Service center response time

          <br><dt><var>Q</var><dd>Average number of requests in the system

          <br><dt><var>X</var><dd>Service center throughput. If the system is ergodic,
we will always have <var>X</var><code> = </code><var>lambda</var>

          <br><dt><var>p0</var><dd>Steady-state probability that there are no requests in the system.

        </dl>

        <p><var>lambda</var> and <var>mu</var> can be vectors of the same size. In this
case, the results will be vectors as well.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qsmmm, qsmminf, qsmmmk.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998, Section 6.3.

   <p><a name="index-Bolch_002c-G_002e-85"></a><a name="index-Greiner_002c-S_002e-86"></a><a name="index-de-Meer_002c-H_002e-87"></a><a name="index-Trivedi_002c-K_002e-88"></a>
<!-- M/M/m -->
<div class="node">
<a name="The-M%2fM%2fm-System"></a>
<a name="The-M_002fM_002fm-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-M_002fM_002finf-System">The M/M/inf System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-M_002fM_002f1-System">The M/M/1 System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">4.2 The M/M/m System</h3>

<p>The M/M/m system is similar to the M/M/1 system, except
that there are m \geq 1 identical servers connected to a shared
FCFS queue. Thus, at most m requests can be served at the same
time. The M/M/m system can be seen as a single server with
load-dependent service rate \mu(n), which is a function of the
number n of requests in the system:

<pre class="example">     mu(n) = min(m,n)*mu
</pre>
   <p class="noindent">where \mu is the service rate of each individual server.

   <p><a name="doc_002dqsmmm"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>, <var>pm</var>] = <b>qsmmm</b> (<var>lambda, mu</var>)<var><a name="index-qsmmm-89"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>, <var>pm</var>] = <b>qsmmm</b> (<var>lambda, mu, m</var>)<var><a name="index-qsmmm-90"></a></var><br>
<blockquote>
        <p><a name="index-g_t_0040math_007bM_002fM_002fm_007d-system-91"></a>
Compute utilization, response time, average number of requests in service and throughput for a M/M/m queue, a queueing system with m identical service centers connected to a single FCFS queue.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate (<var>lambda</var><code>&gt;0</code>).

          <br><dt><var>mu</var><dd>Service rate (<var>mu</var><code>&gt;</code><var>lambda</var>).

          <br><dt><var>m</var><dd>Number of servers (<var>m</var><code> &ge; 1</code>). 
If omitted, it is assumed <var>m</var><code>=1</code>.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Service center utilization, U = \lambda / (m \mu).

          <br><dt><var>R</var><dd>Service center response time

          <br><dt><var>Q</var><dd>Average number of requests in the system

          <br><dt><var>X</var><dd>Service center throughput. If the system is ergodic,
we will always have <var>X</var><code> = </code><var>lambda</var>

          <br><dt><var>p0</var><dd>Steady-state probability that there are 0 requests in the system

          <br><dt><var>pm</var><dd>Steady-state probability that an arriving request has to wait in the
queue

        </dl>

        <p><var>lambda</var>, <var>mu</var> and <var>m</var> can be vectors of the same size. In this
case, the results will be vectors as well.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qsmm1,qsmminf,qsmmmk.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998, Section 6.5.

   <p><a name="index-Bolch_002c-G_002e-92"></a><a name="index-Greiner_002c-S_002e-93"></a><a name="index-de-Meer_002c-H_002e-94"></a><a name="index-Trivedi_002c-K_002e-95"></a>
<!-- M/M/inf -->
<div class="node">
<a name="The-M%2fM%2finf-System"></a>
<a name="The-M_002fM_002finf-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-M_002fM_002f1_002fK-System">The M/M/1/K System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-M_002fM_002fm-System">The M/M/m System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">4.3 The M/M/inf System</h3>

<p>The M/M/\infty system is similar to the M/M/m system,
except that there are infinitely many identical servers (that is,
m = \infty). Each new request is assigned to a new server, so
that queueing never occurs. The M/M/\infty system is always
stable.

   <p><a name="doc_002dqsmminf"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>] = <b>qsmminf</b> (<var>lambda, mu</var>)<var><a name="index-qsmminf-96"></a></var><br>
<blockquote>
        <p>Compute utilization, response time, average number of requests and throughput for a M/M/\infty queue.

        <p>The M/M/\infty system has an infinite number of identical
servers; this kind of system is always stable for every arrival and
service rates.

        <p><a name="index-g_t_0040math_007bM_002fM_002f_007dinf-system-97"></a>

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate (<var>lambda</var><code>&gt;0</code>).

          <br><dt><var>mu</var><dd>Service rate (<var>mu</var><code>&gt;0</code>).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Traffic intensity (defined as \lambda/\mu). Note that this is
different from the utilization, which in the case of M/M/\infty
centers is always zero.

          <p><a name="index-traffic-intensity-98"></a>
<br><dt><var>R</var><dd>Service center response time.

          <br><dt><var>Q</var><dd>Average number of requests in the system (which is equal to the
traffic intensity \lambda/\mu).

          <br><dt><var>X</var><dd>Throughput (which is always equal to <var>X</var><code> = </code><var>lambda</var>).

          <br><dt><var>p0</var><dd>Steady-state probability that there are no requests in the system

        </dl>

        <p><var>lambda</var> and <var>mu</var> can be vectors of the same size. In this
case, the results will be vectors as well.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qsmm1,qsmmm,qsmmmk.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998, Section 6.4.

   <p><a name="index-Bolch_002c-G_002e-99"></a><a name="index-Greiner_002c-S_002e-100"></a><a name="index-de-Meer_002c-H_002e-101"></a><a name="index-Trivedi_002c-K_002e-102"></a>
<!-- M/M/1/k -->
<div class="node">
<a name="The-M%2fM%2f1%2fK-System"></a>
<a name="The-M_002fM_002f1_002fK-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-M_002fM_002finf-System">The M/M/inf System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">4.4 The M/M/1/K System</h3>

<p>In a M/M/1/K finite capacity system there can be at most
k jobs at any time. If a new request tries to join the system
when there are already K other requests, the arriving request
is lost. The queue has K-1 slots. The M/M/1/K system is
always stable, regardless of the arrival and service rates
\lambda and \mu.

   <p><a name="doc_002dqsmm1k"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>, <var>pK</var>] = <b>qsmm1k</b> (<var>lambda, mu, K</var>)<var><a name="index-qsmm1k-103"></a></var><br>
<blockquote>
        <p><a name="index-g_t_0040math_007bM_002fM_002f1_002fK_007d-system-104"></a>
Compute utilization, response time, average number of requests and
throughput for a M/M/1/K finite capacity system. In a
M/M/1/K queue there is a single server; the maximum number of
requests in the system is K, and the maximum queue length is
K-1.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate (<var>lambda</var><code>&gt;0</code>).

          <br><dt><var>mu</var><dd>Service rate (<var>mu</var><code>&gt;0</code>).

          <br><dt><var>K</var><dd>Maximum number of requests allowed in the system (<var>K</var><code> &ge; 1</code>).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Service center utilization, which is defined as <var>U</var><code> = 1-</code><var>p0</var>

          <br><dt><var>R</var><dd>Service center response time

          <br><dt><var>Q</var><dd>Average number of requests in the system

          <br><dt><var>X</var><dd>Service center throughput

          <br><dt><var>p0</var><dd>Steady-state probability that there are no requests in the system

          <br><dt><var>pK</var><dd>Steady-state probability that there are K requests in the system
(i.e., that the system is full)

        </dl>

        <p><var>lambda</var>, <var>mu</var> and <var>K</var> can be vectors of the
same size. In this case, the results will be vectors as well.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qsmm1,qsmminf,qsmmm.

        </blockquote></div>

<!-- M/M/m/k -->
<div class="node">
<a name="The-M%2fM%2fm%2fK-System"></a>
<a name="The-M_002fM_002fm_002fK-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-M_002fM_002f1_002fK-System">The M/M/1/K System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">4.5 The M/M/m/K System</h3>

<p>The M/M/m/K finite capacity system is similar to the
M/M/1/k system except that the number of servers is m,
where 1 \leq m \leq K. The queue is made of K-m
slots. The M/M/m/K system is always stable.

   <p><a name="doc_002dqsmmmk"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>, <var>pK</var>] = <b>qsmmmk</b> (<var>lambda, mu, m, K</var>)<var><a name="index-qsmmmk-105"></a></var><br>
<blockquote>
        <p><a name="index-g_t_0040math_007bM_002fM_002fm_002fK_007d-system-106"></a>
Compute utilization, response time, average number of requests and
throughput for a M/M/m/K finite capacity system. In a
M/M/m/K system there are m \geq 1 identical service
centers sharing a fixed-capacity queue. At any time, at most K &ge; m requests can be in the system. The maximum queue length
is K-m. This function generates and
solves the underlying CTMC.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate (<var>lambda</var><code>&gt;0</code>).

          <br><dt><var>mu</var><dd>Service rate (<var>mu</var><code>&gt;0</code>).

          <br><dt><var>m</var><dd>Number of servers (<var>m</var><code> &ge; 1</code>).

          <br><dt><var>K</var><dd>Maximum number of requests allowed in the system,
including those inside the service centers
(<var>K</var><code> &ge; </code><var>m</var>).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Service center utilization

          <br><dt><var>R</var><dd>Service center response time

          <br><dt><var>Q</var><dd>Average number of requests in the system

          <br><dt><var>X</var><dd>Service center throughput

          <br><dt><var>p0</var><dd>Steady-state probability that there are no requests in the system.

          <br><dt><var>pK</var><dd>Steady-state probability that there are <var>K</var> requests in the system
(i.e., probability that the system is full).

        </dl>

        <p><var>lambda</var>, <var>mu</var>, <var>m</var> and <var>K</var> can be either scalars, or
vectors of the  same size. In this case, the results will be vectors
as well.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qsmm1,qsmminf,qsmmm.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998, Section 6.6.

   <p><a name="index-Bolch_002c-G_002e-107"></a><a name="index-Greiner_002c-S_002e-108"></a><a name="index-de-Meer_002c-H_002e-109"></a><a name="index-Trivedi_002c-K_002e-110"></a>
<!-- Approximate M/M/m -->
<div class="node">
<a name="The-Asymmetric-M%2fM%2fm-System"></a>
<a name="The-Asymmetric-M_002fM_002fm-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-M_002fG_002f1-System">The M/G/1 System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">4.6 The Asymmetric M/M/m System</h3>

<p>The Asymmetric M/M/m system contains m servers connected
to a single queue. Differently from the M/M/m system, in the
asymmetric M/M/m each server may have a different service time.

   <p><a name="doc_002dqsammm"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qsammm</b> (<var>lambda, mu</var>)<var><a name="index-qsammm-111"></a></var><br>
<blockquote>
        <p><a name="index-asymmetric-_0040math_007bM_002fM_002fm_007d-system-112"></a>
Compute <em>approximate</em> utilization, response time, average number
of requests in service and throughput for an asymmetric  M/M/m
queue. In this system there are m different service centers
connected to a single queue. Each server has its own (possibly different)
service rate. If there is more than one server available, requests
are routed to a randomly-chosen one.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate (<var>lambda</var><code>&gt;0</code>).

          <br><dt><var>mu</var><dd><var>mu</var><code>(i)</code> is the service rate of server
i, 1 &le; i &le; m. 
The system must be ergodic (<var>lambda</var><code> &lt; sum(</code><var>mu</var><code>)</code>).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Approximate service center utilization,
U = \lambda / ( \sum_i \mu_i ).

          <br><dt><var>R</var><dd>Approximate service center response time

          <br><dt><var>Q</var><dd>Approximate number of requests in the system

          <br><dt><var>X</var><dd>Approximate service center throughput. If the system is ergodic,
we will always have <var>X</var><code> = </code><var>lambda</var>

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qsmmm.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing Networks
and Markov Chains: Modeling and Performance Evaluation with Computer
Science Applications</cite>, Wiley, 1998

   <p><a name="index-Bolch_002c-G_002e-113"></a><a name="index-Greiner_002c-S_002e-114"></a><a name="index-de-Meer_002c-H_002e-115"></a><a name="index-Trivedi_002c-K_002e-116"></a>
<div class="node">
<a name="The-M%2fG%2f1-System"></a>
<a name="The-M_002fG_002f1-System"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-M_002fHm_002f1-System">The M/Hm/1 System</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">4.7 The M/G/1 System</h3>

<p><a name="doc_002dqsmg1"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>] = <b>qsmg1</b> (<var>lambda, xavg, x2nd</var>)<var><a name="index-qsmg1-117"></a></var><br>
<blockquote>
        <p><a name="index-g_t_0040math_007bM_002fG_002f1_007d-system-118"></a>
Compute utilization, response time, average number of requests and
throughput for a M/G/1 system. The service time distribution
is described by its mean <var>xavg</var>, and by its second moment
<var>x2nd</var>. The computations are based on results from L. Kleinrock,
<cite>Queuing Systems</cite>, Wiley, Vol 2, and Pollaczek-Khinchine formula.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate.

          <br><dt><var>xavg</var><dd>Average service time

          <br><dt><var>x2nd</var><dd>Second moment of service time distribution

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Service center utilization

          <br><dt><var>R</var><dd>Service center response time

          <br><dt><var>Q</var><dd>Average number of requests in the system

          <br><dt><var>X</var><dd>Service center throughput

          <br><dt><var>p0</var><dd>probability that there is not any request at system

        </dl>

        <p><var>lambda</var>, <var>xavg</var>, <var>t2nd</var> can be vectors of the
same size. In this case, the results will be vectors as well.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qsmh1.

        </blockquote></div>

<div class="node">
<a name="The-M%2fHm%2f1-System"></a>
<a name="The-M_002fHm_002f1-System"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-M_002fG_002f1-System">The M/G/1 System</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>

</div>

<h3 class="section">4.8 The M/H_m/1 System</h3>

<p><a name="doc_002dqsmh1"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>p0</var>] = <b>qsmh1</b> (<var>lambda, mu, alpha</var>)<var><a name="index-qsmh1-119"></a></var><br>
<blockquote>
        <p><a name="index-g_t_0040math_007bM_002fH_005fm_002f1_007d-system-120"></a>
Compute utilization, response time, average number of requests and
throughput for a M/H_m/1 system. In this system, the customer
service times have hyper-exponential distribution:

     <pre class="example">                 ___ m
                 \
          B(x) =  &gt;  alpha(j) * (1-exp(-mu(j)*x))   x&gt;0
                 /__
                     j=1
</pre>
        <p>where \alpha_j is the probability that the request is served
at phase j, in which case the average service rate is
\mu_j. After completing service at phase j, for
some j, the request exits the system.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate.

          <br><dt><var>mu</var><dd><var>mu</var><code>(j)</code> is the phase j service rate. The total
number of phases m is <code>length(</code><var>mu</var><code>)</code>.

          <br><dt><var>alpha</var><dd><var>alpha</var><code>(j)</code> is the probability that a request
is served at phase j. <var>alpha</var> must have the same size
as <var>mu</var>.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>Service center utilization

          <br><dt><var>R</var><dd>Service center response time

          <br><dt><var>Q</var><dd>Average number of requests in the system

          <br><dt><var>X</var><dd>Service center throughput

        </dl>

        </blockquote></div>

<!-- This file has been automatically generated from queueingnetworks.txi -->
<!-- by proc.m. Do not edit this file, all changes will be lost -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="Queueing-Networks"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#References">References</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Single-Station-Queueing-Systems">Single Station Queueing Systems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Queueing Networks</h2>

<ul class="menu">
<li><a accesskey="1" href="#Introduction-to-QNs">Introduction to QNs</a>:              A brief introduction to Queueing Networks
<li><a accesskey="2" href="#Single-Class-Models">Single Class Models</a>:              Queueing Models with a single job class
<li><a accesskey="3" href="#Multiple-Class-Models">Multiple Class Models</a>:            Queueing Models with multiple job classess
<li><a accesskey="4" href="#Generic-Algorithms">Generic Algorithms</a>:               High-level functions for QN analysis
<li><a accesskey="5" href="#Bounds-Analysis">Bounds Analysis</a>:                  Computation of asymptotic performance bounds
<li><a accesskey="6" href="#QN-Analysis-Examples">QN Analysis Examples</a>:             Queueing Networks Analysis examples
</ul>

<p><a name="index-queueing-networks-121"></a>
<!-- INTRODUCTION -->
<div class="node">
<a name="Introduction-to-QNs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Single-Class-Models">Single Class Models</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Queueing-Networks">Queueing Networks</a>

</div>

<h3 class="section">5.1 Introduction to QNs</h3>

<p>Queueing Networks (QN) are a very simple yet powerful modeling tool
which can be used to analyze many kind of systems. In its simplest
form, a QN is made of K service centers. Each center k
has a queue, which is connected to m_k (generally identical)
<em>servers</em>. Arriving customers (requests) join the queue if there
is a slot available. Then, requests are served according to a
(de)queueing policy (e.g., FIFO). After service completes, requests
leave the server and can join another queue or exit from the system.

   <p>Service centers for which m_k = \infty are called <em>delay
centers</em> or <em>infinite servers</em>. In this kind of centers, every
request always finds one available server, so queueing never occurs.

   <p>Requests join the queue according to a <em>queueing policy</em>, such as:

     <dl>
<dt><strong>FCFS</strong><dd>First-Come-First-Served

     <br><dt><strong>LCFS-PR</strong><dd>Last-Come-First-Served, Preemptive Resume

     <br><dt><strong>PS</strong><dd>Processor Sharing

     <br><dt><strong>IS</strong><dd>Infinite Server (for which m_k = \infty).

   </dl>

   <p>Queueing models can be <em>open</em> or <em>closed</em>. In open models
there is an infinite population of requests; new customers are
generated outside the system, and eventually leave the system. In
closed systems there is a fixed population of request.

   <p>Queueing models can have a single request class (<em>single class
models</em>), meaning that all requests behave in the same way (e.g., they
spend the same average time on each particular server). In
<em>multiple class models</em> there are multiple request classes, each
one with its own parameters. Furthermore, in multiclass models there
can be open and closed classes of requests within the same system.

   <p>A particular class of QN models, <em>product-form</em> QNs, is of
particular interest. Product-form networks fulfill the following
assumptions:

     <ul>
<li>The network can consist of open and closed job classes.

     <li>The following queueing disciplines are allowed: FCFS, PS, LCFS-PR and IS.

     <li>Service times for FCFS nodes must be exponentially distributed and
class-independent. Service centers at PS, LCFS-PR and IS nodes can
have any kind of service time distribution with a rational Laplace
transform.  Furthermore, for PS, LCFS-PR and IS nodes, different
classes of customers can have different service times.

     <li>The service rate of an FCFS node is only allowed to depend on the
number of jobs at this node; in a PS, LCFS-PR and IS node the service
rate for a particular job class can also depend on the number of jobs
of that class at the node.

     <li>In open networks two kinds of arrival processes are allowed: i) the
arrival process is Poisson, with arrival rate \lambda which can
depend on the number of jobs in the network. ii) the arrival process
consists of U independent Poisson arrival streams where the
U job sources are assigned to the U chains; the arrival
rate can be load dependent.

   </ul>

   <p>Product-form networks are attractive because they be efficiently
analyzed to compute steady-state performance measures.

<!-- Single Class Models -->
<div class="node">
<a name="Single-Class-Models"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Multiple-Class-Models">Multiple Class Models</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-to-QNs">Introduction to QNs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Queueing-Networks">Queueing Networks</a>

</div>

<h3 class="section">5.2 Single Class Models</h3>

<p>In single class models, all requests are indistinguishable and belong
to the same class. This means that every request has the same average
service time, and all requests move through the system with the same
routing probabilities.

<p class="noindent"><strong>Model Inputs</strong>

     <dl>
<dt>lambda_k<dd>(Open models only) External arrival rate to service center k.

     <br><dt>lambda<dd>(Open models only) Overall external arrival rate to the system as a whole: \lambda =
\sum_k \lambda_k.

     <br><dt>N<dd>(Closed models only) Total number of requests in the system.

     <br><dt>S_k<dd>Average service time. S_k is the average service time on service
center k. In other words, S_k is the average time from the
instant in which a request is extracted from the queue and starts being
service, and the instant at which service finishes and the request moves
to another queue (or exits the system).

     <br><dt>P_i, j<dd>Routing probability matrix. \bf P = [P_i, j] is a K
\times K matrix such that P_i, j is the probability that a
request completing service at server i will move directly to
server j, The probability that a request leaves the system
after service at service center i is 1-\sum_j=1^K P_i,
j.

     <br><dt>V_k<dd>Average number of visits. V_k is the average number of visits to
the service center k. This quantity will be described shortly.

   </dl>

<p class="noindent"><strong>Model Outputs</strong>

     <dl>
<dt>U_k<dd>Service center utilization. U_k is the utilization of service
center k. The utilization is defined as the fraction of time in
which the resource is busy (i.e., the server is processing requests).

     <br><dt>R_k<dd>Average response time. R_k is the average response time of
service center k. The average response time is defined as the
average time between the arrival of a customer in the queue, and the
completion of service.

     <br><dt>Q_k<dd>Average number of customers. Q_k is the average number of
requests in service center k. This includes both the requests in
the queue, and the request being served.

     <br><dt>X_k<dd>Throughput. X_k is the throughput of service center k. 
The throughput is defined as the ratio of job completions (i.e., average
number of jobs completed over a fixed interval of time).

   </dl>

<p class="noindent">Given these output parameters, additional performance measures can
be computed as follows:

     <dl>
<dt>X<dd>System throughput, X = X_1 / V_1

     <br><dt>R<dd>System response time, R = \sum_k=1^K R_k V_k

     <br><dt>Q<dd>Average number of requests in the system, Q = \sum_k=1 Q_k; for
closed systems, this can be written as Q = N-XZ;

   </dl>

   <p>For open, single class models, the scalar \lambda denotes the
external arrival rate of requests to the system. The average number of
visits satisfy the following equation:

<pre class="example">                       K
                      ___
                     \
     V_j = P_(0, j) + &gt;   V_i P_(i, j)    j=1,...,K
                     /___
                      i=1
</pre>
   <p class="noindent">where P_0, j is the probability that an external
arrival goes to service center j. If \lambda_j is the
external arrival rate to service center j, and \lambda =
\sum_j \lambda_j is the overall external arrival rate, then
P_0, j = \lambda_j / \lambda.

   <p>For closed models, the visit ratios satisfy the following equation:

<pre class="example">     /
     |         K
     |        ___
     |       \
     | V_j =  &gt;   V_i P_(i, j)     j=1,...,K
     |       /___
     |        i=1
     |
     | V_r = 1                     for a selected reference station r
     \
</pre>
   <p>Note that the set of traffic equations V_j = \sum_i=1^K V_i
P_i, j alone can only be solved up to a multiplicative constant; to
get a unique solution we impose an additional constraint V_r =
1. This constraint is equivalent to defining station r as the
<em>reference station</em> (the default is r=1,
See <a href="#doc_002dqncsvisits">doc-qncsvisits</a>). A job that returns to the reference station is
assumed to have completed its activity cycle. The network throughput
is set to the throughput of the reference station.

   <p><a name="doc_002dqncsvisits"></a>

<div class="defun">
&mdash; Function File: <var>V</var> = <b>qncsvisits</b> (<var>P</var>)<var><a name="index-qncsvisits-122"></a></var><br>
&mdash; Function File: <var>V</var> = <b>qncsvisits</b> (<var>P, r</var>)<var><a name="index-qncsvisits-123"></a></var><br>
<blockquote>
        <p>Compute the mean number of visits to the service centers of a
single class, closed network with K service centers.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>P</var><dd><var>P</var><code>(i,j)</code> is the probability that a request which completed
service at center i is routed to center j. For closed
networks it must hold that <code>sum(</code><var>P</var><code>,2)==1</code>. The routing
graph must be strongly connected, meaning that each node must be
reachable from every other node.

          <br><dt><var>r</var><dd>Index of the reference station, r \in {1, <small class="dots">...</small>, K};
Default <var>r</var><code>=1</code>. The traffic equations are solved by
imposing the condition <var>V</var><code>(r) = 1</code>. A request returning to
the reference station completes its activity cycle.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>V</var><dd><var>V</var><code>(i)</code> is the average number of visits to service center
i, assuming center r as the reference station.

        </dl>

        </blockquote></div>

   <p><a name="doc_002dqnosvisits"></a>

<div class="defun">
&mdash; Function File: <var>V</var> = <b>qnosvisits</b> (<var>P, lambda</var>)<var><a name="index-qnosvisits-124"></a></var><br>
<blockquote>
        <p>Compute the average number of visits to the service centers of a single
class open Queueing Network with K service centers.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>P</var><dd><var>P</var><code>(i,j)</code> is the probability that a request which completed
service at center i is routed to center j.

          <br><dt><var>lambda</var><dd><var>lambda</var><code>(i)</code> is the external arrival rate to
center i.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>V</var><dd><var>V</var><code>(i)</code> is the average number of
visits to server i.

        </dl>

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

   <div class="float">
<a name="fig_003aqn_005fclosed_005fsingle"></a><div align="center"><img src="qn_closed_single.png" alt="qn_closed_single.png"></div>
   <p><strong class="float-caption">Figure 5.1: Closed network with a single class of requests</strong></p></div>

   <p><a href="#fig_003aqn_005fclosed_005fsingle">Figure 5.1</a> shows a closed QN with a single class of
requests. The network has three service centers, labeled <em>CPU</em>,
<em>Disk1</em>, <em>Disk2</em>. and represents the so called <em>central
server</em> model of a computer system. Requests spend some time at the
CPU, which is represented by a PS (Processor Sharing) node. After
that, requests are routed to node Disk1 with probability 0.3,
and to node Disk2 with probability 0.7. Both Disk1 and Disk2
are modeled as FCFS nodes.

   <p>If we enumerate the servers as CPU=1, Disk1=2, Disk2=3, we can define
the routing matrix as follows:

<pre class="example">         / 0  0.3  0.7 \
     P = | 1  0    0   |
         \ 1  0    0   /
</pre>
   <p>The visit ratios V using station 1 as the reference
station can be computed with:

<pre class="example"><pre class="verbatim">      P = [0 0.3 0.7; \
           1 0   0  ; \
           1 0   0  ];
      V = qncsvisits(P)
</pre>
        &rArr; V = 1.00000   0.30000   0.70000
</pre>
   <p class="noindent"><strong>EXAMPLE</strong>

   <div class="float">
<a name="fig_003aqn_005fopen_005fsingle"></a><div align="center"><img src="qn_open_single.png" alt="qn_open_single.png"></div>
   <p><strong class="float-caption">Figure 5.2: Open Queueing Network with a single class of requests</strong></p></div>

   <p><a href="#fig_003aqn_005fopen_005fsingle">Figure 5.2</a> shows a open QN with a single class of
requests. The network has the same structure as the one in
<a href="#fig_003aqn_005fclosed_005fsingle">Figure 5.1</a>, with the difference that here we have a
stream of jobs arriving from outside the system, at a rate
\lambda. After service completion at the CPU, a job can leave
the system with probability 0.2, or be transferred to other nodes with
the probabilities shown in the figure.

   <p>The routing matrix of this network is

<pre class="example">         / 0  0.3  0.5 \
     P = | 1  0    0   |
         \ 1  0    0   /
</pre>
   <p>If we let \lambda = 1.2, we can compute the visit ratios
V as follows:

<pre class="example"><pre class="verbatim">      p = 0.3;
      lambda = 1.2
      P = [0 0.3 0.5; \
           1 0   0  ; \
           1 0   0  ];
      V = qnosvisits(P,[1.2 0 0])
</pre>
        &rArr; V = 5.0000   1.5000   2.5000
</pre>
   <p>Function <samp><span class="command">qnosvisits</span></samp> expects a vector with K elements
as a second parameter, for open networks only. The vector contains the
arrival rates at each individual node; since in our example external
arrivals exist only for node S_1 with rate \lambda =
1.2, the second parameter is <code>[1.2, 0, 0]</code>.

<!-- Open Networks -->
<h4 class="subsection">5.2.1 Open Networks</h4>

<p>Jackson networks satisfy the following conditions:

     <ul>
<li>There is only one job class in the network; the overall number of jobs
in the system is unlimited.

     <li>There are N service centers in the network. Each service center
may have Poisson arrivals from outside the system. A job can leave
the system from any node.

     <li>Arrival rates as well as routing probabilities are independent from
the number of nodes in the network.

     <li>External arrivals and service times at the service centers are
exponentially distributed, and in general can be load-dependent.

     <li>Service discipline at each node is FCFS

   </ul>

   <p>We define the <em>joint probability vector</em> \pi(k_1, k_2,
\ldots, k_N) as the steady-state probability that there are k_i
requests at service center i, for all i=1, 2, \ldots, N. 
Jackson networks have the property that the joint probability is the
product of the marginal probabilities \pi_i:

<pre class="example">     <var>joint_prob</var> = prod( <var>pi</var> )
</pre>
   <p class="noindent">where \pi_i(k_i) is the steady-state probability
that there are k_i requests at service center i.

   <p><a name="doc_002dqnos"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnos</b> (<var>lambda, S, V</var>)<var><a name="index-qnos-125"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnos</b> (<var>lambda, S, V, m</var>)<var><a name="index-qnos-126"></a></var><br>
<blockquote>
        <p><a name="index-open-network_002c-single-class-127"></a><a name="index-BCMP-network-128"></a>
Analyze open, single class BCMP queueing networks.

        <p>This function works for a subset of BCMP single-class open networks
satisfying the following properties:

          <ul>
<li>The allowed service disciplines at network nodes are: FCFS,
PS, LCFS-PR, IS (infinite server);

          <li>Service times are exponentially distributed and
load-independent;

          <li>Service center i can consist of <var>m</var><code>(i) &ge; 1</code>
identical servers.

          <li>Routing is load-independent

        </ul>

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Overall external arrival rate (<var>lambda</var><code>&gt;0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the average service time at center
i (<var>S</var><code>(k)&gt;0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the average number of visits to center
k (<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center i. If
<var>m</var><code>(k) &lt; 1</code>, enter k is a delay center (IS);
otherwise it is a regular queueing center with <var>m</var><code>(k)</code>
servers. Default is <var>m</var><code>(k) = 1</code> for all k.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If k is a queueing center,
<var>U</var><code>(k)</code> is the utilization of center k. 
If k is an IS node, then <var>U</var><code>(k)</code> is the
<em>traffic intensity</em> defined as <var>X</var><code>(k)*</code><var>S</var><code>(k)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the average response time of center k.

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of requests at center
k.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of center k.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnopen,qnclosed,qnosvisits.

        </blockquote></div>

   <p>From the results computed by this function, it is possible to derive
other quantities of interest as follows:

     <ul>
<li><strong>System Response Time</strong>: The overall system response time
can be computed as
<code>R_s = dot(V,R);</code>

     <li><strong>Average number of requests</strong>: The average number of requests
in the system can be computed as:
<code>Q_s = sum(Q)</code>

   </ul>

<p class="noindent"><strong>EXAMPLE</strong>

<pre class="example"><pre class="verbatim">      lambda = 3;
      V = [16 7 8];
      S = [0.01 0.02 0.03];
      [U R Q X] = qnos( lambda, S, V );
      R_s = dot(R,V) # System response time
      N = sum(Q) # Average number in system
</pre>
     -| R_s =  1.4062
     -| N =  4.2186
</pre>
   <p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Bolch, S. Greiner, H. de Meer and K. Trivedi, <cite>Queueing
Networks and Markov Chains: Modeling and Performance Evaluation with
Computer Science Applications</cite>, Wiley, 1998.

   <p><a name="index-Bolch_002c-G_002e-129"></a><a name="index-Greiner_002c-S_002e-130"></a><a name="index-de-Meer_002c-H_002e-131"></a><a name="index-Trivedi_002c-K_002e-132"></a>
<!-- Closed Networks -->

<h4 class="subsection">5.2.2 Closed Networks</h4>

<p><a name="doc_002dqncsmva"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] = <b>qncsmva</b> (<var>N, S, V</var>)<var><a name="index-qncsmva-133"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] = <b>qncsmva</b> (<var>N, S, V, m</var>)<var><a name="index-qncsmva-134"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] = <b>qncsmva</b> (<var>N, S, V, m, Z</var>)<var><a name="index-qncsmva-135"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029-136"></a><a name="index-closed-network_002c-single-class-137"></a><a name="index-normalization-constant-138"></a>
Analyze closed, single class queueing networks using the exact Mean Value Analysis (MVA) algorithm.

        <p>The following queueing disciplines are supported: FCFS, LCFS-PR, PS
and IS (Infinite Server). This function supports fixed-rate service
centers or multiple server nodes. For general load-dependent service
centers, use the function <code>qncsmvald</code> instead.

        <p>Additionally, the normalization constant G(n), n=0,
<small class="dots">...</small>, N is computed; G(n) can be used in conjunction with
the BCMP theorem to compute steady-state probabilities.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Population size (number of requests in the system, <var>N</var><code> &ge; 0</code>). 
If <var>N</var><code> == 0</code>, this function returns
<var>U</var><code> = </code><var>R</var><code> = </code><var>Q</var><code> = </code><var>X</var><code> = 0</code>

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the mean service time at center k
(<var>S</var><code>(k) &ge; 0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the average number of visits to service center
k (<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>Z</var><dd>External delay for customers (<var>Z</var><code> &ge; 0</code>). Default is 0.

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center k
(if <var>m</var> is a scalar, all centers have that number of servers). If
<var>m</var><code>(k) &lt; 1</code>, center k is a delay center (IS);
otherwise it is a regular queueing center (FCFS, LCFS-PR or PS) with
<var>m</var><code>(k)</code> servers. Default is <var>m</var><code>(k) = 1</code> for all
k (each service center has a single server).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If k is a FCFS, LCFS-PR or PS node (<var>m</var><code>(k) == 1</code>),
then <var>U</var><code>(k)</code> is the utilization of center k. If
k is an IS node (<var>m</var><code>(k) &lt; 1</code>), then
<var>U</var><code>(k)</code> is the <em>traffic intensity</em> defined as
<var>X</var><code>(k)*</code><var>S</var><code>(k)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the response time at center k. 
The <em>Residence Time</em> at center k is
<var>R</var><code>(k) * </code><var>V</var><code>(k)</code>. 
The system response time <var>Rsys</var>
can be computed either as <var>Rsys</var><code> = </code><var>N</var><code>/</code><var>Xsys</var><code> - Z</code>
or as <var>Rsys</var><code> = dot(</code><var>R</var><code>,</code><var>V</var><code>)</code>

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of requests at center
k. The number of requests in the system can be computed
either as <code>sum(</code><var>Q</var><code>)</code>, or using the formula
<var>N</var><code>-</code><var>Xsys</var><code>*</code><var>Z</var>.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of center k. The
system throughput <var>Xsys</var> can be computed as
<var>Xsys</var><code> = </code><var>X</var><code>(1) / </code><var>V</var><code>(1)</code>

          <br><dt><var>G</var><dd>Normalization constants. <var>G</var><code>(n+1)</code> corresponds to the value
of the normalization constant G(n), n=0, <small class="dots">...</small>, N as
array indexes in Octave start from 1. G(n) can be used in
conjunction with the BCMP theorem to compute steady-state
probabilities.

        </dl>

        <blockquote>
<b>Note:</b> In presence of load-dependent servers (i.e., if <var>m</var><code>(i)&gt;1</code>
for some i), the MVA algorithm is known to be numerically
unstable. Generally this problem manifests itself as negative
response times produced by this function. 
</blockquote>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qncsmvald,qncscmva.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">M. Reiser and S. S. Lavenberg, <cite>Mean-Value Analysis of Closed
Multichain Queuing Networks</cite>, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313&ndash;322. <a href="http://doi.acm.org/10.1145/322186.322195">10.1145/322186.322195</a>

   <p><a name="index-Reiser_002c-M_002e-139"></a><a name="index-Lavenberg_002c-S_002e-S_002e-140"></a>
This implementation is described in R. Jain , <cite>The Art of
Computer Systems Performance Analysis</cite>, Wiley, 1991, p. 577. 
Multi-server nodes are treated according to G. Bolch, S. Greiner,
H. de Meer and K. Trivedi, <cite>Queueing Networks and Markov Chains:
Modeling and Performance Evaluation with Computer Science
Applications</cite>, Wiley, 1998, Section 8.2.1, "Single Class Queueing
Networks".

   <p><a name="index-Jain_002c-R_002e-141"></a><a name="index-Bolch_002c-G_002e-142"></a><a name="index-Greiner_002c-S_002e-143"></a><a name="index-de-Meer_002c-H_002e-144"></a><a name="index-Trivedi_002c-K_002e-145"></a>
<strong>EXAMPLE</strong>

<pre class="example"><pre class="verbatim">      S = [ 0.125 0.3 0.2 ];
      V = [ 16 10 5 ];
      N = 20;
      m = ones(1,3);
      Z = 4;
      [U R Q X] = qncsmva(N,S,V,m,Z);
      X_s = X(1)/V(1); # System throughput
      R_s = dot(R,V); # System response time
      printf("\t    Util      Qlen     RespT      Tput\n");
      printf("\t--------  --------  --------  --------\n");
      for k=1:length(S)
        printf("Dev%d\t%8.4f  %8.4f  %8.4f  %8.4f\n", k, U(k), Q(k), R(k), X(k) );
      endfor
      printf("\nSystem\t          %8.4f  %8.4f  %8.4f\n\n", N-X_s*Z, R_s, X_s );
</pre>
</pre>
   <!-- MVA for single class, closed networks with load dependent servers -->
   <p><a name="doc_002dqncsmvald"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncsmvald</b> (<var>N, S, V</var>)<var><a name="index-qncsmvald-146"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncsmvald</b> (<var>N, S, V, Z</var>)<var><a name="index-qncsmvald-147"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029-148"></a><a name="index-MVA-149"></a><a name="index-closed-network_002c-single-class-150"></a><a name="index-load_002ddependent-service-center-151"></a>
Exact MVA algorithm for closed, single class queueing networks
with load-dependent service centers. This function supports
FCFS, LCFS-PR, PS and IS nodes. For networks with only fixed-rate
service centers and multiple-server nodes, the function
<code>qncsmva</code> is more efficient.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Population size (number of requests in the system, <var>N</var><code> &ge; 0</code>). 
If <var>N</var><code> == 0</code>, this function returns <var>U</var><code> = </code><var>R</var><code> = </code><var>Q</var><code> = </code><var>X</var><code> = 0</code>

          <br><dt><var>S</var><dd><var>S</var><code>(k,n)</code> is the mean service time at center k
where there are n requests, 1 &le; n
&le; N. <var>S</var><code>(k,n)</code> = 1 / \mu_k,n,
where \mu_k,n is the service rate of center k
when there are n requests.

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the average number
of visits to service center k (<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>Z</var><dd>external delay ("think time", <var>Z</var><code> &ge; 0</code>); default 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(k)</code> is the utilization of service center k. The
utilization is defined as the probability that service center
k is not empty, that is, U_k = 1-\pi_k(0) where
\pi_k(0) is the steady-state probability that there are 0
jobs at service center k.

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the response time on service center k.

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of requests in service center
k.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of service center k.

        </dl>

        <blockquote>
<b>Note:</b> In presence of load-dependent servers,
the MVA algorithm is known to be numerically
unstable. Generally this problem manifests itself as negative
response times produced by this function. 
</blockquote>

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">M. Reiser and S. S. Lavenberg, <cite>Mean-Value Analysis of Closed
Multichain Queuing Networks</cite>, Journal of the ACM, vol. 27, n. 2,
April 1980, pp. 313&ndash;322. <a href="http://doi.acm.org/10.1145/322186.322195">10.1145/322186.322195</a>

   <p>This implementation is described in G. Bolch, S. Greiner, H. de Meer
and K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling
and Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998, Section 8.2.4.1, &ldquo;Networks with Load-Dependent Service: Closed
Networks&rdquo;.

   <p><a name="index-Bolch_002c-G_002e-152"></a><a name="index-Greiner_002c-S_002e-153"></a><a name="index-de-Meer_002c-H_002e-154"></a><a name="index-Trivedi_002c-K_002e-155"></a>
<!-- CMVA for single class, closed networks with a single load dependent servers -->
<a name="doc_002dqncscmva"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncscmva</b> (<var>N, S, Sld, V</var>)<var><a name="index-qncscmva-156"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncscmva</b> (<var>N, S, Sld, V, Z</var>)<var><a name="index-qncscmva-157"></a></var><br>
<blockquote>
        <p><a name="index-conditional-MVA-_0028CMVA_0029-158"></a><a name="index-Mean-Value-Analysis_002c-conditional-_0028CMVA_0029-159"></a><a name="index-closed-network_002c-single-class-160"></a><a name="index-CMVA-161"></a>
This is the implementation of the original Conditional MVA (CMVA)
algorithm, a numerically stable variant of MVA, as described in G. 
Casale, <cite>A Note on Stable Flow-Equivalent Aggregation in Closed
Networks</cite>. This function supports a network of M &ge; 1
service centers and a single delay center. Servers 1, <small class="dots">...</small>,
M-1 are load-independent; server M is load-dependent.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Number of requests in the system, <var>N</var><code> &ge; 0</code>. If
<var>N</var><code> == 0</code>, this function returns <var>U</var><code> = </code><var>R</var><code> =
</code><var>Q</var><code> = </code><var>X</var><code> = 0</code>

          <br><dt><var>S</var><dd>Vector of mean service times for load-independent (fixed rate) servers. 
Specifically, <var>S</var><code>(k)</code> is the mean service time on server
k = 1, <small class="dots">...</small>, M-1 (<var>S</var><code>(k) &gt; 0</code>). If there are no
fixed-rate servers, then <code>S = []</code>

          <br><dt><var>Sld</var><dd><var>Sld</var><code>(n)</code> is the inverse service rate at server M
(the load-dependent server) when there are n requests,
n=1, <small class="dots">...</small>, N. <var>Sld</var><code>(n) = </code> 1 / \mu(n).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the average number of visits to service center
k=1, <small class="dots">...</small>, M, where <var>V</var><code>(k) &ge; 0</code>. 
<var>V</var><code>(1:M-1)</code> are the visit rates to the fixed rate servers;
<var>V</var><code>(M)</code> is the visit rate to the load dependent server.

          <br><dt><var>Z</var><dd>External delay for customers (<var>Z</var><code> &ge; 0</code>). Default is 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(k)</code> is the utilization of center k (k=1, <small class="dots">...</small>, M)

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the response time of center k, (k=1,
<small class="dots">...</small>, M). The system response time <var>Rsys</var> can be computed as
<var>Rsys</var><code> = </code><var>N</var><code>/</code><var>Xsys</var><code> - Z</code>

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of requests at center k, (k=1, <small class="dots">...</small>, M).

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of center k, (k=1, <small class="dots">...</small>, M).

        </dl>

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Casale. <cite>A note on stable flow-equivalent aggregation in
closed networks</cite>. Queueing Syst. Theory Appl., 60:193-202, December
2008, <a href="http://dx.doi.org/10.1007/s11134-008-9093-6">10.1007/s11134-008-9093-6</a>

   <p><a name="index-Casale_002c-G_002e-162"></a>
<!-- Approximate MVA for single class, closed networks -->

   <p><a name="doc_002dqncsmvaap"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncsmvaap</b> (<var>N, S, V</var>)<var><a name="index-qncsmvaap-163"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncsmvaap</b> (<var>N, S, V, m</var>)<var><a name="index-qncsmvaap-164"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncsmvaap</b> (<var>N, S, V, m, Z</var>)<var><a name="index-qncsmvaap-165"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncsmvaap</b> (<var>N, S, V, m, Z, tol</var>)<var><a name="index-qncsmvaap-166"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncsmvaap</b> (<var>N, S, V, m, Z, tol, iter_max</var>)<var><a name="index-qncsmvaap-167"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029_002c-approximate-168"></a><a name="index-MVA_002c-approximate-169"></a><a name="index-approximate-MVA-170"></a><a name="index-closed-network_002c-single-class-171"></a><a name="index-closed-network_002c-approximate-analysis-172"></a>
Analyze closed, single class queueing networks using the Approximate
Mean Value Analysis (MVA) algorithm. This function is based on
approximating the number of customers seen at center k when a
new request arrives as Q_k(N) \times (N-1)/N. This function
only handles single-server and delay centers; if your network
contains general load-dependent service centers, use the function
<code>qncsmvald</code> instead.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Population size (number of requests in the system, <var>N</var><code> &gt; 0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the mean service time on server k
(<var>S</var><code>(k)&gt;0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the average number of visits to service center
k (<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center k
(if <var>m</var> is a scalar, all centers have that number of servers). If
<var>m</var><code>(k) &lt; 1</code>, center k is a delay center (IS); if
<var>m</var><code>(k) == 1</code>, center k is a regular queueing
center (FCFS, LCFS-PR or PS) with one server (default). This function
does not support multiple server nodes (<var>m</var><code>(k) &gt; 1</code>).

          <br><dt><var>Z</var><dd>External delay for customers (<var>Z</var><code> &ge; 0</code>). Default is 0.

          <br><dt><var>tol</var><dd>Stopping tolerance. The algorithm stops when the maximum relative difference
between the new and old value of the queue lengths <var>Q</var> becomes
less than the tolerance. Default is 10^-5.

          <br><dt><var>iter_max</var><dd>Maximum number of iterations (<var>iter_max</var><code>&gt;0</code>. 
The function aborts if convergenge is not reached within the maximum
number of iterations. Default is 100.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If k is a FCFS, LCFS-PR or PS node (<var>m</var><code>(k) == 1</code>),
then <var>U</var><code>(k)</code> is the utilization of center k. If
k is an IS node (<var>m</var><code>(k) &lt; 1</code>), then
<var>U</var><code>(k)</code> is the <em>traffic intensity</em> defined as
<var>X</var><code>(k)*</code><var>S</var><code>(k)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the response time at center k. 
The system response time <var>Rsys</var>
can be computed as <var>Rsys</var><code> = </code><var>N</var><code>/</code><var>Xsys</var><code> - Z</code>

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of requests at center
k. The number of requests in the system can be computed
either as <code>sum(</code><var>Q</var><code>)</code>, or using the formula
<var>N</var><code>-</code><var>Xsys</var><code>*</code><var>Z</var>.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of center k. The
system throughput <var>Xsys</var> can be computed as
<var>Xsys</var><code> = </code><var>X</var><code>(1) / </code><var>V</var><code>(1)</code>

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qncsmva,qncsmvald.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>This implementation is based on Edward D. Lazowska, John Zahorjan,
G. Scott Graham, and Kenneth C. Sevcik, <cite>Quantitative System
Performance: Computer System Analysis Using Queueing Network Models</cite>,
Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 6.4.2.2 ("Approximate Solution Techniques").

   <p><a name="index-Lazowska_002c-E_002e-D_002e-173"></a><a name="index-Zahorjan_002c-J_002e-174"></a><a name="index-Graham_002c-G_002e-S_002e-175"></a><a name="index-Sevcik_002c-K_002e-C_002e-176"></a>
<!-- Convolution -->

   <p>According to the BCMP theorem, the state probability of a closed
single class queueing network with K nodes and N requests
can be expressed as:

<pre class="example">     k = [k1, k2, ... kn]; <span class="roman">population vector</span>
     p = 1/G(N+1) \prod F(i,k);
</pre>
   <p>Here \pi(k_1, k_2, \ldots, k_K) is the joint probability of
having k_i requests at node i, for all i=1, 2,
\ldots, K.

   <p>The <em>convolution algorithms</em> computes the normalization constants
\bf G = \left(G(0), G(1), \ldots, G(N)\right) for single-class, closed networks
with N requests.  The normalization constants are returned as
vector <var>G</var><code>=[</code><var>G</var><code>(1), </code><var>G</var><code>(2), ... </code><var>G</var><code>(N+1)]</code> where
<var>G</var><code>(i+1)</code> is the value of G(i) (remember that Octave
uses 1-base vectors). The normalization constant can be used to
compute all performance measures of interest (utilization, average
response time and so on).

   <p><samp><span class="command">queueing</span></samp> implements the convolution algorithm, in the function
<samp><span class="command">qncsconv</span></samp> and <samp><span class="command">qncsconvld</span></samp>. The first one
supports single-station nodes, multiple-station nodes and IS nodes. 
The second one supports networks with general load-dependent service
centers.

   <p><a name="doc_002dqncsconv"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] = <b>qncsconv</b> (<var>N, S, V</var>)<var><a name="index-qncsconv-177"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] = <b>qncsconv</b> (<var>N, S, V, m</var>)<var><a name="index-qncsconv-178"></a></var><br>
<blockquote>
        <p><a name="index-closed-network_002c-single-class-179"></a><a name="index-normalization-constant-180"></a><a name="index-convolution-algorithm-181"></a>
Analyze product-form, single class closed networks using the convolution algorithm.

        <p>Load-independent service centers, multiple servers (M/M/m
queues) and IS nodes are supported. For general load-dependent
service centers, use <code>qncsconvld</code> instead.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Number of requests in the system (<var>N</var><code>&gt;0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the average service time on center k
(<var>S</var><code>(k) &ge; 0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the visit count of service center k
(<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center
k. If <var>m</var><code>(k) &lt; 1</code>, center k is a delay center (IS);
if <var>m</var><code>(k) &ge; 1</code>, center k
it is a regular M/M/m queueing center with <var>m</var><code>(k)</code>
identical servers. Default is <var>m</var><code>(k) = 1</code> for all k.

        </dl>

        <p><strong>OUTPUT</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(k)</code> is the utilization of center k. 
For IS nodes, <var>U</var><code>(k)</code> is the <em>traffic intensity</em>.

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the average response time of center k.

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of customers at center
k.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of center k.

          <br><dt><var>G</var><dd>Vector of normalization constants. <var>G</var><code>(n+1)</code> contains the value of
the normalization constant with n requests
G(n), n=0, <small class="dots">...</small>, N.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qncsconvld.

        </blockquote></div>

<p class="noindent"><strong>NOTE</strong>

   <p>For a network with K service centers and N requests,
this implementation of the convolution algorithm has time and space
complexity O(NK).

<p class="noindent"><strong>REFERENCES</strong>

   <p>Jeffrey P. Buzen, <cite>Computational Algorithms for Closed Queueing
Networks with Exponential Servers</cite>, Communications of the ACM, volume
16, number 9, september 1973,
pp. 527&ndash;531. <a href="http://doi.acm.org/10.1145/362342.362345">10.1145/362342.362345</a>

   <p><a name="index-Buzen_002c-J_002e-P_002e-182"></a>
This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998, pp. 313&ndash;317.

   <p><a name="index-Bolch_002c-G_002e-183"></a><a name="index-Greiner_002c-S_002e-184"></a><a name="index-de-Meer_002c-H_002e-185"></a><a name="index-Trivedi_002c-K_002e-186"></a>
<strong>EXAMPLE</strong>

   <p>The normalization constant G can be used to compute the
steady-state probabilities for a closed single class product-form
Queueing Network with K nodes. Let <var>k</var><code>=[k_1,
k_2, ..., k_K]</code> be a valid population vector. Then, the
steady-state probability <var>p</var><code>(i)</code> to have <var>k</var><code>(i)</code>
requests at service center i can be computed as:

<pre class="example"><pre class="verbatim">      k = [1 2 0];
      K = sum(k); # Total population size
      S = [ 1/0.8 1/0.6 1/0.4 ];
      m = [ 2 3 1 ];
      V = [ 1 .667 .2 ];
      [U R Q X G] = qncsconv( K, S, V, m );
      p = [0 0 0]; # initialize p
      # Compute the probability to have k(i) jobs at service center i
      for i=1:3
        p(i) = (V(i)*S(i))^k(i) / G(K+1) * \
               (G(K-k(i)+1) - V(i)*S(i)*G(K-k(i)) );
        printf("k(%d)=%d prob=%f\n", i, k(i), p(i) );
      endfor
</pre>
     -| k(1)=1 prob=0.17975
     -| k(2)=2 prob=0.48404
     -| k(3)=0 prob=0.52779
</pre>
   <p><a name="doc_002dqncsconvld"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>, <var>G</var>] = <b>qncsconvld</b> (<var>N, S, V</var>)<var><a name="index-qncsconvld-187"></a></var><br>
<blockquote>
        <p><a name="index-closed-network-188"></a><a name="index-normalization-constant-189"></a><a name="index-convolution-algorithm-190"></a><a name="index-load_002ddependent-service-center-191"></a>
This function implements the <em>convolution algorithm</em> for
product-form, single-class closed queueing networks with general
load-dependent service centers.

        <p>This function computes steady-state performance measures for
single-class, closed networks with load-dependent service centers
using the convolution algorithm; the normalization constants are also
computed. The normalization constants are returned as vector
<var>G</var><code>=[</code><var>G</var><code>(1), ..., </code><var>G</var><code>(N+1)]</code> where
<var>G</var><code>(i+1)</code> is the value of G(i).

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Number of requests in the system (<var>N</var><code>&gt;0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(k,n)</code> is the mean service time at center k
where there are n requests, 1 &le; n
&le; N. <var>S</var><code>(k,n)</code> = 1 / \mu_k,n,
where \mu_k,n is the service rate of center k
when there are n requests.

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the visit count of service center k
(<var>V</var><code>(k) &ge; 0</code>). The length of <var>V</var> is the number of
servers K in the network.

        </dl>

        <p><strong>OUTPUT</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(k)</code> is the utilization of center k.

          <br><dt><var>R</var><dd><var>R</var><code>(k)</code> is the average response time at center k.

          <br><dt><var>Q</var><dd><var>Q</var><code>(k)</code> is the average number of customers in center k.

          <br><dt><var>X</var><dd><var>X</var><code>(k)</code> is the throughput of center k.

          <br><dt><var>G</var><dd>Normalization constants (vector). <var>G</var><code>(n+1)</code>
corresponds to G(n), as array indexes in Octave start
from 1.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qncsconv.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">Herb Schwetman, <cite>Some Computational Aspects of Queueing Network
Models</cite>, Technical Report
<a href="http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-354.pdf">CSD-TR-354</a>, Department of Computer Sciences, Purdue University, feb,
1981 (revised).

   <p><a name="index-Schwetman_002c-H_002e-192"></a>
M. Reiser, H. Kobayashi, <cite>On The Convolution Algorithm for
Separable Queueing Networks</cite>, In Proceedings of the 1976 ACM
SIGMETRICS Conference on Computer Performance Modeling Measurement and
Evaluation (Cambridge, Massachusetts, United States, March 29&ndash;31,
1976). SIGMETRICS '76. ACM, New York, NY,
pp. 109&ndash;117. <a href="http://doi.acm.org/10.1145/800200.806187">10.1145/800200.806187</a>

   <p><a name="index-Reiser_002c-M_002e-193"></a><a name="index-Kobayashi_002c-H_002e-194"></a>
This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998, pp. 313&ndash;317. Function <samp><span class="command">qncsconvld</span></samp> is slightly
different from the version described in Bolch et al. because it
supports general load-dependent centers (while the version in the book
does not). The modification is in the definition of function
<code>F()</code> in <samp><span class="command">qncsconvld</span></samp> which has been made similar to
function f_i defined in Schwetman, <cite>Some Computational
Aspects of Queueing Network Models</cite>.

   <p><a name="index-Bolch_002c-G_002e-195"></a><a name="index-Greiner_002c-S_002e-196"></a><a name="index-de-Meer_002c-H_002e-197"></a><a name="index-Trivedi_002c-K_002e-198"></a>

<h4 class="subsection">5.2.3 Non Product-Form QNs</h4>

<p><a name="Non-Product_002dForm-QNs"></a><!-- MVABLO algorithm for approximate analysis of closed, single class -->
<!-- QN with blocking -->
<a name="doc_002dqncsmvablo"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncsmvablo</b> (<var>N, S, M, P </var>)<var><a name="index-qncsmvablo-199"></a></var><br>
<blockquote>
        <p><a name="index-queueing-network-with-blocking-200"></a><a name="index-blocking-queueing-network-201"></a><a name="index-closed-network_002c-finite-capacity-202"></a><a name="index-MVABLO-203"></a>
Approximate MVA algorithm for closed queueing networks with blocking.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>population size, i.e., number of requests in the system. <var>N</var> must
be strictly greater than zero, and less than the overall network capacity:
<code>0 &lt; </code><var>N</var><code> &lt; sum(</code><var>M</var><code>)</code>.

          <br><dt><var>S</var><dd>Average service time. <var>S</var><code>(i)</code> is the average service time
requested on server i (<var>S</var><code>(i) &gt; 0</code>).

          <br><dt><var>M</var><dd><var>M</var><code>(i)</code> is the capacity of center
i. The capacity is the maximum number of requests in a service
center, including the request currently in service (<var>M</var><code>(i) &ge; 1</code>).

          <br><dt><var>P</var><dd><var>P</var><code>(i,j)</code> is the probability that a request which completes
service at server i will be transferred to server j.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(i)</code> is the utilization of
service center i.

          <br><dt><var>R</var><dd><var>R</var><code>(i)</code> is the average response time
of service center i.

          <br><dt><var>Q</var><dd><var>Q</var><code>(i)</code> is
the average number of requests in service center i (including
the request in service).

          <br><dt><var>X</var><dd><var>X</var><code>(i)</code> is the throughput of
service center i.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnopen, qnclosed.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">Ian F. Akyildiz, <cite>Mean Value Analysis for Blocking Queueing
Networks</cite>, IEEE Transactions on Software Engineering, vol. 14, n. 2,
april 1988, pp. 418&ndash;428.  <a href="http://dx.doi.org/10.1109/32.4663">10.1109/32.4663</a>

   <p><a name="index-Akyildiz_002c-I_002e-F_002e-204"></a>
<a name="doc_002dqnmarkov"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnmarkov</b> (<var>lambda, S, C, P</var>)<var><a name="index-qnmarkov-205"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnmarkov</b> (<var>lambda, S, C, P, m</var>)<var><a name="index-qnmarkov-206"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnmarkov</b> (<var>N, S, C, P</var>)<var><a name="index-qnmarkov-207"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnmarkov</b> (<var>N, S, C, P, m</var>)<var><a name="index-qnmarkov-208"></a></var><br>
<blockquote>
        <p><a name="index-closed-network_002c-multiple-classes-209"></a><a name="index-closed-network_002c-finite-capacity-210"></a><a name="index-blocking-queueing-network-211"></a><a name="index-RS-blocking-212"></a>
Compute utilization, response time, average queue length and
throughput for open or closed queueing networks with finite capacity. 
Blocking type is Repetitive-Service (RS). This function explicitly
generates and solve the underlying Markov chain, and thus might
require a large amount of memory.

        <p>More specifically, networks which can me analyzed by this
function have the following properties:

          <ul>
<li>There exists only a single class of customers.

          <li>The network has K service centers. Center
i has m_i &gt; 0 servers, and has a total (finite) capacity of
C_i \geq m_i which includes both buffer space and servers. 
The buffer space at service center i is therefore
C_i - m_i.

          <li>The network can be open, with external arrival rate to
center i equal to
\lambda_i, or closed with fixed
population size N. For closed networks, the population size
N must be strictly less than the network capacity: N &lt; \sum_i C_i.

          <li>Average service times are load-independent.

          <li>P_i, j is the probability that requests completing
execution at center i are transferred to
center j, i \neq j. For open networks, a request may leave the system
from any node i with probability 1-\sum_j P_i, j.

          <li>Blocking type is Repetitive-Service (RS). Service
center j is <em>saturated</em> if the number of requests is equal
to its capacity C_j. Under the RS blocking discipline,
a request completing service at center i which is being
transferred to a saturated server j is put back at the end of
the queue of i and will receive service again. Center i
then processes the next request in queue. External arrivals to a
saturated servers are dropped.

        </ul>

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dt><var>N</var><dd>If the first argument is a vector <var>lambda</var>, it is considered to be
the external arrival rate <var>lambda</var><code>(i) &ge; 0</code> to service center
i of an open network. If the first argument is a scalar, it is
considered as the population size <var>N</var> of a closed network; in this case
<var>N</var> must be strictly
less than the network capacity: <var>N</var><code> &lt; sum(</code><var>C</var><code>)</code>.

          <br><dt><var>S</var><dd><var>S</var><code>(i)</code> is the average service time at service center
i

          <br><dt><var>C</var><dd><var>C</var><code>(i)</code> is the Capacity of service center i. The capacity includes both
the buffer and server space <var>m</var><code>(i)</code>. Thus the buffer space is
<var>C</var><code>(i)-</code><var>m</var><code>(i)</code>.

          <br><dt><var>P</var><dd><var>P</var><code>(i,j)</code> is the transition probability from service center
i to service center j.

          <br><dt><var>m</var><dd><var>m</var><code>(i)</code> is the number of servers at service center
i. Note that <var>m</var><code>(i) &ge; </code><var>C</var><code>(i)</code> for each <var>i</var>. 
If <var>m</var> is omitted, all service centers are assumed to have a
single server (<var>m</var><code>(i) = 1</code> for all i).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(i)</code> is the utilization of service center i.

          <br><dt><var>R</var><dd><var>R</var><code>(i)</code> is the response time on service center i.

          <br><dt><var>Q</var><dd><var>Q</var><code>(i)</code> is the average number of customers in the
service center i, <em>including</em> the request in service.

          <br><dt><var>X</var><dd><var>X</var><code>(i)</code> is the throughput of service center i.

        </dl>

        <blockquote>
<b>Note:</b> 
The space complexity of this implementation is
O( \prod_i=1^K (C_i + 1)^2). The time complexity is dominated
by the time needed to solve a linear system with
\prod_i=1^K (C_i + 1)
unknowns.

        </blockquote>

        </blockquote></div>

<div class="node">
<a name="Multiple-Class-Models"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Generic-Algorithms">Generic Algorithms</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Single-Class-Models">Single Class Models</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Queueing-Networks">Queueing Networks</a>

</div>

<h3 class="section">5.3 Multiple Class Models</h3>

<p>In multiple class QN models, we assume that there exist C
different classes of requests. Each request from class c spends
on average time S_c, k in service at service center
k. For open models, we denote with \bf \lambda =
\lambda_ck the arrival rates, where \lambda_c, k is the
external arrival rate of class c customers at service center
k. For closed models, we denote with \bf N = (N_1, N_2,
\ldots, N_C) the population vector, where N_c is the number of
class c requests in the system.

   <p>The transition probability matrix for these kind of networks will be a
C \times K \times C \times K matrix \bf P = [P_r, i, s, j]
such that P_r, i, s, j is the probability that a class
r request which completes service at center i will join
server j as a class s request.

   <p>Model input and outputs can be adjusted by adding additional indexes
for the customer classes.

<p class="noindent"><strong>Model Inputs</strong>

     <dl>
<dt>lambda_{c, k}<dd>External arrival rate of class-c requests to service center k

     <br><dt>lambda<dd>Overall external arrival rate to the whole system: \lambda = \sum_c \sum_k \lambda_c, k

     <br><dt>S_c, k<dd>Average service time. S_c, k is the average service time on
service center k for class c requests.

     <br><dt>P_r, i, s, j<dd>Routing probability matrix. \bf P = [P_r, i, s, j] is a C
\times K \times C \times K matrix such that P_r, i, s, j is
the probability that a class r request which completes service
at server i will move to server j as a class s
request.

     <br><dt>V_c, k<dd>Average number of visits. V_c, k is the average number of visits
of class c requests to center k.

   </dl>

<p class="noindent"><strong>Model Outputs</strong>

     <dl>
<dt>U_c, k<dd>Utilization of service center k by class c requests. The
utilization is defined as the fraction of time in which the resource is
busy (i.e., the server is processing requests).

     <br><dt>R_c, k<dd>Average response time experienced by class c requests on service
center k. The average response time is defined as the average
time between the arrival of a customer in the queue, and the completion
of service.

     <br><dt>Q_c, k<dd>Average number of class c requests on service center
k. This includes both the requests in the queue, and the request
being served.

     <br><dt>X_c, k<dd>Throughput of service center k for class c requests.  The
throughput is defined as the rate of completion of class c
requests.

   </dl>

<p class="noindent">It is possible to define aggregate performance measures as follows:

     <dl>
<dt>U_k<dd>Utilization of service center k:
<code>Uk = sum(U,k);</code>

     <br><dt>R_c<dd>System response time for class c requests:
<code>Rc = sum( V.*R, 1 );</code>

     <br><dt>Q_c<dd>Average number of class c requests in the system:
<code>Qc = sum( Q, 2 );</code>

     <br><dt>X_c<dd>Class c throughput:
<code>Xc = X(:,1) ./ V(:,1);</code>

   </dl>

   <p>We can define the visit ratios V_s, j for class s
customers at service center j as follows:

   <p>V_sj = sum_r sum_i V_ri P_risj    s=1,...,C, j=1,...,K
V_s r_s = 1                       s=1,...,C

<p class="noindent">where r_s is the class s
reference station. Similarly to single class models, the traffic
equation for closed multiclass networks can be solved up to
multiplicative constants unless we choose one reference station for
each closed chain class and set its visit ratio to 1.

   <p>For open networks the traffic equations are as follows:

   <p>V_sj = P_0sj + sum_r sum_i V_ri P_risj  s=1,...,K, j=1,...,K

<p class="noindent">where P_0, s, j is the probability that an external
arrival goes to service center j as a class-s request. 
If \lambda_s, j is the external arrival rate of class
s requests to service center j, and \lambda =
\sum_s \sum_j \lambda_s, j is the overall external arrival rate to
the whole system, then P_0, s, j = \lambda_s, j / \lambda.

   <p><a name="doc_002dqncmvisits"></a>

<div class="defun">
&mdash; Function File: [<var>V</var> <var>ch</var>] = <b>qncmvisits</b> (<var>P</var>)<var><a name="index-qncmvisits-213"></a></var><br>
&mdash; Function File: [<var>V</var> <var>ch</var>] = <b>qncmvisits</b> (<var>P, r</var>)<var><a name="index-qncmvisits-214"></a></var><br>
<blockquote>
        <p>Compute the average number of visits to the service centers of a closed multiclass network with K service centers and C customer classes.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>P</var><dd><var>P</var><code>(r,i,s,j)</code> is the probability that a
class r request which completed service at center i is
routed to center j as a class s request. Class switching
is allowed.

          <br><dt><var>r</var><dd><var>r</var><code>(c)</code> is the index of class c reference station,
r(c) \in {1, <small class="dots">...</small>, K}, c \in {1, \<small class="dots">...</small>, C}. 
The class c visit count to server <var>r</var><code>(c)</code>
(<var>V</var><code>(c,r(c))</code>) is conventionally set to 1. The reference
station serves two purposes: (i) its throughput is assumed to be the
system throughput, and (ii) a job returning to the reference station
is assumed to have completed one cycle. Default is to consider
station 1 as the reference station for all classes.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>V</var><dd><var>V</var><code>(c,i)</code> is the number of visits of class c
requests at center i.

          <br><dt><var>ch</var><dd><var>ch</var><code>(c)</code> is the chain number that class c belongs
to. Different classes can belong to the same chain. Chains are
numbered sequentially starting from 1 (1, 2, <small class="dots">...</small>). The
total number of chains is <code>max(</code><var>ch</var><code>)</code>.

        </dl>

        </blockquote></div>

   <p><a name="doc_002dqnomvisits"></a>

<div class="defun">
&mdash; Function File: <var>V</var> = <b>qnomvisits</b> (<var>P, lambda</var>)<var><a name="index-qnomvisits-215"></a></var><br>
<blockquote>
        <p>Compute the average number of visits to the service centers of an open multiclass network with K service centers and C customer classes.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>P</var><dd><var>P</var><code>(r,i,s,j)</code> is the probability that a
class r request which completed service at center i is
routed to center j as a class s request. Class switching
is supported.

          <br><dt><var>lambda</var><dd><var>lambda</var><code>(r,i)</code> is the arrival rate of class r
requests to center i.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>V</var><dd><var>V</var><code>(r,i)</code> is the number of visits of class r
requests at center i.

        </dl>

        </blockquote></div>

<!-- Open Networks -->
<h4 class="subsection">5.3.1 Open Networks</h4>

<!-- Open network with multiple classes -->
<p><a name="doc_002dqnom"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnom</b> (<var>lambda, S, V</var>)<var><a name="index-qnom-216"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnom</b> (<var>lambda, S, V, m</var>)<var><a name="index-qnom-217"></a></var><br>
<blockquote>
        <p><a name="index-open-network_002c-multiple-classes-218"></a><a name="index-multiclass-network_002c-open-219"></a>
Exact analysis of open, multiple-class BCMP networks. The network can
be made of <em>single-server</em> queueing centers (FCFS, LCFS-PR or
PS) or delay centers (IS). This function assumes a network with
K service centers and C customer classes.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd><var>lambda</var><code>(c)</code> is the external
arrival rate of class c customers (<var>lambda</var><code>(c)&gt;0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(c,k)</code> is the mean service time of class c
customers on the service center k (<var>S</var><code>(c,k)&gt;0</code>). 
For FCFS nodes, mean service times must be class-independent.

          <br><dt><var>V</var><dd><var>V</var><code>(c,k)</code> is the average number of visits of class c
customers to service center k (<var>V</var><code>(c,k) &ge; 0 </code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center i. If
<var>m</var><code>(k) &lt; 1</code>, enter k is a delay center (IS);
otherwise it is a regular queueing center with <var>m</var><code>(k)</code>
servers. Default is <var>m</var><code>(k) = 1</code> for all k.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If k is a queueing center, then <var>U</var><code>(c,k)</code> is the
class c utilization of center k. If k is an IS
node, then <var>U</var><code>(c,k)</code> is the class c <em>traffic
intensity</em> defined as <var>X</var><code>(c,k)*</code><var>S</var><code>(c,k)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(c,k)</code> is the class c response time at center
k. The system response time for class c requests can be
computed as <code>dot(</code><var>R</var><code>, </code><var>V</var><code>, 2)</code>.

          <br><dt><var>Q</var><dd><var>Q</var><code>(c,k)</code> is the average number of class c requests
at center k. The average number of class c requests
in the system <var>Qc</var> can be computed as <code>Qc = sum(</code><var>Q</var><code>, 2)</code>

          <br><dt><var>X</var><dd><var>X</var><code>(c,k)</code> is the class c throughput
at center k.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnopen,qnos,qnomvisits.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C. 
Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 7.4.1 ("Open Model Solution Techniques").

   <p><a name="index-Lazowska_002c-E_002e-D_002e-220"></a><a name="index-Zahorjan_002c-J_002e-221"></a><a name="index-Graham_002c-G_002e-S_002e-222"></a><a name="index-Sevcik_002c-K_002e-C_002e-223"></a>

<h4 class="subsection">5.3.2 Closed Networks</h4>

<p><a name="doc_002dqncmpopmix"></a>

<div class="defun">
&mdash; Function File: pop_mix = <b>qncmpopmix</b> (<var>k, N</var>)<var><a name="index-qncmpopmix-224"></a></var><br>
<blockquote>
        <p><a name="index-population-mix-225"></a><a name="index-closed-network_002c-multiple-classes-226"></a>
Return the set of valid population mixes with exactly <var>k</var>
customers, for a closed multiclass Queueing Network with population
vector <var>N</var>. More specifically, given a multiclass Queueing
Network with C customer classes, such that there are
<var>N</var><code>(i)</code> requests of class i, a
k-mix <var>mix</var> is a C-dimensional vector with the
following properties:

     <pre class="example">          all( mix &gt;= 0 );
          all( mix &lt;= N );
          sum( mix ) == k;
</pre>
        <p class="noindent">This function enumerates all valid k-mixes, such that
<var>pop_mix</var><code>(i)</code> is a C dimensional row vector representing
a valid population mix, for all i.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>k</var><dd>Total population size of the requested mix. <var>k</var> must be a nonnegative integer

          <br><dt><var>N</var><dd><var>N</var><code>(i)</code> is the number of class i requests. 
The condition <var>k</var><code> &le; sum(</code><var>N</var><code>)</code> must hold.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>pop_mix</var><dd><var>pop_mix</var><code>(i,j)</code> is the number of class j requests
in the i-th population mix. The number of
population mixes is <code>rows( </code><var>pop_mix</var><code> ) </code>.

        </dl>

        <p>Note that if you are interested in the number of k-mixes
and you don't care to enumerate them, you can use the funcion
<code>qnmvapop</code>.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qncmnpop.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">Herb Schwetman, <cite>Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models</cite>, Technical Report
<a href="http://www.cs.purdue.edu/research/technical_reports/1980/TR 80-355.pdf">CSD-TR-355</a>,
Department of Computer Sciences, Purdue University, feb 15, 1982,

   <p>Note that the slightly different problem of generating all tuples
k_1, k_2, \ldots, k_N such that \sum_i k_i = k and
k_i are nonnegative integers, for some fixed integer k
&ge; 0 has been described in S. Santini, <cite>Computing the
Indices for a Complex Summation</cite>, unpublished report, available at
<a href="http://arantxa.ii.uam.es/~ssantini/writing/notes/s668_summation.pdf">http://arantxa.ii.uam.es/~ssantini/writing/notes/s668_summation.pdf</a>

   <p><a name="index-Schwetman_002c-H_002e-227"></a><a name="index-Santini_002c-S_002e-228"></a>
<a name="doc_002dqncmnpop"></a>

<div class="defun">
&mdash; Function File: <var>H</var> = <b>qncmnpop</b> (<var>N</var>)<var><a name="index-qncmnpop-229"></a></var><br>
<blockquote>
        <p><a name="index-population-mix-230"></a><a name="index-closed-network_002c-multiple-classes-231"></a>
Given a network with C customer classes, this function
computes the number of valid population mixes <var>H</var><code>(r,n)</code> that can
be constructed by the multiclass MVA algorithm by allocating n
customers to the first r classes.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Population vector. <var>N</var><code>(c)</code> is the number of class-c
requests in the system. The total number of requests in the network
is <code>sum(</code><var>N</var><code>)</code>.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>H</var><dd><var>H</var><code>(r,n)</code> is the number of valid populations that can be
constructed allocating n customers to the first r classes.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qncmmva,qncmpopmix.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">Zahorjan, J. and Wong, E. <cite>The solution of separable queueing
network models using mean value analysis</cite>. SIGMETRICS
Perform. Eval. Rev. 10, 3 (Sep. 1981), 80-85. DOI
<a href="http://doi.acm.org/10.1145/1010629.805477">10.1145/1010629.805477</a>

   <p><a name="index-Zahorjan_002c-J_002e-232"></a><a name="index-Wong_002c-E_002e-233"></a>
<!-- MVA for multiple class, closed networks -->
<a name="doc_002dqncmmva"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmmva</b> (<var>N, S </var>)<var><a name="index-qncmmva-234"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmmva</b> (<var>N, S, V</var>)<var><a name="index-qncmmva-235"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmmva</b> (<var>N, S, V, m</var>)<var><a name="index-qncmmva-236"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmmva</b> (<var>N, S, V, m, Z</var>)<var><a name="index-qncmmva-237"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmmva</b> (<var>N, S, P</var>)<var><a name="index-qncmmva-238"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmmva</b> (<var>N, S, P, r</var>)<var><a name="index-qncmmva-239"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmmva</b> (<var>N, S, P, r, m</var>)<var><a name="index-qncmmva-240"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029-241"></a><a name="index-closed-network_002c-multiple-classes-242"></a><a name="index-multiclass-network_002c-closed-243"></a>
Compute steady-state performance measures for closed, multiclass
queueing networks using the Mean Value Analysys (MVA) algorithm.

        <p>Queueing policies at service centers can be any of the following:

          <dl>
<dt><strong>FCFS</strong><dd>(First-Come-First-Served) customers are served in order of arrival;
multiple servers are allowed. For this kind of queueing discipline,
average service times must be class-independent.

          <br><dt><strong>PS</strong><dd>(Processor Sharing) customers are served in parallel by a single
server, each customer receiving an equal share of the service rate.

          <br><dt><strong>LCFS-PR</strong><dd>(Last-Come-First-Served, Preemptive Resume) customers are served in
reverse order of arrival by a single server and the last arrival
preempts the customer in service who will later resume service at the
point of interruption.

          <br><dt><strong>IS</strong><dd>(Infinite Server) customers are delayed independently of other
customers at the service center (there is effectively an infinite
number of servers).

        </dl>

        <blockquote>
<b>Note:</b> If this function is called specifying the visit ratios
<var>V</var>, class switching is <strong>not</strong> allowed.

        <p>If this function is called specifying the routing probability matrix
<var>P</var>, then class switching <strong>is</strong> allowed; however, in this
case all nodes are restricted to be fixed rate servers or delay
centers: multiple-server and general load-dependent centers are not
supported. 
</blockquote>

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd><var>N</var><code>(c)</code> is the number of class c requests in the
system; <var>N</var><code>(c) &ge; 0</code>. If class c has
no requests (<var>N</var><code>(c) == 0</code>), then for all <var>k</var>,
<var>U</var><code>(c,k) = </code><var>R</var><code>(c,k) = </code><var>Q</var><code>(c,k) = </code><var>X</var><code>(c,k) = 0</code>

          <br><dt><var>S</var><dd><var>S</var><code>(c,k)</code> is the mean service time for class c
customers at center k (<var>S</var><code>(c,k) &ge; 0</code>). If the
service time at center k is class-dependent, i.e., different
classes have different service times at center k, then center
k is assumed to be of type -/G/1&ndash;PS (Processor
Sharing). 
If center k is a FCFS node (<var>m</var><code>(k)&gt;1</code>), then the
service times <strong>must</strong> be class-independent, i.e., all classes
<strong>must</strong> have the same service time.

          <br><dt><var>V</var><dd><var>V</var><code>(c,k)</code> is the average number of visits of class c
customers to service center k; <var>V</var><code>(c,k) &ge; 0</code>,
default is 1. 
<strong>If you pass this argument, class switching is not
allowed</strong>

          <br><dt><var>P</var><dd><var>P</var><code>(r,i,s,j)</code> is the probability that a class r
job completing service at center i is routed to center j
as a class s job; the reference stations for each class
are specified with the paramter <var>r</var>. 
<strong>If you pass argument </strong><var>P</var><strong>,
class switching is allowed</strong>, but you can not specify any external delay
(i.e., <var>Z</var> must be zero).

          <br><dt><var>r</var><dd><var>r</var><code>(c)</code> is the reference station for class c. 
If omitted, station 1 is the reference station for all classes. 
See <samp><span class="command">qncmvisits</span></samp>.

          <br><dt><var>m</var><dd>If <var>m</var><code>(k)&lt;1</code>, then center k is assumed to be a delay
center (IS node -/G/\infty). If <var>m</var><code>(k)==1</code>, then
service center k is a regular queueing center
(M/M/1&ndash;FCFS, -/G/1&ndash;LCFS-PR or -/G/1&ndash;PS). 
Finally, if <var>m</var><code>(k)&gt;1</code>, center k is a
M/M/m&ndash;FCFS center with <var>m</var><code>(k)</code> identical servers. 
Default is <var>m</var><code>(k)=1</code> for each k.

          <br><dt><var>Z</var><dd><var>Z</var><code>(c)</code> is the class c external delay (think time);
<var>Z</var><code>(c) &ge; 0</code>. Default is 0. This parameter can not be
used if you pass a routing matrix as the second parameter of
<code>qncmmva</code>.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If k is a FCFS, LCFS-PR or PS node, then <var>U</var><code>(c,k)</code>
is the class c utilization at center
k. If k is an IS node, then <var>U</var><code>(c,k)</code> is the
class c <em>traffic intensity</em> at center k,
defined as <var>U</var><code>(c,k) = </code><var>X</var><code>(c,k)*</code><var>S</var><code>(c,k)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(c,k)</code> is the class c response time at
center k. The class c <em>residence time</em>
at center k is <var>R</var><code>(c,k) * </code><var>C</var><code>(c,k)</code>. 
The total class c system response time
is <code>dot(</code><var>R</var><code>, </code><var>V</var><code>, 2)</code>.

          <br><dt><var>Q</var><dd><var>Q</var><code>(c,k)</code> is the average number of
class c requests at center k. The total number of
requests at center k is <code>sum(</code><var>Q</var><code>(:,k))</code>. 
The total number of class c requests in the system
is <code>sum(</code><var>Q</var><code>(c,:))</code>.

          <br><dt><var>X</var><dd><var>X</var><code>(c,k)</code> is the class c throughput at
center k. The class c throughput can be computed
as <var>X</var><code>(c,1) / </code><var>V</var><code>(c,1)</code>.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosed, qncmmvaapprox, qncmvisits.

        </blockquote></div>

<p class="noindent"><strong>NOTE</strong>

   <p>Given a network with K service centers, C job classes
and population vector \bf N=(N_1, N_2, \ldots, N_C), the MVA
algorithm requires space O(C \prod_i (N_i + 1)). The time
complexity is O(CK\prod_i (N_i + 1)). This implementation is
slightly more space-efficient (see details in the code). While the
space requirement can be mitigated by using some optimizations, the
time complexity can not. If you need to analyze large closed networks
you should consider the <samp><span class="command">qncmmvaap</span></samp> function, which implements
the approximate MVA algorithm. Note however that <samp><span class="command">qncmmvaap</span></samp>
will only provide approximate results.

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">M. Reiser and S. S. Lavenberg, <cite>Mean-Value Analysis of Closed
Multichain Queuing Networks</cite>, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313&ndash;322. <a href="http://doi.acm.org/10.1145/322186.322195">10.1145/322186.322195</a>

   <p><a name="index-Reiser_002c-M_002e-244"></a><a name="index-Lavenberg_002c-S_002e-S_002e-245"></a>
This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998 and Edward D. Lazowska, John Zahorjan, G. Scott Graham, and
Kenneth C. Sevcik, <cite>Quantitative System Performance: Computer
System Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 7.4.2.1 ("Exact Solution Techniques").

   <p><a name="index-Bolch_002c-G_002e-246"></a><a name="index-Greiner_002c-S_002e-247"></a><a name="index-de-Meer_002c-H_002e-248"></a><a name="index-Trivedi_002c-K_002e-249"></a><a name="index-Lazowska_002c-E_002e-D_002e-250"></a><a name="index-Zahorjan_002c-J_002e-251"></a><a name="index-Graham_002c-G_002e-S_002e-252"></a><a name="index-Sevcik_002c-K_002e-C_002e-253"></a>
<!-- Approximate MVA, with Bard-Schweitzer approximation -->
<a name="doc_002dqncmmvaap"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmmvaap</b> (<var>N, S, V</var>)<var><a name="index-qncmmvaap-254"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmmvaap</b> (<var>N, S, V, m</var>)<var><a name="index-qncmmvaap-255"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmmvaap</b> (<var>N, S, V, m, Z</var>)<var><a name="index-qncmmvaap-256"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmmvaap</b> (<var>N, S, V, m, Z, tol</var>)<var><a name="index-qncmmvaap-257"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qncmmvaap</b> (<var>N, S, V, m, Z, tol, iter_max</var>)<var><a name="index-qncmmvaap-258"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029_002c-approximate-259"></a><a name="index-MVA_002c-approximate-260"></a><a name="index-closed-network_002c-multiple-classes-261"></a><a name="index-multiclass-network_002c-closed-262"></a>
Analyze closed, multiclass queueing networks with K service
centers and C customer classes using the approximate Mean
Value Analysys (MVA) algorithm.

        <p>This implementation uses Bard and Schweitzer approximation. It is based
on the assumption that
the queue length at service center k with population
set \bf N-\bf 1_c is approximately equal to the queue length
with population set \bf N, times (n-1)/n:

     <pre class="example">          Q_i(N-1c) ~ (n-1)/n Q_i(N)
</pre>
        <p>where \bf N is a valid population mix, \bf N-\bf 1_c
is the population mix \bf N with one class c customer
removed, and n = \sum_c N_c is the total number of requests.

        <p>This implementation works for networks made of infinite server (IS)
nodes and single-server nodes only.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd><var>N</var><code>(c)</code> is the number of
class c requests in the system (<var>N</var><code>(c)&gt;0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(c,k)</code> is the mean service time for class c
customers at center k (<var>S</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(c,k)</code> is the average number of visits of class c
requests to center k (<var>V</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at service center
k. If <var>m</var><code>(k) &lt; 1</code>, then the service center k
is assumed to be a delay center (IS). If <var>m</var><code>(k) == 1</code>,
service center k is a regular queueing center (FCFS, LCFS-PR
or PS) with a single server node. If omitted, each service center has
a single server. Note that multiple server nodes are not supported.

          <br><dt><var>Z</var><dd><var>Z</var><code>(c)</code> is the class c external delay. Default
is 0.

          <br><dt><var>tol</var><dd>Stopping tolerance (<var>tol</var><code>&gt;0</code>). The algorithm stops if
the queue length computed on two subsequent iterations are less than
<var>tol</var>. Default is 10^-5.

          <br><dt><var>iter_max</var><dd>Maximum number of iterations (<var>iter_max</var><code>&gt;0</code>. 
The function aborts if convergenge is not reached within the maximum
number of iterations. Default is 100.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If k is a FCFS, LCFS-PR or PS node, then <var>U</var><code>(c,k)</code>
is the utilization of class c requests on service center
k. If k is an IS node, then <var>U</var><code>(c,k)</code> is the
class c <em>traffic intensity</em> at device k,
defined as <var>U</var><code>(c,k) = </code><var>X</var><code>(c)*</code><var>S</var><code>(c,k)</code>

          <br><dt><var>R</var><dd><var>R</var><code>(c,k)</code> is the response
time of class c requests at service center k.

          <br><dt><var>Q</var><dd><var>Q</var><code>(c,k)</code> is the average number of
class c requests at service center k.

          <br><dt><var>X</var><dd><var>X</var><code>(c,k)</code> is the class c
throughput at service center k.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qncmmva.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">Y. Bard, <cite>Some Extensions to Multiclass Queueing Network Analysis</cite>,
proc. 4th Int. Symp. on Modelling and Performance Evaluation of
Computer Systems, feb. 1979, pp. 51&ndash;62.

   <p><a name="index-Bard_002c-Y_002e-263"></a>
P. Schweitzer, <cite>Approximate Analysis of Multiclass Closed
Networks of Queues</cite>, Proc. Int. Conf. on Stochastic Control and
Optimization, jun 1979, pp. 25&ndash;29.

   <p><a name="index-Schweitzer_002c-P_002e-264"></a>
This implementation is based on Edward D. Lazowska, John Zahorjan, G. 
Scott Graham, and Kenneth C. Sevcik, <cite>Quantitative System
Performance: Computer System Analysis Using Queueing Network Models</cite>,
Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>.  In
particular, see section 7.4.2.2 ("Approximate Solution
Techniques"). This implementation is slightly different from the one
described above, as it computes the average response times R
instead of the residence times.

   <p><a name="index-Lazowska_002c-E_002e-D_002e-265"></a><a name="index-Zahorjan_002c-J_002e-266"></a><a name="index-Graham_002c-G_002e-S_002e-267"></a><a name="index-Sevcik_002c-K_002e-C_002e-268"></a>

<h4 class="subsection">5.3.3 Mixed Networks</h4>

<!-- MVA for mixed networks -->
<p><a name="doc_002dqnmix"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnmix</b> (<var>lambda, N, S, V, m</var>)<var><a name="index-qnmix-269"></a></var><br>
<blockquote>
        <p><a name="index-Mean-Value-Analysys-_0028MVA_0029-270"></a><a name="index-mixed-network-271"></a>
Solution of mixed queueing networks through MVA. The network consists
of K service centers (single-server or delay centers) and
C independent customer chains. Both open and closed chains
are possible. <var>lambda</var> is the vector of per-chain
arrival rates (open classes); <var>N</var> is the vector of populations
for closed chains.

        <blockquote>
<b>Note:</b> In this implementation class switching is <strong>not</strong> allowed. Each
customer class <em>must</em> correspond to an independent chain. 
</blockquote>

        <p>If the network is made of open or closed classes only, then this
function calls <code>qnom</code> or <code>qncmmva</code>
respectively, and prints a warning message.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dt><var>N</var><dd>For each customer chain c:

               <ul>
<li>if c is a closed chain, then <var>N</var><code>(c)&gt;0</code> is the
number of class c requests and <var>lambda</var><code>(c)</code> must be
zero;

               <li>If c is an open chain,
<var>lambda</var><code>(c)&gt;0</code> is the arrival rate of class c
requests and <var>N</var><code>(c)</code> must be zero;

          </ul>

          <p class="noindent">In other words, for each class c the following must hold:

          <pre class="example">               (<var>lambda</var>(c)&gt;0 &amp;&amp; <var>N</var>(c)==0) || (<var>lambda</var>(c)==0 &amp;&amp; <var>N</var>(c)&gt;0)
</pre>
          <br><dt><var>S</var><dd><var>S</var><code>(c,k)</code> is the mean class c service time at center
k, <var>S</var><code>(c,k) &ge; 0</code>. For FCFS nodes, service times
must be class-independent.

          <br><dt><var>V</var><dd><var>V</var><code>(c,k)</code> is the average number of visits of class c
customers to center k (<var>V</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center k. Only
single-server (<var>m</var><code>(k)==1</code>) or IS (Infinite Server) nodes
(<var>m</var><code>(k)&lt;1</code>) are supported. If omitted, each center
is assumed to be of type M/M/1-FCFS. Queueing discipline for
single-server nodes can be FCFS, PS or LCFS-PR.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd><var>U</var><code>(c,k)</code> is class c utilization at center k.

          <br><dt><var>R</var><dd><var>R</var><code>(c,k)</code> is class c response time at center k.

          <br><dt><var>Q</var><dd><var>Q</var><code>(c,k)</code> is the average number of
class c requests at center k.

          <br><dt><var>X</var><dd><var>X</var><code>(c,k)</code> is class c throughput at center k.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qncmmva, qncm.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C. 
Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 7.4.3 ("Mixed Model Solution Techniques"). 
Note that in this function we compute the mean response time R
instead of the mean residence time as in the reference.

   <p><a name="index-Lazowska_002c-E_002e-D_002e-272"></a><a name="index-Zahorjan_002c-J_002e-273"></a><a name="index-Graham_002c-G_002e-S_002e-274"></a><a name="index-Sevcik_002c-K_002e-C_002e-275"></a>
Herb Schwetman, <cite>Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models</cite>, Technical Report
<a href="http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-355.pdf">CSD-TR-355</a>, Department of Computer Sciences, Purdue University, feb
15, 1982,

   <p><a name="index-Schwetman_002c-H_002e-276"></a>
<div class="node">
<a name="Generic-Algorithms"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bounds-Analysis">Bounds Analysis</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Multiple-Class-Models">Multiple Class Models</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Queueing-Networks">Queueing Networks</a>

</div>

<h3 class="section">5.4 Generic Algorithms</h3>

<p>The <code>queueing</code> package provides a high-level function
<samp><span class="command">qnsolve</span></samp> for analyzing QN models. <samp><span class="command">qnsolve</span></samp> takes as
input a high-level description of the queueing model, and delegates
the actual solution of the model to one of the lower-level
function. <samp><span class="command">qnsolve</span></samp> supports single or multiclass models, but at
the moment only product-form networks can be analyzed. For non
product-form networks See <a href="#Non-Product_002dForm-QNs">Non Product-Form QNs</a>.

   <p><samp><span class="command">qnsolve</span></samp> accepts two input parameters. The first one is the list
of nodes, encoded as an Octave <em>cell array</em>. The second parameter
is the vector of visit ratios <var>V</var>, which can be either a vector
(for single-class models) or a two-dimensional matrix (for
multiple-class models).

   <p>Individual nodes in the network are structures build using the
<samp><span class="command">qnmknode</span></samp> function.

   <p><a name="doc_002dqnmknode"></a>

<div class="defun">
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"m/m/m-fcfs", S</var>)<var><a name="index-qnmknode-277"></a></var><br>
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"m/m/m-fcfs", S, m</var>)<var><a name="index-qnmknode-278"></a></var><br>
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"m/m/1-lcfs-pr", S</var>)<var><a name="index-qnmknode-279"></a></var><br>
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"-/g/1-ps", S</var>)<var><a name="index-qnmknode-280"></a></var><br>
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"-/g/1-ps", S, s2</var>)<var><a name="index-qnmknode-281"></a></var><br>
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"-/g/inf", S</var>)<var><a name="index-qnmknode-282"></a></var><br>
&mdash; Function File: <var>Q</var> = <b>qnmknode</b> (<var>"-/g/inf", S, s2</var>)<var><a name="index-qnmknode-283"></a></var><br>
<blockquote>
        <p>Creates a node; this function can be used together with
<code>qnsolve</code>. It is possible to create either single-class nodes
(where there is only one customer class), or multiple-class nodes
(where the service time is given per-class). Furthermore, it is
possible to specify load-dependent service times.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>S</var><dd>Mean service time.

               <ul>
<li>If S is a scalar,
it is assumed to be a load-independent, class-independent service time.

               <li>If S is a column vector, then <var>S</var><code>(c)</code> is assumed to
the the load-independent service time for class c customers.

               <li>If S is a row vector, then <var>S</var><code>(n)</code> is assumed to be
the class-independent service time at the node, when there are n
requests.

               <li>Finally, if <var>S</var> is a two-dimensional matrix, then
<var>S</var><code>(c,n)</code> is assumed to be the class c service time
when there are n requests at the node.

          </ul>

          <br><dt><var>m</var><dd>Number of identical servers at the node. Default is <var>m</var><code>=1</code>.

          <br><dt><var>s2</var><dd>Squared coefficient of variation for the service time. Default is 1.0.

        </dl>

        <p>The returned struct <var>Q</var> should be considered opaque to the client.

     <!-- The returned struct @var{Q} has the following fields: -->
     <!-- @table @var -->
     <!-- @item Q.node -->
     <!-- (String) type of the node; valid values are @code{"m/m/m-fcfs"}, -->
     <!-- @code{"-/g/1-lcfs-pr"}, @code{"-/g/1-ps"} (Processor-Sharing) -->
     <!-- and @code{"-/g/inf"} (Infinite Server, or delay center). -->
     <!-- @item Q.S -->
     <!-- Average service time. If @code{@var{Q}.S} is a vector, then -->
     <!-- @code{@var{Q}.S(i)} is the average service time at that node -->
     <!-- if there are @math{i} requests. -->
     <!-- @item Q.m -->
     <!-- Number of identical servers at a @code{"m/m/m-fcfs"}. Default is 1. -->
     <!-- @item Q.c -->
     <!-- Number of customer classes. Default is 1. -->
     <!-- @end table -->
        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnsolve.

        </blockquote></div>

   <p>After the network has been defined, it is possible to solve it using
<samp><span class="command">qnsolve</span></samp>.

   <p><a name="doc_002dqnsolve"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnsolve</b> (<var>"closed", N, QQ, V</var>)<var><a name="index-qnsolve-284"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnsolve</b> (<var>"closed", N, QQ, V, Z</var>)<var><a name="index-qnsolve-285"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnsolve</b> (<var>"open", lambda, QQ, V</var>)<var><a name="index-qnsolve-286"></a></var><br>
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnsolve</b> (<var>"mixed", lambda, N, QQ, V</var>)<var><a name="index-qnsolve-287"></a></var><br>
<blockquote>
        <p>High-level function for analyzing QN models.

          <ul>
<li>For <strong>closed</strong> networks, the following server types are
supported: M/M/m&ndash;FCFS, -/G/\infty, -/G/1&ndash;LCFS-PR,
-/G/1&ndash;PS and load-dependent variants.

          <li>For <strong>open</strong> networks, the following server types are supported:
M/M/m&ndash;FCFS, -/G/\infty and -/G/1&ndash;PS. General
load-dependent nodes are <em>not</em> supported. Multiclass open networks
do not support multiple server M/M/m nodes, but only
single server M/M/1&ndash;FCFS.

          <li>For <strong>mixed</strong> networks, the following server types are supported:
M/M/1&ndash;FCFS, -/G/\infty and -/G/1&ndash;PS. General
load-dependent nodes are <em>not</em> supported.

        </ul>

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>Number of requests in the system for closed networks. For
single-class networks, <var>N</var> must be a scalar. For multiclass
networks, <var>N</var><code>(c)</code> is the population size of closed class
c.

          <br><dt><var>lambda</var><dd>External arrival rate (scalar) for open networks. For single-class
networks, <var>lambda</var> must be a scalar. For multiclass networks,
<var>lambda</var><code>(c)</code> is the class c overall arrival rate.

          <br><dt><var>QQ</var><dd>List of queues in the network. This must be a cell array
with N elements, such that <var>QQ</var><code>{i}</code> is
a struct produced by the <code>qnmknode</code> function.

          <br><dt><var>Z</var><dd>External delay ("think time") for closed networks. Default 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>U</var><dd>If i is a FCFS node, then <var>U</var><code>(i)</code> is the utilization
of service center i. If i is an IS node, then
<var>U</var><code>(i)</code> is the <em>traffic intensity</em> defined as
<var>X</var><code>(i)*</code><var>S</var><code>(i)</code>.

          <br><dt><var>R</var><dd><var>R</var><code>(i)</code> is the average response time of service center i.

          <br><dt><var>Q</var><dd><var>Q</var><code>(i)</code> is the average number of customers in service center
i.

          <br><dt><var>X</var><dd><var>X</var><code>(i)</code> is the throughput of service center i.

        </dl>

        <p>Note that for multiclass networks, the computed results are per-class
utilization, response time, number of customers and throughput:
<var>U</var><code>(c,k)</code>, <var>R</var><code>(c,k)</code>, <var>Q</var><code>(c,k)</code>,
<var>X</var><code>(c,k)</code>,

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

   <p>Let us consider a closed, multiclass network with C=2 classes
and K=3 service center. Let the population be M=(2, 1)
(class 1 has 2 requests, and class 2 has 1 request). The nodes are as
follows:

     <ul>
<li>Node 1 is a M/M/1&ndash;FCFS node, with load-dependent service
times. Service times are class-independent, and are defined by the
matrix <code>[0.2 0.1 0.1; 0.2 0.1 0.1]</code>. Thus, <var>S</var><code>(1,2) =
0.2</code> means that service time for class 1 customers where there are 2
requests in 0.2. Note that service times are class-independent;

     <li>Node 2 is a -/G/1&ndash;PS node, with service times
S_1, 2 = 0.4 for class 1, and S_2, 2 = 0.6 for class 2
requests;

     <li>Node 3 is a -/G/\infty node (delay center), with service
times S_1, 3=1 and S_2, 3=2 for class 1 and 2
respectively.

   </ul>

   <p>After defining the per-class visit count <var>V</var> such that
<var>V</var><code>(c,k)</code> is the visit count of class c requests to
service center k.  We can define and solve the model as
follows:

<pre class="example">     
     
<pre class="verbatim">      QQ = { qnmknode( "m/m/m-fcfs", [0.2 0.1 0.1; 0.2 0.1 0.1] ), \
             qnmknode( "-/g/1-ps", [0.4; 0.6] ), \
             qnmknode( "-/g/inf", [1; 2] ) };
      V = [ 1 0.6 0.4; \
            1 0.3 0.7 ];
      N = [ 2 1 ];
      [U R Q X] = qnsolve( "closed", N, QQ, V );
</pre>
</pre>
   <p><a name="doc_002dqnclosed"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnclosed</b> (<var>N, S, V, <small class="dots">...</small></var>)<var><a name="index-qnclosed-288"></a></var><br>
<blockquote>
        <p><a name="index-closed-network_002c-single-class-289"></a><a name="index-closed-network_002c-multiple-classes-290"></a>
This function computes steady-state performance measures of closed
queueing networks using the Mean Value Analysis (MVA) algorithm. The
qneneing network is allowed to contain fixed-capacity centers, delay
centers or general load-dependent centers. Multiple request
classes are supported.

        <p>This function dispatches the computation to one of
<code>qncsemva</code>, <code>qncsmvald</code> or <code>qncmmva</code>.

          <ul>
<li>If <var>N</var> is a scalar, the network is assumed to have a single
class of requests; in this case, the exact MVA algorithm is used to
analyze the network. If <var>S</var> is a vector, then <var>S</var><code>(k)</code>
is the average service time of center k, and this function
calls <code>qncsmva</code> which supports load-independent
service centers. If <var>S</var> is a matrix, <var>S</var><code>(k,i)</code> is the
average service time at center k when i=1, <small class="dots">...</small>, N
jobs are present; in this case, the network is analyzed with the
<code>qncmmvald</code> function.

          <li>If <var>N</var> is a vector, the network is assumed to have multiple
classes of requests, and is analyzed using the exact multiclass
MVA algorithm as implemented in the <code>qncmmva</code> function.

        </ul>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qncsmva, qncsmvald, qncmmva.

        </blockquote></div>

<p class="noindent"><strong>EXAMPLE</strong>

<pre class="example"><pre class="verbatim">      P = [0 0.3 0.7; 1 0 0; 1 0 0]; # Transition probability matrix
      S = [1 0.6 0.2];               # Average service times
      m = ones(size(S));             # All centers are single-server
      Z = 2;                         # External delay
      N = 15;                        # Maximum population to consider
      V = qncsvisits(P);             # Compute number of visits
      X_bsb_lower = X_bsb_upper = X_ab_lower = X_ab_upper = X_mva = zeros(1,N);
      for n=1:N
        [X_bsb_lower(n) X_bsb_upper(n)] = qncsbsb(n, S, V, m, Z);
        [X_ab_lower(n) X_ab_upper(n)] = qncsaba(n, S, V, m, Z);
        [U R Q X] = qnclosed( n, S, V, m, Z );
        X_mva(n) = X(1)/V(1);
      endfor
      close all;
      plot(1:N, X_ab_lower,"g;Asymptotic Bounds;", \
           1:N, X_bsb_lower,"k;Balanced System Bounds;", \
           1:N, X_mva,"b;MVA;", "linewidth", 2, \
           1:N, X_bsb_upper,"k", 1:N, X_ab_upper,"g" );
      axis([1,N,0,1]); legend("location","southeast");
      xlabel("Number of Requests n"); ylabel("System Throughput X(n)");
</pre>
</pre>
   <p><a name="doc_002dqnopen"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>R</var>, <var>Q</var>, <var>X</var>] = <b>qnopen</b> (<var>lambda, S, V, <small class="dots">...</small></var>)<var><a name="index-qnopen-291"></a></var><br>
<blockquote>
        <p><a name="index-open-network-292"></a>
Compute utilization, response time, average number of requests in the
system, and throughput for open queueing networks. If <var>lambda</var> is
a scalar, the network is considered a single-class QN and is solved
using <code>qnopensingle</code>. If <var>lambda</var> is a vector, the network
is considered as a multiclass QN and solved using <code>qnopenmulti</code>.

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnos, qnom.

        </blockquote></div>

<div class="node">
<a name="Bounds-Analysis"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#QN-Analysis-Examples">QN Analysis Examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Generic-Algorithms">Generic Algorithms</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Queueing-Networks">Queueing Networks</a>

</div>

<h3 class="section">5.5 Bounds Analysis</h3>

<p><a name="doc_002dqnosaba"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qnosaba</b> (<var>lambda, D</var>)<var><a name="index-qnosaba-293"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qnosaba</b> (<var>lambda, S, V</var>)<var><a name="index-qnosaba-294"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qnosaba</b> (<var>lambda, S, V, m</var>)<var><a name="index-qnosaba-295"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-asymptotic-296"></a><a name="index-open-network-297"></a>
Compute Asymptotic Bounds for open, single-class networks.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>Arrival rate of requests (<var>lambda</var><code> &ge; 0</code>).

          <br><dt><var>D</var><dd><var>D</var><code>(k)</code> is the service demand at center k. 
(<var>D</var><code>(k) &ge; 0</code> for all k).

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the mean service time at center k. 
(<var>S</var><code>(k) &ge; 0</code> for all k).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the mean number of visits to center k. 
(<var>V</var><code>(k) &ge; 0</code> for all k).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center k. 
This function only supports M/M/1 queues, therefore
<var>m</var> must be <code>ones(size(S))</code>.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><br><dt><var>Xu</var><dd>Lower and upper bounds on the system throughput. <var>Xl</var> is
always set to 0 since there can be no lower bound on the
throughput of open networks.

          <br><dt><var>Rl</var><br><dt><var>Ru</var><dd>Lower and upper bounds on the system response time. <var>Ru</var>
is always set to <code>+inf</code> since there can be no upper bound on the
throughput of open networks.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnopenmultiab.

        </blockquote></div>

   <p><a name="doc_002dqnomaba"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qnomaba</b> (<var>lambda, D</var>)<var><a name="index-qnomaba-298"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Rl</var>] = <b>qnomaba</b> (<var>lambda, S, V</var>)<var><a name="index-qnomaba-299"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-asymptotic-300"></a><a name="index-open-network-301"></a><a name="index-multiclass-network_002c-open-302"></a>
Compute Asymptotic Bounds for open, multiclass networks.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd><var>lambda</var><code>(c)</code> is the class c arrival rate to the
system.

          <br><dt><var>D</var><dd><var>D</var><code>(c, k)</code> is class c service demand
at center k. (<var>D</var><code>(c, k) &ge; 0</code> for all
k).

          <br><dt><var>S</var><dd><var>S</var><code>(c, k)</code> is the mean service time of class c
requests at center k. (<var>S</var><code>(c, k) &ge; 0</code> for all
k).

          <br><dt><var>V</var><dd><var>V</var><code>(c, k)</code> is the mean number of visits of class c
requests at center k. (<var>V</var><code>(c, k) &ge; 0</code> for all
k).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><br><dt><var>Xu</var><dd>Per-class lower and upper throughput bounds. For example,
<var>Xu</var><code>(c)</code> is the upper bound for class c throughput. 
<code>Xl</code> is always 0 since there can be no lower bound
on the throughput of open networks.

          <br><dt><var>Rl</var><br><dt><var>Ru</var><dd>Per-class lower and upper response time bounds. 
<code>Ru</code> is always <code>+inf</code> since there can be no upper bound
on the response time of open networks.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnombsb.

        </blockquote></div>

   <p><a name="doc_002dqncsaba"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncsaba</b> (<var>N, D</var>)<var><a name="index-qncsaba-303"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncsaba</b> (<var>N, S, V</var>)<var><a name="index-qncsaba-304"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncsaba</b> (<var>N, S, V, m</var>)<var><a name="index-qncsaba-305"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncsaba</b> (<var>N, S, V, m, Z</var>)<var><a name="index-qncsaba-306"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-asymptotic-307"></a><a name="index-asymptotic-bounds-308"></a><a name="index-closed-network_002c-single-class-309"></a>
Compute Asymptotic Bounds for throughput and response time of closed, single-class networks.

        <p>Single-server and infinite-server nodes are supported. 
Multiple-server nodes and general load-dependent servers are not
supported.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>number of requests in the system (scalar, <var>N</var><code>&gt;0</code>).

          <br><dt><var>D</var><dd><var>D</var><code>(k)</code> is the service demand at center k
(<var>D</var><code>(k) &ge; 0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the mean service time at center k
(<var>S</var><code>(k) &ge; 0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the average number of visits to center
k (<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center k
(if <var>m</var> is a scalar, all centers have that number of servers). If
<var>m</var><code>(k) &lt; 1</code>, center k is a delay center (IS);
if <var>m</var><code>(k) = 1</code>, center k is a M/M/1-FCFS server. 
This function does not support multiple-server nodes. Default
is 1.

          <br><dt><var>Z</var><dd>External delay (<var>Z</var><code> &ge; 0</code>). Default is 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><dt><var>Xu</var><dd>Lower and upper system throughput bounds.

          <br><dt><var>Rl</var><dt><var>Ru</var><dd>Lower and upper response time bounds.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qncmaba.

        </blockquote></div>

   <p><a name="doc_002dqncmaba"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncmaba</b> (<var>N, D</var>)<var><a name="index-qncmaba-310"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncmaba</b> (<var>N, S, V</var>)<var><a name="index-qncmaba-311"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncmaba</b> (<var>N, S, V, m</var>)<var><a name="index-qncmaba-312"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncmaba</b> (<var>N, S, V, m, Z</var>)<var><a name="index-qncmaba-313"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-asymptotic-314"></a><a name="index-asymptotic-bounds-315"></a><a name="index-closed-network-316"></a><a name="index-multiclass-network_002c-closed-317"></a><a name="index-closed-multiclass-network-318"></a>
Compute Asymptotic Bounds for multiclass networks. 
Single-server and infinite-server nodes are supported. 
Multiple-server nodes and general load-dependent servers are not
supported.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd><var>N</var><code>(c)</code> is the number of class c requests in the system.

          <br><dt><var>D</var><dd><var>D</var><code>(c, k)</code> is class c service demand
at center k (<var>D</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(c, k)</code> is the mean service time of class c
requests at center k (<var>S</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(c,k)</code> is the average number of visits of class c
requests to center k (<var>V</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center k
(if <var>m</var> is a scalar, all centers have that number of servers). If
<var>m</var><code>(k) &lt; 1</code>, center k is a delay center (IS);
if <var>m</var><code>(k) = 1</code>, center k is a M/M/1-FCFS server. 
This function does not support multiple-server nodes. Default
is 1.

          <br><dt><var>Z</var><dd><var>Z</var><code>(c)</code> is class c external delay
(<var>Z</var><code>(c) &ge; 0</code>). Default is 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><dt><var>Xu</var><dd>Lower and upper class c throughput bounds.

          <br><dt><var>Rl</var><dt><var>Ru</var><dd>Lower and upper class c response time bounds.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosedsingleab.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 5.2 ("Asymptotic Bounds").

   <p><a name="index-Lazowska_002c-E_002e-D_002e-319"></a><a name="index-Zahorjan_002c-J_002e-320"></a><a name="index-Graham_002c-G_002e-S_002e-321"></a><a name="index-Sevcik_002c-K_002e-C_002e-322"></a>
<a name="doc_002dqnosbsb"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qnosbsb</b> (<var>lambda, D</var>)<var><a name="index-qnosbsb-323"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qnosbsb</b> (<var>lambda, S, V</var>)<var><a name="index-qnosbsb-324"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-balanced-system-325"></a><a name="index-open-network-326"></a>
Compute Balanced System Bounds for single-class, open networks.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>lambda</var><dd>overall arrival rate to the system (scalar). Abort if
<var>lambda</var><code> &lt; 0 </code>

          <br><dt><var>D</var><dd><var>D</var><code>(k)</code> is the service demand at center k. 
(<var>D</var><code>(k) &ge; 0</code> for all k).

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the mean service time at center k. 
(<var>S</var><code>(k) &ge; 0</code> for all k).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the mean number of visits at center k. 
(<var>V</var><code>(k) &ge; 0</code> for all k).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center k. 
This function only supports M/M/1 queues, therefore
<var>m</var> must be <code>ones(size(S))</code>.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><br><dt><var>Xu</var><dd>Lower and upper bounds on the system throughput. <var>Xl</var> is always
set to 0, since there can be no lower bound on open
networks throughput.

          <br><dt><var>Rl</var><dt><var>Ru</var><dd>Lower and upper bounds on the system response time.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnosaba.

        </blockquote></div>

   <p><a name="doc_002dqncsbsb"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncsbsb</b> (<var>N, D</var>)<var><a name="index-qncsbsb-327"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncsbsb</b> (<var>N, S, V</var>)<var><a name="index-qncsbsb-328"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncsbsb</b> (<var>N, S, V, m</var>)<var><a name="index-qncsbsb-329"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncsbsb</b> (<var>N, S, V, m, Z</var>)<var><a name="index-qncsbsb-330"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-balanced-system-331"></a><a name="index-closed-network_002c-single-class-332"></a><a name="index-balanced-system-bounds-333"></a>
Compute Balanced System Bounds on system throughput and response time for closed, single-class networks.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>number of requests in the system (scalar).

          <br><dt><var>D</var><dd><var>D</var><code>(k)</code> is the service demand at center k
(<var>D</var><code>(k) &ge; 0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the mean service time at center k
(<var>S</var><code>(k) &ge; 0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the average number of visits to center
k (<var>V</var><code>(k) &ge; 0</code>). Default is 1.

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center k. This
function supports <var>m</var><code>(k) = 1</code> only (sing-eserver FCFS
nodes). This option is left for compatibility with
<code>qncsaba</code>, Default is 1.

          <br><dt><var>Z</var><dd>External delay (<var>Z</var><code> &ge; 0</code>). Default is 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><dt><var>Xu</var><dd>Lower and upper bound on the system throughput.

          <br><dt><var>Rl</var><dt><var>Ru</var><dd>Lower and upper bound on the system response time.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qncmbsb.

        </blockquote></div>

   <p><a name="doc_002dqncmbsb"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncmbsb</b> (<var>N, D</var>)<var><a name="index-qncmbsb-334"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncmbsb</b> (<var>N, S, V</var>)<var><a name="index-qncmbsb-335"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-balanced-system-336"></a><a name="index-balanced-system-bounds-337"></a><a name="index-multiclass-network_002c-closed-338"></a><a name="index-closed-multiclass-network-339"></a>
Compute Balanced System Bounds for multiclass networks. 
Only single-server nodes are supported.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd><var>N</var><code>(c)</code> is the number of class c requests in the system.

          <br><dt><var>D</var><dd><var>D</var><code>(c, k)</code> is class c service demand
at center k (<var>D</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(c, k)</code> is the mean service time of class c
requests at center k (<var>S</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(c,k)</code> is the average number of visits of class c
requests to center k (<var>V</var><code>(c,k) &ge; 0</code>).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><dt><var>Xu</var><dd>Lower and upper class c throughput bounds.

          <br><dt><var>Rl</var><dt><var>Ru</var><dd>Lower and upper class c response time bounds.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qnclosedsinglebsb.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">http://www.cs.washington.edu/homes/lazowska/qsp/</a>. In
particular, see section 5.4 ("Balanced Systems Bounds").

   <p><a name="index-Lazowska_002c-E_002e-D_002e-340"></a><a name="index-Zahorjan_002c-J_002e-341"></a><a name="index-Graham_002c-G_002e-S_002e-342"></a><a name="index-Sevcik_002c-K_002e-C_002e-343"></a>
<a name="doc_002dqncmcb"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncmcb</b> (<var>N, D</var>)<var><a name="index-qncmcb-344"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncmcb</b> (<var>N, S, V</var>)<var><a name="index-qncmcb-345"></a></var><br>
<blockquote>
        <p><a name="index-multiclass-network_002c-closed-346"></a><a name="index-closed-multiclass-network-347"></a><a name="index-bounds_002c-composite-348"></a><a name="index-composite-bounds-349"></a>
Composite Bound (CB) on throughput and response time for closed multiclass networks.

        <p>This function implements the Composite Bound Method described in T. 
Kerola, <cite>The Composite Bound Method (CBM) for Computing
Throughput Bounds in Multiple Class Environments</cite>, Technical Report
CSD-TR-475, Purdue University, march 13, 1984 (revised august 27,
1984).

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd><var>N</var><code>(c)</code> is the number of class c requests in the system.

          <br><dt><var>D</var><dd><var>D</var><code>(c, k)</code> is class c service demand
at center k (<var>S</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(c, k)</code> is the mean service time of class c
requests at center k (<var>S</var><code>(c,k) &ge; 0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(c,k)</code> is the average number of visits of class c
requests to center k (<var>V</var><code>(c,k) &ge; 0</code>).

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><dt><var>Xu</var><dd>Lower and upper class c throughput bounds.

          <br><dt><var>Rl</var><dt><var>Ru</var><dd>Lower and upper class c response time bounds.

        </dl>

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">Teemu Kerola, <cite>The Composite Bound Method (CBM) for Computing
Throughput Bounds in Multiple Class Environments</cite>, Technical Report
CSD-TR-475, Department of Computer Sciences, Purdue University, mar 13,
1984 (Revised aug 27, 1984).

   <p><a name="index-Kerola_002c-T_002e-350"></a>
<a name="doc_002dqncspb"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncspb</b> (<var>N, D </var>)<var><a name="index-qncspb-351"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncspb</b> (<var>N, S, V </var>)<var><a name="index-qncspb-352"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncspb</b> (<var>N, S, V, m </var>)<var><a name="index-qncspb-353"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>] = <b>qncspb</b> (<var>N, S, V, m, Z </var>)<var><a name="index-qncspb-354"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-PB-355"></a><a name="index-PB-bounds-356"></a><a name="index-closed-network_002c-single-class-357"></a>
Compute PB Bounds (C. H. Hsieh and S. Lam, 1987) for single-class,
closed networks.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>number of requests in the system (scalar). Must be <var>N</var><code> &gt; 0</code>.

          <br><dt><var>D</var><dd><var>D</var><code>(k)</code> is the service demand of service center k
(<var>D</var><code>(k) &ge; 0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the mean service time at center k
(<var>S</var><code>(k) &ge; 0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the visit ratio to center k
(<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center k. 
This function only supports M/M/1 queues, therefore
<var>m</var> must be <code>ones(size(S))</code>.

          <br><dt><var>Z</var><dd>external delay (think time, <var>Z</var><code> &ge; 0</code>). Default 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><dt><var>Xu</var><dd>Lower and upper bounds on the system throughput.

          <br><dt><var>Rl</var><dt><var>Ru</var><dd>Lower and upper bounds on the system response time.

        </dl>

        <pre class="sp">
     
     </pre>
     <strong>See also:</strong> qncsaba, qbcsbsb, qncsgb.

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

   <p>The original paper describing PB Bounds is C. H. Hsieh and S. Lam,
<cite>Two classes of performance bounds for closed queueing networks</cite>,
PEVA, vol. 7, n. 1, pp. 3&ndash;30, 1987

   <p>This function implements the non-iterative variant described in G. 
Casale, R. R. Muntz, G. Serazzi, <cite>Geometric Bounds: a
Non-Iterative Analysis Technique for Closed Queueing Networks</cite>, IEEE
Transactions on Computers, 57(6):780-794, June 2008.

   <p><a name="index-Hsieh_002c-C_002e-H-358"></a><a name="index-Lam_002c-S_002e-359"></a><a name="index-Casale_002c-G_002e-360"></a><a name="index-Muntz_002c-R_002e-R_002e-361"></a><a name="index-Serazzi_002c-G_002e-362"></a>
<a name="doc_002dqncsgb"></a>

<div class="defun">
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>, <var>Ql</var>, <var>Qu</var>] = <b>qncsgb</b> (<var>N, D</var>)<var><a name="index-qncsgb-363"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>, <var>Ql</var>, <var>Qu</var>] = <b>qncsgb</b> (<var>N, S, V</var>)<var><a name="index-qncsgb-364"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>, <var>Ql</var>, <var>Qu</var>] = <b>qncsgb</b> (<var>N, S, V, m</var>)<var><a name="index-qncsgb-365"></a></var><br>
&mdash; Function File: [<var>Xl</var>, <var>Xu</var>, <var>Rl</var>, <var>Ru</var>, <var>Ql</var>, <var>Qu</var>] = <b>qncsgb</b> (<var>N, S, V, m, Z</var>)<var><a name="index-qncsgb-366"></a></var><br>
<blockquote>
        <p><a name="index-bounds_002c-geometric-367"></a><a name="index-geometric-bounds-368"></a><a name="index-closed-network-369"></a>
Compute Geometric Bounds (GB) on system throughput, system response time and server queue lenghts for closed, single-class networks.

        <p><strong>INPUTS</strong>

          <dl>
<dt><var>N</var><dd>number of requests in the system (scalar, <var>N</var><code> &gt; 0</code>).

          <br><dt><var>D</var><dd><var>D</var><code>(k)</code> is the service demand of service center k
(<var>D</var><code>(k) &ge; 0</code>).

          <br><dt><var>S</var><dd><var>S</var><code>(k)</code> is the mean service time at center k
(<var>S</var><code>(k) &ge; 0</code>).

          <br><dt><var>V</var><dd><var>V</var><code>(k)</code> is the visit ratio to center k
(<var>V</var><code>(k) &ge; 0</code>).

          <br><dt><var>m</var><dd><var>m</var><code>(k)</code> is the number of servers at center k. 
This function only supports M/M/1 queues, therefore
<var>m</var> must be <code>ones(size(S))</code>.

          <br><dt><var>Z</var><dd>external delay (think time, <var>Z</var><code> &ge; 0</code>). Default 0.

        </dl>

        <p><strong>OUTPUTS</strong>

          <dl>
<dt><var>Xl</var><dt><var>Xu</var><dd>Lower and upper bound on the system throughput. If <var>Z</var><code>&gt;0</code>,
these bounds are computed using <em>Geometric Square-root Bounds</em>
(GSB). If <var>Z</var><code>==0</code>, these bounds are computed using <em>Geometric Bounds</em> (GB)

          <br><dt><var>Rl</var><dt><var>Ru</var><dd>Lower and upper bound on the system response time. These bounds
are derived from <var>Xl</var> and <var>Xu</var> using Little's Law:
<var>Rl</var><code> = </code><var>N</var><code> / </code><var>Xu</var><code> - </code><var>Z</var>,
<var>Ru</var><code> = </code><var>N</var><code> / </code><var>Xl</var><code> - </code><var>Z</var>

          <br><dt><var>Ql</var><dt><var>Qu</var><dd><var>Ql</var><code>(i)</code> and <var>Qu</var><code>(i)</code> are the lower and upper
bounds respectively of the queue length for service center i.

        </dl>

        </blockquote></div>

<p class="noindent"><strong>REFERENCES</strong>

<p class="noindent">G. Casale, R. R. Muntz, G. Serazzi,
<cite>Geometric Bounds: a Non-Iterative Analysis Technique for Closed
Queueing Networks</cite>, IEEE Transactions on Computers, 57(6):780-794,
June 2008. <a href="http://doi.ieeecomputersociety.org/10.1109/TC.2008.37">10.1109/TC.2008.37</a>

   <p><a name="index-Casale_002c-G_002e-370"></a><a name="index-Muntz_002c-R_002e-R_002e-371"></a><a name="index-Serazzi_002c-G_002e-372"></a>
In this implementation we set X^+ and X^- as the upper
and lower Asymptotic Bounds as computed by the <samp><span class="command">qncsab</span></samp>
function, respectively.

<!-- Examples -->
<div class="node">
<a name="QN-Analysis-Examples"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bounds-Analysis">Bounds Analysis</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Queueing-Networks">Queueing Networks</a>

</div>

<h3 class="section">5.6 QN Analysis Examples</h3>

<p>In this section we illustrate with a few examples how the
<code>queueing</code> package can be used to evaluate queueing network
models. Further examples can be found in the demo blocks of the
functions described in this section, and can be accessed with the
<code>demo </code><em>function</em> Octave command.

<h4 class="subsection">5.6.1 Closed, Single Class Network</h4>

<p>We now give a simple example on how the queueing toolbox can be used
to analyze a closed network. Let us consider again the network shown
in <a href="#fig_003aqn_005fclosed_005fsingle">Figure 5.1</a>. We denote with S_k the average
service time at center k, k=1, 2, 3. We use S_1 =
1.0, S_2 = 2.0 and S_3 = 0.8. The routing of jobs
within the network is described with a <em>routing probability
matrix</em> \bf P. Specifically, a request completing service at
center i is enqueued at center j with probability
P_i, j.  We use the following routing matrix:

<pre class="example">         / 0  0.3  0.7 \
     P = | 1  0    0   |
         \ 1  0    0   /
</pre>
   <p>The network above can be analyzed with the <samp><span class="command">qnclosed</span></samp> function
see <a href="#doc_002dqnclosed">doc-qnclosed</a>. <samp><span class="command">qnclosed</span></samp> requires the following
parameters:

     <dl>
<dt><var>N</var><dd>Number of requests in the network (since we are considering a closed
network, the number of requests is fixed)

     <br><dt><var>S</var><dd>Array of average service times at the centers: <var>S</var><code>(k)</code> is
the average service time at center k.

     <br><dt><var>V</var><dd>Array of visit ratios: <var>V</var><code>(k)</code> is the average number of
visits to center k.

   </dl>

   <p>We can compute V_k from the routing probability matrix
P_i, j using the <samp><span class="command">qncsvisits</span></samp> function
see <a href="#doc_002dqncsvisits">doc-qncsvisits</a>.  We can analyze the network for a given
population size N (for example, N=10) as follows:

<pre class="example">     <kbd>N = 10;</kbd>
     <kbd>S = [1 2 0.8];</kbd>
     <kbd>P = [0 0.3 0.7; 1 0 0; 1 0 0];</kbd>
     <kbd>V = qncsvisits(P);</kbd>
     <kbd>[U R Q X] = qnclosed( N, S, V )</kbd>
        &rArr; U = 0.99139 0.59483 0.55518
        &rArr; R = 7.4360  4.7531  1.7500
        &rArr; Q = 7.3719  1.4136  1.2144
        &rArr; X = 0.99139 0.29742 0.69397
</pre>
   <p>The output of <samp><span class="command">qnclosed</span></samp> includes the vector of utilizations
U_k at center k, response time R_k, average
number of customers Q_k and throughput X_k. In our
example, the throughput of center 1 is X_1 = 0.99139, and the
average number of requests in center 3 is Q_3 = 1.2144. The
utilization of center 1 is U_1 = 0.99139, which is the higher
value among the service centers. Tus, center 1 is the <em>bottleneck
device</em>.

   <p>This network can also be analyzed with the <samp><span class="command">qnsolve</span></samp> function
see <a href="#doc_002dqnsolve">doc-qnsolve</a>. <samp><span class="command">qnsolve</span></samp> can handle open, closed or
mixed networks, and allows the network to be described in a very
flexible way.  First, let <var>Q1</var>, <var>Q2</var> and <var>Q3</var> be the
variables describing the service centers. Each variable is
instantiated with the <samp><span class="command">qnmknode</span></samp> function.

<pre class="example">     <kbd>Q1 = qnmknode( "m/m/m-fcfs", 1 );</kbd>
     <kbd>Q2 = qnmknode( "m/m/m-fcfs", 2 );</kbd>
     <kbd>Q3 = qnmknode( "m/m/m-fcfs", 0.8 );</kbd>
</pre>
   <p>The first parameter of <samp><span class="command">qnmknode</span></samp> is a string describing the
type of the node. Here we use <code>"m/m/m-fcfs"</code> to denote a
M/M/m&ndash;FCFS center. The second parameter gives the average
service time. An optional third parameter can be used to specify the
number m of service centers. If omitted, it is assumed
m=1 (single-server node).

   <p>Now, the network can be analyzed as follows:

<pre class="example">     <kbd>N = 10;</kbd>
     <kbd>V = [1 0.3 0.7];</kbd>
     <kbd>[U R Q X] = qnsolve( "closed", N, { Q1, Q2, Q3 }, V )</kbd>
        &rArr; U = 0.99139 0.59483 0.55518
        &rArr; R = 7.4360  4.7531  1.7500
        &rArr; Q = 7.3719  1.4136  1.2144
        &rArr; X = 0.99139 0.29742 0.69397
</pre>
   <h4 class="subsection">5.6.2 Open, Single Class Network</h4>

<p>Open networks can be analyzed in a similar way. Let us consider
an open network with K=3 service centers, and routing
probability matrix as follows:

<pre class="example">         / 0  0.3  0.5 \
     P = ! 1  0    0   |
         \ 1  0    0   /
</pre>
   <p>In this network, requests can leave the system from center 1 with
probability 1-(0.3+0.5) = 0.2. We suppose that external jobs
arrive at center 1 with rate \lambda_1 = 0.15; there are no
arrivals at centers 2 and 3.

   <p>Similarly to closed networks, we first need to compute the visit
counts V_k to center k. We use the
<samp><span class="command">qnosvisits</span></samp> function as follows:

<pre class="example">     <kbd>P = [0 0.3 0.5; 1 0 0; 1 0 0];</kbd>
     <kbd>lambda = [0.15 0 0];</kbd>
     <kbd>V = qnosvisits(P, lambda)</kbd>
        &rArr; V = 5.00000 1.50000 2.50000
</pre>
   <p class="noindent">where <var>lambda</var><code>(k)</code> is the arrival rate at center k,
and <var>P</var> is the routing matrix. Assuming the same service times as
in the previous example, the network can be analyzed with the
<samp><span class="command">qnopen</span></samp> function see <a href="#doc_002dqnopen">doc-qnopen</a>, as follows:

<pre class="example">     <kbd>S = [1 2 0.8];</kbd>
     <kbd>[U R Q X] = qnopen( sum(lambda), S, V )</kbd>
        &rArr; U = 0.75000 0.45000 0.30000
        &rArr; R = 4.0000  3.6364  1.1429
        &rArr; Q = 3.00000 0.81818 0.42857
        &rArr; X = 0.75000 0.22500 0.37500
</pre>
   <p>The first parameter of the <samp><span class="command">qnopen</span></samp> function is the (scalar)
aggregate arrival rate.

   <p>Again, it is possible to use the <samp><span class="command">qnsolve</span></samp> high-level function:

<pre class="example">     <kbd>Q1 = qnmknode( "m/m/m-fcfs", 1 );</kbd>
     <kbd>Q2 = qnmknode( "m/m/m-fcfs", 2 );</kbd>
     <kbd>Q3 = qnmknode( "m/m/m-fcfs", 0.8 );</kbd>
     <kbd>lambda = [0.15 0 0];</kbd>
     <kbd>[U R Q X] = qnsolve( "open", sum(lambda), { Q1, Q2, Q3 }, V )</kbd>
        &rArr; U = 0.75000 0.45000 0.30000
        &rArr; R = 4.0000  3.6364  1.1429
        &rArr; Q = 3.00000 0.81818 0.42857
        &rArr; X = 0.75000 0.22500 0.37500
</pre>
   <h4 class="subsection">5.6.3 Closed Multiclass Network/1</h4>

<p>The following example is taken from Herb Schwetman, <cite>Implementing
the Mean Value Algorith for the Solution of Queueing Network Models</cite>,
Technical Report CSD-TR-355, Department of Computer Sciences, Purdue
University, feb 15, 1982.

   <p>We consider the following multiclass QN with three servers and two classes

   <div class="float">
<a name="fig_003aapl"></a><div align="center"><img src="qn_closed_multi_apl.png" alt="qn_closed_multi_apl.png"></div>
   <p><strong class="float-caption">Figure 5.3</strong></p></div>

   <p>Servers 1 and 2 (labeled <em>APL</em> and <em>IMS</em>, respectively) are
infinite server nodes; server 3 (labeled <em>SYS</em>) is Processor
Sharing (PS). Mean service times are given in the following table:

   <p><table summary=""><tr align="left"><th valign="top" width="15%"></th><th valign="top" width="15%">APL </th><th valign="top" width="15%">IMS </th><th valign="top" width="15%">SYS
<br></th></tr><tr align="left"><td valign="top" width="15%">Class 1 </td><td valign="top" width="15%">1 </td><td valign="top" width="15%">- </td><td valign="top" width="15%">0.025
<br></td></tr><tr align="left"><td valign="top" width="15%">Class 2 </td><td valign="top" width="15%">- </td><td valign="top" width="15%">15 </td><td valign="top" width="15%">0.500
   <br></td></tr></table>

   <p>There is no class switching. If  we assume a population of 15 requests
for  class 1,  and  5 requests  for class  2,  then the  model can  be
analyzed as follows:

<pre class="example"><pre class="verbatim">      S = [1 0 .025; 0 15 .5];
      P = zeros(2,3,2,3);
      P(1,1,1,3) = P(1,3,1,1) = 1;
      P(2,2,2,3) = P(2,3,2,2) = 1;
      V = qncmvisits(P,[3 3]); # reference station is station 3
      N = [15 5];
      m = [-1 -1 1];
      [U R Q X] = qncmmva(N,S,V,m)
</pre>
       &rArr;
     U =
     
        14.32312    0.00000    0.35808
         0.00000    4.70699    0.15690
     
     R =
     
         1.00000    0.00000    0.04726
         0.00000   15.00000    0.93374
     
     Q =
     
        14.32312    0.00000    0.67688
         0.00000    4.70699    0.29301
     
     X =
     
        14.32312    0.00000   14.32312
         0.00000    0.31380    0.31380
</pre>
   <h4 class="subsection">5.6.4 Closed Multiclass Network/2</h4>

<p>The following example is taken from M. Marzolla, <cite>The qnetworks
Toolbox: A Software Package for Queueing Networks Analysis</cite>, Technical
Report
<a href="http://www.informatica.unibo.it/ricerca/technical-report/2010/UBLCS-2010-04">UBLCS-2010-04</a>, Department of Computer Science, University of Bologna,
Italy, February 2010.

   <div class="float">
<a name="fig_003aweb_005fmodel"></a><div align="center"><img src="qn_web_model.png" alt="qn_web_model.png"></div>
   <p><strong class="float-caption">Figure 5.4: Three-tier enterprise system model</strong></p></div>

   <p>The model shown in <a href="#fig_003aweb_005fmodel">Figure 5.4</a> shows a three-tier enterprise system
with K=6 service centers. The first tier contains the
<em>Web server</em> (node 1), which is responsible for generating Web pages and
transmitting them to clients. The application logic is implemented by
nodes 2 and 3, and the storage tier is made of nodes 4&ndash;6.The system
is subject to two workload classes, both represented as closed
populations of N_1 and N_2 requests, respectively. Let
D_c, k denote the service demand of class c requests
at center k. We use the parameter values:

   <p><table summary=""><tr align="left"><th valign="top" width="20%">Serv. no. </th><th valign="top" width="33%">Name </th><th valign="top" width="10%">Class 1 </th><th valign="top" width="10%">Class 2
<br></th></tr><tr align="left"><td valign="top" width="20%">1 </td><td valign="top" width="33%">Web Server    </td><td valign="top" width="10%">12 </td><td valign="top" width="10%">2
<br></td></tr><tr align="left"><td valign="top" width="20%">2 </td><td valign="top" width="33%">App. Server 1 </td><td valign="top" width="10%">14 </td><td valign="top" width="10%">20
<br></td></tr><tr align="left"><td valign="top" width="20%">3 </td><td valign="top" width="33%">App. Server 2 </td><td valign="top" width="10%">23 </td><td valign="top" width="10%">14
<br></td></tr><tr align="left"><td valign="top" width="20%">4 </td><td valign="top" width="33%">DB Server 1   </td><td valign="top" width="10%">20 </td><td valign="top" width="10%">90
<br></td></tr><tr align="left"><td valign="top" width="20%">5 </td><td valign="top" width="33%">DB Server 2   </td><td valign="top" width="10%">80 </td><td valign="top" width="10%">30
<br></td></tr><tr align="left"><td valign="top" width="20%">6 </td><td valign="top" width="33%">DB Server 3   </td><td valign="top" width="10%">31 </td><td valign="top" width="10%">33
   <br></td></tr></table>

   <p>We set the total number of requests to 100, that is N_1 + N_2 =
N = 100, and we study how different population mixes (N_1,
N_2) affect the system throughput and response time. Let
\beta_1 \in (0, 1) denote the fraction of class 1 requests:
N_1 = \beta_1 N, N_2 = (1-\beta_1)N. The following
Octave code defines the model for \beta_1 = 0.1:

<pre class="example">     N = 100;     # total population size
     beta1 = 0.1; # fraction of class 1 reqs.
     S = [12 14 23 20 80 31; \
           2 20 14 90 30 33 ];
     V = ones(size(S));
     pop = [fix(beta1*N) N-fix(beta1*N)];
     [U R Q X] = qncmmva(pop, S, V);
</pre>
   <p>The <samp><span class="command">qncmmva(pop, S, V)</span></samp> function invocation (line 7)
uses the multiclass MVA algorithm to compute per-class utilizations
U_c, k, response times R_c,k, mean queue lengths
Q_c,k and throughputs X_c,k at each service center
k, given a population vector <var>pop</var>, mean service times
<var>S</var> and visit ratios <var>V</var>. Since we are given the service
demands D_c, k = S_c, k V_c,k, but function
<samp><span class="command">qncmmva()</span></samp> requires separate service times and visit
ratios, we set the service times equal to the demands (line 3&ndash;4), and
all visit ratios equal to one (line 5). Overall class and system
throughputs and response times can also be computed:

<pre class="example">     X1 = X(1,1) / V(1,1)     # class 1 throughput
             &rArr; X1 =  0.0044219
     X2 = X(2,1) / V(2,1)     # class 2 throughput
             &rArr; X2 =  0.010128
     XX = X1 + X2             # system throughput
             &rArr; XX =  0.014550
     R1 = dot(R(1,:), V(1,:)) # class 1 resp. time
             &rArr; R1 =  2261.5
     R2 = dot(R(2,:), V(2,:)) # class 2 resp. time
             &rArr; R2 =  8885.9
     RR = N / XX              # system resp. time
             &rArr; RR =  6872.7
</pre>
   <p><code>dot(X,Y)</code> computes the dot product of two vectors. 
<code>R(1,:)</code> is the first row of matrix <var>R</var> and <code>V(1,:)</code> is
the first row of matrix <var>V</var>, so <code>dot(R(1,:), V(1,:))</code>
computes \sum_k R_1,k V_1,k.

   <div class="float">
<a name="fig_003aweb"></a><div align="center"><img src="web.png" alt="web.png"></div>
   <p><strong class="float-caption">Figure 5.5: Throughput and Response Times as a function of the population mix</strong></p></div>

   <p>We can also compute the system power \Phi = X / R, which
defines how efficiently resources are being used: high values of
\Phi denote the desirable situation of high throughput and low
response time. <a href="#fig_003apower">fig:power</a> shows \Phi as a function of
\beta_1. We observe a &ldquo;plateau&rdquo; of the global system power,
corresponding to values of \beta_1 which approximately lie
between 0.3 and 0.7. The per-class power exhibits an
interesting (although not completely surprising) pattern, where the
class with higher population exhibits worst efficiency as it produces
higher contention on the resources.

   <div class="float">
<a name="fig_003apower"></a><div align="center"><img src="power.png" alt="power.png"></div>
   <p><strong class="float-caption">Figure 5.6: System Power as a function of the population mix</strong></p></div>

<h4 class="subsection">5.6.5 Closed Multiclass Network/3</h4>

<p>We now consider an example of multiclass network with class switching. 
The example is taken from <a href="#Sch82">Sch82</a>, and is shown in Figure
<a href="#fig_003aclass_005fswitching">fig:class_switching</a>.

   <div class="float">
<a name="fig_003aclass_005fswitching"></a><div align="center"><img src="qn_closed_multi_cs.png" alt="qn_closed_multi_cs.png"></div>
   <p><strong class="float-caption">Figure 5.7: Multiclass Model with Class Switching</strong></p></div>

   <p>The system consists of three devices and two job classes. The CPU node
is a PS server, while the two nodes labeled I/O are FCFS. Class 1 mean
service time at the CPU is 0.01; class 2 mean service time at the CPU
is 0.05. The mean service time at node 2 is 0.1, and is
class-independent. Similarly, the mean service time at node 3 is
0.07. Jobs in class 1 leave the CPU and join class 2 with probability
0.1; jobs of class 2 leave the CPU and join class 1 with probability
0.2. There are N=3 jobs, which are initially allocated to class
1. However, note that since class switching is allowed, the total
number of jobs in each class does not remain constant; however the
total number of jobs does.

<pre class="example"><pre class="verbatim">      C = 2; K = 3;
      S = [.01 .07 .10; \
           .05 .07 .10 ];
      P = zeros(C,K,C,K);
      P(1,1,1,2) = .7; P(1,1,1,3) = .2; P(1,1,2,1) = .1;
      P(2,1,2,2) = .3; P(2,1,2,3) = .5; P(2,1,1,1) = .2;
      P(1,2,1,1) = P(2,2,2,1) = 1;
      P(1,3,1,1) = P(2,3,2,1) = 1;
      N = [3 0];
      [U R Q X] = qncmmva(N, S, P)
</pre>
       &rArr;
     U =
     
        0.12609   0.61784   0.25218
        0.31522   0.13239   0.31522
     
     R =
     
        0.014653   0.133148   0.163256
        0.073266   0.133148   0.163256
     
     Q =
     
        0.18476   1.17519   0.41170
        0.46190   0.25183   0.51462
     
     X =
     
        12.6089    8.8262    2.5218
         6.3044    1.8913    3.1522
</pre>
   <!-- This file has been automatically generated from references.txi -->
<!-- by proc.m. Do not edit this file, all changes will be lost -->
<!-- *- texinfo -*- -->
<!-- Copyright (C) 2012 Moreno Marzolla -->
<!-- This file is part of the queueing toolbox, a Queueing Networks -->
<!-- analysis package for GNU Octave. -->
<!-- The queueing toolbox is free software; you can redistribute it -->
<!-- and/or modify it under the terms of the GNU General Public License -->
<!-- as published by the Free Software Foundation; either version 3 of -->
<!-- the License, or (at your option) any later version. -->
<!-- The queueing toolbox is distributed in the hope that it will be -->
<!-- useful, but WITHOUT ANY WARRANTY; without even the implied warranty -->
<!-- of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with the queueing toolbox; see the file COPYING.  If not, see -->
<!-- <http://www.gnu.org/licenses/>. -->
<div class="node">
<a name="References"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Copying">Copying</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Queueing-Networks">Queueing Networks</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 References</h2>

     <dl>
<dt>[Aky88]<dd>Ian F. Akyildiz, <cite>Mean Value Analysis for Blocking Queueing
Networks</cite>, IEEE Transactions on Software Engineering, vol. 14, n. 2,
april 1988, pp. 418&ndash;428.  DOI <a href="http://dx.doi.org/10.1109/32.4663">10.1109/32.4663</a>

     <br><dt>[Bar79]<dd>Y. Bard, <cite>Some Extensions to Multiclass Queueing Network Analysis</cite>,
proc. 4th Int. Symp. on Modelling and Performance Evaluation of
Computer Systems, feb. 1979, pp. 51&ndash;62.

     <br><dt>[BCMP75]<dd>F. Baskett, K. Mani Chandy, R. R. Muntz, and F. G. Palacios. 1975. <cite>Open, Closed, and Mixed Networks of Queues with Different Classes of Customers</cite>. J. ACM 22, 2 (April 1975), 248260, DOI <a href="http://doi.acm.org/10.1145/321879.321887">10.1145/321879.321887</a>

     <br><dt>[BGMT98]<dd>G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, <cite>Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications</cite>, Wiley,
1998.

     <br><dt>[Buz73]<dd>J. P. Buzen, <cite>Computational Algorithms for Closed Queueing
Networks with Exponential Servers</cite>, Communications of the ACM, volume
16, number 9, september 1973,
pp. 527&ndash;531. DOI <a href="http://doi.acm.org/10.1145/362342.362345">10.1145/362342.362345</a>

     <br><dt>[C08]<dd>G. Casale, <cite>A note on stable flow-equivalent aggregation in
closed networks</cite>. Queueing Syst. Theory Appl., 60:193-202, December
2008, DOI <a href="http://dx.doi.org/10.1007/s11134-008-9093-6">10.1007/s11134-008-9093-6</a>

     <br><dt>[CMS08]<dd>G. Casale, R. R. Muntz, G. Serazzi,
<cite>Geometric Bounds: a Non-Iterative Analysis Technique for Closed
Queueing Networks</cite>, IEEE Transactions on Computers, 57(6):780-794,
June 2008. DOI <a href="http://doi.ieeecomputersociety.org/10.1109/TC.2008.37">10.1109/TC.2008.37</a>

     <br><dt><a name="GrSn97"></a>[GrSn97]<dd>C. M. Grinstead, J. L. Snell, (July 1997). <cite>Introduction
to Probability</cite>. American Mathematical Society. ISBN 978-0821807491;
this excellent textbook is <a href="http://www.dartmouth.edu/~chance/teaching_aids/books_articles/probability_book/amsbook.mac.pdf">available in PDF format</a>
and can be used under the terms of the <a href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License (FDL)</a>

     <br><dt>[Jac04]<dd>J. R. Jackson, <cite>Jobshop-Like Queueing Systems</cite>, Vol. 50, No. 12, Ten Most Influential Titles of "Management Science's" First Fifty Years (Dec., 2004), pp. 1796-1802, <a href="http://www.jstor.org/stable/30046149">available online</a>

     <br><dt>[Jai91]<dd>R. Jain, <cite>The Art of Computer Systems Performance Analysis</cite>,
Wiley, 1991, p. 577.

     <br><dt>[HsLa87]<dd>C. H. Hsieh and S. Lam,
<cite>Two classes of performance bounds for closed queueing networks</cite>,
PEVA, vol. 7, n. 1, pp. 3&ndash;30, 1987

     <br><dt>[Ker84]<dd>T. Kerola, <cite>The Composite Bound Method (CBM) for Computing
Throughput Bounds in Multiple Class Environments</cite>,
<a href="http://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1394&amp;context=cstech">Technical Report CSD-TR-475</a>, Department of Computer Sciences, Purdue
University, mar 13, 1984 (Revised aug 27, 1984).

     <br><dt>[LZGS84]<dd>E. D. Lazowska, J. Zahorjan, G. Scott Graham, and K. C. 
Sevcik, <cite>Quantitative System Performance: Computer System
Analysis Using Queueing Network Models</cite>, Prentice Hall,
1984. <a href="http://www.cs.washington.edu/homes/lazowska/qsp/">available online</a>.

     <br><dt>[ReKo76]<dd>M. Reiser, H. Kobayashi, <cite>On The Convolution Algorithm for
Separable Queueing Networks</cite>, In Proceedings of the 1976 ACM
SIGMETRICS Conference on Computer Performance Modeling Measurement and
Evaluation (Cambridge, Massachusetts, United States, March 29&ndash;31,
1976). SIGMETRICS '76. ACM, New York, NY,
pp. 109&ndash;117. DOI <a href="http://doi.acm.org/10.1145/800200.806187">10.1145/800200.806187</a>

     <br><dt>[ReLa80]<dd>M. Reiser and S. S. Lavenberg, <cite>Mean-Value Analysis of Closed
Multichain Queuing Networks</cite>, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313&ndash;322. DOI <a href="http://doi.acm.org/10.1145/322186.322195">10.1145/322186.322195</a>

     <br><dt>[Sch79]<dd>P. Schweitzer, <cite>Approximate Analysis of Multiclass Closed Networks of
Queues</cite>, Proc. Int. Conf. on Stochastic Control and Optimization, jun
1979, pp. 2529

     <br><dt>[Sch81]<dd>H. Schwetman, <cite>Some Computational
Aspects of Queueing Network Models</cite>, <a href="http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-354.pdf">Technical Report CSD-TR-354</a>,
Department of Computer Sciences, Purdue University, feb, 1981
(revised).

     <br><dt><a name="Sch82"></a>[Sch82]<dd>H. Schwetman, <cite>Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models</cite>, <a href="http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-355.pdf">Technical Report CSD-TR-355</a>,
Department of Computer Sciences, Purdue University, feb 15, 1982.

     <br><dt>[Tij03]<dd>H. C. Tijms, <cite>A first course in stochastic models</cite>,
John Wiley and Sons, 2003, ISBN 0471498807, ISBN 9780471498803,
DOI <a href="http://dx.doi.org/10.1002/047001363X">10.1002/047001363X</a>

     <br><dt>[ZaWo81]<dd>J. Zahorjan and E. Wong, <cite>The solution of separable queueing
network models using mean value analysis</cite>. SIGMETRICS
Perform. Eval. Rev. 10, 3 (Sep. 1981), 80-85. DOI
DOI <a href="http://doi.acm.org/10.1145/1010629.805477">10.1145/1010629.805477</a>

</dl>

<!-- Appendix starts here -->
<!-- This file has been automatically generated from gpl.txi -->
<!-- by proc.m. Do not edit this file, all changes will be lost -->
<div class="node">
<a name="Copying"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Concept-Index">Concept Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#References">References</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix A GNU GENERAL PUBLIC LICENSE</h2>

<p><a name="index-warranty-373"></a><a name="index-copyright-374"></a>
<div align="center">Version 3, 29 June 2007</div>

<pre class="display">     Copyright &copy; 2007 Free Software Foundation, Inc. <a href="http://fsf.org/">http://fsf.org/</a>
     
     Everyone is permitted to copy and distribute verbatim copies of this
     license document, but changing it is not allowed.
</pre>
<h3 class="heading">Preamble</h3>

<p>The GNU General Public License is a free, copyleft license for
software and other kinds of works.

   <p>The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom
to share and change all versions of a program&mdash;to make sure it remains
free software for all its users.  We, the Free Software Foundation,
use the GNU General Public License for most of our software; it
applies also to any other work released this way by its authors.  You
can apply it to your programs, too.

   <p>When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

   <p>To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you
have certain responsibilities if you distribute copies of the
software, or if you modify it: responsibilities to respect the freedom
of others.

   <p>For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too,
receive or can get the source code.  And you must show them these
terms so they know their rights.

   <p>Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

   <p>For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

   <p>Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the
manufacturer can do so.  This is fundamentally incompatible with the
aim of protecting users' freedom to change the software.  The
systematic pattern of such abuse occurs in the area of products for
individuals to use, which is precisely where it is most unacceptable. 
Therefore, we have designed this version of the GPL to prohibit the
practice for those products.  If such problems arise substantially in
other domains, we stand ready to extend this provision to those
domains in future versions of the GPL, as needed to protect the
freedom of users.

   <p>Finally, every program is threatened constantly by software patents. 
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish
to avoid the special danger that patents applied to a free program
could make it effectively proprietary.  To prevent this, the GPL
assures that patents cannot be used to render the program non-free.

   <p>The precise terms and conditions for copying, distribution and
modification follow.

<h3 class="heading">TERMS AND CONDITIONS</h3>

     <ol type=1 start=0>
<li>Definitions.

     <p>&ldquo;This License&rdquo; refers to version 3 of the GNU General Public License.

     <p>&ldquo;Copyright&rdquo; also means copyright-like laws that apply to other kinds
of works, such as semiconductor masks.

     <p>&ldquo;The Program&rdquo; refers to any copyrightable work licensed under this
License.  Each licensee is addressed as &ldquo;you&rdquo;.  &ldquo;Licensees&rdquo; and
&ldquo;recipients&rdquo; may be individuals or organizations.

     <p>To &ldquo;modify&rdquo; a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of
an exact copy.  The resulting work is called a &ldquo;modified version&rdquo; of
the earlier work or a work &ldquo;based on&rdquo; the earlier work.

     <p>A &ldquo;covered work&rdquo; means either the unmodified Program or a work based
on the Program.

     <p>To &ldquo;propagate&rdquo; a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

     <p>To &ldquo;convey&rdquo; a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user
through a computer network, with no transfer of a copy, is not
conveying.

     <p>An interactive user interface displays &ldquo;Appropriate Legal Notices&rdquo; to
the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

     <li>Source Code.

     <p>The &ldquo;source code&rdquo; for a work means the preferred form of the work for
making modifications to it.  &ldquo;Object code&rdquo; means any non-source form
of a work.

     <p>A &ldquo;Standard Interface&rdquo; means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

     <p>The &ldquo;System Libraries&rdquo; of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
&ldquo;Major Component&rdquo;, in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

     <p>The &ldquo;Corresponding Source&rdquo; for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

     <p>The Corresponding Source need not include anything that users can
regenerate automatically from other parts of the Corresponding Source.

     <p>The Corresponding Source for a work in source code form is that same
work.

     <li>Basic Permissions.

     <p>All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

     <p>You may make, run and propagate covered works that you do not convey,
without conditions so long as your license otherwise remains in force. 
You may convey covered works to others for the sole purpose of having
them make modifications exclusively for you, or provide you with
facilities for running those works, provided that you comply with the
terms of this License in conveying all material for which you do not
control copyright.  Those thus making or running the covered works for
you must do so exclusively on your behalf, under your direction and
control, on terms that prohibit them from making any copies of your
copyrighted material outside their relationship with you.

     <p>Conveying under any other circumstances is permitted solely under the
conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

     <li>Protecting Users' Legal Rights From Anti-Circumvention Law.

     <p>No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

     <p>When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such
circumvention is effected by exercising rights under this License with
respect to the covered work, and you disclaim any intention to limit
operation or modification of the work as a means of enforcing, against
the work's users, your or third parties' legal rights to forbid
circumvention of technological measures.

     <li>Conveying Verbatim Copies.

     <p>You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

     <p>You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

     <li>Conveying Modified Source Versions.

     <p>You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these
conditions:

          <ol type=a start=1>
<li>The work must carry prominent notices stating that you modified it,
and giving a relevant date.

          <li>The work must carry prominent notices stating that it is released
under this License and any conditions added under section 7.  This
requirement modifies the requirement in section 4 to &ldquo;keep intact all
notices&rdquo;.

          <li>You must license the entire work, as a whole, under this License to
anyone who comes into possession of a copy.  This License will
therefore apply, along with any applicable section 7 additional terms,
to the whole of the work, and all its parts, regardless of how they
are packaged.  This License gives no permission to license the work in
any other way, but it does not invalidate such permission if you have
separately received it.

          <li>If the work has interactive user interfaces, each must display
Appropriate Legal Notices; however, if the Program has interactive
interfaces that do not display Appropriate Legal Notices, your work
need not make them do so.
          </ol>

     <p>A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
&ldquo;aggregate&rdquo; if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

     <li>Conveying Non-Source Forms.

     <p>You may convey a covered work in object code form under the terms of
sections 4 and 5, provided that you also convey the machine-readable
Corresponding Source under the terms of this License, in one of these
ways:

          <ol type=a start=1>
<li>Convey the object code in, or embodied in, a physical product
(including a physical distribution medium), accompanied by the
Corresponding Source fixed on a durable physical medium customarily
used for software interchange.

          <li>Convey the object code in, or embodied in, a physical product
(including a physical distribution medium), accompanied by a written
offer, valid for at least three years and valid for as long as you
offer spare parts or customer support for that product model, to give
anyone who possesses the object code either (1) a copy of the
Corresponding Source for all the software in the product that is
covered by this License, on a durable physical medium customarily used
for software interchange, for a price no more than your reasonable
cost of physically performing this conveying of source, or (2) access
to copy the Corresponding Source from a network server at no charge.

          <li>Convey individual copies of the object code with a copy of the written
offer to provide the Corresponding Source.  This alternative is
allowed only occasionally and noncommercially, and only if you
received the object code with such an offer, in accord with subsection
6b.

          <li>Convey the object code by offering access from a designated place
(gratis or for a charge), and offer equivalent access to the
Corresponding Source in the same way through the same place at no
further charge.  You need not require recipients to copy the
Corresponding Source along with the object code.  If the place to copy
the object code is a network server, the Corresponding Source may be
on a different server (operated by you or a third party) that supports
equivalent copying facilities, provided you maintain clear directions
next to the object code saying where to find the Corresponding Source. 
Regardless of what server hosts the Corresponding Source, you remain
obligated to ensure that it is available for as long as needed to
satisfy these requirements.

          <li>Convey the object code using peer-to-peer transmission, provided you
inform other peers where the object code and Corresponding Source of
the work are being offered to the general public at no charge under
subsection 6d.

          </ol>

     <p>A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

     <p>A &ldquo;User Product&rdquo; is either (1) a &ldquo;consumer product&rdquo;, which means any
tangible personal property which is normally used for personal,
family, or household purposes, or (2) anything designed or sold for
incorporation into a dwelling.  In determining whether a product is a
consumer product, doubtful cases shall be resolved in favor of
coverage.  For a particular product received by a particular user,
&ldquo;normally used&rdquo; refers to a typical or common use of that class of
product, regardless of the status of the particular user or of the way
in which the particular user actually uses, or expects or is expected
to use, the product.  A product is a consumer product regardless of
whether the product has substantial commercial, industrial or
non-consumer uses, unless such uses represent the only significant
mode of use of the product.

     <p>&ldquo;Installation Information&rdquo; for a User Product means any methods,
procedures, authorization keys, or other information required to
install and execute modified versions of a covered work in that User
Product from a modified version of its Corresponding Source.  The
information must suffice to ensure that the continued functioning of
the modified object code is in no case prevented or interfered with
solely because modification has been made.

     <p>If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

     <p>The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or
updates for a work that has been modified or installed by the
recipient, or for the User Product in which it has been modified or
installed.  Access to a network may be denied when the modification
itself materially and adversely affects the operation of the network
or violates the rules and protocols for communication across the
network.

     <p>Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

     <li>Additional Terms.

     <p>&ldquo;Additional permissions&rdquo; are terms that supplement the terms of this
License by making exceptions from one or more of its conditions. 
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

     <p>When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

     <p>Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders
of that material) supplement the terms of this License with terms:

          <ol type=a start=1>
<li>Disclaiming warranty or limiting liability differently from the terms
of sections 15 and 16 of this License; or

          <li>Requiring preservation of specified reasonable legal notices or author
attributions in that material or in the Appropriate Legal Notices
displayed by works containing it; or

          <li>Prohibiting misrepresentation of the origin of that material, or
requiring that modified versions of such material be marked in
reasonable ways as different from the original version; or

          <li>Limiting the use for publicity purposes of names of licensors or
authors of the material; or

          <li>Declining to grant rights under trademark law for use of some trade
names, trademarks, or service marks; or

          <li>Requiring indemnification of licensors and authors of that material by
anyone who conveys the material (or modified versions of it) with
contractual assumptions of liability to the recipient, for any
liability that these contractual assumptions directly impose on those
licensors and authors.
          </ol>

     <p>All other non-permissive additional terms are considered &ldquo;further
restrictions&rdquo; within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

     <p>If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

     <p>Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions; the
above requirements apply either way.

     <li>Termination.

     <p>You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

     <p>However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.

     <p>Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

     <p>Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

     <li>Acceptance Not Required for Having Copies.

     <p>You are not required to accept this License in order to receive or run
a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

     <li>Automatic Licensing of Downstream Recipients.

     <p>Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

     <p>An &ldquo;entity transaction&rdquo; is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

     <p>You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

     <li>Patents.

     <p>A &ldquo;contributor&rdquo; is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's &ldquo;contributor version&rdquo;.

     <p>A contributor's &ldquo;essential patent claims&rdquo; are all patent claims owned
or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, &ldquo;control&rdquo; includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

     <p>Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

     <p>In the following three paragraphs, a &ldquo;patent license&rdquo; is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To &ldquo;grant&rdquo; such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

     <p>If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  &ldquo;Knowingly relying&rdquo; means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

     <p>If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

     <p>A patent license is &ldquo;discriminatory&rdquo; if it does not include within the
scope of its coverage, prohibits the exercise of, or is conditioned on
the non-exercise of one or more of the rights that are specifically
granted under this License.  You may not convey a covered work if you
are a party to an arrangement with a third party that is in the
business of distributing software, under which you make payment to the
third party based on the extent of your activity of conveying the
work, and under which the third party grants, to any of the parties
who would receive the covered work from you, a discriminatory patent
license (a) in connection with copies of the covered work conveyed by
you (or copies made from those copies), or (b) primarily for and in
connection with specific products or compilations that contain the
covered work, unless you entered into that arrangement, or that patent
license was granted, prior to 28 March 2007.

     <p>Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

     <li>No Surrender of Others' Freedom.

     <p>If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey
a covered work so as to satisfy simultaneously your obligations under
this License and any other pertinent obligations, then as a
consequence you may not convey it at all.  For example, if you agree
to terms that obligate you to collect a royalty for further conveying
from those to whom you convey the Program, the only way you could
satisfy both those terms and this License would be to refrain entirely
from conveying the Program.

     <li>Use with the GNU Affero General Public License.

     <p>Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

     <li>Revised Versions of this License.

     <p>The Free Software Foundation may publish revised and/or new versions
of the GNU General Public License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

     <p>Each version is given a distinguishing version number.  If the Program
specifies that a certain numbered version of the GNU General Public
License &ldquo;or any later version&rdquo; applies to it, you have the option of
following the terms and conditions either of that numbered version or
of any later version published by the Free Software Foundation.  If
the Program does not specify a version number of the GNU General
Public License, you may choose any version ever published by the Free
Software Foundation.

     <p>If the Program specifies that a proxy can decide which future versions
of the GNU General Public License can be used, that proxy's public
statement of acceptance of a version permanently authorizes you to
choose that version for the Program.

     <p>Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

     <li>Disclaimer of Warranty.

     <p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM &ldquo;AS IS&rdquo; WITHOUT
WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
CORRECTION.

     <li>Limitation of Liability.

     <p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR
CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR
LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM
TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER
PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

     <li>Interpretation of Sections 15 and 16.

     <p>If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

     </ol>

<h3 class="heading">END OF TERMS AND CONDITIONS</h3>

<h3 class="heading">How to Apply These Terms to Your New Programs</h3>

<p>If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   <p>To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the &ldquo;copyright&rdquo; line and a pointer to where the full notice is found.

<pre class="smallexample">     <var>one line to give the program's name and a brief idea of what it does.</var>
     Copyright (C) <var>year</var> <var>name of author</var>
     
     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or (at
     your option) any later version.
     
     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.
     
     You should have received a copy of the GNU General Public License
     along with this program.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.
</pre>
   <p>Also add information on how to contact you by electronic and paper mail.

   <p>If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

<pre class="smallexample">     <var>program</var> Copyright (C) <var>year</var> <var>name of author</var>
     This program comes with ABSOLUTELY NO WARRANTY; for details type &lsquo;<samp><span class="samp">show w</span></samp>&rsquo;.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type &lsquo;<samp><span class="samp">show c</span></samp>&rsquo; for details.
</pre>
   <p>The hypothetical commands &lsquo;<samp><span class="samp">show w</span></samp>&rsquo; and &lsquo;<samp><span class="samp">show c</span></samp>&rsquo; should show
the appropriate parts of the General Public License.  Of course, your
program's commands might be different; for a GUI interface, you would
use an &ldquo;about box&rdquo;.

   <p>You should also get your employer (if you work as a programmer) or school,
if any, to sign a &ldquo;copyright disclaimer&rdquo; for the program, if necessary. 
For more information on this, and how to apply and follow the GNU GPL, see
<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.

   <p>The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use
the GNU Lesser General Public License instead of this License.  But
first, please read <a href="http://www.gnu.org/philosophy/why-not-lgpl.html">http://www.gnu.org/philosophy/why-not-lgpl.html</a>.

<!-- INDEX -->
<div class="node">
<a name="Concept-Index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Function-Index">Function Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Copying">Copying</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Concept Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-absorption-probabilities_002c-DTMC-33">absorption probabilities, DTMC</a>: <a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></li>
<li><a href="#index-approximate-MVA-170">approximate MVA</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-asymmetric-_0040math_007bM_002fM_002fm_007d-system-112">asymmetric M/M/m system</a>: <a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></li>
<li><a href="#index-asymptotic-bounds-308">asymptotic bounds</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-balanced-system-bounds-333">balanced system bounds</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-BCMP-network-128">BCMP network</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-birth_002ddeath-process_002c-CTMC-57">birth-death process, CTMC</a>: <a href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a></li>
<li><a href="#index-birth_002ddeath-process_002c-DTMC-17">birth-death process, DTMC</a>: <a href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a></li>
<li><a href="#index-blocking-queueing-network-201">blocking queueing network</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-bounds_002c-asymptotic-296">bounds, asymptotic</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-bounds_002c-balanced-system-325">bounds, balanced system</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-bounds_002c-composite-348">bounds, composite</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-bounds_002c-geometric-367">bounds, geometric</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-bounds_002c-PB-355">bounds, PB</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-closed-multiclass-network-318">closed multiclass network</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-closed-network-316">closed network</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-closed-network-188">closed network</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-closed-network_002c-approximate-analysis-172">closed network, approximate analysis</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-closed-network_002c-finite-capacity-202">closed network, finite capacity</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-closed-network_002c-multiple-classes-290">closed network, multiple classes</a>: <a href="#Generic-Algorithms">Generic Algorithms</a></li>
<li><a href="#index-closed-network_002c-multiple-classes-226">closed network, multiple classes</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-closed-network_002c-multiple-classes-209">closed network, multiple classes</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-closed-network_002c-single-class-309">closed network, single class</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-closed-network_002c-single-class-289">closed network, single class</a>: <a href="#Generic-Algorithms">Generic Algorithms</a></li>
<li><a href="#index-closed-network_002c-single-class-137">closed network, single class</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-CMVA-161">CMVA</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-composite-bounds-349">composite bounds</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-conditional-MVA-_0028CMVA_0029-158">conditional MVA (CMVA)</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-continuous-time-Markov-chain-81">continuous time Markov chain</a>: <a href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a></li>
<li><a href="#index-continuous-time-Markov-chain-70">continuous time Markov chain</a>: <a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></li>
<li><a href="#index-continuous-time-Markov-chain-66">continuous time Markov chain</a>: <a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a></li>
<li><a href="#index-continuous-time-Markov-chain-55">continuous time Markov chain</a>: <a href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a></li>
<li><a href="#index-continuous-time-Markov-chain-49">continuous time Markov chain</a>: <a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></li>
<li><a href="#index-convolution-algorithm-181">convolution algorithm</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-copyright-374">copyright</a>: <a href="#Copying">Copying</a></li>
<li><a href="#index-CTMC-80">CTMC</a>: <a href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a></li>
<li><a href="#index-CTMC-71">CTMC</a>: <a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></li>
<li><a href="#index-CTMC-67">CTMC</a>: <a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a></li>
<li><a href="#index-CTMC-56">CTMC</a>: <a href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a></li>
<li><a href="#index-CTMC-52">CTMC</a>: <a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></li>
<li><a href="#index-deprecated-functions-1">deprecated functions</a>: <a href="#Naming-Conventions">Naming Conventions</a></li>
<li><a href="#index-discrete-time-Markov-chain-41">discrete time Markov chain</a>: <a href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a></li>
<li><a href="#index-discrete-time-Markov-chain-36">discrete time Markov chain</a>: <a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></li>
<li><a href="#index-discrete-time-Markov-chain-27">discrete time Markov chain</a>: <a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a></li>
<li><a href="#index-discrete-time-Markov-chain-22">discrete time Markov chain</a>: <a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a></li>
<li><a href="#index-discrete-time-Markov-chain-16">discrete time Markov chain</a>: <a href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a></li>
<li><a href="#index-discrete-time-Markov-chain-9">discrete time Markov chain</a>: <a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></li>
<li><a href="#index-discrete-time-Markov-chain-5">discrete time Markov chain</a>: <a href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a></li>
<li><a href="#index-DTMC-43">DTMC</a>: <a href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a></li>
<li><a href="#index-DTMC-35">DTMC</a>: <a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></li>
<li><a href="#index-DTMC-29">DTMC</a>: <a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a></li>
<li><a href="#index-DTMC-21">DTMC</a>: <a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a></li>
<li><a href="#index-DTMC-15">DTMC</a>: <a href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a></li>
<li><a href="#index-DTMC-10">DTMC</a>: <a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></li>
<li><a href="#index-DTMC-4">DTMC</a>: <a href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a></li>
<li><a href="#index-expected-sojourn-time_002c-CTMC-61">expected sojourn time, CTMC</a>: <a href="#Expected-sojourn-times-_0028CTMC_0029">Expected sojourn times (CTMC)</a></li>
<li><a href="#index-expected-sojourn-times_002c-DTMC-20">expected sojourn times, DTMC</a>: <a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a></li>
<li><a href="#index-first-passage-times-39">first passage times</a>: <a href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a></li>
<li><a href="#index-first-passage-times_002c-CTMC-79">first passage times, CTMC</a>: <a href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a></li>
<li><a href="#index-fundamental-matrix-34">fundamental matrix</a>: <a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></li>
<li><a href="#index-geometric-bounds-368">geometric bounds</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-load_002ddependent-service-center-151">load-dependent service center</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-g_t_0040math_007bM_002fG_002f1_007d-system-118">M/G/1 system</a>: <a href="#The-M_002fG_002f1-System">The M/G/1 System</a></li>
<li><a href="#index-g_t_0040math_007bM_002fH_005fm_002f1_007d-system-120">M/H_m/1 system</a>: <a href="#The-M_002fHm_002f1-System">The M/Hm/1 System</a></li>
<li><a href="#index-g_t_0040math_007bM_002fM_002f1_007d-system-84">M/M/1 system</a>: <a href="#The-M_002fM_002f1-System">The M/M/1 System</a></li>
<li><a href="#index-g_t_0040math_007bM_002fM_002f1_002fK_007d-system-104">M/M/1/K system</a>: <a href="#The-M_002fM_002f1_002fK-System">The M/M/1/K System</a></li>
<li><a href="#index-g_t_0040math_007bM_002fM_002f_007dinf-system-97">M/M/inf system</a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-g_t_0040math_007bM_002fM_002fm_007d-system-91">M/M/m system</a>: <a href="#The-M_002fM_002fm-System">The M/M/m System</a></li>
<li><a href="#index-g_t_0040math_007bM_002fM_002fm_002fK_007d-system-106">M/M/m/K system</a>: <a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-82">Markov chain, continuous time</a>: <a href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-69">Markov chain, continuous time</a>: <a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-64">Markov chain, continuous time</a>: <a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-60">Markov chain, continuous time</a>: <a href="#Expected-sojourn-times-_0028CTMC_0029">Expected sojourn times (CTMC)</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-54">Markov chain, continuous time</a>: <a href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-48">Markov chain, continuous time</a>: <a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></li>
<li><a href="#index-Markov-chain_002c-continuous-time-45">Markov chain, continuous time</a>: <a href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a></li>
<li><a href="#index-Markov-chain_002c-discrete-time-42">Markov chain, discrete time</a>: <a href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a></li>
<li><a href="#index-Markov-chain_002c-discrete-time-37">Markov chain, discrete time</a>: <a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></li>
<li><a href="#index-Markov-chain_002c-discrete-time-28">Markov chain, discrete time</a>: <a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a></li>
<li><a href="#index-Markov-chain_002c-discrete-time-23">Markov chain, discrete time</a>: <a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a></li>
<li><a href="#index-Markov-chain_002c-discrete-time-14">Markov chain, discrete time</a>: <a href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a></li>
<li><a href="#index-Markov-chain_002c-discrete-time-8">Markov chain, discrete time</a>: <a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></li>
<li><a href="#index-Markov-chain_002c-discrete-time-3">Markov chain, discrete time</a>: <a href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a></li>
<li><a href="#index-Markov-chain_002c-state-occupancy-probabilities-50">Markov chain, state occupancy probabilities</a>: <a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></li>
<li><a href="#index-Markov-chain_002c-stationary-probabilities-11">Markov chain, stationary probabilities</a>: <a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></li>
<li><a href="#index-Markov-chain_002c-transient-probabilities-12">Markov chain, transient probabilities</a>: <a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></li>
<li><a href="#index-mean-recurrence-times-40">mean recurrence times</a>: <a href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a></li>
<li><a href="#index-mean-time-to-absorption_002c-CTMC-72">mean time to absorption, CTMC</a>: <a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></li>
<li><a href="#index-mean-time-to-absorption_002c-DTMC-32">mean time to absorption, DTMC</a>: <a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></li>
<li><a href="#index-Mean-Value-Analysis_002c-conditional-_0028CMVA_0029-159">Mean Value Analysis, conditional (CMVA)</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Mean-Value-Analysys-_0028MVA_0029-241">Mean Value Analysys (MVA)</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Mean-Value-Analysys-_0028MVA_0029-136">Mean Value Analysys (MVA)</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Mean-Value-Analysys-_0028MVA_0029_002c-approximate-259">Mean Value Analysys (MVA), approximate</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Mean-Value-Analysys-_0028MVA_0029_002c-approximate-168">Mean Value Analysys (MVA), approximate</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-mixed-network-271">mixed network</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-multiclass-network_002c-closed-317">multiclass network, closed</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-multiclass-network_002c-closed-243">multiclass network, closed</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-multiclass-network_002c-open-302">multiclass network, open</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-multiclass-network_002c-open-219">multiclass network, open</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-MVA-149">MVA</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-MVA_002c-approximate-260">MVA, approximate</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-MVA_002c-approximate-169">MVA, approximate</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-MVABLO-203">MVABLO</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-normalization-constant-138">normalization constant</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-open-network-297">open network</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-open-network-292">open network</a>: <a href="#Generic-Algorithms">Generic Algorithms</a></li>
<li><a href="#index-open-network_002c-multiple-classes-218">open network, multiple classes</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-open-network_002c-single-class-127">open network, single class</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-PB-bounds-356">PB bounds</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-population-mix-225">population mix</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-queueing-network-with-blocking-200">queueing network with blocking</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-queueing-networks-121">queueing networks</a>: <a href="#Queueing-Networks">Queueing Networks</a></li>
<li><a href="#index-RS-blocking-212">RS blocking</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-stationary-probabilities-51">stationary probabilities</a>: <a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></li>
<li><a href="#index-time_002dalveraged-sojourn-time_002c-CTMC-65">time-alveraged sojourn time, CTMC</a>: <a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a></li>
<li><a href="#index-time_002dalveraged-sojourn-time_002c-DTMC-26">time-alveraged sojourn time, DTMC</a>: <a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a></li>
<li><a href="#index-traffic-intensity-98">traffic intensity</a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-warranty-373">warranty</a>: <a href="#Copying">Copying</a></li>
   </ul><div class="node">
<a name="Function-Index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Author-Index">Author Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Concept-Index">Concept Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Function Index</h2>



<ul class="index-fn" compact>
<li><a href="#index-ctmc-46"><code>ctmc</code></a>: <a href="#State-occupancy-probabilities-_0028CTMC_0029">State occupancy probabilities (CTMC)</a></li>
<li><a href="#index-ctmcbd-53"><code>ctmcbd</code></a>: <a href="#Birth_002ddeath-process-_0028CTMC_0029">Birth-death process (CTMC)</a></li>
<li><a href="#index-ctmcchkQ-44"><code>ctmcchkQ</code></a>: <a href="#Continuous_002dTime-Markov-Chains">Continuous-Time Markov Chains</a></li>
<li><a href="#index-ctmcexps-58"><code>ctmcexps</code></a>: <a href="#Expected-sojourn-times-_0028CTMC_0029">Expected sojourn times (CTMC)</a></li>
<li><a href="#index-ctmcfpt-77"><code>ctmcfpt</code></a>: <a href="#First-passage-times-_0028CTMC_0029">First passage times (CTMC)</a></li>
<li><a href="#index-ctmcmtta-68"><code>ctmcmtta</code></a>: <a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></li>
<li><a href="#index-ctmctaexps-62"><code>ctmctaexps</code></a>: <a href="#Time_002daveraged-expected-sojourn-times-_0028CTMC_0029">Time-averaged expected sojourn times (CTMC)</a></li>
<li><a href="#index-dtmc-6"><code>dtmc</code></a>: <a href="#State-occupancy-probabilities-_0028DTMC_0029">State occupancy probabilities (DTMC)</a></li>
<li><a href="#index-dtmcbd-13"><code>dtmcbd</code></a>: <a href="#Birth_002ddeath-process-_0028DTMC_0029">Birth-death process (DTMC)</a></li>
<li><a href="#index-dtmcchkP-2"><code>dtmcchkP</code></a>: <a href="#Discrete_002dTime-Markov-Chains">Discrete-Time Markov Chains</a></li>
<li><a href="#index-dtmcexps-18"><code>dtmcexps</code></a>: <a href="#Expected-number-of-visits-_0028DTMC_0029">Expected number of visits (DTMC)</a></li>
<li><a href="#index-dtmcfpt-38"><code>dtmcfpt</code></a>: <a href="#First-passage-times-_0028DTMC_0029">First passage times (DTMC)</a></li>
<li><a href="#index-dtmcmtta-30"><code>dtmcmtta</code></a>: <a href="#Mean-time-to-absorption-_0028DTMC_0029">Mean time to absorption (DTMC)</a></li>
<li><a href="#index-dtmctaexps-24"><code>dtmctaexps</code></a>: <a href="#Time_002daveraged-expected-sojourn-times-_0028DTMC_0029">Time-averaged expected sojourn times (DTMC)</a></li>
<li><a href="#index-qnclosed-288"><code>qnclosed</code></a>: <a href="#Generic-Algorithms">Generic Algorithms</a></li>
<li><a href="#index-qncmaba-310"><code>qncmaba</code></a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-qncmbsb-334"><code>qncmbsb</code></a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-qncmcb-344"><code>qncmcb</code></a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-qncmmva-234"><code>qncmmva</code></a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-qncmmvaap-254"><code>qncmmvaap</code></a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-qncmnpop-229"><code>qncmnpop</code></a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-qncmpopmix-224"><code>qncmpopmix</code></a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-qncmvisits-213"><code>qncmvisits</code></a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-qncsaba-303"><code>qncsaba</code></a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-qncsbsb-327"><code>qncsbsb</code></a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-qncscmva-156"><code>qncscmva</code></a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-qncsconv-177"><code>qncsconv</code></a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-qncsconvld-187"><code>qncsconvld</code></a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-qncsgb-363"><code>qncsgb</code></a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-qncsmva-133"><code>qncsmva</code></a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-qncsmvaap-163"><code>qncsmvaap</code></a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-qncsmvablo-199"><code>qncsmvablo</code></a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-qncsmvald-146"><code>qncsmvald</code></a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-qncspb-351"><code>qncspb</code></a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-qncsvisits-122"><code>qncsvisits</code></a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-qnmarkov-205"><code>qnmarkov</code></a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-qnmix-269"><code>qnmix</code></a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-qnmknode-277"><code>qnmknode</code></a>: <a href="#Generic-Algorithms">Generic Algorithms</a></li>
<li><a href="#index-qnom-216"><code>qnom</code></a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-qnomaba-298"><code>qnomaba</code></a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-qnomvisits-215"><code>qnomvisits</code></a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-qnopen-291"><code>qnopen</code></a>: <a href="#Generic-Algorithms">Generic Algorithms</a></li>
<li><a href="#index-qnos-125"><code>qnos</code></a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-qnosaba-293"><code>qnosaba</code></a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-qnosbsb-323"><code>qnosbsb</code></a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-qnosvisits-124"><code>qnosvisits</code></a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-qnsolve-284"><code>qnsolve</code></a>: <a href="#Generic-Algorithms">Generic Algorithms</a></li>
<li><a href="#index-qsammm-111"><code>qsammm</code></a>: <a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></li>
<li><a href="#index-qsmg1-117"><code>qsmg1</code></a>: <a href="#The-M_002fG_002f1-System">The M/G/1 System</a></li>
<li><a href="#index-qsmh1-119"><code>qsmh1</code></a>: <a href="#The-M_002fHm_002f1-System">The M/Hm/1 System</a></li>
<li><a href="#index-qsmm1-83"><code>qsmm1</code></a>: <a href="#The-M_002fM_002f1-System">The M/M/1 System</a></li>
<li><a href="#index-qsmm1k-103"><code>qsmm1k</code></a>: <a href="#The-M_002fM_002f1_002fK-System">The M/M/1/K System</a></li>
<li><a href="#index-qsmminf-96"><code>qsmminf</code></a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-qsmmm-89"><code>qsmmm</code></a>: <a href="#The-M_002fM_002fm-System">The M/M/m System</a></li>
<li><a href="#index-qsmmmk-105"><code>qsmmmk</code></a>: <a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></li>
   </ul><div class="node">
<a name="Author-Index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Function-Index">Function Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Author Index</h2>



<ul class="index-au" compact>
<li><a href="#index-Akyildiz_002c-I_002e-F_002e-204">Akyildiz, I. F.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Bard_002c-Y_002e-263">Bard, Y.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Bolch_002c-G_002e-246">Bolch, G.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Bolch_002c-G_002e-129">Bolch, G.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Bolch_002c-G_002e-113">Bolch, G.</a>: <a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></li>
<li><a href="#index-Bolch_002c-G_002e-107">Bolch, G.</a>: <a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></li>
<li><a href="#index-Bolch_002c-G_002e-99">Bolch, G.</a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-Bolch_002c-G_002e-92">Bolch, G.</a>: <a href="#The-M_002fM_002fm-System">The M/M/m System</a></li>
<li><a href="#index-Bolch_002c-G_002e-85">Bolch, G.</a>: <a href="#The-M_002fM_002f1-System">The M/M/1 System</a></li>
<li><a href="#index-Bolch_002c-G_002e-73">Bolch, G.</a>: <a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></li>
<li><a href="#index-Buzen_002c-J_002e-P_002e-182">Buzen, J. P.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Casale_002c-G_002e-360">Casale, G.</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-Casale_002c-G_002e-162">Casale, G.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-de-Meer_002c-H_002e-248">de Meer, H.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-de-Meer_002c-H_002e-131">de Meer, H.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-de-Meer_002c-H_002e-115">de Meer, H.</a>: <a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></li>
<li><a href="#index-de-Meer_002c-H_002e-109">de Meer, H.</a>: <a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></li>
<li><a href="#index-de-Meer_002c-H_002e-101">de Meer, H.</a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-de-Meer_002c-H_002e-94">de Meer, H.</a>: <a href="#The-M_002fM_002fm-System">The M/M/m System</a></li>
<li><a href="#index-de-Meer_002c-H_002e-87">de Meer, H.</a>: <a href="#The-M_002fM_002f1-System">The M/M/1 System</a></li>
<li><a href="#index-de-Meer_002c-H_002e-75">de Meer, H.</a>: <a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></li>
<li><a href="#index-Graham_002c-G_002e-S_002e-321">Graham, G. S.</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-Graham_002c-G_002e-S_002e-222">Graham, G. S.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Graham_002c-G_002e-S_002e-175">Graham, G. S.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Greiner_002c-S_002e-247">Greiner, S.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Greiner_002c-S_002e-130">Greiner, S.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Greiner_002c-S_002e-114">Greiner, S.</a>: <a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></li>
<li><a href="#index-Greiner_002c-S_002e-108">Greiner, S.</a>: <a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></li>
<li><a href="#index-Greiner_002c-S_002e-100">Greiner, S.</a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-Greiner_002c-S_002e-93">Greiner, S.</a>: <a href="#The-M_002fM_002fm-System">The M/M/m System</a></li>
<li><a href="#index-Greiner_002c-S_002e-86">Greiner, S.</a>: <a href="#The-M_002fM_002f1-System">The M/M/1 System</a></li>
<li><a href="#index-Greiner_002c-S_002e-74">Greiner, S.</a>: <a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></li>
<li><a href="#index-Hsieh_002c-C_002e-H-358">Hsieh, C. H</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-Jain_002c-R_002e-141">Jain, R.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Kerola_002c-T_002e-350">Kerola, T.</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-Kobayashi_002c-H_002e-194">Kobayashi, H.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Lam_002c-S_002e-359">Lam, S.</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-Lavenberg_002c-S_002e-S_002e-245">Lavenberg, S. S.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Lavenberg_002c-S_002e-S_002e-140">Lavenberg, S. S.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Lazowska_002c-E_002e-D_002e-319">Lazowska, E. D.</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-Lazowska_002c-E_002e-D_002e-220">Lazowska, E. D.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Lazowska_002c-E_002e-D_002e-173">Lazowska, E. D.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Muntz_002c-R_002e-R_002e-361">Muntz, R. R.</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-Reiser_002c-M_002e-244">Reiser, M.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Reiser_002c-M_002e-139">Reiser, M.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Santini_002c-S_002e-228">Santini, S.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Schweitzer_002c-P_002e-264">Schweitzer, P.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Schwetman_002c-H_002e-227">Schwetman, H.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Schwetman_002c-H_002e-192">Schwetman, H.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Serazzi_002c-G_002e-362">Serazzi, G.</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-Sevcik_002c-K_002e-C_002e-322">Sevcik, K. C.</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-Sevcik_002c-K_002e-C_002e-223">Sevcik, K. C.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Sevcik_002c-K_002e-C_002e-176">Sevcik, K. C.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Trivedi_002c-K_002e-249">Trivedi, K.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Trivedi_002c-K_002e-132">Trivedi, K.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
<li><a href="#index-Trivedi_002c-K_002e-116">Trivedi, K.</a>: <a href="#The-Asymmetric-M_002fM_002fm-System">The Asymmetric M/M/m System</a></li>
<li><a href="#index-Trivedi_002c-K_002e-110">Trivedi, K.</a>: <a href="#The-M_002fM_002fm_002fK-System">The M/M/m/K System</a></li>
<li><a href="#index-Trivedi_002c-K_002e-102">Trivedi, K.</a>: <a href="#The-M_002fM_002finf-System">The M/M/inf System</a></li>
<li><a href="#index-Trivedi_002c-K_002e-95">Trivedi, K.</a>: <a href="#The-M_002fM_002fm-System">The M/M/m System</a></li>
<li><a href="#index-Trivedi_002c-K_002e-88">Trivedi, K.</a>: <a href="#The-M_002fM_002f1-System">The M/M/1 System</a></li>
<li><a href="#index-Trivedi_002c-K_002e-76">Trivedi, K.</a>: <a href="#Mean-time-to-absorption-_0028CTMC_0029">Mean time to absorption (CTMC)</a></li>
<li><a href="#index-Wong_002c-E_002e-233">Wong, E.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Zahorjan_002c-J_002e-320">Zahorjan, J.</a>: <a href="#Bounds-Analysis">Bounds Analysis</a></li>
<li><a href="#index-Zahorjan_002c-J_002e-221">Zahorjan, J.</a>: <a href="#Multiple-Class-Models">Multiple Class Models</a></li>
<li><a href="#index-Zahorjan_002c-J_002e-174">Zahorjan, J.</a>: <a href="#Single-Class-Models">Single Class Models</a></li>
   </ul></body></html>

