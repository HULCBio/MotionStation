@c This file has been automatically generated from queueingnetworks.txi
@c by proc.m. Do not edit this file, all changes will be lost

@c -*- texinfo -*-

@c Copyright (C) 2008, 2009, 2010, 2011, 2012 Moreno Marzolla
@c
@c This file is part of the queueing toolbox, a Queueing Networks
@c analysis package for GNU Octave.
@c
@c The queueing toolbox is free software; you can redistribute it
@c and/or modify it under the terms of the GNU General Public License
@c as published by the Free Software Foundation; either version 3 of
@c the License, or (at your option) any later version.
@c
@c The queueing toolbox is distributed in the hope that it will be
@c useful, but WITHOUT ANY WARRANTY; without even the implied warranty
@c of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c GNU General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with the queueing toolbox; see the file COPYING.  If not, see
@c <http://www.gnu.org/licenses/>.

@node Queueing Networks
@chapter Queueing Networks

@menu
* Introduction to QNs::             A brief introduction to Queueing Networks
* Single Class Models::             Queueing Models with a single job class
* Multiple Class Models::           Queueing Models with multiple job classess
* Generic Algorithms::              High-level functions for QN analysis
* Bounds Analysis::                 Computation of asymptotic performance bounds
* QN Analysis Examples::            Queueing Networks Analysis examples
@end menu

@cindex queueing networks

@c
@c INTRODUCTION
@c
@node Introduction to QNs
@section Introduction to QNs

Queueing Networks (QN) are a very simple yet powerful modeling tool
which can be used to analyze many kind of systems. In its simplest
form, a QN is made of @math{K} service centers. Each center @math{k}
has a queue, which is connected to @math{m_k} (generally identical)
@emph{servers}. Arriving customers (requests) join the queue if there
is a slot available. Then, requests are served according to a
(de)queueing policy (e.g., FIFO). After service completes, requests
leave the server and can join another queue or exit from the system.

Service centers for which @math{m_k = \infty} are called @emph{delay
centers} or @emph{infinite servers}. In this kind of centers, every
request always finds one available server, so queueing never occurs.

Requests join the queue according to a @emph{queueing policy}, such as:

@table @strong

@item FCFS
First-Come-First-Served

@item LCFS-PR
Last-Come-First-Served, Preemptive Resume

@item PS
Processor Sharing

@item IS
Infinite Server (for which @math{m_k = \infty}).

@end table

Queueing models can be @emph{open} or @emph{closed}. In open models
there is an infinite population of requests; new customers are
generated outside the system, and eventually leave the system. In
closed systems there is a fixed population of request.

Queueing models can have a single request class (@emph{single class
models}), meaning that all requests behave in the same way (e.g., they
spend the same average time on each particular server). In
@emph{multiple class models} there are multiple request classes, each
one with its own parameters. Furthermore, in multiclass models there
can be open and closed classes of requests within the same system.

A particular class of QN models, @emph{product-form} QNs, is of
particular interest. Product-form networks fulfill the following
assumptions:

@itemize

@item The network can consist of open and closed job classes.

@item The following queueing disciplines are allowed: FCFS, PS, LCFS-PR and IS.

@item Service times for FCFS nodes must be exponentially distributed and
class-independent. Service centers at PS, LCFS-PR and IS nodes can
have any kind of service time distribution with a rational Laplace
transform.  Furthermore, for PS, LCFS-PR and IS nodes, different
classes of customers can have different service times.

@item The service rate of an FCFS node is only allowed to depend on the
number of jobs at this node; in a PS, LCFS-PR and IS node the service
rate for a particular job class can also depend on the number of jobs
of that class at the node.

@item In open networks two kinds of arrival processes are allowed: i) the
arrival process is Poisson, with arrival rate @math{\lambda} which can
depend on the number of jobs in the network. ii) the arrival process
consists of @math{U} independent Poisson arrival streams where the
@math{U} job sources are assigned to the @math{U} chains; the arrival
rate can be load dependent.

@end itemize

Product-form networks are attractive because they be efficiently
analyzed to compute steady-state performance measures.

@c
@c Single Class Models
@c

@node Single Class Models
@section Single Class Models

In single class models, all requests are indistinguishable and belong
to the same class. This means that every request has the same average
service time, and all requests move through the system with the same
routing probabilities.

@noindent @strong{Model Inputs}

@table @math

@item @lambda_k
(Open models only) External arrival rate to service center @math{k}.

@item @lambda
(Open models only) Overall external arrival rate to the system as a whole: @math{\lambda =
\sum_k \lambda_k}.

@item N
(Closed models only) Total number of requests in the system.

@item S_k
Average service time. @math{S_k} is the average service time on service
center @math{k}. In other words, @math{S_k} is the average time from the
instant in which a request is extracted from the queue and starts being
service, and the instant at which service finishes and the request moves
to another queue (or exits the system).

@item P_{i, j}
Routing probability matrix. @math{{\bf P} = [P_{i, j}]} is a @math{K
\times K} matrix such that @math{P_{i, j}} is the probability that a
request completing service at server @math{i} will move directly to
server @math{j}, The probability that a request leaves the system
after service at service center @math{i} is @math{1-\sum_{j=1}^K P_{i,
j}}.

@item V_k
Average number of visits. @math{V_k} is the average number of visits to
the service center @math{k}. This quantity will be described shortly.

@end table

@noindent @strong{Model Outputs}

@table @math

@item U_k
Service center utilization. @math{U_k} is the utilization of service
center @math{k}. The utilization is defined as the fraction of time in
which the resource is busy (i.e., the server is processing requests).

@item R_k
Average response time. @math{R_k} is the average response time of
service center @math{k}. The average response time is defined as the
average time between the arrival of a customer in the queue, and the
completion of service.

@item Q_k
Average number of customers. @math{Q_k} is the average number of
requests in service center @math{k}. This includes both the requests in
the queue, and the request being served.

@item X_k
Throughput. @math{X_k} is the throughput of service center @math{k}.
The throughput is defined as the ratio of job completions (i.e., average
number of jobs completed over a fixed interval of time).

@end table

@noindent Given these output parameters, additional performance measures can
be computed as follows:

@table @math

@item X
System throughput, @math{X = X_1 / V_1}

@item R
System response time, @math{R = \sum_{k=1}^K R_k V_k}

@item Q
Average number of requests in the system, @math{Q = \sum_{k=1} Q_k}; for
closed systems, this can be written as @math{Q = N-XZ};

@end table

For open, single class models, the scalar @math{\lambda} denotes the
external arrival rate of requests to the system. The average number of
visits satisfy the following equation:

@iftex
@tex
$$ V_j = P_{0, j} + \sum_{i=1}^K V_i P_{i, j} \quad j=1, \ldots, K $$
@end tex
@end iftex
@ifnottex
@example
@group
                  K
                 ___
                \
V_j = P_(0, j) + >   V_i P_(i, j)    j=1,...,K
                /___
                 i=1
@end group
@end example
@end ifnottex

@noindent where @math{P_{0, j}} is the probability that an external
arrival goes to service center @math{j}. If @math{\lambda_j} is the
external arrival rate to service center @math{j}, and @math{\lambda =
\sum_j \lambda_j} is the overall external arrival rate, then
@math{P_{0, j} = \lambda_j / \lambda}.

For closed models, the visit ratios satisfy the following equation:

@iftex
@tex
$$\left\{\eqalign{V_j & = \sum_{i=1}^K V_i P_{i, j} \quad j=1, \ldots, K \cr
                  V_r & = 1 \quad \hbox{for a selected reference station $r$}}\right. $$
@end tex
@end iftex
@ifnottex
@example
/
|         K
|        ___
|       \
| V_j =  >   V_i P_(i, j)     j=1,...,K
|       /___
|        i=1
|
| V_r = 1                     for a selected reference station r
\
@end example
@end ifnottex

Note that the set of traffic equations @math{V_j = \sum_{i=1}^K V_i
P_{i, j}} alone can only be solved up to a multiplicative constant; to
get a unique solution we impose an additional constraint @math{V_r =
1}. This constraint is equivalent to defining station @math{r} as the
@emph{reference station} (the default is @math{r=1},
@xref{doc-qncsvisits}). A job that returns to the reference station is
assumed to have completed its activity cycle. The network throughput
is set to the throughput of the reference station.

@anchor{doc-qncsvisits}


@deftypefn {Function File} {@var{V} =} qncsvisits (@var{P})
@deftypefnx {Function File} {@var{V} =} qncsvisits (@var{P}, @var{r})

Compute the mean number of visits to the service centers of a
single class, closed network with @math{K} service centers.

@strong{INPUTS}

@table @var

@item P
@code{@var{P}(i,j)} is the probability that a request which completed
service at center @math{i} is routed to center @math{j}. For closed
networks it must hold that @code{sum(@var{P},2)==1}. The routing
graph must be strongly connected, meaning that each node must be
reachable from every other node.

@item r
Index of the reference station, @math{r \in @{1, @dots{}, K@}};
Default @code{@var{r}=1}. The traffic equations are solved by
imposing the condition @code{@var{V}(r) = 1}. A request returning to
the reference station completes its activity cycle.

@end table

@strong{OUTPUTS}

@table @var

@item V
@code{@var{V}(i)} is the average number of visits to service center
@math{i}, assuming center @math{r} as the reference station.

@end table

@end deftypefn


@anchor{doc-qnosvisits}


@deftypefn {Function File} {@var{V} =} qnosvisits (@var{P}, @var{lambda})

Compute the average number of visits to the service centers of a single 
class open Queueing Network with @math{K} service centers.

@strong{INPUTS}

@table @var

@item P
@code{@var{P}(i,j)} is the probability that a request which completed
service at center @math{i} is routed to center @math{j}. 

@item lambda
@code{@var{lambda}(i)} is the external arrival rate to
center @math{i}. 

@end table

@strong{OUTPUTS}

@table @var

@item V
@code{@var{V}(i)} is the average number of
visits to server @math{i}.

@end table

@end deftypefn


@c
@c
@c
@noindent @strong{EXAMPLE}

@float Figure,fig:qn_closed_single
@center @image{qn_closed_single,3in}
@caption{Closed network with a single class of requests}
@end float

@ref{fig:qn_closed_single} shows a closed QN with a single class of
requests. The network has three service centers, labeled @emph{CPU},
@emph{Disk1}, @emph{Disk2}. and represents the so called @emph{central
server} model of a computer system. Requests spend some time at the
CPU, which is represented by a PS (Processor Sharing) node. After
that, requests are routed to node Disk1 with probability @math{0.3},
and to node Disk2 with probability @math{0.7}. Both Disk1 and Disk2
are modeled as FCFS nodes.

If we enumerate the servers as CPU=1, Disk1=2, Disk2=3, we can define
the routing matrix as follows:

@iftex
@tex
$$
P = \pmatrix{ 0 & 0.3 & 0.7 \cr
              1 & 0 & 0 \cr
              1 & 0 & 0 }
$$
@end tex
@end iftex
@ifnottex
@example
    / 0  0.3  0.7 \
P = | 1  0    0   |
    \ 1  0    0   /
@end example
@end ifnottex

The visit ratios @math{V} using station 1 as the reference
station can be computed with:

@example
@verbatim
 P = [0 0.3 0.7; \
      1 0   0  ; \
      1 0   0  ];
 V = qncsvisits(P)
@end verbatim
   @result{} V = 1.00000   0.30000   0.70000
@end example

@noindent @strong{EXAMPLE}

@float Figure,fig:qn_open_single
@center @image{qn_open_single,3in}
@caption{Open Queueing Network with a single class of requests}
@end float

@ref{fig:qn_open_single} shows a open QN with a single class of
requests. The network has the same structure as the one in
@ref{fig:qn_closed_single}, with the difference that here we have a
stream of jobs arriving from outside the system, at a rate
@math{\lambda}. After service completion at the CPU, a job can leave
the system with probability 0.2, or be transferred to other nodes with
the probabilities shown in the figure.

The routing matrix of this network is

@iftex
@tex
$$
P = \pmatrix{ 0 & 0.3 & 0.5 \cr
              1 & 0 & 0 \cr
              1 & 0 & 0 }
$$
@end tex
@end iftex
@ifnottex
@example
    / 0  0.3  0.5 \
P = | 1  0    0   |
    \ 1  0    0   /
@end example
@end ifnottex

If we let @math{\lambda = 1.2}, we can compute the visit ratios
@math{V} as follows:

@example
@verbatim
 p = 0.3;
 lambda = 1.2
 P = [0 0.3 0.5; \
      1 0   0  ; \
      1 0   0  ];
 V = qnosvisits(P,[1.2 0 0])
@end verbatim
   @result{} V = 5.0000   1.5000   2.5000
@end example

Function @command{qnosvisits} expects a vector with @math{K} elements
as a second parameter, for open networks only. The vector contains the
arrival rates at each individual node; since in our example external
arrivals exist only for node @math{S_1} with rate @math{\lambda =
1.2}, the second parameter is @code{[1.2, 0, 0]}.

@c
@c Open Networks
@c
@subsection Open Networks

Jackson networks satisfy the following conditions:

@itemize

@item
There is only one job class in the network; the overall number of jobs
in the system is unlimited.

@item
There are @math{N} service centers in the network. Each service center
may have Poisson arrivals from outside the system. A job can leave
the system from any node.

@item
Arrival rates as well as routing probabilities are independent from
the number of nodes in the network.

@item
External arrivals and service times at the service centers are
exponentially distributed, and in general can be load-dependent.

@item
Service discipline at each node is FCFS

@end itemize

We define the @emph{joint probability vector} @math{\pi(k_1, k_2,
\ldots, k_N)} as the steady-state probability that there are @math{k_i}
requests at service center @math{i}, for all @math{i=1, 2, \ldots, N}.
Jackson networks have the property that the joint probability is the
product of the marginal probabilities @math{\pi_i}:

@iftex
@tex
$$ \pi(k_1, k_2, \ldots, k_N) = \prod_{i=1}^N \pi_i(k_i) $$
@end tex
@end iftex
@ifnottex
@example
@var{joint_prob} = prod( @var{pi} )
@end example
@end ifnottex

@noindent where @math{\pi_i(k_i)} is the steady-state probability
that there are @math{k_i} requests at service center @math{i}.

@anchor{doc-qnos}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnos (@var{lambda}, @var{S}, @var{V}) 
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnos (@var{lambda}, @var{S}, @var{V}, @var{m})

@cindex open network, single class
@cindex BCMP network

Analyze open, single class BCMP queueing networks.

This function works for a subset of BCMP single-class open networks
satisfying the following properties:

@itemize

@item The allowed service disciplines at network nodes are: FCFS,
PS, LCFS-PR, IS (infinite server);

@item Service times are exponentially distributed and
load-independent; 

@item Service center @math{i} can consist of @code{@var{m}(i) @geq{} 1} 
identical servers.

@item Routing is load-independent

@end itemize

@strong{INPUTS}

@table @var

@item lambda
Overall external arrival rate (@code{@var{lambda}>0}).

@item S
@code{@var{S}(k)} is the average service time at center
@math{i} (@code{@var{S}(k)>0}).

@item V
@code{@var{V}(k)} is the average number of visits to center
@math{k} (@code{@var{V}(k) @geq{} 0}).

@item m
@code{@var{m}(k)} is the number of servers at center @math{i}. If
@code{@var{m}(k) < 1}, enter @math{k} is a delay center (IS);
otherwise it is a regular queueing center with @code{@var{m}(k)}
servers. Default is @code{@var{m}(k) = 1} for all @math{k}.

@end table

@strong{OUTPUTS}

@table @var

@item U
If @math{k} is a queueing center, 
@code{@var{U}(k)} is the utilization of center @math{k}.
If @math{k} is an IS node, then @code{@var{U}(k)} is the
@emph{traffic intensity} defined as @code{@var{X}(k)*@var{S}(k)}.

@item R
@code{@var{R}(k)} is the average response time of center @math{k}.

@item Q
@code{@var{Q}(k)} is the average number of requests at center
@math{k}.

@item X
@code{@var{X}(k)} is the throughput of center @math{k}.

@end table

@seealso{qnopen,qnclosed,qnosvisits}

@end deftypefn


From the results computed by this function, it is possible to derive
other quantities of interest as follows:

@itemize

@item
@strong{System Response Time}: The overall system response time
can be computed as
@iftex
@tex
$R_s = \sum_{i=1}^K V_i R_i$
@end tex
@end iftex
@ifnottex
@code{R_s = dot(V,R);}
@end ifnottex

@item
@strong{Average number of requests}: The average number of requests
in the system can be computed as:
@iftex
@tex
$Q_s = \sum_{i=1}^K Q(i)$
@end tex
@end iftex
@ifnottex
@code{Q_s = sum(Q)}
@end ifnottex

@end itemize

@noindent @strong{EXAMPLE}

@example
@verbatim
 lambda = 3;
 V = [16 7 8];
 S = [0.01 0.02 0.03];
 [U R Q X] = qnos( lambda, S, V );
 R_s = dot(R,V) # System response time
 N = sum(Q) # Average number in system
@end verbatim
@print{} R_s =  1.4062
@print{} N =  4.2186
@end example

@noindent @strong{REFERENCES}

@noindent G. Bolch, S. Greiner, H. de Meer and K. Trivedi, @cite{Queueing
Networks and Markov Chains: Modeling and Performance Evaluation with
Computer Science Applications}, Wiley, 1998.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@c
@c Closed Networks
@c
@subsection Closed Networks

@anchor{doc-qncsmva}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}, @var{G}] =} qncsmva (@var{N}, @var{S}, @var{V})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}, @var{G}] =} qncsmva (@var{N}, @var{S}, @var{V}, @var{m})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}, @var{G}] =} qncsmva (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z})

@cindex Mean Value Analysys (MVA)
@cindex closed network, single class
@cindex normalization constant

Analyze closed, single class queueing networks using the exact Mean Value Analysis (MVA) algorithm. 

The following queueing disciplines are supported: FCFS, LCFS-PR, PS
and IS (Infinite Server). This function supports fixed-rate service
centers or multiple server nodes. For general load-dependent service
centers, use the function @code{qncsmvald} instead.

Additionally, the normalization constant @math{G(n)}, @math{n=0,
@dots{}, N} is computed; @math{G(n)} can be used in conjunction with
the BCMP theorem to compute steady-state probabilities.

@strong{INPUTS}

@table @var

@item N
Population size (number of requests in the system, @code{@var{N} @geq{} 0}).
If @code{@var{N} == 0}, this function returns
@code{@var{U} = @var{R} = @var{Q} = @var{X} = 0}

@item S
@code{@var{S}(k)} is the mean service time at center @math{k}
(@code{@var{S}(k) @geq{} 0}).

@item V
@code{@var{V}(k)} is the average number of visits to service center
@math{k} (@code{@var{V}(k) @geq{} 0}).

@item Z
External delay for customers (@code{@var{Z} @geq{} 0}). Default is 0.

@item m
@code{@var{m}(k)} is the number of servers at center @math{k}
(if @var{m} is a scalar, all centers have that number of servers). If
@code{@var{m}(k) < 1}, center @math{k} is a delay center (IS);
otherwise it is a regular queueing center (FCFS, LCFS-PR or PS) with
@code{@var{m}(k)} servers. Default is @code{@var{m}(k) = 1} for all
@math{k} (each service center has a single server).

@end table

@strong{OUTPUTS}

@table @var

@item U
If @math{k} is a FCFS, LCFS-PR or PS node (@code{@var{m}(k) == 1}),
then @code{@var{U}(k)} is the utilization of center @math{k}. If
@math{k} is an IS node (@code{@var{m}(k) < 1}), then
@code{@var{U}(k)} is the @emph{traffic intensity} defined as
@code{@var{X}(k)*@var{S}(k)}.

@item R
@code{@var{R}(k)} is the response time at center @math{k}.
The @emph{Residence Time} at center @math{k} is
@code{@var{R}(k) * @var{V}(k)}.
The system response time @var{Rsys}
can be computed either as @code{@var{Rsys} = @var{N}/@var{Xsys} - Z}
or as @code{@var{Rsys} = dot(@var{R},@var{V})}

@item Q
@code{@var{Q}(k)} is the average number of requests at center
@math{k}. The number of requests in the system can be computed
either as @code{sum(@var{Q})}, or using the formula
@code{@var{N}-@var{Xsys}*@var{Z}}.

@item X
@code{@var{X}(k)} is the throughput of center @math{k}. The
system throughput @var{Xsys} can be computed as
@code{@var{Xsys} = @var{X}(1) / @var{V}(1)}

@item G
Normalization constants. @code{@var{G}(n+1)} corresponds to the value
of the normalization constant @math{G(n)}, @math{n=0, @dots{}, N} as
array indexes in Octave start from 1. @math{G(n)} can be used in
conjunction with the BCMP theorem to compute steady-state
probabilities.

@end table

@quotation Note
In presence of load-dependent servers (i.e., if @code{@var{m}(i)>1}
for some @math{i}), the MVA algorithm is known to be numerically
unstable. Generally this problem manifests itself as negative
response times produced by this function.
@end quotation

@seealso{qncsmvald,qncscmva}

@end deftypefn


@noindent @strong{REFERENCES}

@noindent M. Reiser and S. S. Lavenberg, @cite{Mean-Value Analysis of Closed
Multichain Queuing Networks}, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313--322. @uref{http://doi.acm.org/10.1145/322186.322195, 10.1145/322186.322195}

@auindex Reiser, M.
@auindex Lavenberg, S. S.

This implementation is described in R. Jain , @cite{The Art of
Computer Systems Performance Analysis}, Wiley, 1991, p. 577.
Multi-server nodes are treated according to G. Bolch, S. Greiner,
H. de Meer and K. Trivedi, @cite{Queueing Networks and Markov Chains:
Modeling and Performance Evaluation with Computer Science
Applications}, Wiley, 1998, Section 8.2.1, "Single Class Queueing
Networks".

@auindex Jain, R.
@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@noindent @strong{EXAMPLE}

@example
@verbatim
 S = [ 0.125 0.3 0.2 ];
 V = [ 16 10 5 ];
 N = 20;
 m = ones(1,3);
 Z = 4;
 [U R Q X] = qncsmva(N,S,V,m,Z);
 X_s = X(1)/V(1); # System throughput
 R_s = dot(R,V); # System response time
 printf("\t    Util      Qlen     RespT      Tput\n");
 printf("\t--------  --------  --------  --------\n");
 for k=1:length(S)
   printf("Dev%d\t%8.4f  %8.4f  %8.4f  %8.4f\n", k, U(k), Q(k), R(k), X(k) );
 endfor
 printf("\nSystem\t          %8.4f  %8.4f  %8.4f\n\n", N-X_s*Z, R_s, X_s );
@end verbatim
@end example

@c
@c MVA for single class, closed networks with load dependent servers
@c
@anchor{doc-qncsmvald}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncsmvald (@var{N}, @var{S}, @var{V})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncsmvald (@var{N}, @var{S}, @var{V}, @var{Z})

@cindex Mean Value Analysys (MVA)
@cindex MVA
@cindex closed network, single class
@cindex load-dependent service center

Exact MVA algorithm for closed, single class queueing networks
with load-dependent service centers. This function supports
FCFS, LCFS-PR, PS and IS nodes. For networks with only fixed-rate
service centers and multiple-server nodes, the function
@code{qncsmva} is more efficient.

@strong{INPUTS}

@table @var

@item N
Population size (number of requests in the system, @code{@var{N} @geq{} 0}).
If @code{@var{N} == 0}, this function returns @code{@var{U} = @var{R} = @var{Q} = @var{X} = 0}

@item S
@code{@var{S}(k,n)} is the mean service time at center @math{k}
where there are @math{n} requests, @math{1 @leq{} n
@leq{} N}. @code{@var{S}(k,n)} @math{= 1 / \mu_{k,n}},
where @math{\mu_{k,n}} is the service rate of center @math{k}
when there are @math{n} requests.

@item V
@code{@var{V}(k)} is the average number
of visits to service center @math{k} (@code{@var{V}(k) @geq{} 0}).

@item Z
external delay ("think time", @code{@var{Z} @geq{} 0}); default 0.

@end table

@strong{OUTPUTS}

@table @var

@item U
@code{@var{U}(k)} is the utilization of service center @math{k}. The
utilization is defined as the probability that service center
@math{k} is not empty, that is, @math{U_k = 1-\pi_k(0)} where
@math{\pi_k(0)} is the steady-state probability that there are 0
jobs at service center @math{k}.

@item R
@code{@var{R}(k)} is the response time on service center @math{k}.

@item Q
@code{@var{Q}(k)} is the average number of requests in service center
@math{k}.

@item X
@code{@var{X}(k)} is the throughput of service center @math{k}.

@end table

@quotation Note
In presence of load-dependent servers,
the MVA algorithm is known to be numerically
unstable. Generally this problem manifests itself as negative
response times produced by this function.
@end quotation

@end deftypefn


@noindent @strong{REFERENCES}

@noindent M. Reiser and S. S. Lavenberg, @cite{Mean-Value Analysis of Closed
Multichain Queuing Networks}, Journal of the ACM, vol. 27, n. 2,
April 1980, pp. 313--322. @uref{http://doi.acm.org/10.1145/322186.322195, 10.1145/322186.322195}

This implementation is described in G. Bolch, S. Greiner, H. de Meer
and K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling
and Performance Evaluation with Computer Science Applications}, Wiley,
1998, Section 8.2.4.1, ``Networks with Load-Deèpendent Service: Closed
Networks''.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@c
@c CMVA for single class, closed networks with a single load dependent servers
@c
@anchor{doc-qncscmva}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncscmva (@var{N}, @var{S}, @var{Sld}, @var{V})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncscmva (@var{N}, @var{S}, @var{Sld}, @var{V}, @var{Z})

@cindex conditional MVA (CMVA)
@cindex Mean Value Analysis, conditional (CMVA)
@cindex closed network, single class
@cindex CMVA

This is the implementation of the original Conditional MVA (CMVA)
algorithm, a numerically stable variant of MVA, as described in G.
Casale, @cite{A Note on Stable Flow-Equivalent Aggregation in Closed
Networks}. This function supports a network of @math{M @geq{} 1}
service centers and a single delay center. Servers @math{1, @dots{},
M-1} are load-independent; server @math{M} is load-dependent.

@strong{INPUTS}

@table @var

@item N
Number of requests in the system, @code{@var{N} @geq{} 0}. If
@code{@var{N} == 0}, this function returns @code{@var{U} = @var{R} =
@var{Q} = @var{X} = 0}

@item S
Vector of mean service times for load-independent (fixed rate) servers.
Specifically, @code{@var{S}(k)} is the mean service time on server
@math{k = 1, @dots{}, M-1} (@code{@var{S}(k) > 0}). If there are no
fixed-rate servers, then @code{S = []}

@item Sld
@code{@var{Sld}(n)} is the inverse service rate at server @math{M}
(the load-dependent server) when there are @math{n} requests,
@math{n=1, @dots{}, N}. @code{@var{Sld}(n) = } @math{1 / \mu(n)}.

@item V
@code{@var{V}(k)} is the average number of visits to service center
@math{k=1, @dots{}, M}, where @code{@var{V}(k) @geq{} 0}.
@code{@var{V}(1:M-1)} are the visit rates to the fixed rate servers;
@code{@var{V}(M)} is the visit rate to the load dependent server.

@item Z
External delay for customers (@code{@var{Z} @geq{} 0}). Default is 0.

@end table

@strong{OUTPUTS}

@table @var

@item U
@code{@var{U}(k)} is the utilization of center @math{k} (@math{k=1, @dots{}, M})

@item R
@code{@var{R}(k)} is the response time of center @math{k}, (@math{k=1,
@dots{}, M}). The system response time @var{Rsys} can be computed as
@code{@var{Rsys} = @var{N}/@var{Xsys} - Z}

@item Q
@code{@var{Q}(k)} is the average number of requests at center @math{k}, (@math{k=1, @dots{}, M}).

@item X
@code{@var{X}(k)} is the throughput of center @math{k}, (@math{k=1, @dots{}, M}).

@end table

@end deftypefn


@noindent @strong{REFERENCES}

@noindent G. Casale. @cite{A note on stable flow-equivalent aggregation in
closed networks}. Queueing Syst. Theory Appl., 60:193–-202, December
2008, @uref{http://dx.doi.org/10.1007/s11134-008-9093-6, 10.1007/s11134-008-9093-6}

@auindex Casale, G.

@c
@c Approximate MVA for single class, closed networks
@c

@anchor{doc-qncsmvaap}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncsmvaap (@var{N}, @var{S}, @var{V})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncsmvaap (@var{N}, @var{S}, @var{V}, @var{m})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncsmvaap (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncsmvaap (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z}, @var{tol})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncsmvaap (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z}, @var{tol}, @var{iter_max})

@cindex Mean Value Analysys (MVA), approximate
@cindex MVA, approximate
@cindex approximate MVA
@cindex closed network, single class
@cindex closed network, approximate analysis

Analyze closed, single class queueing networks using the Approximate
Mean Value Analysis (MVA) algorithm. This function is based on
approximating the number of customers seen at center @math{k} when a
new request arrives as @math{Q_k(N) \times (N-1)/N}. This function
only handles single-server and delay centers; if your network
contains general load-dependent service centers, use the function
@code{qncsmvald} instead.

@strong{INPUTS}

@table @var

@item N
Population size (number of requests in the system, @code{@var{N} > 0}).

@item S
@code{@var{S}(k)} is the mean service time on server @math{k}
(@code{@var{S}(k)>0}).

@item V
@code{@var{V}(k)} is the average number of visits to service center
@math{k} (@code{@var{V}(k) @geq{} 0}).

@item m
@code{@var{m}(k)} is the number of servers at center @math{k}
(if @var{m} is a scalar, all centers have that number of servers). If
@code{@var{m}(k) < 1}, center @math{k} is a delay center (IS); if
@code{@var{m}(k) == 1}, center @math{k} is a regular queueing
center (FCFS, LCFS-PR or PS) with one server (default). This function
does not support multiple server nodes (@code{@var{m}(k) > 1}).

@item Z
External delay for customers (@code{@var{Z} @geq{} 0}). Default is 0.

@item tol
Stopping tolerance. The algorithm stops when the maximum relative difference
between the new and old value of the queue lengths @var{Q} becomes
less than the tolerance. Default is @math{10^{-5}}.

@item iter_max
Maximum number of iterations (@code{@var{iter_max}>0}.
The function aborts if convergenge is not reached within the maximum
number of iterations. Default is 100.

@end table

@strong{OUTPUTS}

@table @var

@item U
If @math{k} is a FCFS, LCFS-PR or PS node (@code{@var{m}(k) == 1}),
then @code{@var{U}(k)} is the utilization of center @math{k}. If
@math{k} is an IS node (@code{@var{m}(k) < 1}), then
@code{@var{U}(k)} is the @emph{traffic intensity} defined as
@code{@var{X}(k)*@var{S}(k)}.

@item R
@code{@var{R}(k)} is the response time at center @math{k}.
The system response time @var{Rsys}
can be computed as @code{@var{Rsys} = @var{N}/@var{Xsys} - Z}

@item Q
@code{@var{Q}(k)} is the average number of requests at center
@math{k}. The number of requests in the system can be computed
either as @code{sum(@var{Q})}, or using the formula
@code{@var{N}-@var{Xsys}*@var{Z}}.

@item X
@code{@var{X}(k)} is the throughput of center @math{k}. The
system throughput @var{Xsys} can be computed as
@code{@var{Xsys} = @var{X}(1) / @var{V}(1)}

@end table

@seealso{qncsmva,qncsmvald}

@end deftypefn


@noindent @strong{REFERENCES}

This implementation is based on Edward D. Lazowska, John Zahorjan,
G. Scott Graham, and Kenneth C. Sevcik, @cite{Quantitative System
Performance: Computer System Analysis Using Queueing Network Models},
Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 6.4.2.2 ("Approximate Solution Techniques").

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@c
@c Convolution
@c

According to the BCMP theorem, the state probability of a closed
single class queueing network with @math{K} nodes and @math{N} requests
can be expressed as:

@iftex
@tex
$$ \pi(k_1, k_2, \ldots, k_K) = {1 \over G(N)} \prod_{i=1}^N F_i(k_i) $$
@end tex
@end iftex
@ifnottex
@example
@group
k = [k1, k2, @dots{} kn]; @r{population vector}
p = 1/G(N+1) \prod F(i,k);
@end group
@end example
@end ifnottex

Here @math{\pi(k_1, k_2, \ldots, k_K)} is the joint probability of
having @math{k_i} requests at node @math{i}, for all @math{i=1, 2,
\ldots, K}.

The @emph{convolution algorithms} computes the normalization constants
@math{{\bf G} = \left(G(0), G(1), \ldots, G(N)\right)} for single-class, closed networks
with @math{N} requests.  The normalization constants are returned as
vector @code{@var{G}=[@var{G}(1), @var{G}(2), @dots{} @var{G}(N+1)]} where
@code{@var{G}(i+1)} is the value of @math{G(i)} (remember that Octave
uses 1-base vectors). The normalization constant can be used to
compute all performance measures of interest (utilization, average
response time and so on).

@command{queueing} implements the convolution algorithm, in the function
@command{qncsconv} and @command{qncsconvld}. The first one
supports single-station nodes, multiple-station nodes and IS nodes.
The second one supports networks with general load-dependent service
centers.


@anchor{doc-qncsconv}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}, @var{G}] =} qncsconv (@var{N}, @var{S}, @var{V})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}, @var{G}] =} qncsconv (@var{N}, @var{S}, @var{V}, @var{m})

@cindex closed network, single class
@cindex normalization constant
@cindex convolution algorithm

Analyze product-form, single class closed networks using the convolution algorithm.

Load-independent service centers, multiple servers (@math{M/M/m}
queues) and IS nodes are supported. For general load-dependent
service centers, use @code{qncsconvld} instead.

@strong{INPUTS}

@table @var

@item N
Number of requests in the system (@code{@var{N}>0}).

@item S
@code{@var{S}(k)} is the average service time on center @math{k}
(@code{@var{S}(k) @geq{} 0}).

@item V
@code{@var{V}(k)} is the visit count of service center @math{k}
(@code{@var{V}(k) @geq{} 0}).

@item m
@code{@var{m}(k)} is the number of servers at center
@math{k}. If @code{@var{m}(k) < 1}, center @math{k} is a delay center (IS);
if @code{@var{m}(k) @geq{} 1}, center @math{k}
it is a regular @math{M/M/m} queueing center with @code{@var{m}(k)}
identical servers. Default is @code{@var{m}(k) = 1} for all @math{k}.

@end table

@strong{OUTPUT}

@table @var

@item U
@code{@var{U}(k)} is the utilization of center @math{k}. 
For IS nodes, @code{@var{U}(k)} is the @emph{traffic intensity}.

@item R
@code{@var{R}(k)} is the average response time of center @math{k}.

@item Q
@code{@var{Q}(k)} is the average number of customers at center
@math{k}.

@item X
@code{@var{X}(k)} is the throughput of center @math{k}.

@item G
Vector of normalization constants. @code{@var{G}(n+1)} contains the value of
the normalization constant with @math{n} requests
@math{G(n)}, @math{n=0, @dots{}, N}.

@end table

@seealso{qncsconvld}

@end deftypefn


@noindent @strong{NOTE}

For a network with @math{K} service centers and @math{N} requests,
this implementation of the convolution algorithm has time and space
complexity @math{O(NK)}.

@noindent @strong{REFERENCES}

Jeffrey P. Buzen, @cite{Computational Algorithms for Closed Queueing
Networks with Exponential Servers}, Communications of the ACM, volume
16, number 9, september 1973,
pp. 527--531. @uref{http://doi.acm.org/10.1145/362342.362345, 10.1145/362342.362345}

@auindex Buzen, J. P.

This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications}, Wiley,
1998, pp. 313--317.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@noindent @strong{EXAMPLE}

The normalization constant @math{G} can be used to compute the
steady-state probabilities for a closed single class product-form
Queueing Network with @math{K} nodes. Let @code{@var{k}=[@math{k_1,
k_2, @dots{}, k_K}]} be a valid population vector. Then, the
steady-state probability @code{@var{p}(i)} to have @code{@var{k}(i)}
requests at service center @math{i} can be computed as:

@iftex
@tex
$$
p_i(k_i) = {(V_i S_i)^{k_i} \over G(K)} \left(G(K-k_i) - V_i S_i G(K-k_i-1)\right), \quad i=1, 2, \ldots, K
$$
@end tex
@end iftex

@example
@verbatim
 k = [1 2 0];
 K = sum(k); # Total population size
 S = [ 1/0.8 1/0.6 1/0.4 ];
 m = [ 2 3 1 ];
 V = [ 1 .667 .2 ];
 [U R Q X G] = qncsconv( K, S, V, m );
 p = [0 0 0]; # initialize p
 # Compute the probability to have k(i) jobs at service center i
 for i=1:3
   p(i) = (V(i)*S(i))^k(i) / G(K+1) * \
          (G(K-k(i)+1) - V(i)*S(i)*G(K-k(i)) );
   printf("k(%d)=%d prob=%f\n", i, k(i), p(i) );
 endfor
@end verbatim
@print{} k(1)=1 prob=0.17975
@print{} k(2)=2 prob=0.48404
@print{} k(3)=0 prob=0.52779
@end example


@c
@anchor{doc-qncsconvld}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}, @var{G}] =} qncsconvld (@var{N}, @var{S}, @var{V})

@cindex closed network
@cindex normalization constant
@cindex convolution algorithm
@cindex load-dependent service center

This function implements the @emph{convolution algorithm} for
product-form, single-class closed queueing networks with general
load-dependent service centers.

This function computes steady-state performance measures for
single-class, closed networks with load-dependent service centers
using the convolution algorithm; the normalization constants are also
computed. The normalization constants are returned as vector
@code{@var{G}=[@var{G}(1), @dots{}, @var{G}(N+1)]} where
@code{@var{G}(i+1)} is the value of @math{G(i)}.

@strong{INPUTS}

@table @var

@item N
Number of requests in the system (@code{@var{N}>0}).

@item S
@code{@var{S}(k,n)} is the mean service time at center @math{k}
where there are @math{n} requests, @math{1 @leq{} n
@leq{} N}. @code{@var{S}(k,n)} @math{= 1 / \mu_{k,n}},
where @math{\mu_{k,n}} is the service rate of center @math{k}
when there are @math{n} requests.

@item V
@code{@var{V}(k)} is the visit count of service center @math{k}
(@code{@var{V}(k) @geq{} 0}). The length of @var{V} is the number of
servers @math{K} in the network.

@end table

@strong{OUTPUT}

@table @var

@item U
@code{@var{U}(k)} is the utilization of center @math{k}.

@item R
@code{@var{R}(k)} is the average response time at center @math{k}.

@item Q
@code{@var{Q}(k)} is the average number of customers in center @math{k}.

@item X
@code{@var{X}(k)} is the throughput of center @math{k}.

@item G
Normalization constants (vector). @code{@var{G}(n+1)}
corresponds to @math{G(n)}, as array indexes in Octave start
from 1.

@end table

@seealso{qncsconv}

@end deftypefn


@noindent @strong{REFERENCES}

@noindent Herb Schwetman, @cite{Some Computational Aspects of Queueing Network
Models}, Technical Report
@uref{http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-354.pdf,
CSD-TR-354}, Department of Computer Sciences, Purdue University, feb,
1981 (revised).

@auindex Schwetman, H.

@noindent M. Reiser, H. Kobayashi, @cite{On The Convolution Algorithm for
Separable Queueing Networks}, In Proceedings of the 1976 ACM
SIGMETRICS Conference on Computer Performance Modeling Measurement and
Evaluation (Cambridge, Massachusetts, United States, March 29--31,
1976). SIGMETRICS '76. ACM, New York, NY,
pp. 109--117. @uref{http://doi.acm.org/10.1145/800200.806187, 10.1145/800200.806187}

@auindex Reiser, M.
@auindex Kobayashi, H.

This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications}, Wiley,
1998, pp. 313--317. Function @command{qncsconvld} is slightly
different from the version described in Bolch et al. because it
supports general load-dependent centers (while the version in the book
does not). The modification is in the definition of function
@code{F()} in @command{qncsconvld} which has been made similar to
function @math{f_i} defined in Schwetman, @cite{Some Computational
Aspects of Queueing Network Models}.

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.

@c
@c
@c
@subsection Non Product-Form QNs
@anchor{Non Product-Form QNs}
@c
@c MVABLO algorithm for approximate analysis of closed, single class
@c QN with blocking
@c
@anchor{doc-qncsmvablo}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncsmvablo (@var{N}, @var{S}, @var{M}, @var{P} )

@cindex queueing network with blocking
@cindex blocking queueing network
@cindex closed network, finite capacity
@cindex MVABLO

Approximate MVA algorithm for closed queueing networks with blocking.

@strong{INPUTS}

@table @var

@item N
population size, i.e., number of requests in the system. @var{N} must
be strictly greater than zero, and less than the overall network capacity:
@code{0 < @var{N} < sum(@var{M})}.

@item S
Average service time. @code{@var{S}(i)} is the average service time 
requested on server @math{i} (@code{@var{S}(i) > 0}).

@item M
@code{@var{M}(i)} is the capacity of center
@math{i}. The capacity is the maximum number of requests in a service
center, including the request currently in service (@code{@var{M}(i) @geq{} 1}).

@item P
@code{@var{P}(i,j)} is the probability that a request which completes
service at server @math{i} will be transferred to server @math{j}.

@end table

@strong{OUTPUTS}

@table @var

@item U
@code{@var{U}(i)} is the utilization of
service center @math{i}.

@item R
@code{@var{R}(i)} is the average response time
of service center @math{i}.

@item Q
@code{@var{Q}(i)} is
the average number of requests in service center @math{i} (including
the request in service).

@item X
@code{@var{X}(i)} is the throughput of
service center @math{i}.

@end table

@seealso{qnopen, qnclosed}

@end deftypefn


@noindent @strong{REFERENCES}

@noindent Ian F. Akyildiz, @cite{Mean Value Analysis for Blocking Queueing
Networks}, IEEE Transactions on Software Engineering, vol. 14, n. 2,
april 1988, pp. 418--428.  @uref{http://dx.doi.org/10.1109/32.4663, 10.1109/32.4663}

@auindex Akyildiz, I. F.

@anchor{doc-qnmarkov}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnmarkov (@var{lambda}, @var{S}, @var{C}, @var{P})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnmarkov (@var{lambda}, @var{S}, @var{C}, @var{P}, @var{m})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnmarkov (@var{N}, @var{S}, @var{C}, @var{P})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnmarkov (@var{N}, @var{S}, @var{C}, @var{P}, @var{m})

@cindex closed network, multiple classes
@cindex closed network, finite capacity
@cindex blocking queueing network
@cindex RS blocking

Compute utilization, response time, average queue length and
throughput for open or closed queueing networks with finite capacity.
Blocking type is Repetitive-Service (RS). This function explicitly
generates and solve the underlying Markov chain, and thus might
require a large amount of memory.

More specifically, networks which can me analyzed by this
function have the following properties:

@itemize @bullet

@item There exists only a single class of customers.

@item The network has @math{K} service centers. Center
@math{i} has @math{m_i > 0} servers, and has a total (finite) capacity of
@math{C_i \geq m_i} which includes both buffer space and servers.
The buffer space at service center @math{i} is therefore
@math{C_i - m_i}.

@item The network can be open, with external arrival rate to
center @math{i} equal to 
@math{\lambda_i}, or closed with fixed
population size @math{N}. For closed networks, the population size
@math{N} must be strictly less than the network capacity: @math{N < \sum_i C_i}.

@item Average service times are load-independent.

@item @math{P_{i, j}} is the probability that requests completing
execution at center @math{i} are transferred to
center @math{j}, @math{i \neq j}. For open networks, a request may leave the system
from any node @math{i} with probability @math{1-\sum_j P_{i, j}}.

@item Blocking type is Repetitive-Service (RS). Service
center @math{j} is @emph{saturated} if the number of requests is equal
to its capacity @math{C_j}. Under the RS blocking discipline,
a request completing service at center @math{i} which is being
transferred to a saturated server @math{j} is put back at the end of
the queue of @math{i} and will receive service again. Center @math{i}
then processes the next request in queue. External arrivals to a
saturated servers are dropped.

@end itemize

@strong{INPUTS}

@table @var

@item lambda
@itemx N
If the first argument is a vector @var{lambda}, it is considered to be
the external arrival rate @code{@var{lambda}(i) @geq{} 0} to service center
@math{i} of an open network. If the first argument is a scalar, it is
considered as the population size @var{N} of a closed network; in this case
@var{N} must be strictly
less than the network capacity: @code{@var{N} < sum(@var{C})}.

@item S
@code{@var{S}(i)} is the average service time at service center
@math{i}

@item C
@code{@var{C}(i)} is the Capacity of service center @math{i}. The capacity includes both
the buffer and server space @code{@var{m}(i)}. Thus the buffer space is
@code{@var{C}(i)-@var{m}(i)}.

@item P
@code{@var{P}(i,j)} is the transition probability from service center
@math{i} to service center @math{j}.

@item m
@code{@var{m}(i)} is the number of servers at service center
@math{i}. Note that @code{@var{m}(i) @geq{} @var{C}(i)} for each @var{i}.
If @var{m} is omitted, all service centers are assumed to have a
single server (@code{@var{m}(i) = 1} for all @math{i}).

@end table

@strong{OUTPUTS}

@table @var

@item U
@code{@var{U}(i)} is the utilization of service center @math{i}.

@item R
@code{@var{R}(i)} is the response time on service center @math{i}.

@item Q
@code{@var{Q}(i)} is the average number of customers in the
service center @math{i}, @emph{including} the request in service.

@item X
@code{@var{X}(i)} is the throughput of service center @math{i}.

@end table

@quotation Note

The space complexity of this implementation is
@math{O( \prod_{i=1}^K (C_i + 1)^2)}. The time complexity is dominated
by the time needed to solve a linear system with 
@math{\prod_{i=1}^K (C_i + 1)}
unknowns.

@end quotation

@end deftypefn


@c
@c
@c
@node Multiple Class Models
@section Multiple Class Models

In multiple class QN models, we assume that there exist @math{C}
different classes of requests. Each request from class @math{c} spends
on average time @math{S_{c, k}} in service at service center
@math{k}. For open models, we denote with @math{{\bf \lambda} =
\lambda_{ck}} the arrival rates, where @math{\lambda_{c, k}} is the
external arrival rate of class @math{c} customers at service center
@math{k}. For closed models, we denote with @math{{\bf N} = (N_1, N_2,
\ldots, N_C)} the population vector, where @math{N_c} is the number of
class @math{c} requests in the system.

The transition probability matrix for these kind of networks will be a
@math{C \times K \times C \times K} matrix @math{{\bf P} = [P_{r, i, s, j}]}
such that @math{P_{r, i, s, j}} is the probability that a class
@math{r} request which completes service at center @math{i} will join
server @math{j} as a class @math{s} request.

Model input and outputs can be adjusted by adding additional indexes
for the customer classes.

@noindent @strong{Model Inputs}

@table @math

@item @lambdack
External arrival rate of class-@math{c} requests to service center @math{k}

@item @lambda
Overall external arrival rate to the whole system: @math{\lambda = \sum_c \sum_k \lambda_{c, k}}

@item S_{c, k}
Average service time. @math{S_{c, k}} is the average service time on
service center @math{k} for class @math{c} requests.

@item P_{r, i, s, j}
Routing probability matrix. @math{{\bf P} = [P_{r, i, s, j}]} is a @math{C
\times K \times C \times K} matrix such that @math{P_{r, i, s, j}} is
the probability that a class @math{r} request which completes service
at server @math{i} will move to server @math{j} as a class @math{s}
request.

@item V_{c, k}
Average number of visits. @math{V_{c, k}} is the average number of visits
of class @math{c} requests to center @math{k}.

@end table

@noindent @strong{Model Outputs}

@table @math

@item U_{c, k}
Utilization of service center @math{k} by class @math{c} requests. The
utilization is defined as the fraction of time in which the resource is
busy (i.e., the server is processing requests).

@item R_{c, k}
Average response time experienced by class @math{c} requests on service
center @math{k}. The average response time is defined as the average
time between the arrival of a customer in the queue, and the completion
of service.

@item Q_{c, k}
Average number of class @math{c} requests on service center
@math{k}. This includes both the requests in the queue, and the request
being served.

@item X_{c, k}
Throughput of service center @math{k} for class @math{c} requests.  The
throughput is defined as the rate of completion of class @math{c}
requests.

@end table

@noindent It is possible to define aggregate performance measures as follows:

@table @math

@item U_k
Utilization of service center @math{k}:
@iftex
@tex
$U_k = \sum_{c=1}^C U_{c, k}$
@end tex
@end iftex
@ifnottex
@code{Uk = sum(U,k);}
@end ifnottex

@item R_c
System response time for class @math{c} requests:
@iftex
@tex
$R_c = \sum_{k=1}^K R_{c, k} V_{c, k}$
@end tex
@end iftex
@ifnottex
@code{Rc = sum( V.*R, 1 );}
@end ifnottex

@item Q_c
Average number of class @math{c} requests in the system:
@iftex
@tex
$Q_c = \sum_{k=1}^K Q_{c, k}$
@end tex
@end iftex
@ifnottex
@code{Qc = sum( Q, 2 );}
@end ifnottex

@item X_c
Class @math{c} throughput:
@iftex
@tex
$X_c = X_{c, 1} / V_{c, 1}$
@end tex
@end iftex
@ifnottex
@code{Xc = X(:,1) ./ V(:,1);}
@end ifnottex

@end table

We can define the visit ratios @math{V_{s, j}} for class @math{s}
customers at service center @math{j} as follows:

@iftex
@tex
$$\left\{\eqalign{ V_{s, j} & = \sum_{r=1}^C \sum_{i=1}^K V_{r, i} P_{r, i, s, j}, \quad s=1, \ldots, C, j=1, \ldots, K \cr
                   V_{s, r_s} & = 1 \quad s=1, \ldots, C}\right. $$
@end tex
@end iftex
@ifnottex
@group
V_sj = sum_r sum_i V_ri P_risj    s=1,...,C, j=1,...,K
V_s r_s = 1                       s=1,...,C
@end group
@end ifnottex

@noindent where @math{r_s} is the class @math{s}
reference station. Similarly to single class models, the traffic
equation for closed multiclass networks can be solved up to
multiplicative constants unless we choose one reference station for
each closed chain class and set its visit ratio to 1.

For open networks the traffic equations are as follows:

@iftex
@tex
$$V_{s, j} = P_{0, s, j} + \sum_{r=1}^C \sum_{i=1}^K V_{r, i} P_{r, i, s, j} \quad s=1, \ldots, K, j=1, \ldots, K$$
@end tex
@end iftex
@ifnottex
@group
V_sj = P_0sj + sum_r sum_i V_ri P_risj  s=1,...,K, j=1,...,K
@end group
@end ifnottex

@noindent where @math{P_{0, s, j}} is the probability that an external
arrival goes to service center @math{j} as a class-@math{s} request.
If @math{\lambda_{s, j}} is the external arrival rate of class
@math{s} requests to service center @math{j}, and @math{\lambda =
\sum_s \sum_j \lambda_{s, j}} is the overall external arrival rate to
the whole system, then @math{P_{0, s, j} = \lambda_{s, j} / \lambda}.

@anchor{doc-qncmvisits}


@deftypefn {Function File} {[@var{V} @var{ch}] =} qncmvisits (@var{P})
@deftypefnx {Function File} {[@var{V} @var{ch}] =} qncmvisits (@var{P}, @var{r})

Compute the average number of visits to the service centers of a closed multiclass network with @math{K} service centers and @math{C} customer classes.

@strong{INPUTS}

@table @var

@item P
@code{@var{P}(r,i,s,j)} is the probability that a
class @math{r} request which completed service at center @math{i} is
routed to center @math{j} as a class @math{s} request. Class switching
is allowed.

@item r
@code{@var{r}(c)} is the index of class @math{c} reference station,
@math{r(c) \in @{1, @dots{}, K@}}, @math{c \in @{1, \@dots{}, C@}}.
The class @math{c} visit count to server @code{@var{r}(c)}
(@code{@var{V}(c,r(c))}) is conventionally set to 1. The reference
station serves two purposes: (i) its throughput is assumed to be the
system throughput, and (ii) a job returning to the reference station
is assumed to have completed one cycle. Default is to consider
station 1 as the reference station for all classes.

@end table

@strong{OUTPUTS}

@table @var

@item V
@code{@var{V}(c,i)} is the number of visits of class @math{c}
requests at center @math{i}.

@item ch
@code{@var{ch}(c)} is the chain number that class @math{c} belongs
to. Different classes can belong to the same chain. Chains are
numbered sequentially starting from 1 (@math{1, 2, @dots{}}). The
total number of chains is @code{max(@var{ch})}.

@end table

@end deftypefn


@anchor{doc-qnomvisits}


@deftypefn {Function File} {@var{V} =} qnomvisits (@var{P}, @var{lambda})

Compute the average number of visits to the service centers of an open multiclass network with @math{K} service centers and @math{C} customer classes.

@strong{INPUTS}

@table @var

@item P
@code{@var{P}(r,i,s,j)} is the probability that a
class @math{r} request which completed service at center @math{i} is
routed to center @math{j} as a class @math{s} request. Class switching
is supported.

@item lambda
@code{@var{lambda}(r,i)} is the arrival rate of class @math{r}
requests to center @math{i}.

@end table

@strong{OUTPUTS}

@table @var

@item V
@code{@var{V}(r,i)} is the number of visits of class @math{r}
requests at center @math{i}.

@end table

@end deftypefn


@c
@c Open Networks
@c
@subsection Open Networks

@c
@c Open network with multiple classes
@c
@anchor{doc-qnom}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnom (@var{lambda}, @var{S}, @var{V})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnom (@var{lambda}, @var{S}, @var{V}, @var{m})

@cindex open network, multiple classes
@cindex multiclass network, open

Exact analysis of open, multiple-class BCMP networks. The network can
be made of @emph{single-server} queueing centers (FCFS, LCFS-PR or
PS) or delay centers (IS). This function assumes a network with
@math{K} service centers and @math{C} customer classes.

@strong{INPUTS}

@table @var

@item lambda
@code{@var{lambda}(c)} is the external
arrival rate of class @math{c} customers (@code{@var{lambda}(c)>0}).

@item S
@code{@var{S}(c,k)} is the mean service time of class @math{c}
customers on the service center @math{k} (@code{@var{S}(c,k)>0}).
For FCFS nodes, mean service times must be class-independent.

@item V
@code{@var{V}(c,k)} is the average number of visits of class @math{c}
customers to service center @math{k} (@code{@var{V}(c,k) @geq{} 0 }).

@item m
@code{@var{m}(k)} is the number of servers at center @math{i}. If
@code{@var{m}(k) < 1}, enter @math{k} is a delay center (IS);
otherwise it is a regular queueing center with @code{@var{m}(k)}
servers. Default is @code{@var{m}(k) = 1} for all @math{k}.

@end table

@strong{OUTPUTS}

@table @var

@item U
If @math{k} is a queueing center, then @code{@var{U}(c,k)} is the
class @math{c} utilization of center @math{k}. If @math{k} is an IS
node, then @code{@var{U}(c,k)} is the class @math{c} @emph{traffic
intensity} defined as @code{@var{X}(c,k)*@var{S}(c,k)}.

@item R
@code{@var{R}(c,k)} is the class @math{c} response time at center
@math{k}. The system response time for class @math{c} requests can be
computed as @code{dot(@var{R}, @var{V}, 2)}.

@item Q
@code{@var{Q}(c,k)} is the average number of class @math{c} requests
at center @math{k}. The average number of class @math{c} requests
in the system @var{Qc} can be computed as @code{Qc = sum(@var{Q}, 2)}

@item X
@code{@var{X}(c,k)} is the class @math{c} throughput
at center @math{k}.

@end table

@seealso{qnopen,qnos,qnomvisits}

@end deftypefn


@noindent @strong{REFERENCES}

@noindent Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C.
Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 7.4.1 ("Open Model Solution Techniques").

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.


@subsection Closed Networks

@c
@anchor{doc-qncmpopmix}


@deftypefn {Function File} {pop_mix =} qncmpopmix (@var{k}, @var{N})

@cindex population mix
@cindex closed network, multiple classes

Return the set of valid population mixes with exactly @var{k}
customers, for a closed multiclass Queueing Network with population
vector @var{N}. More specifically, given a multiclass Queueing
Network with @math{C} customer classes, such that there are
@code{@var{N}(i)} requests of class @math{i}, a
@math{k}-mix @var{mix} is a @math{C}-dimensional vector with the
following properties:

@example
@group
all( mix >= 0 );
all( mix <= N );
sum( mix ) == k;
@end group
@end example

@noindent This function enumerates all valid @math{k}-mixes, such that
@code{@var{pop_mix}(i)} is a @math{C} dimensional row vector representing
a valid population mix, for all @math{i}.

@strong{INPUTS}

@table @var

@item k
Total population size of the requested mix. @var{k} must be a nonnegative integer

@item N
@code{@var{N}(i)} is the number of class @math{i} requests.
The condition @code{@var{k} @leq{} sum(@var{N})} must hold.

@end table

@strong{OUTPUTS}

@table @var

@item pop_mix
@code{@var{pop_mix}(i,j)} is the number of class @math{j} requests
in the @math{i}-th population mix. The number of
population mixes is @code{rows( @var{pop_mix} ) }.

@end table

Note that if you are interested in the number of @math{k}-mixes
and you don't care to enumerate them, you can use the funcion
@code{qnmvapop}.

@seealso{qncmnpop}

@end deftypefn


@noindent @strong{REFERENCES}

@noindent Herb Schwetman, @cite{Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models}, Technical Report
@uref{http://www.cs.purdue.edu/research/technical_reports/1980/TR
80-355.pdf, CSD-TR-355},
Department of Computer Sciences, Purdue University, feb 15, 1982,

Note that the slightly different problem of generating all tuples
@math{k_1, k_2, \ldots, k_N} such that @math{\sum_i k_i = k} and
@math{k_i} are nonnegative integers, for some fixed integer @math{k
@geq{} 0} has been described in S. Santini, @cite{Computing the
Indices for a Complex Summation}, unpublished report, available at
@url{http://arantxa.ii.uam.es/~ssantini/writing/notes/s668_summation.pdf}

@auindex Schwetman, H.
@auindex Santini, S.

@c
@anchor{doc-qncmnpop}


@deftypefn {Function File} {@var{H} =} qncmnpop (@var{N})

@cindex population mix
@cindex closed network, multiple classes

Given a network with @math{C} customer classes, this function
computes the number of valid population mixes @code{@var{H}(r,n)} that can
be constructed by the multiclass MVA algorithm by allocating @math{n}
customers to the first @math{r} classes.

@strong{INPUTS}

@table @var

@item N
Population vector. @code{@var{N}(c)} is the number of class-@math{c}
requests in the system. The total number of requests in the network
is @code{sum(@var{N})}.

@end table

@strong{OUTPUTS}

@table @var

@item H
@code{@var{H}(r,n)} is the number of valid populations that can be
constructed allocating @math{n} customers to the first @math{r} classes.

@end table

@seealso{qncmmva,qncmpopmix}

@end deftypefn


@noindent @strong{REFERENCES}

@noindent Zahorjan, J. and Wong, E. @cite{The solution of separable queueing
network models using mean value analysis}. SIGMETRICS
Perform. Eval. Rev. 10, 3 (Sep. 1981), 80-85. DOI
@uref{http://doi.acm.org/10.1145/1010629.805477, 10.1145/1010629.805477}

@auindex Zahorjan, J.
@auindex Wong, E.

@c
@c MVA for multiple class, closed networks
@c
@anchor{doc-qncmmva}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncmmva (@var{N}, @var{S} )
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncmmva (@var{N}, @var{S}, @var{V})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncmmva (@var{N}, @var{S}, @var{V}, @var{m})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncmmva (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncmmva (@var{N}, @var{S}, @var{P})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncmmva (@var{N}, @var{S}, @var{P}, @var{r})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncmmva (@var{N}, @var{S}, @var{P}, @var{r}, @var{m})

@cindex Mean Value Analysys (MVA)
@cindex closed network, multiple classes
@cindex multiclass network, closed

Compute steady-state performance measures for closed, multiclass
queueing networks using the Mean Value Analysys (MVA) algorithm.

Queueing policies at service centers can be any of the following:

@table @strong

@item FCFS
(First-Come-First-Served) customers are served in order of arrival;
multiple servers are allowed. For this kind of queueing discipline,
average service times must be class-independent.

@item PS
(Processor Sharing) customers are served in parallel by a single
server, each customer receiving an equal share of the service rate.

@item LCFS-PR
(Last-Come-First-Served, Preemptive Resume) customers are served in
reverse order of arrival by a single server and the last arrival
preempts the customer in service who will later resume service at the
point of interruption.

@item IS
(Infinite Server) customers are delayed independently of other
customers at the service center (there is effectively an infinite
number of servers).

@end table

@quotation Note
If this function is called specifying the visit ratios
@var{V}, class switching is @strong{not} allowed.

If this function is called specifying the routing probability matrix
@var{P}, then class switching @strong{is} allowed; however, in this
case all nodes are restricted to be fixed rate servers or delay
centers: multiple-server and general load-dependent centers are not
supported.
@end quotation

@strong{INPUTS}

@table @var

@item N
@code{@var{N}(c)} is the number of class @math{c} requests in the
system; @code{@var{N}(c) @geq{} 0}. If class @math{c} has
no requests (@code{@var{N}(c) == 0}), then for all @var{k},
@code{@var{U}(c,k) = @var{R}(c,k) = @var{Q}(c,k) = @var{X}(c,k) = 0}

@item S
@code{@var{S}(c,k)} is the mean service time for class @math{c}
customers at center @math{k} (@code{@var{S}(c,k) @geq{} 0}). If the
service time at center @math{k} is class-dependent, i.e., different
classes have different service times at center @math{k}, then center
@math{k} is assumed to be of type @math{-/G/1}--PS (Processor
Sharing).
If center @math{k} is a FCFS node (@code{@var{m}(k)>1}), then the
service times @strong{must} be class-independent, i.e., all classes
@strong{must} have the same service time.

@item V
@code{@var{V}(c,k)} is the average number of visits of class @math{c}
customers to service center @math{k}; @code{@var{V}(c,k) @geq{} 0},
default is 1.
@strong{If you pass this argument, class switching is not
allowed}

@item P
@code{@var{P}(r,i,s,j)} is the probability that a class @math{r}
job completing service at center @math{i} is routed to center @math{j}
as a class @math{s} job; the reference stations for each class
are specified with the paramter @var{r}.
@strong{If you pass argument @var{P},
class switching is allowed}, but you can not specify any external delay
(i.e., @var{Z} must be zero).

@item r
@code{@var{r}(c)} is the reference station for class @math{c}.
If omitted, station 1 is the reference station for all classes.
See @command{qncmvisits}.

@item m
If @code{@var{m}(k)<1}, then center @math{k} is assumed to be a delay
center (IS node @math{-/G/\infty}). If @code{@var{m}(k)==1}, then
service center @math{k} is a regular queueing center
(@math{M/M/1}--FCFS, @math{-/G/1}--LCFS-PR or @math{-/G/1}--PS).
Finally, if @code{@var{m}(k)>1}, center @math{k} is a
@math{M/M/m}--FCFS center with @code{@var{m}(k)} identical servers.
Default is @code{@var{m}(k)=1} for each @math{k}.

@item Z
@code{@var{Z}(c)} is the class @math{c} external delay (think time);
@code{@var{Z}(c) @geq{} 0}. Default is 0. This parameter can not be
used if you pass a routing matrix as the second parameter of
@code{qncmmva}.

@end table

@strong{OUTPUTS}

@table @var

@item U
If @math{k} is a FCFS, LCFS-PR or PS node, then @code{@var{U}(c,k)}
is the class @math{c} utilization at center
@math{k}. If @math{k} is an IS node, then @code{@var{U}(c,k)} is the
class @math{c} @emph{traffic intensity} at center @math{k},
defined as @code{@var{U}(c,k) = @var{X}(c,k)*@var{S}(c,k)}. 

@item R
@code{@var{R}(c,k)} is the class @math{c} response time at
center @math{k}. The class @math{c} @emph{residence time}
at center @math{k} is @code{@var{R}(c,k) * @var{C}(c,k)}.
The total class @math{c} system response time
is @code{dot(@var{R}, @var{V}, 2)}.

@item Q
@code{@var{Q}(c,k)} is the average number of
class @math{c} requests at center @math{k}. The total number of
requests at center @math{k} is @code{sum(@var{Q}(:,k))}. 
The total number of class @math{c} requests in the system
is @code{sum(@var{Q}(c,:))}.

@item X
@code{@var{X}(c,k)} is the class @math{c} throughput at
center @math{k}. The class @math{c} throughput can be computed
as @code{@var{X}(c,1) / @var{V}(c,1)}.

@end table

@seealso{qnclosed, qncmmvaapprox, qncmvisits}

@end deftypefn


@noindent @strong{NOTE}

Given a network with @math{K} service centers, @math{C} job classes
and population vector @math{{\bf N}=(N_1, N_2, \ldots, N_C)}, the MVA
algorithm requires space @math{O(C \prod_i (N_i + 1))}. The time
complexity is @math{O(CK\prod_i (N_i + 1))}. This implementation is
slightly more space-efficient (see details in the code). While the
space requirement can be mitigated by using some optimizations, the
time complexity can not. If you need to analyze large closed networks
you should consider the @command{qncmmvaap} function, which implements
the approximate MVA algorithm. Note however that @command{qncmmvaap}
will only provide approximate results.


@noindent @strong{REFERENCES}

@noindent M. Reiser and S. S. Lavenberg, @cite{Mean-Value Analysis of Closed
Multichain Queuing Networks}, Journal of the ACM, vol. 27, n. 2, April
1980, pp. 313--322. @uref{http://doi.acm.org/10.1145/322186.322195, 10.1145/322186.322195}

@auindex Reiser, M.
@auindex Lavenberg, S. S.

This implementation is based on G. Bolch, S. Greiner, H. de Meer and
K. Trivedi, @cite{Queueing Networks and Markov Chains: Modeling and
Performance Evaluation with Computer Science Applications}, Wiley,
1998 and Edward D. Lazowska, John Zahorjan, G. Scott Graham, and
Kenneth C. Sevcik, @cite{Quantitative System Performance: Computer
System Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 7.4.2.1 ("Exact Solution Techniques").

@auindex Bolch, G.
@auindex Greiner, S.
@auindex de Meer, H.
@auindex Trivedi, K.
@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@c
@c Approximate MVA, with Bard-Schweitzer approximation
@c
@anchor{doc-qncmmvaap}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncmmvaap (@var{N}, @var{S}, @var{V})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncmmvaap (@var{N}, @var{S}, @var{V}, @var{m})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncmmvaap (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncmmvaap (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z}, @var{tol})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qncmmvaap (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z}, @var{tol}, @var{iter_max})

@cindex Mean Value Analysys (MVA), approximate
@cindex MVA, approximate
@cindex closed network, multiple classes
@cindex multiclass network, closed

Analyze closed, multiclass queueing networks with @math{K} service
centers and @math{C} customer classes using the approximate Mean
Value Analysys (MVA) algorithm.

This implementation uses Bard and Schweitzer approximation. It is based
on the assumption that
@iftex
@tex
$$Q_i({\bf N}-{\bf 1}_c) \approx {n-1 \over n} Q_i({\bf N})$$
@end tex
@end iftex
@ifnottex
the queue length at service center @math{k} with population
set @math{{\bf N}-{\bf 1}_c} is approximately equal to the queue length 
with population set @math{\bf N}, times @math{(n-1)/n}:

@example
@group
Q_i(N-1c) ~ (n-1)/n Q_i(N)
@end group
@end example
@end ifnottex

where @math{\bf N} is a valid population mix, @math{{\bf N}-{\bf 1}_c}
is the population mix @math{\bf N} with one class @math{c} customer
removed, and @math{n = \sum_c N_c} is the total number of requests.

This implementation works for networks made of infinite server (IS)
nodes and single-server nodes only.

@strong{INPUTS}

@table @var

@item N
@code{@var{N}(c)} is the number of
class @math{c} requests in the system (@code{@var{N}(c)>0}).

@item S
@code{@var{S}(c,k)} is the mean service time for class @math{c}
customers at center @math{k} (@code{@var{S}(c,k) @geq{} 0}).

@item V
@code{@var{V}(c,k)} is the average number of visits of class @math{c}
requests to center @math{k} (@code{@var{V}(c,k) @geq{} 0}).

@item m
@code{@var{m}(k)} is the number of servers at service center
@math{k}. If @code{@var{m}(k) < 1}, then the service center @math{k}
is assumed to be a delay center (IS). If @code{@var{m}(k) == 1},
service center @math{k} is a regular queueing center (FCFS, LCFS-PR
or PS) with a single server node. If omitted, each service center has
a single server. Note that multiple server nodes are not supported.

@item Z
@code{@var{Z}(c)} is the class @math{c} external delay. Default
is 0.

@item tol
Stopping tolerance (@code{@var{tol}>0}). The algorithm stops if
the queue length computed on two subsequent iterations are less than
@var{tol}. Default is @math{10^{-5}}.

@item iter_max
Maximum number of iterations (@code{@var{iter_max}>0}.
The function aborts if convergenge is not reached within the maximum
number of iterations. Default is 100.

@end table

@strong{OUTPUTS}

@table @var

@item U
If @math{k} is a FCFS, LCFS-PR or PS node, then @code{@var{U}(c,k)}
is the utilization of class @math{c} requests on service center
@math{k}. If @math{k} is an IS node, then @code{@var{U}(c,k)} is the
class @math{c} @emph{traffic intensity} at device @math{k},
defined as @code{@var{U}(c,k) = @var{X}(c)*@var{S}(c,k)}

@item R
@code{@var{R}(c,k)} is the response
time of class @math{c} requests at service center @math{k}.

@item Q
@code{@var{Q}(c,k)} is the average number of
class @math{c} requests at service center @math{k}.

@item X
@code{@var{X}(c,k)} is the class @math{c}
throughput at service center @math{k}.

@end table

@seealso{qncmmva}

@end deftypefn


@noindent @strong{REFERENCES}

@noindent Y. Bard, @cite{Some Extensions to Multiclass Queueing Network Analysis},
proc. 4th Int. Symp. on Modelling and Performance Evaluation of
Computer Systems, feb. 1979, pp. 51--62.

@auindex Bard, Y.

@noindent P. Schweitzer, @cite{Approximate Analysis of Multiclass Closed
Networks of Queues}, Proc. Int. Conf. on Stochastic Control and
Optimization, jun 1979, pp. 25--29.

@auindex Schweitzer, P.

This implementation is based on Edward D. Lazowska, John Zahorjan, G.
Scott Graham, and Kenneth C. Sevcik, @cite{Quantitative System
Performance: Computer System Analysis Using Queueing Network Models},
Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}.  In
particular, see section 7.4.2.2 ("Approximate Solution
Techniques"). This implementation is slightly different from the one
described above, as it computes the average response times @math{R}
instead of the residence times.

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@subsection Mixed Networks

@c
@c MVA for mixed networks
@c
@anchor{doc-qnmix}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnmix (@var{lambda}, @var{N}, @var{S}, @var{V}, @var{m})

@cindex Mean Value Analysys (MVA)
@cindex mixed network

Solution of mixed queueing networks through MVA. The network consists
of @math{K} service centers (single-server or delay centers) and
@math{C} independent customer chains. Both open and closed chains
are possible. @var{lambda} is the vector of per-chain
arrival rates (open classes); @var{N} is the vector of populations
for closed chains.

@quotation Note
In this implementation class switching is @strong{not} allowed. Each
customer class @emph{must} correspond to an independent chain.
@end quotation

If the network is made of open or closed classes only, then this
function calls @code{qnom} or @code{qncmmva}
respectively, and prints a warning message.

@strong{INPUTS}

@table @var

@item lambda
@itemx N
For each customer chain @math{c}:

@itemize

@item if @math{c} is a closed chain, then @code{@var{N}(c)>0} is the
number of class @math{c} requests and @code{@var{lambda}(c)} must be
zero;

@item If @math{c} is an open chain,
@code{@var{lambda}(c)>0} is the arrival rate of class @math{c}
requests and @code{@var{N}(c)} must be zero;

@end itemize

@noindent In other words, for each class @math{c} the following must hold:

@example
(@var{lambda}(c)>0 && @var{N}(c)==0) || (@var{lambda}(c)==0 && @var{N}(c)>0)
@end example

@item S
@code{@var{S}(c,k)} is the mean class @math{c} service time at center
@math{k}, @code{@var{S}(c,k) @geq{} 0}. For FCFS nodes, service times
must be class-independent.

@item V
@code{@var{V}(c,k)} is the average number of visits of class @math{c}
customers to center @math{k} (@code{@var{V}(c,k) @geq{} 0}).

@item m
@code{@var{m}(k)} is the number of servers at center @math{k}. Only
single-server (@code{@var{m}(k)==1}) or IS (Infinite Server) nodes
(@code{@var{m}(k)<1}) are supported. If omitted, each center
is assumed to be of type @math{M/M/1}-FCFS. Queueing discipline for
single-server nodes can be FCFS, PS or LCFS-PR.

@end table

@strong{OUTPUTS}

@table @var

@item U
@code{@var{U}(c,k)} is class @math{c} utilization at center @math{k}.

@item R
@code{@var{R}(c,k)} is class @math{c} response time at center @math{k}.

@item Q
@code{@var{Q}(c,k)} is the average number of
class @math{c} requests at center @math{k}.

@item X
@code{@var{X}(c,k)} is class @math{c} throughput at center @math{k}.

@end table

@seealso{qncmmva, qncm}

@end deftypefn


@noindent @strong{REFERENCES}

@noindent Edward D. Lazowska, John Zahorjan, G. Scott Graham, and Kenneth C.
Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 7.4.3 ("Mixed Model Solution Techniques").
Note that in this function we compute the mean response time @math{R}
instead of the mean residence time as in the reference.

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@noindent Herb Schwetman, @cite{Implementing the Mean Value Algorithm for the
Solution of Queueing Network Models}, Technical Report
@uref{http://www.cs.purdue.edu/research/technical_reports/1980/TR%2080-355.pdf,
CSD-TR-355}, Department of Computer Sciences, Purdue University, feb
15, 1982,

@auindex Schwetman, H.

@c
@c
@c
@node Generic Algorithms
@section Generic Algorithms

The @code{queueing} package provides a high-level function
@command{qnsolve} for analyzing QN models. @command{qnsolve} takes as
input a high-level description of the queueing model, and delegates
the actual solution of the model to one of the lower-level
function. @command{qnsolve} supports single or multiclass models, but at
the moment only product-form networks can be analyzed. For non
product-form networks @xref{Non Product-Form QNs}.

@command{qnsolve} accepts two input parameters. The first one is the list
of nodes, encoded as an Octave @emph{cell array}. The second parameter
is the vector of visit ratios @var{V}, which can be either a vector
(for single-class models) or a two-dimensional matrix (for
multiple-class models).

Individual nodes in the network are structures build using the
@command{qnmknode} function.

@anchor{doc-qnmknode}


@deftypefn {Function File} {@var{Q} =} qnmknode (@var{"m/m/m-fcfs"}, @var{S})
@deftypefnx {Function File} {@var{Q} =} qnmknode (@var{"m/m/m-fcfs"}, @var{S}, @var{m})
@deftypefnx {Function File} {@var{Q} =} qnmknode (@var{"m/m/1-lcfs-pr"}, @var{S})
@deftypefnx {Function File} {@var{Q} =} qnmknode (@var{"-/g/1-ps"}, @var{S})
@deftypefnx {Function File} {@var{Q} =} qnmknode (@var{"-/g/1-ps"}, @var{S}, @var{s2})
@deftypefnx {Function File} {@var{Q} =} qnmknode (@var{"-/g/inf"}, @var{S})
@deftypefnx {Function File} {@var{Q} =} qnmknode (@var{"-/g/inf"}, @var{S}, @var{s2})

Creates a node; this function can be used together with
@code{qnsolve}. It is possible to create either single-class nodes
(where there is only one customer class), or multiple-class nodes
(where the service time is given per-class). Furthermore, it is
possible to specify load-dependent service times.

@strong{INPUTS}

@table @var

@item S
Mean service time.

@itemize

@item If @math{S} is a scalar,
it is assumed to be a load-independent, class-independent service time.

@item If @math{S} is a column vector, then @code{@var{S}(c)} is assumed to
the the load-independent service time for class @math{c} customers.

@item If @math{S} is a row vector, then @code{@var{S}(n)} is assumed to be
the class-independent service time at the node, when there are @math{n}
requests. 

@item Finally, if @var{S} is a two-dimensional matrix, then
@code{@var{S}(c,n)} is assumed to be the class @math{c} service time
when there are @math{n} requests at the node.

@end itemize

@item m
Number of identical servers at the node. Default is @code{@var{m}=1}.

@item s2
Squared coefficient of variation for the service time. Default is 1.0.

@end table

The returned struct @var{Q} should be considered opaque to the client.

@c The returned struct @var{Q} has the following fields:

@c @table @var

@c @item Q.node
@c (String) type of the node; valid values are @code{"m/m/m-fcfs"}, 
@c @code{"-/g/1-lcfs-pr"}, @code{"-/g/1-ps"} (Processor-Sharing) 
@c and @code{"-/g/inf"} (Infinite Server, or delay center).

@c @item Q.S
@c Average service time. If @code{@var{Q}.S} is a vector, then
@c @code{@var{Q}.S(i)} is the average service time at that node
@c if there are @math{i} requests.

@c @item Q.m
@c Number of identical servers at a @code{"m/m/m-fcfs"}. Default is 1.

@c @item Q.c
@c Number of customer classes. Default is 1.

@c @end table

@seealso{qnsolve}

@end deftypefn


After the network has been defined, it is possible to solve it using
@command{qnsolve}.

@anchor{doc-qnsolve}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnsolve (@var{"closed"}, @var{N}, @var{QQ}, @var{V})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnsolve (@var{"closed"}, @var{N}, @var{QQ}, @var{V}, @var{Z})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnsolve (@var{"open"}, @var{lambda}, @var{QQ}, @var{V})
@deftypefnx {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnsolve (@var{"mixed"}, @var{lambda}, @var{N}, @var{QQ}, @var{V})

High-level function for analyzing QN models.

@itemize

@item For @strong{closed} networks, the following server types are
supported: @math{M/M/m}--FCFS, @math{-/G/\infty}, @math{-/G/1}--LCFS-PR,
@math{-/G/1}--PS and load-dependent variants.

@item For @strong{open} networks, the following server types are supported:
@math{M/M/m}--FCFS, @math{-/G/\infty} and @math{-/G/1}--PS. General
load-dependent nodes are @emph{not} supported. Multiclass open networks
do not support multiple server @math{M/M/m} nodes, but only
single server @math{M/M/1}--FCFS.

@item For @strong{mixed} networks, the following server types are supported:
@math{M/M/1}--FCFS, @math{-/G/\infty} and @math{-/G/1}--PS. General
load-dependent nodes are @emph{not} supported.

@end itemize

@strong{INPUTS}

@table @var

@item N
Number of requests in the system for closed networks. For
single-class networks, @var{N} must be a scalar. For multiclass
networks, @code{@var{N}(c)} is the population size of closed class
@math{c}.

@item lambda
External arrival rate (scalar) for open networks. For single-class
networks, @var{lambda} must be a scalar. For multiclass networks,
@code{@var{lambda}(c)} is the class @math{c} overall arrival rate.

@item QQ
List of queues in the network. This must be a cell array 
with @math{N} elements, such that @code{@var{QQ}@{i@}} is
a struct produced by the @code{qnmknode} function.

@item Z
External delay ("think time") for closed networks. Default 0.

@end table

@strong{OUTPUTS}

@table @var

@item U
If @math{i} is a FCFS node, then @code{@var{U}(i)} is the utilization
of service center @math{i}. If @math{i} is an IS node, then
@code{@var{U}(i)} is the @emph{traffic intensity} defined as
@code{@var{X}(i)*@var{S}(i)}.

@item R
@code{@var{R}(i)} is the average response time of service center @math{i}.

@item Q
@code{@var{Q}(i)} is the average number of customers in service center
@math{i}.

@item X
@code{@var{X}(i)} is the throughput of service center @math{i}.

@end table

Note that for multiclass networks, the computed results are per-class
utilization, response time, number of customers and throughput:
@code{@var{U}(c,k)}, @code{@var{R}(c,k)}, @code{@var{Q}(c,k)},
@code{@var{X}(c,k)},

@end deftypefn


@noindent @strong{EXAMPLE}

Let us consider a closed, multiclass network with @math{C=2} classes
and @math{K=3} service center. Let the population be @math{M=(2, 1)}
(class 1 has 2 requests, and class 2 has 1 request). The nodes are as
follows:

@itemize

@item Node 1 is a @math{M/M/1}--FCFS node, with load-dependent service
times. Service times are class-independent, and are defined by the
matrix @code{[0.2 0.1 0.1; 0.2 0.1 0.1]}. Thus, @code{@var{S}(1,2) =
0.2} means that service time for class 1 customers where there are 2
requests in 0.2. Note that service times are class-independent;

@item Node 2 is a @math{-/G/1}--PS node, with service times
@math{S_{1, 2} = 0.4} for class 1, and @math{S_{2, 2} = 0.6} for class 2
requests;

@item Node 3 is a @math{-/G/\infty} node (delay center), with service
times @math{S_{1, 3}=1} and @math{S_{2, 3}=2} for class 1 and 2
respectively.

@end itemize

After defining the per-class visit count @var{V} such that
@code{@var{V}(c,k)} is the visit count of class @math{c} requests to
service center @math{k}.  We can define and solve the model as
follows:

@example


@verbatim
 QQ = { qnmknode( "m/m/m-fcfs", [0.2 0.1 0.1; 0.2 0.1 0.1] ), \
        qnmknode( "-/g/1-ps", [0.4; 0.6] ), \
        qnmknode( "-/g/inf", [1; 2] ) };
 V = [ 1 0.6 0.4; \
       1 0.3 0.7 ];
 N = [ 2 1 ];
 [U R Q X] = qnsolve( "closed", N, QQ, V );
@end verbatim
@end example

@anchor{doc-qnclosed}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnclosed (@var{N}, @var{S}, @var{V}, @dots{})

@cindex closed network, single class
@cindex closed network, multiple classes

This function computes steady-state performance measures of closed
queueing networks using the Mean Value Analysis (MVA) algorithm. The
qneneing network is allowed to contain fixed-capacity centers, delay
centers or general load-dependent centers. Multiple request
classes are supported.

This function dispatches the computation to one of
@code{qncsemva}, @code{qncsmvald} or @code{qncmmva}.

@itemize

@item If @var{N} is a scalar, the network is assumed to have a single
class of requests; in this case, the exact MVA algorithm is used to
analyze the network. If @var{S} is a vector, then @code{@var{S}(k)}
is the average service time of center @math{k}, and this function
calls @code{qncsmva} which supports load-independent
service centers. If @var{S} is a matrix, @code{@var{S}(k,i)} is the
average service time at center @math{k} when @math{i=1, @dots{}, N}
jobs are present; in this case, the network is analyzed with the
@code{qncmmvald} function.

@item If @var{N} is a vector, the network is assumed to have multiple
classes of requests, and is analyzed using the exact multiclass
MVA algorithm as implemented in the @code{qncmmva} function.

@end itemize

@seealso{qncsmva, qncsmvald, qncmmva}

@end deftypefn


@noindent @strong{EXAMPLE}

@example
@verbatim
 P = [0 0.3 0.7; 1 0 0; 1 0 0]; # Transition probability matrix
 S = [1 0.6 0.2];               # Average service times
 m = ones(size(S));             # All centers are single-server
 Z = 2;                         # External delay
 N = 15;                        # Maximum population to consider
 V = qncsvisits(P);             # Compute number of visits
 X_bsb_lower = X_bsb_upper = X_ab_lower = X_ab_upper = X_mva = zeros(1,N);
 for n=1:N
   [X_bsb_lower(n) X_bsb_upper(n)] = qncsbsb(n, S, V, m, Z);
   [X_ab_lower(n) X_ab_upper(n)] = qncsaba(n, S, V, m, Z);
   [U R Q X] = qnclosed( n, S, V, m, Z );
   X_mva(n) = X(1)/V(1);
 endfor
 close all;
 plot(1:N, X_ab_lower,"g;Asymptotic Bounds;", \
      1:N, X_bsb_lower,"k;Balanced System Bounds;", \
      1:N, X_mva,"b;MVA;", "linewidth", 2, \
      1:N, X_bsb_upper,"k", 1:N, X_ab_upper,"g" );
 axis([1,N,0,1]); legend("location","southeast");
 xlabel("Number of Requests n"); ylabel("System Throughput X(n)");
@end verbatim
@end example

@anchor{doc-qnopen}


@deftypefn {Function File} {[@var{U}, @var{R}, @var{Q}, @var{X}] =} qnopen (@var{lambda}, @var{S}, @var{V}, @dots{})

@cindex open network

Compute utilization, response time, average number of requests in the
system, and throughput for open queueing networks. If @var{lambda} is
a scalar, the network is considered a single-class QN and is solved
using @code{qnopensingle}. If @var{lambda} is a vector, the network
is considered as a multiclass QN and solved using @code{qnopenmulti}.

@seealso{qnos, qnom}

@end deftypefn



@c
@c
@c
@node Bounds Analysis
@section Bounds Analysis

@c
@anchor{doc-qnosaba}


@deftypefn {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qnosaba (@var{lambda}, @var{D})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qnosaba (@var{lambda}, @var{S}, @var{V})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qnosaba (@var{lambda}, @var{S}, @var{V}, @var{m})

@cindex bounds, asymptotic
@cindex open network

Compute Asymptotic Bounds for open, single-class networks.

@strong{INPUTS}

@table @var

@item lambda
Arrival rate of requests (@code{@var{lambda} @geq{} 0}).

@item D
@code{@var{D}(k)} is the service demand at center @math{k}.
(@code{@var{D}(k) @geq{} 0} for all @math{k}).

@item S
@code{@var{S}(k)} is the mean service time at center @math{k}.
(@code{@var{S}(k) @geq{} 0} for all @math{k}).

@item V
@code{@var{V}(k)} is the mean number of visits to center @math{k}.
(@code{@var{V}(k) @geq{} 0} for all @math{k}).

@item m
@code{@var{m}(k)} is the number of servers at center @math{k}.
This function only supports @math{M/M/1} queues, therefore
@var{m} must be @code{ones(size(S))}. 

@end table

@strong{OUTPUTS}

@table @var

@item Xl
@item Xu
Lower and upper bounds on the system throughput. @var{Xl} is
always set to @math{0} since there can be no lower bound on the
throughput of open networks.

@item Rl
@item Ru
Lower and upper bounds on the system response time. @var{Ru}
is always set to @code{+inf} since there can be no upper bound on the
throughput of open networks.

@end table

@seealso{qnopenmultiab}

@end deftypefn


@anchor{doc-qnomaba}


@deftypefn {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qnomaba (@var{lambda}, @var{D})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Rl}] =} qnomaba (@var{lambda}, @var{S}, @var{V})

@cindex bounds, asymptotic
@cindex open network
@cindex multiclass network, open

Compute Asymptotic Bounds for open, multiclass networks.

@strong{INPUTS}

@table @var

@item lambda
@code{@var{lambda}(c)} is the class @math{c} arrival rate to the
system.

@item D
@code{@var{D}(c, k)} is class @math{c} service demand 
at center @math{k}. (@code{@var{D}(c, k) @geq{} 0} for all
@math{k}).

@item S
@code{@var{S}(c, k)} is the mean service time of class @math{c}
requests at center @math{k}. (@code{@var{S}(c, k) @geq{} 0} for all
@math{k}).

@item V
@code{@var{V}(c, k)} is the mean number of visits of class @math{c}
requests at center @math{k}. (@code{@var{V}(c, k) @geq{} 0} for all
@math{k}).

@end table

@strong{OUTPUTS}

@table @var

@item Xl
@item Xu
Per-class lower and upper throughput bounds. For example,
@code{@var{Xu}(c)} is the upper bound for class @math{c} throughput.
@code{Xl} is always @math{0} since there can be no lower bound
on the throughput of open networks.

@item Rl
@item Ru
Per-class lower and upper response time bounds. 
@code{Ru} is always @code{+inf} since there can be no upper bound
on the response time of open networks.

@end table

@seealso{qnombsb}

@end deftypefn


@c
@anchor{doc-qncsaba}


@deftypefn {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncsaba (@var{N}, @var{D})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncsaba (@var{N}, @var{S}, @var{V})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncsaba (@var{N}, @var{S}, @var{V}, @var{m})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncsaba (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z})

@cindex bounds, asymptotic
@cindex asymptotic bounds
@cindex closed network, single class

Compute Asymptotic Bounds for throughput and response time of closed, single-class networks.

Single-server and infinite-server nodes are supported.
Multiple-server nodes and general load-dependent servers are not
supported.

@strong{INPUTS}

@table @var

@item N
number of requests in the system (scalar, @code{@var{N}>0}).

@item D
@code{@var{D}(k)} is the service demand at center @math{k}
(@code{@var{D}(k) @geq{} 0}).

@item S
@code{@var{S}(k)} is the mean service time at center @math{k}
(@code{@var{S}(k) @geq{} 0}).

@item V
@code{@var{V}(k)} is the average number of visits to center
@math{k} (@code{@var{V}(k) @geq{} 0}).

@item m
@code{@var{m}(k)} is the number of servers at center @math{k}
(if @var{m} is a scalar, all centers have that number of servers). If
@code{@var{m}(k) < 1}, center @math{k} is a delay center (IS);
if @code{@var{m}(k) = 1}, center @math{k} is a M/M/1-FCFS server.
This function does not support multiple-server nodes. Default
is 1.

@item Z
External delay (@code{@var{Z} @geq{} 0}). Default is 0.

@end table

@strong{OUTPUTS}

@table @var

@item Xl
@itemx Xu
Lower and upper system throughput bounds.

@item Rl
@itemx Ru
Lower and upper response time bounds.

@end table

@seealso{qncmaba}

@end deftypefn


@anchor{doc-qncmaba}


@deftypefn {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncmaba (@var{N}, @var{D})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncmaba (@var{N}, @var{S}, @var{V})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncmaba (@var{N}, @var{S}, @var{V}, @var{m})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncmaba (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z})

@cindex bounds, asymptotic
@cindex asymptotic bounds
@cindex closed network
@cindex multiclass network, closed
@cindex closed multiclass network

Compute Asymptotic Bounds for multiclass networks.
Single-server and infinite-server nodes are supported.
Multiple-server nodes and general load-dependent servers are not
supported.

@strong{INPUTS}

@table @var

@item N
@code{@var{N}(c)} is the number of class @math{c} requests in the system.

@item D
@code{@var{D}(c, k)} is class @math{c} service demand
at center @math{k} (@code{@var{D}(c,k) @geq{} 0}).

@item S
@code{@var{S}(c, k)} is the mean service time of class @math{c}
requests at center @math{k} (@code{@var{S}(c,k) @geq{} 0}).

@item V
@code{@var{V}(c,k)} is the average number of visits of class @math{c}
requests to center @math{k} (@code{@var{V}(c,k) @geq{} 0}).

@item m
@code{@var{m}(k)} is the number of servers at center @math{k}
(if @var{m} is a scalar, all centers have that number of servers). If
@code{@var{m}(k) < 1}, center @math{k} is a delay center (IS);
if @code{@var{m}(k) = 1}, center @math{k} is a M/M/1-FCFS server.
This function does not support multiple-server nodes. Default
is 1.

@item Z
@code{@var{Z}(c)} is class @math{c} external delay
(@code{@var{Z}(c) @geq{} 0}). Default is 0.

@end table

@strong{OUTPUTS}

@table @var

@item Xl
@itemx Xu
Lower and upper class @math{c} throughput bounds.

@item Rl
@itemx Ru
Lower and upper class @math{c} response time bounds.

@end table

@seealso{qnclosedsingleab}

@end deftypefn


@noindent @strong{REFERENCES}

@noindent Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 5.2 ("Asymptotic Bounds").

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@c
@anchor{doc-qnosbsb}


@deftypefn {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qnosbsb (@var{lambda}, @var{D})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qnosbsb (@var{lambda}, @var{S}, @var{V})

@cindex bounds, balanced system
@cindex open network

Compute Balanced System Bounds for single-class, open networks.

@strong{INPUTS}

@table @var

@item lambda 
overall arrival rate to the system (scalar). Abort if
@code{@var{lambda} < 0 }

@item D
@code{@var{D}(k)} is the service demand at center @math{k}.
(@code{@var{D}(k) @geq{} 0} for all @math{k}).

@item S
@code{@var{S}(k)} is the mean service time at center @math{k}.
(@code{@var{S}(k) @geq{} 0} for all @math{k}).

@item V
@code{@var{V}(k)} is the mean number of visits at center @math{k}.
(@code{@var{V}(k) @geq{} 0} for all @math{k}).

@item m
@code{@var{m}(k)} is the number of servers at center @math{k}.
This function only supports @math{M/M/1} queues, therefore
@var{m} must be @code{ones(size(S))}. 

@end table

@strong{OUTPUTS}

@table @var

@item Xl
@item Xu
Lower and upper bounds on the system throughput. @var{Xl} is always
set to @math{0}, since there can be no lower bound on open
networks throughput.

@item Rl
@itemx Ru
Lower and upper bounds on the system response time.

@end table

@seealso{qnosaba}

@end deftypefn


@c
@anchor{doc-qncsbsb}


@deftypefn {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncsbsb (@var{N}, @var{D})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncsbsb (@var{N}, @var{S}, @var{V})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncsbsb (@var{N}, @var{S}, @var{V}, @var{m})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncsbsb (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z})

@cindex bounds, balanced system
@cindex closed network, single class
@cindex balanced system bounds

Compute Balanced System Bounds on system throughput and response time for closed, single-class networks.

@strong{INPUTS}

@table @var

@item N
number of requests in the system (scalar).

@item D
@code{@var{D}(k)} is the service demand at center @math{k}
(@code{@var{D}(k) @geq{} 0}).

@item S
@code{@var{S}(k)} is the mean service time at center @math{k}
(@code{@var{S}(k) @geq{} 0}).

@item V
@code{@var{V}(k)} is the average number of visits to center
@math{k} (@code{@var{V}(k) @geq{} 0}). Default is 1.

@item m
@code{@var{m}(k)} is the number of servers at center @math{k}. This
function supports @code{@var{m}(k) = 1} only (sing-eserver FCFS
nodes). This option is left for compatibility with
@code{qncsaba}, Default is 1.

@item Z
External delay (@code{@var{Z} @geq{} 0}). Default is 0.

@end table

@strong{OUTPUTS}

@table @var

@item Xl
@itemx Xu
Lower and upper bound on the system throughput.

@item Rl
@itemx Ru
Lower and upper bound on the system response time.

@end table

@seealso{qncmbsb}

@end deftypefn


@anchor{doc-qncmbsb}


@deftypefn {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncmbsb (@var{N}, @var{D})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncmbsb (@var{N}, @var{S}, @var{V})

@cindex bounds, balanced system
@cindex balanced system bounds
@cindex multiclass network, closed
@cindex closed multiclass network

Compute Balanced System Bounds for multiclass networks.
Only single-server nodes are supported.

@strong{INPUTS}

@table @var

@item N
@code{@var{N}(c)} is the number of class @math{c} requests in the system.

@item D
@code{@var{D}(c, k)} is class @math{c} service demand 
at center @math{k} (@code{@var{D}(c,k) @geq{} 0}).

@item S
@code{@var{S}(c, k)} is the mean service time of class @math{c}
requests at center @math{k} (@code{@var{S}(c,k) @geq{} 0}).

@item V
@code{@var{V}(c,k)} is the average number of visits of class @math{c}
requests to center @math{k} (@code{@var{V}(c,k) @geq{} 0}). 

@end table

@strong{OUTPUTS}

@table @var

@item Xl
@itemx Xu
Lower and upper class @math{c} throughput bounds.

@item Rl
@itemx Ru
Lower and upper class @math{c} response time bounds.

@end table

@seealso{qnclosedsinglebsb}

@end deftypefn


@noindent @strong{REFERENCES}

@noindent Edward D. Lazowska, John Zahorjan, G.  Scott Graham, and Kenneth
C. Sevcik, @cite{Quantitative System Performance: Computer System
Analysis Using Queueing Network Models}, Prentice Hall,
1984. @url{http://www.cs.washington.edu/homes/lazowska/qsp/}. In
particular, see section 5.4 ("Balanced Systems Bounds").

@auindex Lazowska, E. D.
@auindex Zahorjan, J.
@auindex Graham, G. S.
@auindex Sevcik, K. C.

@anchor{doc-qncmcb}


@deftypefn {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncmcb (@var{N}, @var{D})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncmcb (@var{N}, @var{S}, @var{V})

@cindex multiclass network, closed
@cindex closed multiclass network
@cindex bounds, composite
@cindex composite bounds

Composite Bound (CB) on throughput and response time for closed multiclass networks.

This function implements the Composite Bound Method described in T.
Kerola, @cite{The Composite Bound Method (CBM) for Computing
Throughput Bounds in Multiple Class Environments}, Technical Report
CSD-TR-475, Purdue University, march 13, 1984 (revised august 27,
1984).

@strong{INPUTS}

@table @var

@item N
@code{@var{N}(c)} is the number of class @math{c} requests in the system.

@item D
@code{@var{D}(c, k)} is class @math{c} service demand
at center @math{k} (@code{@var{S}(c,k) @geq{} 0}).

@item S
@code{@var{S}(c, k)} is the mean service time of class @math{c}
requests at center @math{k} (@code{@var{S}(c,k) @geq{} 0}).

@item V
@code{@var{V}(c,k)} is the average number of visits of class @math{c}
requests to center @math{k} (@code{@var{V}(c,k) @geq{} 0}).

@end table

@strong{OUTPUTS}

@table @var

@item Xl
@itemx Xu
Lower and upper class @math{c} throughput bounds.

@item Rl
@itemx Ru
Lower and upper class @math{c} response time bounds.

@end table

@end deftypefn


@noindent @strong{REFERENCES}

@noindent Teemu Kerola, @cite{The Composite Bound Method (CBM) for Computing
Throughput Bounds in Multiple Class Environments}, Technical Report
CSD-TR-475, Department of Computer Sciences, Purdue University, mar 13,
1984 (Revised aug 27, 1984).

@auindex Kerola, T.

@c
@anchor{doc-qncspb}


@deftypefn {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncspb (@var{N}, @var{D} )
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncspb (@var{N}, @var{S}, @var{V} )
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncspb (@var{N}, @var{S}, @var{V}, @var{m} )
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}] =} qncspb (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z} )

@cindex bounds, PB
@cindex PB bounds
@cindex closed network, single class

Compute PB Bounds (C. H. Hsieh and S. Lam, 1987) for single-class,
closed networks.

@strong{INPUTS}

@table @var

@item N
number of requests in the system (scalar). Must be @code{@var{N} > 0}.

@item D
@code{@var{D}(k)} is the service demand of service center @math{k}
(@code{@var{D}(k) @geq{} 0}).

@item S
@code{@var{S}(k)} is the mean service time at center @math{k}
(@code{@var{S}(k) @geq{} 0}).

@item V
@code{@var{V}(k)} is the visit ratio to center @math{k}
(@code{@var{V}(k) @geq{} 0}).

@item m
@code{@var{m}(k)} is the number of servers at center @math{k}.
This function only supports @math{M/M/1} queues, therefore
@var{m} must be @code{ones(size(S))}. 

@item Z
external delay (think time, @code{@var{Z} @geq{} 0}). Default 0.

@end table

@strong{OUTPUTS}

@table @var

@item Xl
@itemx Xu
Lower and upper bounds on the system throughput.

@item Rl
@itemx Ru
Lower and upper bounds on the system response time.

@end table

@seealso{qncsaba, qbcsbsb, qncsgb}

@end deftypefn


@noindent @strong{REFERENCES}

The original paper describing PB Bounds is C. H. Hsieh and S. Lam,
@cite{Two classes of performance bounds for closed queueing networks},
PEVA, vol. 7, n. 1, pp. 3--30, 1987

This function implements the non-iterative variant described in G.
Casale, R. R. Muntz, G. Serazzi, @cite{Geometric Bounds: a
Non-Iterative Analysis Technique for Closed Queueing Networks}, IEEE
Transactions on Computers, 57(6):780-794, June 2008.

@auindex Hsieh, C. H
@auindex Lam, S.
@auindex Casale, G.
@auindex Muntz, R. R.
@auindex Serazzi, G.

@c
@anchor{doc-qncsgb}


@deftypefn {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}, @var{Ql}, @var{Qu}] =} qncsgb (@var{N}, @var{D})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}, @var{Ql}, @var{Qu}] =} qncsgb (@var{N}, @var{S}, @var{V})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}, @var{Ql}, @var{Qu}] =} qncsgb (@var{N}, @var{S}, @var{V}, @var{m})
@deftypefnx {Function File} {[@var{Xl}, @var{Xu}, @var{Rl}, @var{Ru}, @var{Ql}, @var{Qu}] =} qncsgb (@var{N}, @var{S}, @var{V}, @var{m}, @var{Z})

@cindex bounds, geometric
@cindex geometric bounds
@cindex closed network

Compute Geometric Bounds (GB) on system throughput, system response time and server queue lenghts for closed, single-class networks.

@strong{INPUTS}

@table @var

@item N
number of requests in the system (scalar, @code{@var{N} > 0}).

@item D
@code{@var{D}(k)} is the service demand of service center @math{k}
(@code{@var{D}(k) @geq{} 0}).

@item S
@code{@var{S}(k)} is the mean service time at center @math{k}
(@code{@var{S}(k) @geq{} 0}).

@item V
@code{@var{V}(k)} is the visit ratio to center @math{k}
(@code{@var{V}(k) @geq{} 0}).

@item m
@code{@var{m}(k)} is the number of servers at center @math{k}.
This function only supports @math{M/M/1} queues, therefore
@var{m} must be @code{ones(size(S))}. 

@item Z
external delay (think time, @code{@var{Z} @geq{} 0}). Default 0.

@end table

@strong{OUTPUTS}

@table @var

@item Xl
@itemx Xu
Lower and upper bound on the system throughput. If @code{@var{Z}>0},
these bounds are computed using @emph{Geometric Square-root Bounds}
(GSB). If @code{@var{Z}==0}, these bounds are computed using @emph{Geometric Bounds} (GB)

@item Rl
@itemx Ru
Lower and upper bound on the system response time. These bounds
are derived from @var{Xl} and @var{Xu} using Little's Law:
@code{@var{Rl} = @var{N} / @var{Xu} - @var{Z}}, 
@code{@var{Ru} = @var{N} / @var{Xl} - @var{Z}}

@item Ql
@itemx Qu
@code{@var{Ql}(i)} and @code{@var{Qu}(i)} are the lower and upper
bounds respectively of the queue length for service center @math{i}.

@end table

@end deftypefn


@noindent @strong{REFERENCES}

@noindent G. Casale, R. R. Muntz, G. Serazzi,
@cite{Geometric Bounds: a Non-Iterative Analysis Technique for Closed
Queueing Networks}, IEEE Transactions on Computers, 57(6):780-794,
June 2008. @uref{http://doi.ieeecomputersociety.org/10.1109/TC.2008.37, 10.1109/TC.2008.37}

@auindex Casale, G.
@auindex Muntz, R. R.
@auindex Serazzi, G.

In this implementation we set @math{X^+} and @math{X^-} as the upper
and lower Asymptotic Bounds as computed by the @command{qncsab}
function, respectively.


@c
@c Examples
@c

@node QN Analysis Examples
@section QN Analysis Examples

In this section we illustrate with a few examples how the
@code{queueing} package can be used to evaluate queueing network
models. Further examples can be found in the demo blocks of the
functions described in this section, and can be accessed with the
@code{demo @emph{function}} Octave command.

@subsection Closed, Single Class Network

We now give a simple example on how the queueing toolbox can be used
to analyze a closed network. Let us consider again the network shown
in @ref{fig:qn_closed_single}. We denote with @math{S_k} the average
service time at center @math{k}, @math{k=1, 2, 3}. We use @math{S_1 =
1.0}, @math{S_2 = 2.0} and @math{S_3 = 0.8}. The routing of jobs
within the network is described with a @emph{routing probability
matrix} @math{\bf P}. Specifically, a request completing service at
center @math{i} is enqueued at center @math{j} with probability
@math{P_{i, j}}.  We use the following routing matrix:

@iftex
@tex
$$
P = \pmatrix{ 0 & 0.3 & 0.7 \cr
              1 & 0 & 0 \cr
              1 & 0 & 0 }
$$
@end tex
@end iftex
@ifnottex
@example
    / 0  0.3  0.7 \
P = | 1  0    0   |
    \ 1  0    0   /
@end example
@end ifnottex

The network above can be analyzed with the @command{qnclosed} function
@pxref{doc-qnclosed}. @command{qnclosed} requires the following
parameters:

@table @var

@item N
Number of requests in the network (since we are considering a closed
network, the number of requests is fixed)

@item S
Array of average service times at the centers: @code{@var{S}(k)} is
the average service time at center @math{k}.

@item V
Array of visit ratios: @code{@var{V}(k)} is the average number of
visits to center @math{k}.

@end table

We can compute @math{V_k} from the routing probability matrix
@math{P_{i, j}} using the @command{qncsvisits} function
@pxref{doc-qncsvisits}.  We can analyze the network for a given
population size @math{N} (for example, @math{N=10}) as follows:

@example
@group
@kbd{N = 10;}
@kbd{S = [1 2 0.8];}
@kbd{P = [0 0.3 0.7; 1 0 0; 1 0 0];}
@kbd{V = qncsvisits(P);}
@kbd{[U R Q X] = qnclosed( N, S, V )}
   @result{} U = 0.99139 0.59483 0.55518
   @result{} R = 7.4360  4.7531  1.7500
   @result{} Q = 7.3719  1.4136  1.2144
   @result{} X = 0.99139 0.29742 0.69397
@end group
@end example

The output of @command{qnclosed} includes the vector of utilizations
@math{U_k} at center @math{k}, response time @math{R_k}, average
number of customers @math{Q_k} and throughput @math{X_k}. In our
example, the throughput of center 1 is @math{X_1 = 0.99139}, and the
average number of requests in center 3 is @math{Q_3 = 1.2144}. The
utilization of center 1 is @math{U_1 = 0.99139}, which is the higher
value among the service centers. Tus, center 1 is the @emph{bottleneck
device}.

This network can also be analyzed with the @command{qnsolve} function
@pxref{doc-qnsolve}. @command{qnsolve} can handle open, closed or
mixed networks, and allows the network to be described in a very
flexible way.  First, let @var{Q1}, @var{Q2} and @var{Q3} be the
variables describing the service centers. Each variable is
instantiated with the @command{qnmknode} function.

@example
@group
@kbd{Q1 = qnmknode( "m/m/m-fcfs", 1 );}
@kbd{Q2 = qnmknode( "m/m/m-fcfs", 2 );}
@kbd{Q3 = qnmknode( "m/m/m-fcfs", 0.8 );}
@end group
@end example

The first parameter of @command{qnmknode} is a string describing the
type of the node. Here we use @code{"m/m/m-fcfs"} to denote a
@math{M/M/m}--FCFS center. The second parameter gives the average
service time. An optional third parameter can be used to specify the
number @math{m} of service centers. If omitted, it is assumed
@math{m=1} (single-server node).

Now, the network can be analyzed as follows:

@example
@group
@kbd{N = 10;}
@kbd{V = [1 0.3 0.7];}
@kbd{[U R Q X] = qnsolve( "closed", N, @{ Q1, Q2, Q3 @}, V )}
   @result{} U = 0.99139 0.59483 0.55518
   @result{} R = 7.4360  4.7531  1.7500
   @result{} Q = 7.3719  1.4136  1.2144
   @result{} X = 0.99139 0.29742 0.69397
@end group
@end example

@subsection Open, Single Class Network

Open networks can be analyzed in a similar way. Let us consider
an open network with @math{K=3} service centers, and routing
probability matrix as follows:

@iftex
@tex
$$
P = \pmatrix{ 0 & 0.3 & 0.5 \cr
              1 & 0 & 0 \cr
              1 & 0 & 0 }
$$
@end tex
@end iftex
@ifnottex
@example
    / 0  0.3  0.5 \
P = ! 1  0    0   |
    \ 1  0    0   /
@end example
@end ifnottex

In this network, requests can leave the system from center 1 with
probability @math{1-(0.3+0.5) = 0.2}. We suppose that external jobs
arrive at center 1 with rate @math{\lambda_1 = 0.15}; there are no
arrivals at centers 2 and 3.

Similarly to closed networks, we first need to compute the visit
counts @math{V_k} to center @math{k}. We use the
@command{qnosvisits} function as follows:

@example
@group
@kbd{P = [0 0.3 0.5; 1 0 0; 1 0 0];}
@kbd{lambda = [0.15 0 0];}
@kbd{V = qnosvisits(P, lambda)}
   @result{} V = 5.00000 1.50000 2.50000
@end group
@end example

@noindent where @code{@var{lambda}(k)} is the arrival rate at center @math{k},
and @var{P} is the routing matrix. Assuming the same service times as
in the previous example, the network can be analyzed with the
@command{qnopen} function @pxref{doc-qnopen}, as follows:

@example
@group
@kbd{S = [1 2 0.8];}
@kbd{[U R Q X] = qnopen( sum(lambda), S, V )}
   @result{} U = 0.75000 0.45000 0.30000
   @result{} R = 4.0000  3.6364  1.1429
   @result{} Q = 3.00000 0.81818 0.42857
   @result{} X = 0.75000 0.22500 0.37500
@end group
@end example

The first parameter of the @command{qnopen} function is the (scalar)
aggregate arrival rate.

Again, it is possible to use the @command{qnsolve} high-level function:

@example
@group
@kbd{Q1 = qnmknode( "m/m/m-fcfs", 1 );}
@kbd{Q2 = qnmknode( "m/m/m-fcfs", 2 );}
@kbd{Q3 = qnmknode( "m/m/m-fcfs", 0.8 );}
@kbd{lambda = [0.15 0 0];}
@kbd{[U R Q X] = qnsolve( "open", sum(lambda), @{ Q1, Q2, Q3 @}, V )}
   @result{} U = 0.75000 0.45000 0.30000
   @result{} R = 4.0000  3.6364  1.1429
   @result{} Q = 3.00000 0.81818 0.42857
   @result{} X = 0.75000 0.22500 0.37500
@end group
@end example

@subsection Closed Multiclass Network/1

The following example is taken from Herb Schwetman, @cite{Implementing
the Mean Value Algorith for the Solution of Queueing Network Models},
Technical Report CSD-TR-355, Department of Computer Sciences, Purdue
University, feb 15, 1982.

We consider the following multiclass QN with three servers and two classes

@float Figure,fig:apl
@center @image{qn_closed_multi_apl}
@end float

Servers 1 and 2 (labeled @emph{APL} and @emph{IMS}, respectively) are
infinite server nodes; server 3 (labeled @emph{SYS}) is Processor
Sharing (PS). Mean service times are given in the following table:

@multitable @columnfractions .15 .15 .15 .15
@headitem @tab  APL @tab IMS @tab SYS
@item Class 1 @tab 1 @tab - @tab 0.025
@item Class 2 @tab - @tab 15 @tab 0.500
@end multitable

There is no class switching. If  we assume a population of 15 requests
for  class 1,  and  5 requests  for class  2,  then the  model can  be
analyzed as follows:

@example
@verbatim
 S = [1 0 .025; 0 15 .5];
 P = zeros(2,3,2,3);
 P(1,1,1,3) = P(1,3,1,1) = 1;
 P(2,2,2,3) = P(2,3,2,2) = 1;
 V = qncmvisits(P,[3 3]); # reference station is station 3
 N = [15 5];
 m = [-1 -1 1];
 [U R Q X] = qncmmva(N,S,V,m)
@end verbatim
  @result{}
U =

   14.32312    0.00000    0.35808
    0.00000    4.70699    0.15690

R =

    1.00000    0.00000    0.04726
    0.00000   15.00000    0.93374

Q =

   14.32312    0.00000    0.67688
    0.00000    4.70699    0.29301

X =

   14.32312    0.00000   14.32312
    0.00000    0.31380    0.31380
@end example

@subsection Closed Multiclass Network/2

The following example is taken from M. Marzolla, @cite{The qnetworks
Toolbox: A Software Package for Queueing Networks Analysis}, Technical
Report
@uref{http://www.informatica.unibo.it/ricerca/technical-report/2010/UBLCS-2010-04,
UBLCS-2010-04}, Department of Computer Science, University of Bologna,
Italy, February 2010.


@float Figure,fig:web_model
@center @image{qn_web_model,3in}
@caption{Three-tier enterprise system model}
@end float

The model shown in @ref{fig:web_model} shows a three-tier enterprise system
with @math{K=6} service centers. The first tier contains the 
@emph{Web server} (node 1), which is responsible for generating Web pages and
transmitting them to clients. The application logic is implemented by
nodes 2 and 3, and the storage tier is made of nodes 4--6.The system
is subject to two workload classes, both represented as closed
populations of @math{N_1} and @math{N_2} requests, respectively. Let
@math{D_{c, k}} denote the service demand of class @math{c} requests
at center @math{k}. We use the parameter values:

@multitable @columnfractions .2 .33 .1 .1
@headitem Serv. no. @tab  Name @tab Class 1 @tab Class 2
@item 1 @tab Web Server    @tab 12 @tab 2
@item 2 @tab App. Server 1 @tab 14 @tab 20
@item 3 @tab App. Server 2 @tab 23 @tab 14
@item 4 @tab DB Server 1   @tab 20 @tab 90
@item 5 @tab DB Server 2   @tab 80 @tab 30
@item 6 @tab DB Server 3   @tab 31 @tab 33
@end multitable

We set the total number of requests to 100, that is @math{N_1 + N_2 =
N = 100}, and we study how different population mixes @math{(N_1,
N_2)} affect the system throughput and response time. Let
@math{\beta_1 \in (0, 1)} denote the fraction of class 1 requests:
@math{N_1 = \beta_1 N}, @math{N_2 = (1-\beta_1)N}. The following
Octave code defines the model for @math{\beta_1 = 0.1}:

@example
@group
N = 100;     # total population size
beta1 = 0.1; # fraction of class 1 reqs.
S = [12 14 23 20 80 31; \
      2 20 14 90 30 33 ];
V = ones(size(S));
pop = [fix(beta1*N) N-fix(beta1*N)];
[U R Q X] = qncmmva(pop, S, V);
@end group
@end example

The @command{qncmmva(pop, S, V)} function invocation (line 7)
uses the multiclass MVA algorithm to compute per-class utilizations
@math{U_{c, k}}, response times @math{R_{c,k}}, mean queue lengths
@math{Q_{c,k}} and throughputs @math{X_{c,k}} at each service center
@math{k}, given a population vector @var{pop}, mean service times
@var{S} and visit ratios @var{V}. Since we are given the service
demands @math{D_{c, k} = S_{c, k} V_{c,k}}, but function
@command{qncmmva()} requires separate service times and visit
ratios, we set the service times equal to the demands (line 3--4), and
all visit ratios equal to one (line 5). Overall class and system
throughputs and response times can also be computed:

@example
@group
X1 = X(1,1) / V(1,1)     # class 1 throughput
        @result{} X1 =  0.0044219
X2 = X(2,1) / V(2,1)     # class 2 throughput
        @result{} X2 =  0.010128
XX = X1 + X2             # system throughput
        @result{} XX =  0.014550
R1 = dot(R(1,:), V(1,:)) # class 1 resp. time
        @result{} R1 =  2261.5
R2 = dot(R(2,:), V(2,:)) # class 2 resp. time
        @result{} R2 =  8885.9
RR = N / XX              # system resp. time
        @result{} RR =  6872.7
@end group
@end example

@code{dot(X,Y)} computes the dot product of two vectors.
@code{R(1,:)} is the first row of matrix @var{R} and @code{V(1,:)} is
the first row of matrix @var{V}, so @code{dot(R(1,:), V(1,:))}
computes @math{\sum_k R_{1,k} V_{1,k}}.

@float Figure,fig:web
@center @image{web,3in}
@caption{Throughput and Response Times as a function of the population mix}
@end float

We can also compute the system power @math{\Phi = X / R}, which
defines how efficiently resources are being used: high values of
@math{\Phi} denote the desirable situation of high throughput and low
response time. @ref{fig:power} shows @math{\Phi} as a function of
@math{\beta_1}. We observe a ``plateau'' of the global system power,
corresponding to values of @math{\beta_1} which approximately lie
between @math{0.3} and @math{0.7}. The per-class power exhibits an
interesting (although not completely surprising) pattern, where the
class with higher population exhibits worst efficiency as it produces
higher contention on the resources.

@float Figure,fig:power
@center @image{power,3in}
@caption{System Power as a function of the population mix}
@end float

@subsection Closed Multiclass Network/3

We now consider an example of multiclass network with class switching.
The example is taken from @ref{Sch82}, and is shown in Figure
@ref{fig:class_switching}.

@float Figure,fig:class_switching
@center @image{qn_closed_multi_cs,3in}
@caption{Multiclass Model with Class Switching}
@end float

The system consists of three devices and two job classes. The CPU node
is a PS server, while the two nodes labeled I/O are FCFS. Class 1 mean
service time at the CPU is 0.01; class 2 mean service time at the CPU
is 0.05. The mean service time at node 2 is 0.1, and is
class-independent. Similarly, the mean service time at node 3 is
0.07. Jobs in class 1 leave the CPU and join class 2 with probability
0.1; jobs of class 2 leave the CPU and join class 1 with probability
0.2. There are @math{N=3} jobs, which are initially allocated to class
1. However, note that since class switching is allowed, the total
number of jobs in each class does not remain constant; however the
total number of jobs does.

@example
@verbatim
 C = 2; K = 3;
 S = [.01 .07 .10; \
      .05 .07 .10 ];
 P = zeros(C,K,C,K);
 P(1,1,1,2) = .7; P(1,1,1,3) = .2; P(1,1,2,1) = .1;
 P(2,1,2,2) = .3; P(2,1,2,3) = .5; P(2,1,1,1) = .2;
 P(1,2,1,1) = P(2,2,2,1) = 1;
 P(1,3,1,1) = P(2,3,2,1) = 1;
 N = [3 0];
 [U R Q X] = qncmmva(N, S, P)
@end verbatim
  @result{}
U =

   0.12609   0.61784   0.25218
   0.31522   0.13239   0.31522

R =

   0.014653   0.133148   0.163256
   0.073266   0.133148   0.163256

Q =

   0.18476   1.17519   0.41170
   0.46190   0.25183   0.51462

X =

   12.6089    8.8262    2.5218
    6.3044    1.8913    3.1522
@end example
