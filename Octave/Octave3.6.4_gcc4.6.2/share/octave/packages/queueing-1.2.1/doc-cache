# Created by Octave 3.6.4, Sat Mar 30 12:19:45 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 98
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ctmc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1595
 -- Function File: P = ctmc (Q)
 -- Function File: P = ctmc (Q, T. P0)
     Compute stationary or transient state occupancy probabilities for
     a continuous-time Markov chain.

     With a single argument, compute the stationary state occupancy
     probability vector P(1), ..., P(N) for a continuous-time Markov
     chain with state space {1, 2, ..., N} and N \times N infinitesimal
     generator matrix Q.  With three arguments, compute the state
     occupancy probabilities P(1), ..., P(N) that the system is in
     state i at time T, given initial state occupancy probabilities
     P0(1), ..., P0(N) at time 0.

     *INPUTS*

    Q
          Infinitesimal generator matrix. Q is a N \times N square
          matrix where `Q(i,j)' is the transition rate from state i to
          state j, for 1 <= i \neq j <= N.  #varQ must satisfy the
          property that \sum_j=1^N Q_i, j = 0

    T
          Time at which to compute the transient probability (t >= 0).
          If omitted, the function computes the steady state occupancy
          probability vector.

    P0
          `P0(i)' is the probability that the system is in state i at
          time 0.


     *OUTPUTS*

    P
          If this function is invoked with a single argument, `P(i)' is
          the steady-state probability that the system is in state i, i
          = 1, ..., N. If this function is invoked with three
          arguments, `P(i)' is the probability that the system is in
          state i at time T, given the initial occupancy probabilities
          P0(1), ..., P0(N).


     See also: dtmc





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute stationary or transient state occupancy probabilities for a
continuous-t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ctmc_bd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
 -- Function File: Q = ctmc_bd (B, D)
     This function is deprecated. Please use `ctmcbd' instead.

     See also: ctmcbd





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
ctmc_check_Q


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
 -- Function File: [RESULT ERR] = ctmc_check_Q (Q)
     This function is deprecated. Please use `ctmcchkQ' instead





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
ctmc_exps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
 -- Function File: L = ctmc_exps (Q, T, P )
 -- Function File: L = ctmc_exps (Q, P)
     This function is deprecated. Please use `ctmcexps' instead.

     See also: ctmcexps





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ctmc_fpt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 168
 -- Function File: M = ctmc_fpt (Q)
 -- Function File: M = ctmc_fpt (Q, I, J)
     This function is deprecated. Please use `ctmcfpt' instead.

     See also: ctmcfpt





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
ctmc_mtta


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
 -- Function File: T = ctmc_mtta (Q, P)
     This function is deprecated. Please use `ctmcmtta' instead.

     See also: ctmcmtta





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
ctmc_taexps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 -- Function File: M = ctmc_taexps (Q, T, P)
 -- Function File: M = ctmc_taexps (Q, P)
     This function is deprecated. Please use `ctmctaexps' instead.

     See also: ctmctaexps





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ctmcbd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1081
 -- Function File: Q = ctmcbd (B, D)
     Returns the infinitesimal generator matrix Q for a continuous
     birth-death process over state space 1, 2, ..., N.  `B(i)' is the
     transition rate from state i to i+1, and `D(i)' is the transition
     rate from state i+1 to state i, i=1, 2, ..., N-1.

     Matrix \bf Q is therefore defined as:

          /                                                          \
          | -b(1)     b(1)                                           |
          |  d(1) -(d(1)+b(2))     b(2)                              |
          |           d(2)     -(d(2)+b(3))        b(3)              |
          |                                                          |
          |                ...           ...          ...            |
          |                                                          |
          |                       d(N-2)    -(d(N-2)+b(N-1))  b(N-1) |
          |                                       d(N-1)     -d(N-1) |
          \                                                          /

     See also: dtmcbd





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Returns the infinitesimal generator matrix Q for a continuous
birth-death proces



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ctmcchkQ


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 274
 -- Function File: [RESULT ERR] = ctmcchkQ (Q)
     If Q is a valid infinitesimal generator matrix, return the size
     (number of rows or columns) of Q. If Q is not an infinitesimal
     generator matrix, set RESULT to zero, and ERR to an appropriate
     error string.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If Q is a valid infinitesimal generator matrix, return the size (number
of rows 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ctmcexps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1212
 -- Function File: L = ctmcexps (Q, T, P )
 -- Function File: L = ctmcexps (Q, P)
     With three arguments, compute the expected times `L(i)' spent in
     each state i during the time interval [0,t], assuming that the
     initial occupancy vector is P. With two arguments, compute the
     expected time `L(i)' spent in each transient state i until
     absorption.

     *INPUTS*

    Q
          N \times N infinitesimal generator matrix. `Q(i,j)' is the
          transition rate from state i to state j, 1 <= i \neq j <= N.
          The matrix Q must also satisfy the condition \sum_j=1^N Q_ij
          = 0.

    T
          If given, compute the expected sojourn times in [0,t]

    P
          Initial occupancy probability vector; `P(i)' is the
          probability the system is in state i at time 0, i = 1, ..., N


     *OUTPUTS*

    L
          If this function is called with three arguments, `L(i)' is
          the expected time spent in state i during the interval [0,t].
          If this function is called with two arguments `L(i)' is the
          expected time spent in transient state i until absorption; if
          state i is absorbing, `L(i)' is zero.


     See also: dtmcexps





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
With three arguments, compute the expected times `L(i)' spent in each
state i du



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ctmcfpt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 822
 -- Function File: M = ctmcfpt (Q)
 -- Function File: M = ctmcfpt (Q, I, J)
     Compute mean first passage times for an irreducible continuous-time
     Markov chain.

     *INPUTS*

    Q
          Infinitesimal generator matrix. Q is a N \times N square
          matrix where `Q(i,j)' is the transition rate from state i to
          state j, for 1 <= i \neq j <= N.  Transition rates must be
          nonnegative, and \sum_j=1^N Q_i j = 0

    I
          Initial state.

    J
          Destination state.


     *OUTPUTS*

    M
          `M(i,j)' is the average time before state J is visited for
          the first time, starting from state I.  We set `M(i,i) = 0'.

    M
          M is the average time before state J is visited for the first
          time, starting from state I.


     See also: dtmcfpt





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute mean first passage times for an irreducible continuous-time
Markov chain



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ctmcmtta


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 813
 -- Function File: T = ctmcmtta (Q, P)
     Compute the Mean-Time to Absorption (MTTA) of the CTMC described by
     the infinitesimal generator matrix Q, starting from initial
     occupancy probabilities P. If there are no absorbing states, this
     function fails with an error.

     *INPUTS*

    Q
          N \times N infinitesimal generator matrix. `Q(i,j)' is the
          transition rate from state i to state j, i \neq j. The matrix
          Q must satisfy the condition \sum_j=1^N Q_i j = 0

    P
          `P(i)' is the probability that the system is in state i at
          time 0, for each i=1, ..., N


     *OUTPUTS*

    T
          Mean time to absorption of the process represented by matrix
          Q.  If there are no absorbing states, this function fails.


     See also: dtmcmtta





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the Mean-Time to Absorption (MTTA) of the CTMC described by the
infinite



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
ctmctaexps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1178
 -- Function File: M = ctmctaexps (Q, T, P)
 -- Function File: M = ctmctaexps (Q, P)
     Compute the _time-averaged sojourn time_ `M(i)', defined as the
     fraction of the time interval [0,t] (or until absorption) spent in
     state i, assuming that the state occupancy probabilities at time 0
     are P.

     *INPUTS*

    Q
          Infinitesimal generator matrix. `Q(i,j)' is the transition
          rate from state i to state j, 1 <= i \neq j <= N. The matrix
          Q must also satisfy the condition \sum_j=1^N Q_ij = 0

    T
          Time. If omitted, the results are computed until absorption.

    P
          `P(i)' is the probability that, at time 0, the system was in
          state i, for all i = 1, ..., N


     *OUTPUTS*

    M
          When called with three arguments, `M(i)' is the expected
          fraction of the interval [0,t] spent in state i assuming that
          the state occupancy probability at time zero is P. When
          called with two arguments, `M(i)' is the expected fraction of
          time until absorption spent in state i; in this case the mean
          time to absorption is `sum(M)'.


     See also: dtmctaexps





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the _time-averaged sojourn time_ `M(i)', defined as the
fraction of the 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
dtmc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1547
 -- Function File: P = dtmc (P)
 -- Function File: P = dtmc (P, N, P0)
     Compute stationary or transient state occupancy probabilities for
     a discrete-time Markov chain.

     With a single argument, compute the stationary state occupancy
     probability vector `P(1), ..., P(N)' for a discrete-time Markov
     chain with state space {1, 2, ..., N} and with N \times N
     transition probability matrix P. With three arguments, compute the
     transient state occupancy vector `P(1), ..., P(N)' that the system
     is in state i after N steps, given initial occupancy probabilities
     P0(1), ..., P0(N).

     *INPUTS*

    P
          `P(i,j)' is the transition probability from state i to state
          j. P must be an irreducible stochastic matrix, which means
          that the sum of each row must be 1 (\sum_j=1^N P_i, j = 1),
          and the rank of P must be equal to its dimension.

    N
          Number of transitions after which compute the state occupancy
          probabilities (n=0, 1, ...)

    P0
          `P0(i)' is the probability that at step 0 the system is in
          state i.


     *OUTPUTS*

    P
          If this function is called with a single argument, `P(i)' is
          the steady-state probability that the system is in state i.
          If this function is called with three arguments, `P(i)' is
          the probability that the system is in state i after N
          transitions, given the initial probabilities `P0(i)' that the
          initial state is i.


     See also: ctmc





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute stationary or transient state occupancy probabilities for a
discrete-tim



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dtmc_bd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
 -- Function File: P = dtmc_bd (B, D)
     This function is deprecated. Please use `dtmcbd' instead.

     See also: dtmcbd





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
dtmc_check_P


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
 -- Function File: [R ERR] = dtmc_check_P (P)
     This function is deprecated. Please use `dtmcchkP' instead.

     See also: dtmcchkP





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
dtmc_exps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 177
 -- Function File: L = dtmc_exps (P, N, P0)
 -- Function File: L = dtmc_exps (P, P0)
     This function is deprecated. Please use `dtmcexps' instead.

     See also: dtmcexps





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dtmc_fpt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
 -- Function File: M = dtmc_fpt (P)
     This function is deprecated. Please use `dtmcfpt' instead.

     See also: ctmcfpt





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
dtmc_is_irreducible


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
 -- Function File: [R S] = dtmc_is_irreducible (P)
     This function is deprecated. Please use `dtmcisir' instead.

     See also: dtmcisir





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
dtmc_mtta


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 182
 -- Function File: [T N B] = dtmc_mtta (P)
 -- Function File: [T N B] = dtmc_mtta (P, P0)
     This function is deprecated. Please use `dtmcmtta' instead.

     See also: ctmcmtta





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
dtmc_taexps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 175
 -- Function File: L = dtmc_taexps (P, N, P0)
 -- Function File: L = dtmc_taexps (P, P0)
     This function is deprecated. Please use `dtmctaexps' instead.

     `dtmcexps'





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dtmcbd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1122
 -- Function File: P = dtmcbd (B, D)
     Returns the transition probability matrix P for a discrete
     birth-death process over state space 1, 2, ..., N.  `B(i)' is the
     transition probability from state i to i+1, and `D(i)' is the
     transition probability from state i+1 to state i, i=1, 2, ..., N-1.

     Matrix \bf P is therefore defined as:

          /                                                             \
          | 1-b(1)     b(1)                                             |
          |  d(1)  (1-d(1)-b(2))     b(2)                               |
          |            d(2)      (1-d(2)-b(3))     b(3)                 |
          |                                                             |
          |                 ...           ...          ...              |
          |                                                             |
          |                         d(N-2)   (1-d(N-2)-b(N-1))  b(N-1)  |
          |                                        d(N-1)      1-d(N-1) |
          \                                                             /

     See also: ctmcbd





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Returns the transition probability matrix P for a discrete birth-death
process o



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dtmcchkP


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 289
 -- Function File: [R ERR] = dtmcchkP (P)
     Check whether P is a valid transition probability matrix.

     If P is valid, R is the size (number of rows or columns) of P. If
     P is not a transition probability matrix, R is set to zero, and
     ERR to an appropriate error string.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Check whether P is a valid transition probability matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dtmcexps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 918
 -- Function File: L = dtmcexps (P, N, P0)
 -- Function File: L = dtmcexps (P, P0)
     Compute the expected number of visits to each state during the
     first N transitions, or until abrosption.

     *INPUTS*

    P
          N \times N transition probability matrix.

    N
          Number of steps during which the expected number of visits are
          computed (N >= 0). If `N=0', returns P0. If `N > 0', returns
          the expected number of visits after exactly N transitions.

    P0
          Initial state occupancy probability.


     *OUTPUTS*

    L
          When called with two arguments, `L(i)' is the expected number
          of visits to transient state i before absorption. When called
          with three arguments, `L(i)' is the expected number of visits
          to state i during the first N transitions, given initial
          occupancy probability P0.


     See also: ctmcexps





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the expected number of visits to each state during the first N
transitio



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dtmcfpt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 788
 -- Function File: M = dtmcfpt (P)
     Compute mean first passage times and mean recurrence times for an
     irreducible discrete-time Markov chain.

     *INPUTS*

    P
          `P(i,j)' is the transition probability from state i to state
          j. P must be an irreducible stochastic matrix, which means
          that the sum of each row must be 1 (\sum_j=1^N P_i j = 1),
          and the rank of P must be equal to its dimension.


     *OUTPUTS*

    M
          For all i \neq j, `M(i,j)' is the average number of
          transitions before state J is reached for the first time,
          starting from state I. `M(i,i)' is the _mean recurrence time_
          of state i, and represents the average time needed to return
          to state I.


     See also: ctmcfpt





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute mean first passage times and mean recurrence times for an
irreducible di



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dtmcisir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 718
 -- Function File: [R S] = dtmcisir (P)
     Check if P is irreducible, and identify Strongly Connected
     Components (SCC) in the transition graph of the DTMC with
     transition probability matrix P.

     *INPUTS*

    P
          `P(i,j)' is the transition probability from state i to state
          j. This function does not currently check whether P is a
          valid transition probability matrix.


     *OUTPUTS*

    R
          1 if P irreducible, 0 otherwise.

    S
          `S(i)' is the SCC that state i belongs to. SCCs are numbered
          as 1, 2, .... If the graph is strongly connected, then there
          is a single SCC and the predicate `all(s == 1)' evaluates to
          true.






# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Check if P is irreducible, and identify Strongly Connected Components
(SCC) in t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dtmcmtta


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1872
 -- Function File: [T N B] = dtmcmtta (P)
 -- Function File: [T N B] = dtmcmtta (P, P0)
     Compute the expected number of steps before absorption for a DTMC
     with N \times N transition probability matrix P; compute also the
     fundamental matrix N for P.

     *INPUTS*

    P
          N \times N transition probability matrix.


     *OUTPUTS*

    T
          When called with a single argument, T is a vector of size N
          such that `T(i)' is the expected number of steps before being
          absorbed in any absorbing state, starting from state i; if i
          is absorbing, `T(i) = 0'. When called with two arguments, T
          is a scalar, and represents the expected number of steps
          before absorption, starting from the initial state occupancy
          probability P0.

    N
          When called with a single argument, N is the N \times N
          fundamental matrix for P. `N(i,j)' is the expected number of
          visits to transient state J before absorption, if it is
          started in transient state I. The initial state is counted if
          i = j. When called with two arguments, N is a vector of size
          N such that `N(j)' is the expected number of visits to
          transient state J before absorption, given initial state
          occupancy probability P0.

    B
          When called with a single argument, B is a N \times N matrix
          where `B(i,j)' is the probability of being absorbed in state
          j, starting from transient state i; if j is not absorbing,
          `B(i,j) = 0'; if i is absorbing, `B(i,i) = 1' and `B(i,j) =
          0' for all j \neq j. When called with two arguments, B is a
          vector of size N where `B(j)' is the probability of being
          absorbed in state J, given initial state occupancy
          probabilities P0.


     See also: ctmcmtta





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the expected number of steps before absorption for a DTMC with
N \times 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
dtmctaexps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1023
 -- Function File: L = dtmctaexps (P, N, P0)
 -- Function File: L = dtmctaexps (P, P0)
     Compute the _time-averaged sojourn time_ `M(i)', defined as the
     fraction of time steps {0, 1, ..., n} (or until absorption) spent
     in state i, assuming that the state occupancy probabilities at
     time 0 are P0.

     *INPUTS*

    P
          N \times N transition probability matrix.

    N
          Number of transitions during which the time-averaged expected
          sojourn times are computed (N >= 0). if N = 0, returns P0.

    P0
          Initial state occupancy probabilities.


     *OUTPUTS*

    M
          If this function is called with three arguments, `M(i)' is
          the expected fraction of steps {0, 1, ..., n} spent in state
          i, assuming that the state occupancy probabilities at time
          zero are P0. If this function is called with two arguments,
          `M(i)' is the expected fraction of steps spent in state i
          until absorption.


     See also: ctmctaexps





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the _time-averaged sojourn time_ `M(i)', defined as the
fraction of time



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
population_mix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
 -- Function File: pop_mix = population_mix (K, N)
     This function is deprecated. Please use `qncmpopmix' instead.

     See also: qncmpopmix





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qnammm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
 -- Function File: [U, R, Q, X] = qnammm (LAMBDA, MU)
     This function is deprecated. Please use `qsammm' instead.

     See also: qsammm





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qnclosed


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1290
 -- Function File: [U, R, Q, X] = qnclosed (N, S, V, ...)
     This function computes steady-state performance measures of closed
     queueing networks using the Mean Value Analysis (MVA) algorithm.
     The qneneing network is allowed to contain fixed-capacity centers,
     delay centers or general load-dependent centers. Multiple request
     classes are supported.

     This function dispatches the computation to one of `qncsemva',
     `qncsmvald' or `qncmmva'.

        * If N is a scalar, the network is assumed to have a single
          class of requests; in this case, the exact MVA algorithm is
          used to analyze the network. If S is a vector, then `S(k)' is
          the average service time of center k, and this function calls
          `qncsmva' which supports load-independent service centers. If
          S is a matrix, `S(k,i)' is the average service time at center
          k when i=1, ..., N jobs are present; in this case, the
          network is analyzed with the `qncmmvald' function.

        * If N is a vector, the network is assumed to have multiple
          classes of requests, and is analyzed using the exact
          multiclass MVA algorithm as implemented in the `qncmmva'
          function.


     See also: qncsmva, qncsmvald, qncmmva





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function computes steady-state performance measures of closed
queueing netw



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
qnclosedab


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
 -- Function File: [XL, XU, RL, RU] = qnclosedab (N, ...)
     This function is deprecated. Please use `qncsaba' instead.

     See also: qncsaba





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
qnclosedbsb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
 -- Function File: [XL, XU, RL, RU] = qnclosedbsb (N, ... )
     This function is deprecated. Please use `qncsbsb' instead.

     See also: qncsbsb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
qnclosedgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
 -- Function File: [XL, XU, QL, QU] = qnclosedgb (N, D, Z)
     This function is deprecated. Please use `qncsgb' instead.

     See also: qncsgb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
qnclosedmultimva


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 466
 -- Function File: [U, R, Q, X] = qnclosedmultimva (N, S )
 -- Function File: [U, R, Q, X] = qnclosedmultimva (N, S, V)
 -- Function File: [U, R, Q, X] = qnclosedmultimva (N, S, V, M)
 -- Function File: [U, R, Q, X] = qnclosedmultimva (N, S, V, M, Z)
 -- Function File: [U, R, Q, X] = qnclosedmultimva (N, S, P)
 -- Function File: [U, R, Q, X] = qnclosedmultimva (N, S, P, M)
     This function is deprecated. Please use `qncmmva' instead.

     See also: qncmmva





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
qnclosedmultimvaapprox


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 490
 -- Function File: [U, R, Q, X] = qnclosedmultimvaapprox (N, S, V)
 -- Function File: [U, R, Q, X] = qnclosedmultimvaapprox (N, S, V, M)
 -- Function File: [U, R, Q, X] = qnclosedmultimvaapprox (N, S, V, M, Z)
 -- Function File: [U, R, Q, X] = qnclosedmultimvaapprox (N, S, V, M,
          Z, TOL)
 -- Function File: [U, R, Q, X] = qnclosedmultimvaapprox (N, S, V, M,
          Z, TOL, ITER_MAX)
     This function is deprecated. Please use `qncmmvaap' instead.

     See also: qncmmvaap





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
qnclosedpb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 205
 -- Function File: [XL, XU, RL, RU] = qnclosedpb (N, D )
 -- Function File: [XL, XU, RL, RU] = qnclosedpb (N, D, Z )
     This function is deprecated. Please use `qncspb' instead.

     See also: qncspb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
qnclosedsinglemva


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 294
 -- Function File: [U, R, Q, X, G] = qnclosedsinglemva (N, S, V)
 -- Function File: [U, R, Q, X, G] = qnclosedsinglemva (N, S, V, M)
 -- Function File: [U, R, Q, X, G] = qnclosedsinglemva (N, S, V, M, Z)
     This function is deprecated. Please use `qncsmva' instead.

     See also: qncsmva





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
qnclosedsinglemvaapprox


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 505
 -- Function File: [U, R, Q, X] = qnclosedsinglemvaapprox (N, S, V)
 -- Function File: [U, R, Q, X] = qnclosedsinglemvaapprox (N, S, V, M)
 -- Function File: [U, R, Q, X] = qnclosedsinglemvaapprox (N, S, V, M,
          Z)
 -- Function File: [U, R, Q, X] = qnclosedsinglemvaapprox (N, S, V, M,
          Z, TOL)
 -- Function File: [U, R, Q, X] = qnclosedsinglemvaapprox (N, S, V, M,
          Z, TOL, ITER_MAX)
     This function is deprecated. Please use `qncsmvaap' instead.

     See also: qncsmvaap





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
qnclosedsinglemvald


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 225
 -- Function File: [U, R, Q, X] = qnclosedsinglemvald (N, S, V)
 -- Function File: [U, R, Q, X] = qnclosedsinglemvald (N, S, V, Z)
     This function is deprecated. Please use `qncsmvald' instead.

     See also: qncsmvald





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qncmaba


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1435
 -- Function File: [XL, XU, RL, RU] = qncmaba (N, D)
 -- Function File: [XL, XU, RL, RU] = qncmaba (N, S, V)
 -- Function File: [XL, XU, RL, RU] = qncmaba (N, S, V, M)
 -- Function File: [XL, XU, RL, RU] = qncmaba (N, S, V, M, Z)
     Compute Asymptotic Bounds for multiclass networks.  Single-server
     and infinite-server nodes are supported.  Multiple-server nodes
     and general load-dependent servers are not supported.

     *INPUTS*

    N
          `N(c)' is the number of class c requests in the system.

    D
          `D(c, k)' is class c service demand at center k (`D(c,k) >=
          0').

    S
          `S(c, k)' is the mean service time of class c requests at
          center k (`S(c,k) >= 0').

    V
          `V(c,k)' is the average number of visits of class c requests
          to center k (`V(c,k) >= 0').

    M
          `M(k)' is the number of servers at center k (if M is a
          scalar, all centers have that number of servers). If `M(k) <
          1', center k is a delay center (IS); if `M(k) = 1', center k
          is a M/M/1-FCFS server.  This function does not support
          multiple-server nodes. Default is 1.

    Z
          `Z(c)' is class c external delay (`Z(c) >= 0'). Default is 0.


     *OUTPUTS*

    XL
    XU
          Lower and upper class c throughput bounds.

    RL
    RU
          Lower and upper class c response time bounds.


     See also: qnclosedsingleab





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute Asymptotic Bounds for multiclass networks.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qncmbsb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 817
 -- Function File: [XL, XU, RL, RU] = qncmbsb (N, D)
 -- Function File: [XL, XU, RL, RU] = qncmbsb (N, S, V)
     Compute Balanced System Bounds for multiclass networks.  Only
     single-server nodes are supported.

     *INPUTS*

    N
          `N(c)' is the number of class c requests in the system.

    D
          `D(c, k)' is class c service demand at center k (`D(c,k) >=
          0').

    S
          `S(c, k)' is the mean service time of class c requests at
          center k (`S(c,k) >= 0').

    V
          `V(c,k)' is the average number of visits of class c requests
          to center k (`V(c,k) >= 0').


     *OUTPUTS*

    XL
    XU
          Lower and upper class c throughput bounds.

    RL
    RU
          Lower and upper class c response time bounds.


     See also: qnclosedsinglebsb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Compute Balanced System Bounds for multiclass networks.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qncmcb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1060
 -- Function File: [XL, XU, RL, RU] = qncmcb (N, D)
 -- Function File: [XL, XU, RL, RU] = qncmcb (N, S, V)
     Composite Bound (CB) on throughput and response time for closed
     multiclass networks.

     This function implements the Composite Bound Method described in T.
     Kerola, `The Composite Bound Method (CBM) for Computing Throughput
     Bounds in Multiple Class Environments', Technical Report
     CSD-TR-475, Purdue University, march 13, 1984 (revised august 27,
     1984).

     *INPUTS*

    N
          `N(c)' is the number of class c requests in the system.

    D
          `D(c, k)' is class c service demand at center k (`S(c,k) >=
          0').

    S
          `S(c, k)' is the mean service time of class c requests at
          center k (`S(c,k) >= 0').

    V
          `V(c,k)' is the average number of visits of class c requests
          to center k (`V(c,k) >= 0').


     *OUTPUTS*

    XL
    XU
          Lower and upper class c throughput bounds.

    RL
    RU
          Lower and upper class c response time bounds.






# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Composite Bound (CB) on throughput and response time for closed
multiclass netwo



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qncmmva


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4892
 -- Function File: [U, R, Q, X] = qncmmva (N, S )
 -- Function File: [U, R, Q, X] = qncmmva (N, S, V)
 -- Function File: [U, R, Q, X] = qncmmva (N, S, V, M)
 -- Function File: [U, R, Q, X] = qncmmva (N, S, V, M, Z)
 -- Function File: [U, R, Q, X] = qncmmva (N, S, P)
 -- Function File: [U, R, Q, X] = qncmmva (N, S, P, R)
 -- Function File: [U, R, Q, X] = qncmmva (N, S, P, R, M)
     Compute steady-state performance measures for closed, multiclass
     queueing networks using the Mean Value Analysys (MVA) algorithm.

     Queueing policies at service centers can be any of the following:

    *FCFS*
          (First-Come-First-Served) customers are served in order of
          arrival; multiple servers are allowed. For this kind of
          queueing discipline, average service times must be
          class-independent.

    *PS*
          (Processor Sharing) customers are served in parallel by a
          single server, each customer receiving an equal share of the
          service rate.

    *LCFS-PR*
          (Last-Come-First-Served, Preemptive Resume) customers are
          served in reverse order of arrival by a single server and the
          last arrival preempts the customer in service who will later
          resume service at the point of interruption.

    *IS*
          (Infinite Server) customers are delayed independently of other
          customers at the service center (there is effectively an
          infinite number of servers).


          Note: If this function is called specifying the visit ratios
          V, class switching is *not* allowed.

          If this function is called specifying the routing probability
          matrix P, then class switching *is* allowed; however, in this
          case all nodes are restricted to be fixed rate servers or
          delay centers: multiple-server and general load-dependent
          centers are not supported.

     *INPUTS*

    N
          `N(c)' is the number of class c requests in the system; `N(c)
          >= 0'. If class c has no requests (`N(c) == 0'), then for all
          K, `U(c,k) = R(c,k) = Q(c,k) = X(c,k) = 0'

    S
          `S(c,k)' is the mean service time for class c customers at
          center k (`S(c,k) >= 0'). If the service time at center k is
          class-dependent, i.e., different classes have different
          service times at center k, then center k is assumed to be of
          type -/G/1-PS (Processor Sharing).  If center k is a FCFS
          node (`M(k)>1'), then the service times *must* be
          class-independent, i.e., all classes *must* have the same
          service time.

    V
          `V(c,k)' is the average number of visits of class c customers
          to service center k; `V(c,k) >= 0', default is 1.  *If you
          pass this argument, class switching is not allowed*

    P
          `P(r,i,s,j)' is the probability that a class r job completing
          service at center i is routed to center j as a class s job;
          the reference stations for each class are specified with the
          paramter R.  *If you pass argument P, class switching is
          allowed*, but you can not specify any external delay (i.e., Z
          must be zero).

    R
          `R(c)' is the reference station for class c.  If omitted,
          station 1 is the reference station for all classes.  See
          `qncmvisits'.

    M
          If `M(k)<1', then center k is assumed to be a delay center
          (IS node -/G/\infty). If `M(k)==1', then service center k is
          a regular queueing center (M/M/1-FCFS, -/G/1-LCFS-PR or
          -/G/1-PS).  Finally, if `M(k)>1', center k is a M/M/m-FCFS
          center with `M(k)' identical servers.  Default is `M(k)=1'
          for each k.

    Z
          `Z(c)' is the class c external delay (think time); `Z(c) >=
          0'. Default is 0. This parameter can not be used if you pass
          a routing matrix as the second parameter of `qncmmva'.


     *OUTPUTS*

    U
          If k is a FCFS, LCFS-PR or PS node, then `U(c,k)' is the
          class c utilization at center k. If k is an IS node, then
          `U(c,k)' is the class c _traffic intensity_ at center k,
          defined as `U(c,k) = X(c,k)*S(c,k)'.

    R
          `R(c,k)' is the class c response time at center k. The class
          c _residence time_ at center k is `R(c,k) * C(c,k)'.  The
          total class c system response time is `dot(R, V, 2)'.

    Q
          `Q(c,k)' is the average number of class c requests at center
          k. The total number of requests at center k is `sum(Q(:,k))'.
          The total number of class c requests in the system is
          `sum(Q(c,:))'.

    X
          `X(c,k)' is the class c throughput at center k. The class c
          throughput can be computed as `X(c,1) / V(c,1)'.


     See also: qnclosed, qncmmvaapprox, qncmvisits





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute steady-state performance measures for closed, multiclass
queueing networ



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
qncmmvaap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2883
 -- Function File: [U, R, Q, X] = qncmmvaap (N, S, V)
 -- Function File: [U, R, Q, X] = qncmmvaap (N, S, V, M)
 -- Function File: [U, R, Q, X] = qncmmvaap (N, S, V, M, Z)
 -- Function File: [U, R, Q, X] = qncmmvaap (N, S, V, M, Z, TOL)
 -- Function File: [U, R, Q, X] = qncmmvaap (N, S, V, M, Z, TOL,
          ITER_MAX)
     Analyze closed, multiclass queueing networks with K service
     centers and C customer classes using the approximate Mean Value
     Analysys (MVA) algorithm.

     This implementation uses Bard and Schweitzer approximation. It is
     based on the assumption that the queue length at service center k
     with population set \bf N-\bf 1_c is approximately equal to the
     queue length with population set \bf N, times (n-1)/n:

          Q_i(N-1c) ~ (n-1)/n Q_i(N)

     where \bf N is a valid population mix, \bf N-\bf 1_c is the
     population mix \bf N with one class c customer removed, and n =
     \sum_c N_c is the total number of requests.

     This implementation works for networks made of infinite server (IS)
     nodes and single-server nodes only.

     *INPUTS*

    N
          `N(c)' is the number of class c requests in the system
          (`N(c)>0').

    S
          `S(c,k)' is the mean service time for class c customers at
          center k (`S(c,k) >= 0').

    V
          `V(c,k)' is the average number of visits of class c requests
          to center k (`V(c,k) >= 0').

    M
          `M(k)' is the number of servers at service center k. If `M(k)
          < 1', then the service center k is assumed to be a delay
          center (IS). If `M(k) == 1', service center k is a regular
          queueing center (FCFS, LCFS-PR or PS) with a single server
          node. If omitted, each service center has a single server.
          Note that multiple server nodes are not supported.

    Z
          `Z(c)' is the class c external delay. Default is 0.

    TOL
          Stopping tolerance (`TOL>0'). The algorithm stops if the
          queue length computed on two subsequent iterations are less
          than TOL. Default is 10^-5.

    ITER_MAX
          Maximum number of iterations (`ITER_MAX>0'.  The function
          aborts if convergenge is not reached within the maximum
          number of iterations. Default is 100.


     *OUTPUTS*

    U
          If k is a FCFS, LCFS-PR or PS node, then `U(c,k)' is the
          utilization of class c requests on service center k. If k is
          an IS node, then `U(c,k)' is the class c _traffic intensity_
          at device k, defined as `U(c,k) = X(c)*S(c,k)'

    R
          `R(c,k)' is the response time of class c requests at service
          center k.

    Q
          `Q(c,k)' is the average number of class c requests at service
          center k.

    X
          `X(c,k)' is the class c throughput at service center k.


     See also: qncmmva





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Analyze closed, multiclass queueing networks with K service centers and
C custom



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qncmnpop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 654
 -- Function File: H = qncmnpop (N)
     Given a network with C customer classes, this function computes
     the number of valid population mixes `H(r,n)' that can be
     constructed by the multiclass MVA algorithm by allocating n
     customers to the first r classes.

     *INPUTS*

    N
          Population vector. `N(c)' is the number of class-c requests
          in the system. The total number of requests in the network is
          `sum(N)'.


     *OUTPUTS*

    H
          `H(r,n)' is the number of valid populations that can be
          constructed allocating n customers to the first r classes.


     See also: qncmmva, qncmpopmix





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given a network with C customer classes, this function computes the
number of va



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
qncmpopmix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1234
 -- Function File: pop_mix = qncmpopmix (K, N)
     Return the set of valid population mixes with exactly K customers,
     for a closed multiclass Queueing Network with population vector N.
     More specifically, given a multiclass Queueing Network with C
     customer classes, such that there are `N(i)' requests of class i, a
     k-mix MIX is a C-dimensional vector with the following properties:

          all( mix >= 0 );
          all( mix <= N );
          sum( mix ) == k;

     This function enumerates all valid k-mixes, such that `POP_MIX(i)'
     is a C dimensional row vector representing a valid population mix,
     for all i.

     *INPUTS*

    K
          Total population size of the requested mix. K must be a
          nonnegative integer

    N
          `N(i)' is the number of class i requests.  The condition `K
          <= sum(N)' must hold.


     *OUTPUTS*

    POP_MIX
          `POP_MIX(i,j)' is the number of class j requests in the i-th
          population mix. The number of population mixes is `rows(
          POP_MIX ) '.


     Note that if you are interested in the number of k-mixes and you
     don't care to enumerate them, you can use the funcion `qnmvapop'.

     See also: qncmnpop





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the set of valid population mixes with exactly K customers, for
a closed 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qncmva


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 207
 -- Function File: [U, R, Q, X] = qncmva (N, S, SLD, V)
 -- Function File: [U, R, Q, X] = qncmva (N, S, SLD, V, Z)
     This function is deprecated. Please use `qncscmva' instead.

     See also: qncscmva





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
qncmvisits


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1352
 -- Function File: [V CH] = qncmvisits (P)
 -- Function File: [V CH] = qncmvisits (P, R)
     Compute the average number of visits to the service centers of a
     closed multiclass network with K service centers and C customer
     classes.

     *INPUTS*

    P
          `P(r,i,s,j)' is the probability that a class r request which
          completed service at center i is routed to center j as a
          class s request. Class switching is allowed.

    R
          `R(c)' is the index of class c reference station, r(c) \in
          {1, ..., K}, c \in {1, \..., C}.  The class c visit count to
          server `R(c)' (`V(c,r(c))') is conventionally set to 1. The
          reference station serves two purposes: (i) its throughput is
          assumed to be the system throughput, and (ii) a job returning
          to the reference station is assumed to have completed one
          cycle. Default is to consider station 1 as the reference
          station for all classes.


     *OUTPUTS*

    V
          `V(c,i)' is the number of visits of class c requests at
          center i.

    CH
          `CH(c)' is the chain number that class c belongs to.
          Different classes can belong to the same chain. Chains are
          numbered sequentially starting from 1 (1, 2, ...). The total
          number of chains is `max(CH)'.






# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the average number of visits to the service centers of a closed
multicla



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
qnconvolution


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 217
 -- Function File: [U, R, Q, X, G] = qnconvolution (N, S, V)
 -- Function File: [U, R, Q, X, G] = qnconvolution (N, S, V, M)
     This function is deprecated. Please use `qncsconv' instead.

     See also: qncsconv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
qnconvolutionld


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 159
 -- Function File: [U, R, Q, X, G] = qnconvolutionld (N, S, V)
     This function is deprecated. Please use `qncsconvld' instead.

     See also: qncsconvld





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qncsaba


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1363
 -- Function File: [XL, XU, RL, RU] = qncsaba (N, D)
 -- Function File: [XL, XU, RL, RU] = qncsaba (N, S, V)
 -- Function File: [XL, XU, RL, RU] = qncsaba (N, S, V, M)
 -- Function File: [XL, XU, RL, RU] = qncsaba (N, S, V, M, Z)
     Compute Asymptotic Bounds for throughput and response time of
     closed, single-class networks.

     Single-server and infinite-server nodes are supported.
     Multiple-server nodes and general load-dependent servers are not
     supported.

     *INPUTS*

    N
          number of requests in the system (scalar, `N>0').

    D
          `D(k)' is the service demand at center k (`D(k) >= 0').

    S
          `S(k)' is the mean service time at center k (`S(k) >= 0').

    V
          `V(k)' is the average number of visits to center k (`V(k) >=
          0').

    M
          `M(k)' is the number of servers at center k (if M is a
          scalar, all centers have that number of servers). If `M(k) <
          1', center k is a delay center (IS); if `M(k) = 1', center k
          is a M/M/1-FCFS server.  This function does not support
          multiple-server nodes. Default is 1.

    Z
          External delay (`Z >= 0'). Default is 0.


     *OUTPUTS*

    XL
    XU
          Lower and upper system throughput bounds.

    RL
    RU
          Lower and upper response time bounds.


     See also: qncmaba





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute Asymptotic Bounds for throughput and response time of closed,
single-cla



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qncsbsb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1143
 -- Function File: [XL, XU, RL, RU] = qncsbsb (N, D)
 -- Function File: [XL, XU, RL, RU] = qncsbsb (N, S, V)
 -- Function File: [XL, XU, RL, RU] = qncsbsb (N, S, V, M)
 -- Function File: [XL, XU, RL, RU] = qncsbsb (N, S, V, M, Z)
     Compute Balanced System Bounds on system throughput and response
     time for closed, single-class networks.

     *INPUTS*

    N
          number of requests in the system (scalar).

    D
          `D(k)' is the service demand at center k (`D(k) >= 0').

    S
          `S(k)' is the mean service time at center k (`S(k) >= 0').

    V
          `V(k)' is the average number of visits to center k (`V(k) >=
          0'). Default is 1.

    M
          `M(k)' is the number of servers at center k. This function
          supports `M(k) = 1' only (sing-eserver FCFS nodes). This
          option is left for compatibility with `qncsaba', Default is 1.

    Z
          External delay (`Z >= 0'). Default is 0.


     *OUTPUTS*

    XL
    XU
          Lower and upper bound on the system throughput.

    RL
    RU
          Lower and upper bound on the system response time.


     See also: qncmbsb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute Balanced System Bounds on system throughput and response time
for closed



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qncscmva


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1829
 -- Function File: [U, R, Q, X] = qncscmva (N, S, SLD, V)
 -- Function File: [U, R, Q, X] = qncscmva (N, S, SLD, V, Z)
     This is the implementation of the original Conditional MVA (CMVA)
     algorithm, a numerically stable variant of MVA, as described in G.
     Casale, `A Note on Stable Flow-Equivalent Aggregation in Closed
     Networks'. This function supports a network of M >= 1 service
     centers and a single delay center. Servers 1, ..., M-1 are
     load-independent; server M is load-dependent.

     *INPUTS*

    N
          Number of requests in the system, `N >= 0'. If `N == 0', this
          function returns `U = R = Q = X = 0'

    S
          Vector of mean service times for load-independent (fixed
          rate) servers.  Specifically, `S(k)' is the mean service time
          on server k = 1, ..., M-1 (`S(k) > 0'). If there are no
          fixed-rate servers, then `S = []'

    SLD
          `SLD(n)' is the inverse service rate at server M (the
          load-dependent server) when there are n requests, n=1, ...,
          N. `SLD(n) = ' 1 / \mu(n).

    V
          `V(k)' is the average number of visits to service center k=1,
          ..., M, where `V(k) >= 0'.  `V(1:M-1)' are the visit rates to
          the fixed rate servers; `V(M)' is the visit rate to the load
          dependent server.

    Z
          External delay for customers (`Z >= 0'). Default is 0.


     *OUTPUTS*

    U
          `U(k)' is the utilization of center k (k=1, ..., M)

    R
          `R(k)' is the response time of center k, (k=1, ..., M). The
          system response time RSYS can be computed as `RSYS = N/XSYS -
          Z'

    Q
          `Q(k)' is the average number of requests at center k, (k=1,
          ..., M).

    X
          `X(k)' is the throughput of center k, (k=1, ..., M).






# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This is the implementation of the original Conditional MVA (CMVA)
algorithm, a n



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qncsconv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1407
 -- Function File: [U, R, Q, X, G] = qncsconv (N, S, V)
 -- Function File: [U, R, Q, X, G] = qncsconv (N, S, V, M)
     Analyze product-form, single class closed networks using the
     convolution algorithm.

     Load-independent service centers, multiple servers (M/M/m queues)
     and IS nodes are supported. For general load-dependent service
     centers, use `qncsconvld' instead.

     *INPUTS*

    N
          Number of requests in the system (`N>0').

    S
          `S(k)' is the average service time on center k (`S(k) >= 0').

    V
          `V(k)' is the visit count of service center k (`V(k) >= 0').

    M
          `M(k)' is the number of servers at center k. If `M(k) < 1',
          center k is a delay center (IS); if `M(k) >= 1', center k it
          is a regular M/M/m queueing center with `M(k)' identical
          servers. Default is `M(k) = 1' for all k.


     *OUTPUT*

    U
          `U(k)' is the utilization of center k.  For IS nodes, `U(k)'
          is the _traffic intensity_.

    R
          `R(k)' is the average response time of center k.

    Q
          `Q(k)' is the average number of customers at center k.

    X
          `X(k)' is the throughput of center k.

    G
          Vector of normalization constants. `G(n+1)' contains the
          value of the normalization constant with n requests G(n),
          n=0, ..., N.


     See also: qncsconvld





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Analyze product-form, single class closed networks using the
convolution algorit



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
qncsconvld


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1449
 -- Function File: [U, R, Q, X, G] = qncsconvld (N, S, V)
     This function implements the _convolution algorithm_ for
     product-form, single-class closed queueing networks with general
     load-dependent service centers.

     This function computes steady-state performance measures for
     single-class, closed networks with load-dependent service centers
     using the convolution algorithm; the normalization constants are
     also computed. The normalization constants are returned as vector
     `G=[G(1), ..., G(N+1)]' where `G(i+1)' is the value of G(i).

     *INPUTS*

    N
          Number of requests in the system (`N>0').

    S
          `S(k,n)' is the mean service time at center k where there are
          n requests, 1 <= n <= N. `S(k,n)' = 1 / \mu_k,n, where
          \mu_k,n is the service rate of center k when there are n
          requests.

    V
          `V(k)' is the visit count of service center k (`V(k) >= 0').
          The length of V is the number of servers K in the network.


     *OUTPUT*

    U
          `U(k)' is the utilization of center k.

    R
          `R(k)' is the average response time at center k.

    Q
          `Q(k)' is the average number of customers in center k.

    X
          `X(k)' is the throughput of center k.

    G
          Normalization constants (vector). `G(n+1)' corresponds to
          G(n), as array indexes in Octave start from 1.


     See also: qncsconv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function implements the _convolution algorithm_ for product-form,
single-cl



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qncsgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1560
 -- Function File: [XL, XU, RL, RU, QL, QU] = qncsgb (N, D)
 -- Function File: [XL, XU, RL, RU, QL, QU] = qncsgb (N, S, V)
 -- Function File: [XL, XU, RL, RU, QL, QU] = qncsgb (N, S, V, M)
 -- Function File: [XL, XU, RL, RU, QL, QU] = qncsgb (N, S, V, M, Z)
     Compute Geometric Bounds (GB) on system throughput, system
     response time and server queue lenghts for closed, single-class
     networks.

     *INPUTS*

    N
          number of requests in the system (scalar, `N > 0').

    D
          `D(k)' is the service demand of service center k (`D(k) >=
          0').

    S
          `S(k)' is the mean service time at center k (`S(k) >= 0').

    V
          `V(k)' is the visit ratio to center k (`V(k) >= 0').

    M
          `M(k)' is the number of servers at center k.  This function
          only supports M/M/1 queues, therefore M must be
          `ones(size(S))'.

    Z
          external delay (think time, `Z >= 0'). Default 0.


     *OUTPUTS*

    XL
    XU
          Lower and upper bound on the system throughput. If `Z>0',
          these bounds are computed using _Geometric Square-root Bounds_
          (GSB). If `Z==0', these bounds are computed using _Geometric
          Bounds_ (GB)

    RL
    RU
          Lower and upper bound on the system response time. These
          bounds are derived from XL and XU using Little's Law: `RL = N
          / XU - Z', `RU = N / XL - Z'

    QL
    QU
          `QL(i)' and `QU(i)' are the lower and upper bounds
          respectively of the queue length for service center i.






# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute Geometric Bounds (GB) on system throughput, system response
time and ser



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qncsmva


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2943
 -- Function File: [U, R, Q, X, G] = qncsmva (N, S, V)
 -- Function File: [U, R, Q, X, G] = qncsmva (N, S, V, M)
 -- Function File: [U, R, Q, X, G] = qncsmva (N, S, V, M, Z)
     Analyze closed, single class queueing networks using the exact
     Mean Value Analysis (MVA) algorithm.

     The following queueing disciplines are supported: FCFS, LCFS-PR, PS
     and IS (Infinite Server). This function supports fixed-rate service
     centers or multiple server nodes. For general load-dependent
     service centers, use the function `qncsmvald' instead.

     Additionally, the normalization constant G(n), n=0, ..., N is
     computed; G(n) can be used in conjunction with the BCMP theorem to
     compute steady-state probabilities.

     *INPUTS*

    N
          Population size (number of requests in the system, `N >= 0').
          If `N == 0', this function returns `U = R = Q = X = 0'

    S
          `S(k)' is the mean service time at center k (`S(k) >= 0').

    V
          `V(k)' is the average number of visits to service center k
          (`V(k) >= 0').

    Z
          External delay for customers (`Z >= 0'). Default is 0.

    M
          `M(k)' is the number of servers at center k (if M is a
          scalar, all centers have that number of servers). If `M(k) <
          1', center k is a delay center (IS); otherwise it is a
          regular queueing center (FCFS, LCFS-PR or PS) with `M(k)'
          servers. Default is `M(k) = 1' for all k (each service center
          has a single server).


     *OUTPUTS*

    U
          If k is a FCFS, LCFS-PR or PS node (`M(k) == 1'), then `U(k)'
          is the utilization of center k. If k is an IS node (`M(k) <
          1'), then `U(k)' is the _traffic intensity_ defined as
          `X(k)*S(k)'.

    R
          `R(k)' is the response time at center k.  The _Residence
          Time_ at center k is `R(k) * V(k)'.  The system response time
          RSYS can be computed either as `RSYS = N/XSYS - Z' or as
          `RSYS = dot(R,V)'

    Q
          `Q(k)' is the average number of requests at center k. The
          number of requests in the system can be computed either as
          `sum(Q)', or using the formula `N-XSYS*Z'.

    X
          `X(k)' is the throughput of center k. The system throughput
          XSYS can be computed as `XSYS = X(1) / V(1)'

    G
          Normalization constants. `G(n+1)' corresponds to the value of
          the normalization constant G(n), n=0, ..., N as array indexes
          in Octave start from 1. G(n) can be used in conjunction with
          the BCMP theorem to compute steady-state probabilities.


          Note: In presence of load-dependent servers (i.e., if `M(i)>1'
          for some i), the MVA algorithm is known to be numerically
          unstable. Generally this problem manifests itself as negative
          response times produced by this function.

     See also: qncsmvald, qncscmva





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Analyze closed, single class queueing networks using the exact Mean
Value Analys



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
qncsmvaap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2673
 -- Function File: [U, R, Q, X] = qncsmvaap (N, S, V)
 -- Function File: [U, R, Q, X] = qncsmvaap (N, S, V, M)
 -- Function File: [U, R, Q, X] = qncsmvaap (N, S, V, M, Z)
 -- Function File: [U, R, Q, X] = qncsmvaap (N, S, V, M, Z, TOL)
 -- Function File: [U, R, Q, X] = qncsmvaap (N, S, V, M, Z, TOL,
          ITER_MAX)
     Analyze closed, single class queueing networks using the
     Approximate Mean Value Analysis (MVA) algorithm. This function is
     based on approximating the number of customers seen at center k
     when a new request arrives as Q_k(N) \times (N-1)/N. This function
     only handles single-server and delay centers; if your network
     contains general load-dependent service centers, use the function
     `qncsmvald' instead.

     *INPUTS*

    N
          Population size (number of requests in the system, `N > 0').

    S
          `S(k)' is the mean service time on server k (`S(k)>0').

    V
          `V(k)' is the average number of visits to service center k
          (`V(k) >= 0').

    M
          `M(k)' is the number of servers at center k (if M is a
          scalar, all centers have that number of servers). If `M(k) <
          1', center k is a delay center (IS); if `M(k) == 1', center k
          is a regular queueing center (FCFS, LCFS-PR or PS) with one
          server (default). This function does not support multiple
          server nodes (`M(k) > 1').

    Z
          External delay for customers (`Z >= 0'). Default is 0.

    TOL
          Stopping tolerance. The algorithm stops when the maximum
          relative difference between the new and old value of the
          queue lengths Q becomes less than the tolerance. Default is
          10^-5.

    ITER_MAX
          Maximum number of iterations (`ITER_MAX>0'.  The function
          aborts if convergenge is not reached within the maximum
          number of iterations. Default is 100.


     *OUTPUTS*

    U
          If k is a FCFS, LCFS-PR or PS node (`M(k) == 1'), then `U(k)'
          is the utilization of center k. If k is an IS node (`M(k) <
          1'), then `U(k)' is the _traffic intensity_ defined as
          `X(k)*S(k)'.

    R
          `R(k)' is the response time at center k.  The system response
          time RSYS can be computed as `RSYS = N/XSYS - Z'

    Q
          `Q(k)' is the average number of requests at center k. The
          number of requests in the system can be computed either as
          `sum(Q)', or using the formula `N-XSYS*Z'.

    X
          `X(k)' is the throughput of center k. The system throughput
          XSYS can be computed as `XSYS = X(1) / V(1)'


     See also: qncsmva, qncsmvald





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Analyze closed, single class queueing networks using the Approximate
Mean Value 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
qncsmvablo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1184
 -- Function File: [U, R, Q, X] = qncsmvablo (N, S, M, P )
     Approximate MVA algorithm for closed queueing networks with
     blocking.

     *INPUTS*

    N
          population size, i.e., number of requests in the system. N
          must be strictly greater than zero, and less than the overall
          network capacity: `0 < N < sum(M)'.

    S
          Average service time. `S(i)' is the average service time
          requested on server i (`S(i) > 0').

    M
          `M(i)' is the capacity of center i. The capacity is the
          maximum number of requests in a service center, including the
          request currently in service (`M(i) >= 1').

    P
          `P(i,j)' is the probability that a request which completes
          service at server i will be transferred to server j.


     *OUTPUTS*

    U
          `U(i)' is the utilization of service center i.

    R
          `R(i)' is the average response time of service center i.

    Q
          `Q(i)' is the average number of requests in service center i
          (including the request in service).

    X
          `X(i)' is the throughput of service center i.


     See also: qnopen, qnclosed





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Approximate MVA algorithm for closed queueing networks with blocking.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
qncsmvald


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1735
 -- Function File: [U, R, Q, X] = qncsmvald (N, S, V)
 -- Function File: [U, R, Q, X] = qncsmvald (N, S, V, Z)
     Exact MVA algorithm for closed, single class queueing networks
     with load-dependent service centers. This function supports FCFS,
     LCFS-PR, PS and IS nodes. For networks with only fixed-rate
     service centers and multiple-server nodes, the function `qncsmva'
     is more efficient.

     *INPUTS*

    N
          Population size (number of requests in the system, `N >= 0').
          If `N == 0', this function returns `U = R = Q = X = 0'

    S
          `S(k,n)' is the mean service time at center k where there are
          n requests, 1 <= n <= N. `S(k,n)' = 1 / \mu_k,n, where
          \mu_k,n is the service rate of center k when there are n
          requests.

    V
          `V(k)' is the average number of visits to service center k
          (`V(k) >= 0').

    Z
          external delay ("think time", `Z >= 0'); default 0.


     *OUTPUTS*

    U
          `U(k)' is the utilization of service center k. The
          utilization is defined as the probability that service center
          k is not empty, that is, U_k = 1-\pi_k(0) where \pi_k(0) is
          the steady-state probability that there are 0 jobs at service
          center k.

    R
          `R(k)' is the response time on service center k.

    Q
          `Q(k)' is the average number of requests in service center k.

    X
          `X(k)' is the throughput of service center k.


          Note: In presence of load-dependent servers, the MVA
          algorithm is known to be numerically unstable. Generally this
          problem manifests itself as negative response times produced
          by this function.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Exact MVA algorithm for closed, single class queueing networks with
load-depende



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qncspb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1094
 -- Function File: [XL, XU, RL, RU] = qncspb (N, D )
 -- Function File: [XL, XU, RL, RU] = qncspb (N, S, V )
 -- Function File: [XL, XU, RL, RU] = qncspb (N, S, V, M )
 -- Function File: [XL, XU, RL, RU] = qncspb (N, S, V, M, Z )
     Compute PB Bounds (C. H. Hsieh and S. Lam, 1987) for single-class,
     closed networks.

     *INPUTS*

    N
          number of requests in the system (scalar). Must be `N > 0'.

    D
          `D(k)' is the service demand of service center k (`D(k) >=
          0').

    S
          `S(k)' is the mean service time at center k (`S(k) >= 0').

    V
          `V(k)' is the visit ratio to center k (`V(k) >= 0').

    M
          `M(k)' is the number of servers at center k.  This function
          only supports M/M/1 queues, therefore M must be
          `ones(size(S))'.

    Z
          external delay (think time, `Z >= 0'). Default 0.


     *OUTPUTS*

    XL
    XU
          Lower and upper bounds on the system throughput.

    RL
    RU
          Lower and upper bounds on the system response time.


     See also: qncsaba, qbcsbsb, qncsgb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Compute PB Bounds (C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
qncsvisits


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 951
 -- Function File: V = qncsvisits (P)
 -- Function File: V = qncsvisits (P, R)
     Compute the mean number of visits to the service centers of a
     single class, closed network with K service centers.

     *INPUTS*

    P
          `P(i,j)' is the probability that a request which completed
          service at center i is routed to center j. For closed
          networks it must hold that `sum(P,2)==1'. The routing graph
          must be strongly connected, meaning that each node must be
          reachable from every other node.

    R
          Index of the reference station, r \in {1, ..., K}; Default
          `R=1'. The traffic equations are solved by imposing the
          condition `V(r) = 1'. A request returning to the reference
          station completes its activity cycle.


     *OUTPUTS*

    V
          `V(i)' is the average number of visits to service center i,
          assuming center r as the reference station.






# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the mean number of visits to the service centers of a single
class, clos



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
qnjackson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2307
 -- Function File: [U, R, Q, X] = qnjackson (LAMBDA, S, P )
 -- Function File: [U, R, Q, X] = qnjackson (LAMBDA, S, P, M )
 -- Function File: PR = qnjackson (LAMBDA, S, P, M, K)
     This function is deprecated. Please use `qnopensingle' instead.

     With three or four arguments, this function computes the
     steady-state occupancy probabilities for a Jackson network. With
     five arguments, this function computes the steady-state probability
     `PI(j)' that there are `K(j)' requests at service center j.

     This function solves a subset of Jackson networks, with the
     following constraints:

        * External arrival rates are load-independent.

        * Service center i consists either of `M(i) >= 1' identical
          servers with individual average service time `S(i)', or of an
          Infinite Server (IS) node.


     *INPUTS*

    LAMBDA
          `LAMBDA(i)' is the external arrival rate to service center i.
          LAMBDA must be a vector of length N, `LAMBDA(i) >= 0'.

    S
          `S(i)' is the average service time on service center i S must
          be a vector of length N, `S(i)>0'.

    P
          `P(i,j)' is the probability that a job which completes
          service at service center i proceeds to service center j. P
          must be a matrix of size N \times N.

    M
          `M(i)' is the number of servers at center i. If `M(i) < 1',
          center i is an infinite-server node. Otherwise, it is a
          regular FCFS queueing center with `M(i)' servers. Default is
          1.

    K
          Compute the steady-state probability that there are `K(i)'
          requests at service center i. K must have the same length as
          LAMBDA, with `K(i) >= 0'.


     *OUTPUT*

    U
          If i is a FCFS node, then `U(i)' is the utilization of
          service center i.  If i is an IS node, then `U(i)' is the
          _traffic intensity_ defined as `X(i)*S(i)'.

    R
          `R(i)' is the average response time of service center i.

    Q
          `Q(i)' is the average number of customers in service center i.

    X
          `X(i)' is the throughput of service center i.

    PR
          `PR(i)' is the steady state probability that there are `K(i)'
          requests at service center i.


     See also: qnopen





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qnmarkov


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3687
 -- Function File: [U, R, Q, X] = qnmarkov (LAMBDA, S, C, P)
 -- Function File: [U, R, Q, X] = qnmarkov (LAMBDA, S, C, P, M)
 -- Function File: [U, R, Q, X] = qnmarkov (N, S, C, P)
 -- Function File: [U, R, Q, X] = qnmarkov (N, S, C, P, M)
     Compute utilization, response time, average queue length and
     throughput for open or closed queueing networks with finite
     capacity.  Blocking type is Repetitive-Service (RS). This function
     explicitly generates and solve the underlying Markov chain, and
     thus might require a large amount of memory.

     More specifically, networks which can me analyzed by this function
     have the following properties:

        * There exists only a single class of customers.

        * The network has K service centers. Center i has m_i > 0
          servers, and has a total (finite) capacity of C_i \geq m_i
          which includes both buffer space and servers.  The buffer
          space at service center i is therefore C_i - m_i.

        * The network can be open, with external arrival rate to center
          i equal to \lambda_i, or closed with fixed population size N.
          For closed networks, the population size N must be strictly
          less than the network capacity: N < \sum_i C_i.

        * Average service times are load-independent.

        * P_i, j is the probability that requests completing execution
          at center i are transferred to center j, i \neq j. For open
          networks, a request may leave the system from any node i with
          probability 1-\sum_j P_i, j.

        * Blocking type is Repetitive-Service (RS). Service center j is
          _saturated_ if the number of requests is equal to its
          capacity C_j. Under the RS blocking discipline, a request
          completing service at center i which is being transferred to
          a saturated server j is put back at the end of the queue of i
          and will receive service again. Center i then processes the
          next request in queue. External arrivals to a saturated
          servers are dropped.


     *INPUTS*

    LAMBDA
    N
          If the first argument is a vector LAMBDA, it is considered to
          be the external arrival rate `LAMBDA(i) >= 0' to service
          center i of an open network. If the first argument is a
          scalar, it is considered as the population size N of a closed
          network; in this case N must be strictly less than the
          network capacity: `N < sum(C)'.

    S
          `S(i)' is the average service time at service center i

    C
          `C(i)' is the Capacity of service center i. The capacity
          includes both the buffer and server space `M(i)'. Thus the
          buffer space is `C(i)-M(i)'.

    P
          `P(i,j)' is the transition probability from service center i
          to service center j.

    M
          `M(i)' is the number of servers at service center i. Note
          that `M(i) >= C(i)' for each I.  If M is omitted, all service
          centers are assumed to have a single server (`M(i) = 1' for
          all i).


     *OUTPUTS*

    U
          `U(i)' is the utilization of service center i.

    R
          `R(i)' is the response time on service center i.

    Q
          `Q(i)' is the average number of customers in the service
          center i, _including_ the request in service.

    X
          `X(i)' is the throughput of service center i.


          Note:  The space complexity of this implementation is O(
          \prod_i=1^K (C_i + 1)^2). The time complexity is dominated by
          the time needed to solve a linear system with \prod_i=1^K
          (C_i + 1) unknowns.






# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute utilization, response time, average queue length and throughput
for open



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
qnmg1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
 -- Function File: [U, R, Q, X, P0] = qnmg1 (LAMBDA, XAVG, X2ND)
     This function is deprecated. Please use `qsmg1' instead.

     See also: qsmg1





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
qnmh1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
 -- Function File: [U, R, Q, X, P0] = qnmh1 (LAMBDA, MU, ALPHA)
     This function is deprecated. Please use `qsmh1' instead.

     See also: qsmh1





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
qnmix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2125
 -- Function File: [U, R, Q, X] = qnmix (LAMBDA, N, S, V, M)
     Solution of mixed queueing networks through MVA. The network
     consists of K service centers (single-server or delay centers) and
     C independent customer chains. Both open and closed chains are
     possible. LAMBDA is the vector of per-chain arrival rates (open
     classes); N is the vector of populations for closed chains.

          Note: In this implementation class switching is *not*
          allowed. Each customer class _must_ correspond to an
          independent chain.

     If the network is made of open or closed classes only, then this
     function calls `qnom' or `qncmmva' respectively, and prints a
     warning message.

     *INPUTS*

    LAMBDA
    N
          For each customer chain c:

             * if c is a closed chain, then `N(c)>0' is the number of
               class c requests and `LAMBDA(c)' must be zero;

             * If c is an open chain, `LAMBDA(c)>0' is the arrival rate
               of class c requests and `N(c)' must be zero;


          In other words, for each class c the following must hold:

               (LAMBDA(c)>0 && N(c)==0) || (LAMBDA(c)==0 && N(c)>0)

    S
          `S(c,k)' is the mean class c service time at center k,
          `S(c,k) >= 0'. For FCFS nodes, service times must be
          class-independent.

    V
          `V(c,k)' is the average number of visits of class c customers
          to center k (`V(c,k) >= 0').

    M
          `M(k)' is the number of servers at center k. Only
          single-server (`M(k)==1') or IS (Infinite Server) nodes
          (`M(k)<1') are supported. If omitted, each center is assumed
          to be of type M/M/1-FCFS. Queueing discipline for
          single-server nodes can be FCFS, PS or LCFS-PR.


     *OUTPUTS*

    U
          `U(c,k)' is class c utilization at center k.

    R
          `R(c,k)' is class c response time at center k.

    Q
          `Q(c,k)' is the average number of class c requests at center
          k.

    X
          `X(c,k)' is class c throughput at center k.


     See also: qncmmva, qncm





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Solution of mixed queueing networks through MVA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qnmknode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1622
 -- Function File: Q = qnmknode ("M/M/M-FCFS", S)
 -- Function File: Q = qnmknode ("M/M/M-FCFS", S, M)
 -- Function File: Q = qnmknode ("M/M/1-LCFS-PR", S)
 -- Function File: Q = qnmknode ("-/G/1-PS", S)
 -- Function File: Q = qnmknode ("-/G/1-PS", S, S2)
 -- Function File: Q = qnmknode ("-/G/INF", S)
 -- Function File: Q = qnmknode ("-/G/INF", S, S2)
     Creates a node; this function can be used together with `qnsolve'.
     It is possible to create either single-class nodes (where there is
     only one customer class), or multiple-class nodes (where the
     service time is given per-class). Furthermore, it is possible to
     specify load-dependent service times.

     *INPUTS*

    S
          Mean service time.

             * If S is a scalar, it is assumed to be a
               load-independent, class-independent service time.

             * If S is a column vector, then `S(c)' is assumed to the
               the load-independent service time for class c customers.

             * If S is a row vector, then `S(n)' is assumed to be the
               class-independent service time at the node, when there
               are n requests.

             * Finally, if S is a two-dimensional matrix, then `S(c,n)'
               is assumed to be the class c service time when there are
               n requests at the node.


    M
          Number of identical servers at the node. Default is `M=1'.

    S2
          Squared coefficient of variation for the service time.
          Default is 1.0.


     The returned struct Q should be considered opaque to the client.

     See also: qnsolve





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Creates a node; this function can be used together with `qnsolve'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
qnmm1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 143
 -- Function File: [U, R, Q, X, P0] = qnmm1 (LAMBDA, MU)
     This function is deprecated. Please use `qsmm1' instead.

     See also: qsmm1





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qnmm1k


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 146
 -- Function File: [U, R, Q, X, P0, PK] = qnmm1k (LAMBDA, MU, K)
     This function is deprecated. Use `qsmm1k' instead.

     See also: qsmm1k





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qnmminf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
 -- Function File: [U, R, Q, X, P0] = qnmminf (LAMBDA, MU)
     This function is deprecated. Please use `qsmminf' instead.

     See also: qsmminf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
qnmmm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 211
 -- Function File: [U, R, Q, X, P0, PM] = qnmmm (LAMBDA, MU)
 -- Function File: [U, R, Q, X, P0, PM] = qnmmm (LAMBDA, MU, M)
     This function is deprecated. Please use `qsmmm' instead.

     See also: qsmmm





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qnmmmk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 156
 -- Function File: [U, R, Q, X, P0, PK] = qnmmmk (LAMBDA, MU, M, K)
     This function is deprecated. Please use `qsmmmk' instead.

     See also: qsmmmk





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qnmvablo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
 -- Function File: [U, R, Q, X] = qnmvablo (N, S, M, P)
     This function is deprecated. Please use `qncsmvablo' instead.

     See also: qncsmvablo





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qnmvapop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- Function File: H = qnmvapop (N)
     This function is deprecated. Please use `qncmnpop' instead.

     See also: qncmnpop





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
qnom


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1753
 -- Function File: [U, R, Q, X] = qnom (LAMBDA, S, V)
 -- Function File: [U, R, Q, X] = qnom (LAMBDA, S, V, M)
     Exact analysis of open, multiple-class BCMP networks. The network
     can be made of _single-server_ queueing centers (FCFS, LCFS-PR or
     PS) or delay centers (IS). This function assumes a network with K
     service centers and C customer classes.

     *INPUTS*

    LAMBDA
          `LAMBDA(c)' is the external arrival rate of class c customers
          (`LAMBDA(c)>0').

    S
          `S(c,k)' is the mean service time of class c customers on the
          service center k (`S(c,k)>0').  For FCFS nodes, mean service
          times must be class-independent.

    V
          `V(c,k)' is the average number of visits of class c customers
          to service center k (`V(c,k) >= 0 ').

    M
          `M(k)' is the number of servers at center i. If `M(k) < 1',
          enter k is a delay center (IS); otherwise it is a regular
          queueing center with `M(k)' servers. Default is `M(k) = 1'
          for all k.


     *OUTPUTS*

    U
          If k is a queueing center, then `U(c,k)' is the class c
          utilization of center k. If k is an IS node, then `U(c,k)' is
          the class c _traffic intensity_ defined as `X(c,k)*S(c,k)'.

    R
          `R(c,k)' is the class c response time at center k. The system
          response time for class c requests can be computed as `dot(R,
          V, 2)'.

    Q
          `Q(c,k)' is the average number of class c requests at center
          k. The average number of class c requests in the system QC
          can be computed as `Qc = sum(Q, 2)'

    X
          `X(c,k)' is the class c throughput at center k.


     See also: qnopen, qnos, qnomvisits





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Exact analysis of open, multiple-class BCMP networks.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qnomaba


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1114
 -- Function File: [XL, XU, RL, RU] = qnomaba (LAMBDA, D)
 -- Function File: [XL, XU, RL, RL] = qnomaba (LAMBDA, S, V)
     Compute Asymptotic Bounds for open, multiclass networks.

     *INPUTS*

    LAMBDA
          `LAMBDA(c)' is the class c arrival rate to the system.

    D
          `D(c, k)' is class c service demand at center k. (`D(c, k) >=
          0' for all k).

    S
          `S(c, k)' is the mean service time of class c requests at
          center k. (`S(c, k) >= 0' for all k).

    V
          `V(c, k)' is the mean number of visits of class c requests at
          center k. (`V(c, k) >= 0' for all k).


     *OUTPUTS*

    XL

    XU
          Per-class lower and upper throughput bounds. For example,
          `XU(c)' is the upper bound for class c throughput.  `Xl' is
          always 0 since there can be no lower bound on the throughput
          of open networks.

    RL

    RU
          Per-class lower and upper response time bounds.  `Ru' is
          always `+inf' since there can be no upper bound on the
          response time of open networks.


     See also: qnombsb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Compute Asymptotic Bounds for open, multiclass networks.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
qnomvisits


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 627
 -- Function File: V = qnomvisits (P, LAMBDA)
     Compute the average number of visits to the service centers of an
     open multiclass network with K service centers and C customer
     classes.

     *INPUTS*

    P
          `P(r,i,s,j)' is the probability that a class r request which
          completed service at center i is routed to center j as a
          class s request. Class switching is supported.

    LAMBDA
          `LAMBDA(r,i)' is the arrival rate of class r requests to
          center i.


     *OUTPUTS*

    V
          `V(r,i)' is the number of visits of class r requests at
          center i.






# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the average number of visits to the service centers of an open
multiclas



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qnopen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 439
 -- Function File: [U, R, Q, X] = qnopen (LAMBDA, S, V, ...)
     Compute utilization, response time, average number of requests in
     the system, and throughput for open queueing networks. If LAMBDA is
     a scalar, the network is considered a single-class QN and is solved
     using `qnopensingle'. If LAMBDA is a vector, the network is
     considered as a multiclass QN and solved using `qnopenmulti'.

     See also: qnos, qnom





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute utilization, response time, average number of requests in the
system, an



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qnopenab


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 152
 -- Function File: [XL, XU, RL, RU] = qnopenab (LAMBDA, ... )
     This function is deprecated. Please use `qnosaba' instead.

     See also: qnosaba





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
qnopenbsb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
 -- Function File: [XU, RL, RU] = qnopenbsb (LAMBDA, ...)
     This function is deprecated. Please use `qnosbsb' instead.

     See also: qnosbsb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
qnopenmulti


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 209
 -- Function File: [U, R, Q, X] = qnopenmulti (LAMBDA, S, V)
 -- Function File: [U, R, Q, X] = qnopenmulti (LAMBDA, S, V, M)
     This function is deprecated. Please use `qnom' instead.

     See also: qnom





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
qnopensingle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 211
 -- Function File: [U, R, Q, X] = qnopensingle (LAMBDA, S, V)
 -- Function File: [U, R, Q, X] = qnopensingle (LAMBDA, S, V, M)
     This function is deprecated. Please use `qnos' instead.

     See also: qnos





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
This function is deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
qnos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1529
 -- Function File: [U, R, Q, X] = qnos (LAMBDA, S, V)
 -- Function File: [U, R, Q, X] = qnos (LAMBDA, S, V, M)
     Analyze open, single class BCMP queueing networks.

     This function works for a subset of BCMP single-class open networks
     satisfying the following properties:

        * The allowed service disciplines at network nodes are: FCFS,
          PS, LCFS-PR, IS (infinite server);

        * Service times are exponentially distributed and
          load-independent;

        * Service center i can consist of `M(i) >= 1' identical servers.

        * Routing is load-independent


     *INPUTS*

    LAMBDA
          Overall external arrival rate (`LAMBDA>0').

    S
          `S(k)' is the average service time at center i (`S(k)>0').

    V
          `V(k)' is the average number of visits to center k (`V(k) >=
          0').

    M
          `M(k)' is the number of servers at center i. If `M(k) < 1',
          enter k is a delay center (IS); otherwise it is a regular
          queueing center with `M(k)' servers. Default is `M(k) = 1'
          for all k.


     *OUTPUTS*

    U
          If k is a queueing center, `U(k)' is the utilization of
          center k.  If k is an IS node, then `U(k)' is the _traffic
          intensity_ defined as `X(k)*S(k)'.

    R
          `R(k)' is the average response time of center k.

    Q
          `Q(k)' is the average number of requests at center k.

    X
          `X(k)' is the throughput of center k.


     See also: qnopen, qnclosed, qnosvisits





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Analyze open, single class BCMP queueing networks.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qnosaba


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1215
 -- Function File: [XL, XU, RL, RU] = qnosaba (LAMBDA, D)
 -- Function File: [XL, XU, RL, RU] = qnosaba (LAMBDA, S, V)
 -- Function File: [XL, XU, RL, RU] = qnosaba (LAMBDA, S, V, M)
     Compute Asymptotic Bounds for open, single-class networks.

     *INPUTS*

    LAMBDA
          Arrival rate of requests (`LAMBDA >= 0').

    D
          `D(k)' is the service demand at center k.  (`D(k) >= 0' for
          all k).

    S
          `S(k)' is the mean service time at center k.  (`S(k) >= 0'
          for all k).

    V
          `V(k)' is the mean number of visits to center k.  (`V(k) >=
          0' for all k).

    M
          `M(k)' is the number of servers at center k.  This function
          only supports M/M/1 queues, therefore M must be
          `ones(size(S))'.


     *OUTPUTS*

    XL

    XU
          Lower and upper bounds on the system throughput. XL is always
          set to 0 since there can be no lower bound on the throughput
          of open networks.

    RL

    RU
          Lower and upper bounds on the system response time. RU is
          always set to `+inf' since there can be no upper bound on the
          throughput of open networks.


     See also: qnopenmultiab





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Compute Asymptotic Bounds for open, single-class networks.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qnosbsb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1062
 -- Function File: [XL, XU, RL, RU] = qnosbsb (LAMBDA, D)
 -- Function File: [XL, XU, RL, RU] = qnosbsb (LAMBDA, S, V)
     Compute Balanced System Bounds for single-class, open networks.

     *INPUTS*

    LAMBDA
          overall arrival rate to the system (scalar). Abort if `LAMBDA
          < 0 '

    D
          `D(k)' is the service demand at center k.  (`D(k) >= 0' for
          all k).

    S
          `S(k)' is the mean service time at center k.  (`S(k) >= 0'
          for all k).

    V
          `V(k)' is the mean number of visits at center k.  (`V(k) >=
          0' for all k).

    M
          `M(k)' is the number of servers at center k.  This function
          only supports M/M/1 queues, therefore M must be
          `ones(size(S))'.


     *OUTPUTS*

    XL

    XU
          Lower and upper bounds on the system throughput. XL is always
          set to 0, since there can be no lower bound on open networks
          throughput.

    RL
    RU
          Lower and upper bounds on the system response time.


     See also: qnosaba





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Compute Balanced System Bounds for single-class, open networks.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
qnosvisits


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 489
 -- Function File: V = qnosvisits (P, LAMBDA)
     Compute the average number of visits to the service centers of a
     single class open Queueing Network with K service centers.

     *INPUTS*

    P
          `P(i,j)' is the probability that a request which completed
          service at center i is routed to center j.

    LAMBDA
          `LAMBDA(i)' is the external arrival rate to center i.


     *OUTPUTS*

    V
          `V(i)' is the average number of visits to server i.






# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the average number of visits to the service centers of a single
class op



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qnsolve


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2309
 -- Function File: [U, R, Q, X] = qnsolve ("CLOSED", N, QQ, V)
 -- Function File: [U, R, Q, X] = qnsolve ("CLOSED", N, QQ, V, Z)
 -- Function File: [U, R, Q, X] = qnsolve ("OPEN", LAMBDA, QQ, V)
 -- Function File: [U, R, Q, X] = qnsolve ("MIXED", LAMBDA, N, QQ, V)
     High-level function for analyzing QN models.

        * For *closed* networks, the following server types are
          supported: M/M/m-FCFS, -/G/\infty, -/G/1-LCFS-PR, -/G/1-PS
          and load-dependent variants.

        * For *open* networks, the following server types are supported:
          M/M/m-FCFS, -/G/\infty and -/G/1-PS. General load-dependent
          nodes are _not_ supported. Multiclass open networks do not
          support multiple server M/M/m nodes, but only single server
          M/M/1-FCFS.

        * For *mixed* networks, the following server types are
          supported: M/M/1-FCFS, -/G/\infty and -/G/1-PS. General
          load-dependent nodes are _not_ supported.


     *INPUTS*

    N
          Number of requests in the system for closed networks. For
          single-class networks, N must be a scalar. For multiclass
          networks, `N(c)' is the population size of closed class c.

    LAMBDA
          External arrival rate (scalar) for open networks. For
          single-class networks, LAMBDA must be a scalar. For
          multiclass networks, `LAMBDA(c)' is the class c overall
          arrival rate.

    QQ
          List of queues in the network. This must be a cell array with
          N elements, such that `QQ{i}' is a struct produced by the
          `qnmknode' function.

    Z
          External delay ("think time") for closed networks. Default 0.


     *OUTPUTS*

    U
          If i is a FCFS node, then `U(i)' is the utilization of
          service center i. If i is an IS node, then `U(i)' is the
          _traffic intensity_ defined as `X(i)*S(i)'.

    R
          `R(i)' is the average response time of service center i.

    Q
          `Q(i)' is the average number of customers in service center i.

    X
          `X(i)' is the throughput of service center i.


     Note that for multiclass networks, the computed results are
     per-class utilization, response time, number of customers and
     throughput: `U(c,k)', `R(c,k)', `Q(c,k)', `X(c,k)',





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
High-level function for analyzing QN models.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qnvisits


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1866
 -- Function File: [V CH] = qnvisits (P)
 -- Function File: V = qnvisits (P, LAMBDA)
     Compute the average number of visits to the service centers of a
     single class, open or closed Queueing Network with N service
     centers.

     *INPUTS*

    P
          Routing probability matrix. For single class networks,
          `P(i,j)' is the probability that a request which completed
          service at center i is routed to center j. For closed
          networks it must hold that `sum(P,2)==1'. The routing graph
          myst be strongly connected, meaning that it must be possible
          to eventually reach each node starting from each node. For
          multiple class networks, `P(r,i,s,j)' is the probability that
          a class r request which completed service at center i is
          routed to center j as a class s request. Class switching is
          supported.

    LAMBDA
          (open networks only) vector of external arrivals. For single
          class networks, `LAMBDA(i)' is the external arrival rate to
          center i. For multiple class networks, `LAMBDA(r,i)' is the
          arrival rate of class r requests to center i. If this
          function is called with a single argument, the network is
          assumed to be closed.


     *OUTPUTS*

    V
          For single class networks, `V(i)' is the average number of
          visits to server i, assuming center 1 as the reference station
          (i.e., `V(1) = 1'). For multiple class networks, `V(r,i)' is
          the number of visits of class r requests at center i.

    CH
          (For closed networks only). `CH(c)' is the chain number that
          class c belongs to. Different classes can belong to the same
          chain. Chains are numbered sequentially starting from 1 (1,
          2, ...). The total number of chains is `max(CH)'.






# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the average number of visits to the service centers of a single
class, o



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qsammm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1032
 -- Function File: [U, R, Q, X] = qsammm (LAMBDA, MU)
     Compute _approximate_ utilization, response time, average number
     of requests in service and throughput for an asymmetric  M/M/m
     queue. In this system there are m different service centers
     connected to a single queue. Each server has its own (possibly
     different) service rate. If there is more than one server
     available, requests are routed to a randomly-chosen one.

     *INPUTS*

    LAMBDA
          Arrival rate (`LAMBDA>0').

    MU
          `MU(i)' is the service rate of server i, 1 <= i <= m.  The
          system must be ergodic (`LAMBDA < sum(MU)').


     *OUTPUTS*

    U
          Approximate service center utilization, U = \lambda / (
          \sum_i \mu_i ).

    R
          Approximate service center response time

    Q
          Approximate number of requests in the system

    X
          Approximate service center throughput. If the system is
          ergodic, we will always have `X = LAMBDA'


     See also: qsmmm





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute _approximate_ utilization, response time, average number of
requests in 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
qsmg1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 975
 -- Function File: [U, R, Q, X, P0] = qsmg1 (LAMBDA, XAVG, X2ND)
     Compute utilization, response time, average number of requests and
     throughput for a M/G/1 system. The service time distribution is
     described by its mean XAVG, and by its second moment X2ND. The
     computations are based on results from L. Kleinrock, `Queuing
     Systems', Wiley, Vol 2, and Pollaczek-Khinchine formula.

     *INPUTS*

    LAMBDA
          Arrival rate.

    XAVG
          Average service time

    X2ND
          Second moment of service time distribution


     *OUTPUTS*

    U
          Service center utilization

    R
          Service center response time

    Q
          Average number of requests in the system

    X
          Service center throughput

    P0
          probability that there is not any request at system


     LAMBDA, XAVG, T2ND can be vectors of the same size. In this case,
     the results will be vectors as well.

     See also: qsmh1





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute utilization, response time, average number of requests and
throughput fo



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
qsmh1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1134
 -- Function File: [U, R, Q, X, P0] = qsmh1 (LAMBDA, MU, ALPHA)
     Compute utilization, response time, average number of requests and
     throughput for a M/H_m/1 system. In this system, the customer
     service times have hyper-exponential distribution:

                 ___ m
                 \
          B(x) =  >  alpha(j) * (1-exp(-mu(j)*x))   x>0
                 /__
                     j=1

     where \alpha_j is the probability that the request is served at
     phase j, in which case the average service rate is \mu_j. After
     completing service at phase j, for some j, the request exits the
     system.

     *INPUTS*

    LAMBDA
          Arrival rate.

    MU
          `MU(j)' is the phase j service rate. The total number of
          phases m is `length(MU)'.

    ALPHA
          `ALPHA(j)' is the probability that a request is served at
          phase j. ALPHA must have the same size as MU.


     *OUTPUTS*

    U
          Service center utilization

    R
          Service center response time

    Q
          Average number of requests in the system

    X
          Service center throughput






# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute utilization, response time, average number of requests and
throughput fo



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
qsmm1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 794
 -- Function File: [U, R, Q, X, P0] = qsmm1 (LAMBDA, MU)
     Compute utilization, response time, average number of requests and
     throughput for a M/M/1 queue.

     *INPUTS*

    LAMBDA
          Arrival rate (`LAMBDA > 0').

    MU
          Service rate (`MU > LAMBDA').


     *OUTPUTS*

    U
          Server utilization

    R
          Service center response time

    Q
          Average number of requests in the system

    X
          Service center throughput. If the system is ergodic, we will
          always have `X = LAMBDA'

    P0
          Steady-state probability that there are no requests in the
          system.


     LAMBDA and MU can be vectors of the same size. In this case, the
     results will be vectors as well.

     See also: qsmmm, qsmminf, qsmmmk





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute utilization, response time, average number of requests and
throughput fo



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qsmm1k


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1129
 -- Function File: [U, R, Q, X, P0, PK] = qsmm1k (LAMBDA, MU, K)
     Compute utilization, response time, average number of requests and
     throughput for a M/M/1/K finite capacity system. In a M/M/1/K
     queue there is a single server; the maximum number of requests in
     the system is K, and the maximum queue length is K-1.

     *INPUTS*

    LAMBDA
          Arrival rate (`LAMBDA>0').

    MU
          Service rate (`MU>0').

    K
          Maximum number of requests allowed in the system (`K >= 1').


     *OUTPUTS*

    U
          Service center utilization, which is defined as `U = 1-P0'

    R
          Service center response time

    Q
          Average number of requests in the system

    X
          Service center throughput

    P0
          Steady-state probability that there are no requests in the
          system

    PK
          Steady-state probability that there are K requests in the
          system (i.e., that the system is full)


     LAMBDA, MU and K can be vectors of the same size. In this case,
     the results will be vectors as well.

     See also: qsmm1, qsmminf, qsmmm





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute utilization, response time, average number of requests and
throughput fo



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
qsmminf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1119
 -- Function File: [U, R, Q, X, P0] = qsmminf (LAMBDA, MU)
     Compute utilization, response time, average number of requests and
     throughput for a M/M/\infty queue.

     The M/M/\infty system has an infinite number of identical servers;
     this kind of system is always stable for every arrival and service
     rates.

     *INPUTS*

    LAMBDA
          Arrival rate (`LAMBDA>0').

    MU
          Service rate (`MU>0').


     *OUTPUTS*

    U
          Traffic intensity (defined as \lambda/\mu). Note that this is
          different from the utilization, which in the case of
          M/M/\infty centers is always zero.

    R
          Service center response time.

    Q
          Average number of requests in the system (which is equal to
          the traffic intensity \lambda/\mu).

    X
          Throughput (which is always equal to `X = LAMBDA').

    P0
          Steady-state probability that there are no requests in the
          system


     LAMBDA and MU can be vectors of the same size. In this case, the
     results will be vectors as well.

     See also: qsmm1, qsmmm, qsmmmk





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute utilization, response time, average number of requests and
throughput fo



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
qsmmm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1186
 -- Function File: [U, R, Q, X, P0, PM] = qsmmm (LAMBDA, MU)
 -- Function File: [U, R, Q, X, P0, PM] = qsmmm (LAMBDA, MU, M)
     Compute utilization, response time, average number of requests in
     service and throughput for a M/M/m queue, a queueing system with m
     identical service centers connected to a single FCFS queue.

     *INPUTS*

    LAMBDA
          Arrival rate (`LAMBDA>0').

    MU
          Service rate (`MU>LAMBDA').

    M
          Number of servers (`M >= 1').  If omitted, it is assumed
          `M=1'.


     *OUTPUTS*

    U
          Service center utilization, U = \lambda / (m \mu).

    R
          Service center response time

    Q
          Average number of requests in the system

    X
          Service center throughput. If the system is ergodic, we will
          always have `X = LAMBDA'

    P0
          Steady-state probability that there are 0 requests in the
          system

    PM
          Steady-state probability that an arriving request has to wait
          in the queue


     LAMBDA, MU and M can be vectors of the same size. In this case,
     the results will be vectors as well.

     See also: qsmm1, qsmminf, qsmmmk





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute utilization, response time, average number of requests in
service and th



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qsmmmk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1360
 -- Function File: [U, R, Q, X, P0, PK] = qsmmmk (LAMBDA, MU, M, K)
     Compute utilization, response time, average number of requests and
     throughput for a M/M/m/K finite capacity system. In a M/M/m/K
     system there are m \geq 1 identical service centers sharing a
     fixed-capacity queue. At any time, at most K >= m requests can be
     in the system. The maximum queue length is K-m. This function
     generates and solves the underlying CTMC.

     *INPUTS*

    LAMBDA
          Arrival rate (`LAMBDA>0').

    MU
          Service rate (`MU>0').

    M
          Number of servers (`M >= 1').

    K
          Maximum number of requests allowed in the system, including
          those inside the service centers (`K >= M').


     *OUTPUTS*

    U
          Service center utilization

    R
          Service center response time

    Q
          Average number of requests in the system

    X
          Service center throughput

    P0
          Steady-state probability that there are no requests in the
          system.

    PK
          Steady-state probability that there are K requests in the
          system (i.e., probability that the system is full).


     LAMBDA, MU, M and K can be either scalars, or vectors of the  same
     size. In this case, the results will be vectors as well.

     See also: qsmm1, qsmminf, qsmmm





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute utilization, response time, average number of requests and
throughput fo





