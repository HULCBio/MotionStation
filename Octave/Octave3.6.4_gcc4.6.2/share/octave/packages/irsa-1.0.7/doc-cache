# Created by Octave 3.6.4, Sat Mar 30 12:50:19 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 14
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
irsa_act


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 938
 -- Function File: irsa_act.m
     [RXP,RYP,ERR] = irsa_act (XP, YP, FMAX, [NOUT], [ITMAX],[THRESH])

     Reconstructs a band-limited signal from an irregular sampled
     timeseries using Adaptive weights, Conjugate gradients and
     Toeplitz matrices.

     Input:

     XP    : Vector - sampling points

     YP    : Vector - corresponding sampling values

     FMAX  : Scalar - maximum (band-limiting) frequency

     NOUT  : Vector - Number of sampling points for the representation
     of the reconstruced signal. Default is the shortest possible
     representation.

     ITMAX : Scalar - maximum number of reconstruction iterations.
     Default is twice the number of the frequencies.

     THRESH: Scalar - threshold for conjugate gradients (stop
        criterion). Default is machine precision.

     Output:

     RFYP  : Columnvector - reconstructed spectrum

     ERR   : Columnvector - error for each iteration step





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
[RXP,RYP,ERR] = irsa_act (XP, YP, FMAX, [NOUT], [ITMAX],[THRESH])




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
irsa_actcore


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1102
 -- Function File: irsa_actcore.m
     [RFYP,ERR] = irsa_actcore (XPN, YP, FMAXN, [ITMAX], [THRESH])

     Reconstruction of the frequency representation (i.e. the spectrum)
     of a band-limited signal from an irregular sampled timeseries using
     Adaptive weights, Conjugate gradients and Toeplitz matrices.

     Input:

     XPN   : Vector - sampling points in [0,(N-1)/N]

     YP    : Vector - corresponding sampling values

     FMAXN : Scalar - maximum (band-limiting) frequency. Due to the
     scaling of XPN it has to be a positive integer.

     ITMAX : Scalar - maximum number of reconstruction iterations.
     Default is twice the number of the frequencies.

     THRESH: Scalar - threshold for conjugate gradients (stop
     criterion). Default is machine precision.

     Output:

     RFYP  : Columnvector - reconstructed spectrum

     ERR   : Columnvector - error for each iteration step

     _Note:_

     The use of this function requires normalized sampling points XPN
     in `[0,(N-1)/N]' and the knowledge of FMAXN. Use the function
     `irsa_normalize' for this task.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
[RFYP,ERR] = irsa_actcore (XPN, YP, FMAXN, [ITMAX], [THRESH])




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
irsa_check


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 533
 -- Function File: irsa_check.m
     [N, COLS, REG, TM] = irsa_check (XP, [YP])

     Check for consistency of the timeseries and compute some
     characterisitic parameters

     Input:

     XP   : Columnvector of sampling points corresponding to YP

     YP   : Matrix with the timeseries values in its columns

     Output:

     N    : Scalar - length of timeseries

     COLS : Scalar - number of columns of YP

     REG  : Boolean - true if the sampling is regular (equidistant)

     TM   : Scalar - Mean sampling distance




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
[N, COLS, REG, TM] = irsa_check (XP, [YP])




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
irsa_dft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 572
 -- Function File: irsa_dft.m
     FYP = irsa_dft (XP, YP, FXP, [LM])

     Compute Discrete Fourier Transformations of irregular sampled time
     series `[XP,YP]' using `DFT(f) = sum_(k=1)^N YP[k] *
     exp(-2*pi*I*XP[k]*f)' for every f in FXP

     Input:

     XP  : Columnvector - sampling points

     YP  : Matrix with the timeseries values in its columns

     FXP : Vector - frequency points for the DFT

     LM  : Boolean - use lesser memory if 'true' (slower). Default is
     'false'.

     Output:

     FYP : Matrix with values of the DFTs in its columns




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
FYP = irsa_dft (XP, YP, FXP, [LM])




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
irsa_dftfp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 888
 -- Function File: irsa_dftfp.m
     [FXP,NF,FXPS,NFE] = irsa_dft (XP, [HIFAC], [OFAC])

     Compute frequency points for the Discrete Fourier Transformations
     of irregular sampled time series

     Input:

     XP   : Columnvector - sampling points

     HIFAC: Scalar - factor for the amount of higher frequencies

     OFAC : Scalar - factor for the oversampling rate

     Output:

     FXP  : Columnvector - frequency points corresponding to the order
     the DFT or FFT are assuming.

     NF   : Scalar - length of fxp (only a convenience)

     FXPS : Columnvector - frequency points in ascending order

     NFE  : Scalar - true (1) if Nf is even or false (0) if not.

     Notice: FXPS and NFE are convenient for example for plotting
     spectra: There you may need the frequency series in a sorted order
     and you get it with `[fxps, shift(fyp, floor(Nf/2) - Nfe)]'




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
[FXP,NF,FXPS,NFE] = irsa_dft (XP, [HIFAC], [OFAC])




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
irsa_genreal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 790
 -- Function File: irsa_genreal.m
     [YP,FXP,FYP] = irsa_genreal (XP, AMP, PHI)

     Generate values for a real-valued band-limited timeseries at the
     sampling points XP with amplitudes AMP and phases `2*PI*PHI'

     Input:

     XP  : Vector - sampling points

     AMP : Vector - positive amplitudes of the spectrum

     PHI : Vector - positive phases of the spectrum in `rad / 2*PI'.

     Output:

     YP  : Columnvector - sampling values

     FXP : Columnvector - frequency points

     FYP : Columnvector - frequency values

     _Note:_

     If XP doesn't start at 0 the spectrum will be phase shifted. The
     function assumes, that this phase shift is neglected when giving
     the spectrum in AMP and PHI, but computes the correct phase
     shifted values in FYP.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
[YP,FXP,FYP] = irsa_genreal (XP, AMP, PHI)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
irsa_idft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 583
 -- Function File: irsa_idft.m
     YP = irsa_dft (FXP, FYP, XP, [LM])

     Compute Inverse Discrete Fourier Transformations of spectra
     [FXP,FYP] using `YP(t) = (1/N) * sum_(k=1)^N FYP[k] *
     exp(2*pi*I*FXP[k]*t)' for every t in XP

     Input:

     FXP : Columnvector - frequency points

     FYP : Matrix with the spectrum values in its columns

     XP  : Vector - sampling points for the resulting timeseries

     LM  : Boolean - use lesser memory if 'true' (slower). Default is
     'false'.

     Output:

     YP   : Matrix with values of the IDFTs in its columns




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
YP = irsa_dft (FXP, FYP, XP, [LM])




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
irsa_isregular


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 363
 -- Function File: irsa_isregular.m
     [REGULAR,TM] = irsa_isregular (XP)

     Check if the sampling points XP are regular sampled and compute
     the mean sampling period

     Input:

     XP     : Columnvector - sampling points

     Output:

     REGULAR: Boolean - true if the sampling is regular (equidistant)

     TM  : Scalar - Mean sampling period




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
[REGULAR,TM] = irsa_isregular (XP)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
irsa_jitsp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1130
 -- Function File: irsa_jitsp.m
     JITXP = irsa_jitsp (TM, JIT, N [, RFUNC])

     Generate N sampling points with a minimum distance TM and an
     additional random distance JIT with random distribution RFUNC

     Input:

     TM   : Scalar - mean sampling period

     N    : Scalar - number of sampling points to generate

     JIT  : Scalar - factor in [0,1] describing the part of Tm which is
     jittered.

     RFUNC: String (i.e. in quotes) of a random distribution function.
     Has to take the number of rows as the first and the number of
     columns as the second argument. Default is 'rand'.

     RMIN : Scalar - Lower limit of random distribution function
     computed with RFUNC

     RMAX : Scalar - Upper limit of random distribution function

     Output:

     JITXP : Columnvector - sampling points with a jitter

     _Note:_

     1) The first sampling point will be 0, the last (N-1)*Tm. No
     jitter is added to them.

     2) If you use a random distribution function and dont give a upper
     or lower limit it's assumed to be limited by its present computed
     maximum or minimum values.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
JITXP = irsa_jitsp (TM, JIT, N [, RFUNC])




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
irsa_mdsp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 729
 -- Function File: irsa_mdsp.m
     MDXP = irsa_mdsp (MD, RD, N, [RFUNC])

     Generate N sampling points with a minimum distance MD and an
     additional random distance RD with random distribution RFUNC

     Input:

     MD   : Scalar - minimum distance

     RD   : Scalar - mean of the random distance

     N    : Scalar - number of sampling points to generate

     RFUNC: String - random distribution function for the random part.
     Has to take the number of rows as the first and the number of
     columns as the second argument. Default is 'rand'.

     Output:

     MDXP : Columnvector - sampling points with a minimum distance

     _Note:_

     The first sampling point is 0 and the last `(N-1)*(md + rd)'.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
MDXP = irsa_mdsp (MD, RD, N, [RFUNC])




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
irsa_normalize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 774
 -- Function File: irsa_normalize.m
     [XPN,FMAXN,XP1,NFAC] = irsa_normalize( XP, [FMAX] )

     Normalize XP to [0, (N-1)/N], compute the last frequency point
     below or equal to the given bandlimiting frequency FMAX and scale
     it according to the normalization.

     Input:

     XP     : Vector - sampling points

     FMAX   : Scalar - band limiting frequency of signal sampled at XP

     Output:

     XPN    : Vector - normalized sampling points

     FMAXN  : Scalar - last discrete frequency corresponding to XPN

     XP1    : Scalar - offset of XP ( xp(1) )

     NFAC   : Scalar - normalization factor

     _Note:_

     You get XP from XPN by computing `XP = XPN*NFAC+ XP1'. Due to
     discretization the actually used FMAX for XP is `FMAXN/NFAC'.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
[XPN,FMAXN,XP1,NFAC] = irsa_normalize( XP, [FMAX] )




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
irsa_plotdft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
 usage:  [fxps, fyps] = irsa_plotdft (fxp, fyp)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
 usage:  [fxps, fyps] = irsa_plotdft (fxp, fyp)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
irsa_resample


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 513
 -- Function File: irsa_dft.m
     NEWYP = irsa_resample (XP, YP, NEWXP, [LM])

     Resample the signal represented by the timeseries [XP,YP] on
     arbitrary samplepoints.  NEWXP

     Input:

     XP    : Columnvector - sampling points

     YP    : Columnvector - timeseries values

     NEWXP : Vector - sampling points for the resampling

     LM    : Boolean - use lesser memory if 'true' (slower).  Default
     is 'false'.

     Output:

     NEWYP : Columnvector - timeseries values of the resampling




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
NEWYP = irsa_resample (XP, YP, NEWXP, [LM])




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
irsa_rgenreal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 912
 -- Function File: irsa_rgenreal.m
     [YP,FXP,FYP] = irsa_rgenreal (XP, FMAX, ARFUNC, PRFUNC)

     Generate a real-valued band-limited timeseries with sampling points
     XP and maximum frequency FMAX.

     Input:

     XP    : Vector - sampling points

     FMAX  : Scalar - maximum (band-limiting) frequency

     ARFUNC: String - name of random number generator with desired
     distribution for the generated frequency amplitudes. Default is
     `randn'.

     PRFUNC: String - name of random number generator with desired
     distribution for the generated frequency phases taken times
     `2*PI'. Default is `rand'.

     The random number generators have to take the number of rows as
     the first and the number of columns as the second argument.

     Output:

     YP  : Columnvector - sampling values

     FXP : Columnvector - frequency points

     FYP : Columnvector - frequency values




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
[YP,FXP,FYP] = irsa_rgenreal (XP, FMAX, ARFUNC, PRFUNC)






