# Created by Octave 3.6.4, Fri Mar 29 17:02:38 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 32
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
apply


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1709
 -- Loadable Function: RETURN_VALUE = apply
          (@FUNCTION_HANDLE,CELL_ARRAY_OF_ARGS)
 -- Loadable Function: RETURN_VALUE = apply (@FUNCTION_HANDLE)
     Apply calls the function FUNCTION_HANDLE with the arguments of the
     cell array CELL_ARRAY_OF_ARGS which contains the actual arguments
     arg1,arg2,..., argn to the function, in that order. Apply invokes
     the function as FUNCTION_HANDLE(arg1, arg2, ... ,argn), where the
     arguments are extracted from each elements of the 1-row cell array
     CELL_ARRAY_OF_ARGS.

     _warning_: `apply' has been deprecated in favor of `arrayfun' and
     `cellfun' for arrays and cells respectively. This function will be
     removed from future versions of the 'miscellaneous' package".

     Apply also works on array of function handles if FUNCTION_HANDLE
     is passed as a cell array of a handles; in this case apply,
     evaluates each function (using the handle) with the same arguments.

     The cell-array argument is optional second argument, in the form
     of a 1-row with multiple elements. The elements of the cell-array
     form the actual arguments supplied when invoking the  function
     FUNCTION_HANDLE.

     The return value depends on the function invoked, and the validity
     of the arguments.

            z=apply(@sqrt,cell([1,2; 3,4]));
            z=apply(@apply,cell(@sqrt,cell([1,2; 3,4])));
            apply(@sum,cell([1,2,3,4]))
            apply(@max,cell([1,2,3,4]))
            apply(@min,cell([1,2,3,4]))

     In first case, apply computes the sqrt of the matrix [1,2; 3,4];
     The second example is meta-apply, using apply on itself.  The rest
     of the examples invoke sum, max, min respectively.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Apply calls the function FUNCTION_HANDLE with the arguments of the cell
array CE



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
asci


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 712
 -- Function: [STRING] = asci ([COLUMNS])
     Print ASCI table.

     If this function is called without any input argument and without
     any output argument then print a nice ASCI-table (excluding
     special characters with hexcode 0x00 to 0x20) on screen with four
     columns per default. If this function is called with one output
     argument then return an ASCI-table string and don't print anything
     on screen. Finally, if this function is called with one input
     argument of type scalar then either print (no output argument) or
     return (one output argument) an ASCI-table with a number of
     columns given in COLUMNS.

     For example,
          A = asci (3);
          disp (A);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
Print ASCI table.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
chebyshevpoly


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 536
 -- Function File: COEFS= chebyshevpoly (KIND,ORDER,X)
     Compute the coefficients of the Chebyshev polynomial, given the
     ORDER. We calculate the Chebyshev polynomial using the recurrence
     relations, Tn+1(x) = (2*x*Tn(x) - Tn-1(x)). The KIND can set to
     compute the first or second kind chebyshev polynomial.

     If the value X is specified, the polynomial is also evaluated,
     otherwise just the return the coefficients of the polynomial are
     returned.

     This is NOT the generalized Chebyshev polynomial.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Compute the coefficients of the Chebyshev polynomial, given the ORDER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
clip


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 407
 -- Function File: X = clip (X)
 -- Function File: X = clip (X, HI)
 -- Function File: X = clip (X, [LO, HI])
     Clip X values outside the range.to the value at the boundary of the
     range.

     Range boundaries, LO and HI, default to 0 and 1 respectively.

     X = clip (X)   Clip to range [0, 1]

     X = clip (X, HI)   Clip to range [0, HI]

     X = clip (X, [LO, HI])   Clip to range [LO, HI]




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Clip X values outside the range.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
colorboard


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1540
 -- Function File: colorboard (M, PALETTE, OPTIONS)
     Displays a color board corresponding to a numeric matrix M.  M
     should contain zero-based indices of colors.  The available range
     of indices is given by the PALETTE argument, which can be one of
     the following:

        * "b&w"   Black & white, using reverse video mode. This is the
          default if M is logical.

        * "ansi8"   The standard ANSI 8 color palette. This is the
          default unless M is logical.

        * "aix16"   The AIXTerm extended 16-color palette. Uses codes
          100:107 for bright colors.

        * "xterm16"   The first 16 system colors of the Xterm 256-color
          palette.

        * "xterm216"   The 6x6x6 color cube of the Xterm 256-color
          palette.    In this case, matrix can also be passed as a
          MxNx3 RGB array with values 0..5.

        * "grayscale"   The 24 grayscale levels of the Xterm 256-color
          palette.

        * "xterm256"   The full Xterm 256-color palette. The three
          above palettes together.

     OPTIONS comprises additional options. The recognized options are:

        * "indent"   The number of spaces by which the board is
          indented. Default 2.

        * "spaces"   The number of spaces forming one field. Default 2.

        * "horizontalseparator"   The character used for horizontal
          separation of the table. Default "#".

        * "verticalseparator"   The character used for vertical
          separation of the table. Default "|".




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Displays a color board corresponding to a numeric matrix M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
csv2latex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1647
 Creates a latex file from a csv file. The generated latex file contains a 
 tabular with all values of the csv file. The tabular can be decorated with 
 row and column titles. The generated latex file can be inserted in any latex
 document by using the '\input{latex file name without .tex}' statement.

 Usage: 
  - csv2latex(csv_file, csv_sep, latex_file)
  - csv2latex(csv_file, csv_sep, latex_file, tabular_alignments)
  - csv2latex(csv_file, csv_sep, latex_file, tabular_alignments, has_hline)
  - csv2latex(csv_file, csv_sep, latex_file,   
              tabular_alignments, has_hline, column_titles)
  - csv2latex(csv_file, csv_sep, latex_file, tabular_alignments,
              has_hline, column_titles, row_titles)

 Parameters:
  csv_file - the path to an existing csv file
  csv_sep - the seperator of the csv values
  latex_file - the path of the latex file to create     
  tabular_alignments - the tabular alignment preamble (default = {'l','l',...})
  has_hline - indicates horizontal line seperator (default = false)
  column_titles - array with the column titles of the tabular (default = {})
  row_titles - array with the row titles of the tabular (default = {})

 Examples:
  # creates the latex file 'example.tex' from the csv file 'example.csv' 
  csv2latex("example.csv", '\t', "example.tex");

  # creates the latex file with horizontal and vertical lines
  csv2latex('example.csv', '\t', 'example.tex', {'|l|', 'l|'}, true);
 
  # creates the latex file with row and column titles
  csv2latex('example.csv', '\t', 'example.tex', {'|l|', 'l|'}, true, 
            {'Column 1', 'Column 2', 'Column 3'}, {'Row 1', 'Row 2'});



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
 Creates a latex file from a csv file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
gameoflife


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 333
 -- Function File: B = gameoflife (A, ngen, delay)
     Runs the Conways' game of life from a given initial state for a
     given number of generations and visualizes the process.  If ngen
     is infinity, the process is run as long as A changes.  Delay sets
     the pause between two frames. If zero, visualization is not done.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Runs the Conways' game of life from a given initial state for a given
number of 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
hermitepoly


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 352
 -- Function File: COEFS= hermitepoly (ORDER,X)
     Compute the coefficients of the Hermite polynomial, given the
     ORDER. We calculate the Hermite polynomial using the recurrence
     relations, Hn+1(x) = 2x.Hn(x) - 2nHn-1(x).

     If the value X is specified, the polynomial is also evaluated,
     otherwise just the return the coefficients.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Compute the coefficients of the Hermite polynomial, given the ORDER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
hilbert_curve


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 322
 -- Function file: X, Y hilbert_curve (N)
     Creates an iteration of the Hilbert space-filling curve with N
     points.  The argument N must be of the form `2^M', where M is an
     integer greater than 0.

          n = 8
          [x ,y] = hilbert_curve (n);
          line (x, y, "linewidth", 4, "color", "blue");





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Creates an iteration of the Hilbert space-filling curve with N points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
infoskeleton


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 330
 -- Function File: infoskeleton (PROTOTYPE, INDEX_STR, SEE_ALSO)
     Generate TeXinfo skeleton documentation of PROTOTYPE.

     Optionally INDEX_STR and SEE_ALSO can be specified.

     Usage of this function is typically,
          infoskeleton('[V,Q] = eig( A )','linear algebra','eigs, chol, qr, det')

     See also: info





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Generate TeXinfo skeleton documentation of PROTOTYPE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
laguerrepoly


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 461
 -- Function File: COEFS= laguerrepoly (ORDER,X)
     Compute the coefficients of the Laguerre polynomial, given the
     ORDER. We calculate the Laguerre polynomial using the recurrence
     relations, Ln+1(x) = inv(n+1)*((2n+1-x)Ln(x) - nLn-1(x)).

     If the value X is specified, the polynomial is also evaluated,
     otherwise just the return the coefficients of the polynomial are
     returned.

     This is NOT the generalized Laguerre polynomial.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Compute the coefficients of the Laguerre polynomial, given the ORDER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
legendrepoly


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 462
 -- Function File: COEFS= legendrepoly (ORDER,X)
     Compute the coefficients of the Legendre polynomial, given the
     ORDER. We calculate the Legendre polynomial using the recurrence
     relations, Pn+1(x) = inv(n+1)*((2n+1)*x*Pn(x) - nPn-1(x)).

     If the value X is specified, the polynomial is also evaluated,
     otherwise just the return the coefficients of the polynomial are
     returned.

     This is NOT the generalized Legendre polynomial.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Compute the coefficients of the Legendre polynomial, given the ORDER.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
map


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1227
 -- Function File: RESULT = map (FUNCTION, ITERABLE, ...)
     Apply FUNCTION to every item of ITERABLE and return the results.

     `map', like Lisp's ( & numerous other language's ) function for
     iterating the result of a function applied to each of the data
     structure's elements in turn. The results are stored in the
     corresponding input's place. For now, just will work with cells and
     matrices, but support for structs are intended for future versions.
     Also, only "prefix" functions ( like `min (a, b, c, ...)' ) are
     supported. FUN_HANDLE can either be a function name string or a
     function handle (recommended).

     Example:

          octave> A
          A
          {
            [1,1] = 0.0096243
            [2,1] = 0.82781
            [1,2] = 0.052571
            [2,2] = 0.84645
          }
          octave> B
          B =
          {
            [1,1] = 0.75563
            [2,1] = 0.84858
            [1,2] = 0.16765
            [2,2] = 0.85477
          }
          octave> map(@min,A,B)
          ans =
          {
            [1,1] = 0.0096243
            [2,1] = 0.82781
            [1,2] = 0.052571
            [2,2] = 0.84645
          }

     See also: reduce, match





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Apply FUNCTION to every item of ITERABLE and return the results.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
match


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1002
 -- Function File: RESULT =  match ( FUN_HANDLE, ITERABLE )
     match is filter, like Lisp's ( & numerous other language's )
     function for Python has a built-in filter function which takes two
     arguments, a function and a list, and returns a list. 'match'
     performs the same operation like filter in Python. The match
     applies the function to each of the element in the ITERABLE and
     collects that the result of a function applied to each of the data
     structure's elements in turn, and the return values are collected
     as a list of input arguments, whenever the function-result is
     'true' in Octave sense. Anything (1,true,?) evaluating to true,
     the argument is saved into the return value.

     FUN_HANDLE can either be a function name string or a function
     handle (recommended).

     Typically you can use it as,
          match(@(x) ( x >= 1 ), [-1 0 1 2])
                =>   1   2

     See also: reduce, cellfun, arrayfun, cellfun, structfun, spfun





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
match is filter, like Lisp's ( & numerous other language's ) function
for Python



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
normc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 269
 -- Function File: X = normc (M)
     Normalize the columns of a matrix to a length of 1 and return the
     matrix.

            M=[1,2; 3,4];
            normc(M)

            ans =

            0.31623   0.44721
            0.94868   0.89443

     See also: normr





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Normalize the columns of a matrix to a length of 1 and return the
matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
normr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 267
 -- Function File: X =  normr (M)
     Normalize the rows of a matrix to a length of 1 and return the
     matrix.

            M=[1,2; 3,4];
            normr(M)

            ans =

            0.44721   0.89443
            0.60000   0.80000

     See also: normc





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Normalize the rows of a matrix to a length of 1 and return the matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
nze


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
 -- Function File: [Y, F] =  nze (X)
     Extract nonzero elements of X. Equivalent to `X(X != 0)'.
     Optionally, returns also linear indices.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Extract nonzero elements of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
peano_curve


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 316
 -- Function file: X, Y peano_curve (N)
     Creates an iteration of the Peano space-filling curve with N
     points.  The argument N must be of the form `3^M', where M is an
     integer greater than 0.

          n = 9;
          [x, y] = peano_curve (n);
          line (x, y, "linewidth", 4, "color", "red");





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Creates an iteration of the Peano space-filling curve with N points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
physical_constant


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 829
 -- Function File: [NAMES] = physical_constant
 -- Function File: [VAL, UNCERTAINTY, UNIT] = physical_constant (NAME)
 -- Function File: [CONSTANTS] = physical_constant ("all")
     Get physical constant ARG.

     If no arguments are given, returns a cell array with all possible
     NAMEs.  Alternatively, NAME can be `all' in which case VAL is a
     structure array with 4 fields (name, value, uncertainty, units).

     Since the long list of values needs to be parsed on each call to
     this function it is much more efficient to store the values in a
     variable rather make multiple calls to this function with the same
     argument

     The values are the ones recommended by CODATA. This function was
     autogenerated on Wed Apr 25 22:17:07 2012 from NIST database at
     `http://physics.nist.gov/constants'




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Get physical constant ARG.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
publish


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1772
 -- Function File:  publish (FILENAME)
 -- Function File:  publish (FILENAME, OPTIONS)
     Produces latex reports from scripts.

          publish (MY_SCRIPT)

     where the argument is a string that contains the file name of the
     script we want to report.

     If two arguments are given, they are interpreted as follows.

          publish (FILENAME, [OPTION, VALUE, ...])

     The following options are available:

        * format

          the only available format values are the strings `latex' and
          `html'.

        * imageFormat:

          string that specifies the image format, valid formats are
          `pdf', `png', and `jpg'(or `jpeg').

        * showCode:

          boolean value that specifies if the source code will be
          included in the report.

        * evalCode:

          boolean value that specifies if execution results will be
          included in the report.


     Default OPTIONS

        * format = latex

        * imageFormat = pdf

        * showCode =  1

        * evalCode =  1


     Remarks

        * Any additional non-valid field is removed without
          notification.

        * To include several figures in the resulting report you must
          use figure with a unique number for each one of them.

        * You do not have to save the figures manually, publish will do
          it for you.

        * The functions works only for the current path and no way ...
          to specify other path is allowed.


     Assume you have the script `myscript.m' which looks like

          x = 0:0.1:pi;
          y = sin(x)
          figure(1)
          plot(x,y);
          figure(2)
          plot(x,y.^2);

     You can then call publish with default OPTIONS

          publish("myscript")




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Produces latex reports from scripts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
read_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1910
 -- Function File: [OP,NREAD] =  read_options ( args, varargin )
     The function read_options parses arguments to a function as,
     [ops,nread] = read_options (args,...) - Read options

     The input being ARGS a list of options and values.  The options
     can be any of the following,

     'op0'    , string : Space-separated names of opt taking no
     argument  <">

     'op1'    , string : Space-separated names of opt taking one
     argument <">

     'extra'  , string : Name of nameless trailing arguments.
      <">

     'default', struct : Struct holding default option values
     <none>

     'prefix' , int    : If false, only accept whole opt names.
     Otherwise, <0>                     recognize opt from first chars,
     and choose                     shortest if many opts start alike.

     'nocase' , int    : If set, ignore case in option names
       <0>

     'quiet'  , int    : Behavior when a non-string or unknown opt is
     met  <0>              0    - Produce an error              1    -
     Return quietly (can be diagnosed by checking 'nread')

     'skipnan', int    : Ignore NaNs if there is a default value.
     Note : At least one of 'op0' or 'op1' should be specified.

     The output variables are, OPS      : struct : Struct whose
     key/values are option names/values NREAD    : int    : Number of
     elements of args that were read

     USAGE
          # Define options and defaults
          op0 = "is_man is_plane flies"
          default = struct ("is_man",1, "flies",0);

                                       # Read the options

          s = read_options (list (all_va_args), "op0",op0,"default",default)

                                       # Create variables w/ same name as options

          [is_man, is_plane, flies] = getfields (s,"is_man", "is_plane", "flies")
          pre 2.1.39 function [op,nread] = read_options (args, ...)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
The function read_options parses arguments to a function as,
[ops,nread] = read_



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
reduce


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 938
 -- Function File: X = reduce (FUNCTION, SEQUENCE,INITIALIZER)
 -- Function File: X = reduce (FUNCTION, SEQUENCE)
     Implements the 'reduce' operator like in Lisp, or Python.  Apply
     function of two arguments cumulatively to the items of sequence,
     from left to right, so as to reduce the sequence to a single
     value. For example, reduce(@(x,y)(x+y), [1, 2, 3, 4, 5])
     calculates ((((1+2)+3)+4)+5).  The left argument, x, is the
     accumulated value and the right argument, y, is the update value
     from the sequence. If the optional initializer is present, it is
     placed before the items of the sequence in the calculation, and
     serves as a default when the sequence is empty. If initializer is
     not given and sequence contains only one item, the first item is
     returned.

           reduce(@add,[1:10])
           => 55
               reduce(@(x,y)(x*y),[1:7])
           => 5040  (actually, 7!)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Implements the 'reduce' operator like in Lisp, or Python.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
rolldices


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 373
 -- Function File: rolldices (N)
 -- Function File: rolldices (N, NREP, DELAY)
     Returns N random numbers from the 1:6 range, displaying a visual
     selection effect.

     NREP sets the number of rolls, DELAY specifies time between
     successive rolls in seconds. Default is nrep = 25 and delay = 0.1.

     Requires a terminal with ANSI escape sequences enabled.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Returns N random numbers from the 1:6 range, displaying a visual
selection effec



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
slurp_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 293
 -- Function File: S =  slurp_file ( f )
     slurp_file return a whole text file F as a string S.

     F : string : filename S : string : contents of the file

     If F is not an absolute filename, and is not an immediately
     accessible file, slurp_file () will look for F in the path.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
slurp_file return a whole text file F as a string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
solvesudoku


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 313
 -- Function File: [ X, NTRIAL] = solvesudoku (S)
     Solves a classical 9x9 sudoku. S should be a 9x9 array with
     numbers from 0:9. 0 indicates empty field.  Returns the filled
     table or empty matrix if no solution exists.  If requested, NTRIAL
     returns the number of trial-and-error steps needed.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Solves a classical 9x9 sudoku.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
temp_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 504
 -- Function File: N =  temp_name ( rootname, quick )
     name = temp_name(rootname, quick=1) - Return a name that is not
     used

     Returns a name, suitable for defining a new function, script or
     global variable, of the form

     [rootname,number]

     Default rootname is "temp_name_"

     "quick" is an optional parameter, which defaults to 1. If it is
     false, temp_name() will find the smallest acceptable number for
     the name.  Otherwise, a hopefully quicker method is used.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
name = temp_name(rootname, quick=1) - Return a name that is not used




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
textable


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2695
 -- Function File:  textable (MATRIX)
 -- Function File:  textable (MATRIX, PARAMS, ...)
     Save MATRIX in LaTeX format (tabular or array).

     The input matrix must be numeric and two dimensional.

     The generated LaTeX source can be saved directly to a file with
     the option `file'. The file can then be inserted in any latex
     document by using the `\input{latex file name without .tex}'
     statement.

     Available parameters are:
        * `file': filename to save the generated LaTeX source. Requires
          a string as value.

        * `rlines': display row lines.

        * `clines': display column lines.

        * `align': column alignment. Valid values are `l', `c' and `r'
          for center, left and right (default).

        * `math': create table in array environment inside displaymath
          environment. It requires a string as value which will be the
          name of the matrix.

     The basic usage is to generate the source for a table without
     lines and right alignment (default values):
          textable (data)
              =>
                 \begin{tabular}{rrr}
                     0.889283 & 0.949328 & 0.205663 \\
                     0.225978 & 0.426528 & 0.189561 \\
                     0.245896 & 0.466162 & 0.225864 \\
                 \end{tabular}

     Alternatively, the source can be saved directly into a file:
          textable (data, "file", "data.tex");

     The appearance of the table can be controled with switches and key
     values. The following generates a table with both row and column
     lines (rlines and clines), and center alignment:
          textable (data, "rlines", "clines", "align", "c")
              =>
                 \begin{tabular}{|c|c|c|}
                     \hline
                     0.889283 & 0.949328 & 0.205663 \\
                     \hline
                     0.225978 & 0.426528 & 0.189561 \\
                     \hline
                     0.245896 & 0.466162 & 0.225864 \\
                     \hline
                 \end{tabular}

     Finnally, for math mode, it is also possible to place the matrix
     in an array environment and name the matrix:
          textable (data, "math", "matrix-name")
              =>
                 \begin{displaymath}
                   \mathbf{matrix-name} =
                   \left(
                   \begin{array}{*{ 3 }{rrr}}
                     0.889283 & 0.949328 & 0.205663 \\
                     0.225978 & 0.426528 & 0.189561 \\
                     0.245896 & 0.466162 & 0.225864 \\
                   \end{array}
                   \right)
                 \end{displaymath}

     See also: csv2latex, publish





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Save MATRIX in LaTeX format (tabular or array).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
truncate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 798
 -- Function File: Y = truncate (X, ORDER, METHOD)
 -- Function File: Y = truncate (..., METHOD)
     Truncates X to ORDER of magnitude.

     The optional argument METHOD can be a hanlde to a function used to
     truncate the number. Default is `round'.

     Examples:
             format long
             x = 987654321.123456789;
             order = [3:-1:0 -(1:3)]';
             y = truncate (x,order)
          y =
            987654000.000000
            987654300.000000
            987654320.000000
            987654321.000000
            987654321.100000
            987654321.120000
            987654321.123000

             format
             [truncate(0.127,-2), truncate(0.127,-2,@floor)]
          ans =
             0.13000   0.12000

     See also: round, fix, ceil, floor





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Truncates X to ORDER of magnitude.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
units


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 804
 -- Function File:  units (FROMUNIT, TOUNIT)
 -- Function File:  units (FROMUNIT, TOUNIT, X)
     Return the conversion factor from FROMUNIT to TOUNIT measurements.

     This is an octave interface to the *GNU Units* program which comes
     with an annotated, extendable database defining over two thousand
     measurement units.  See `man units' or
     `http://www.gnu.org/software/units' for more information.  If the
     optional argument X is supplied, return that argument multiplied
     by the conversion factor.  Nonlinear conversions such as
     Fahrenheit to Celsius are not currently supported.  For example, to
     convert three values from miles per hour into meters per second:

          units ("mile/hr", "m/sec", [30, 55, 75])
          ans =

            13.411  24.587  33.528




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Return the conversion factor from FROMUNIT to TOUNIT measurements.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
z_curve


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 310
 -- Function file: X, Y z_curve (N)
     Creates an iteration of the Z-order space-filling curve with N
     points.  The argument N must be of the form `2^M', where M is an
     integer greater than 0.

          n = 8
          [x ,y] = z_curve (n);
          line (x, y, "linewidth", 4, "color", "blue");





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Creates an iteration of the Z-order space-filling curve with N points.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
zagzig


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 627
 -- Function File:  zagzig (MTRX)
     Returns zagzig walk-off of the elements of MTRX.  Essentially it
     walks the matrix in a Z-fashion.

     mat =   1   4   7   2   5   8   3   6   9 then zagzag(mat) gives
     the output, [1 4 2 3 5 7 8 6 9], by walking as shown in the figure
     from pt 1 in that order of output.  The argument MTRX should be a
     MxN matrix. One use of zagzig the use with picking up DCT
     coefficients like in the JPEG algorithm for compression.

     An example of zagzig use:
          mat = reshape(1:9,3,3);
          zagzag(mat)
          ans =[1 4 2 3 5 7 8 6 9]


   See also: zigzag




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Returns zagzig walk-off of the elements of MTRX.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
zigzag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 550
 -- Function File:  zigzag (MTRX)
     Returns zigzag walk-off of the elements of MTRX.  Essentially it
     walks the matrix in a Z-fashion.

     mat =   1   4   7   2   5   8   3   6   9 then zigzag(mat) gives
     the output, [1   2   4   7   5   3   6   8   9], by walking as
     shown in the figure from pt 1 in that order of output.  The
     argument MTRX should be a MxN matrix

     An example of zagzig use:
          mat = reshape(1:9,3,3);
          zigzag(mat)
          ans =[1   2   4   7   5   3   6   8   9]


   See also: zagzig




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Returns zigzag walk-off of the elements of MTRX.





