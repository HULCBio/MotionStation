# Created by Octave 3.6.4, Sat Mar 30 09:21:36 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 19
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
Ci


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 275
 -- Function File: Y = Ci (Z)
     Compute the cosine integral function defined by:                    Inf
                       /
               Ci(x) = | cos(t)/t dt
                       /
                       x

     See also: cosint, Si, sinint, expint, expint_Ei





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the cosine integral function defined by:
                   Inf
        



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
Si


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 207
 -- Function File: Y = Si (X)
     Compute the sine integral defined by:                    x
                       /
               Si(x) = | sin(t)/t dt
                       /
                       0




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the sine integral defined by:
                   x
                  /
 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
cosint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 275
 -- Function File: Y = cosint (Z)
     Compute the cosine integral function defined by:                    Inf
                       /
           cosint(x) = | cos(t)/t dt
                       /
                       x

     See also: Ci, Si, sinint, expint, expint_Ei





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the cosine integral function defined by:
                   Inf
        



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
dirac


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
 -- Function File: Y = dirac(X)
     Compute the dirac delta function.

     See also: heaviside





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Compute the dirac delta function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ellipke


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 410
 -- Function File: [K, E] = ellipke (M[,TOL])
     Compute complete elliptic integral of first K(M) and second E(M).

     M is either real array or scalar with 0 <= m <= 1

     TOL will be ignored (MATLAB uses this to allow faster, less
     accurate approximation)

     Ref: Abramowitz, Milton and Stegun, Irene A. Handbook of
     Mathematical Functions, Dover, 1965, Chapter 17.

     See also: ellipj





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Compute complete elliptic integral of first K(M) and second E(M).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
erfcinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
 -- Function File: erfcinv (X)
     Compute the inverse complementary error function.

     See also: erfc, erf, erfinv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute the inverse complementary error function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
expint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 251
 -- Function File: Y = expint (X)
     Compute the exponential integral,                    infinity
                       /
           expint(x) = | exp(t)/t dt
                       /
                      x

     See also: expint_E1, expint_Ei





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the exponential integral,
                   infinity
                  



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
expint_E1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 251
 -- Function File: Y = expint_E1 (X)
     Compute the exponential integral,                    infinity
                       /
           expint(x) = | exp(t)/t dt
                       /
                      x

     See also: expint, expint_Ei





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the exponential integral,
                   infinity
                  



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
expint_Ei


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 263
 -- Function File: Y = expint_Ei (X)
     Compute the exponential integral,                      infinity
                         /
        expint_Ei(x) = - | exp(t)/t dt
                         /
                         -x

     See also: expint, expint_E1





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the exponential integral,
                     infinity
                



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
heaviside


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 400
 -- Function File:  heaviside(X)
 -- Function File:  heaviside(X, ZERO_VALUE)
     Compute the Heaviside step function.

     The Heaviside function is defined as

            Heaviside (X) = 1,   X > 0
            Heaviside (X) = 0,   X < 0

     The value of the Heaviside function at X = 0 is by default 0.5,
     but can be changed via the optional second input argument.

     See also: dirac





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Compute the Heaviside step function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
laguerre


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 171
 -- Function File: Y =  laguerre (X,N)
 -- Function File: [Y P]=  laguerre (X,N)
     Compute the value of the Laguerre polynomial of order N for each
     element of X





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Compute the value of the Laguerre polynomial of order N for each
element of X




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
lambertw


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1029
 -- Function File: X =  lambertw (Z)
 -- Function File: X =  lambertw (Z, N)
     Compute the Lambert W function of Z.

     This function satisfies W(z).*exp(W(z)) = z, and can thus be used
     to express solutions of transcendental equations involving
     exponentials or logarithms.

     N must be integer, and specifies the branch of W to be computed;
     W(z) is a shorthand for W(0,z), the principal branch.  Branches 0
     and -1 are the only ones that can take on non-complex values.

     If either N or Z are non-scalar, the function is mapped to each
     element; both may be non-scalar provided their dimensions agree.

     This implementation should return values within 2.5*eps of its
     counterpart in Maple V, release 3 or later.  Please report any
     discrepancies to the author, Nici Schraudolph
     <schraudo@inf.ethz.ch>.

     For further details, see:

     Corless, Gonnet, Hare, Jeffrey, and Knuth (1996), `On the Lambert
     W Function', Advances in Computational Mathematics 5(4):329-359.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Compute the Lambert W function of Z.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
laplacian


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3694
 LAPLACIAN   Sparse Negative Laplacian in 1D, 2D, or 3D

    [~,~,A]=LAPLACIAN(N) generates a sparse negative 3D Laplacian matrix
    with Dirichlet boundary conditions, from a rectangular cuboid regular
    grid with j x k x l interior grid points if N = [j k l], using the
    standard 7-point finite-difference scheme,  The grid size is always
    one in all directions.

    [~,~,A]=LAPLACIAN(N,B) specifies boundary conditions with a cell array
    B. For example, B = {'DD' 'DN' 'P'} will Dirichlet boundary conditions
    ('DD') in the x-direction, Dirichlet-Neumann conditions ('DN') in the
    y-direction and period conditions ('P') in the z-direction. Possible
    values for the elements of B are 'DD', 'DN', 'ND', 'NN' and 'P'.

    LAMBDA = LAPLACIAN(N,B,M) or LAPLACIAN(N,M) outputs the m smallest
    eigenvalues of the matrix, computed by an exact known formula, see
    http://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors_of_the_second_derivative
    It will produce a warning if the mth eigenvalue is equal to the
    (m+1)th eigenvalue. If m is absebt or zero, lambda will be empty.

    [LAMBDA,V] = LAPLACIAN(N,B,M) also outputs orthonormal eigenvectors
    associated with the corresponding m smallest eigenvalues.

    [LAMBDA,V,A] = LAPLACIAN(N,B,M) produces a 2D or 1D negative
    Laplacian matrix if the length of N and B are 2 or 1 respectively.
    It uses the standard 5-point scheme for 2D, and 3-point scheme for 1D.

    % Examples:
    [lambda,V,A] = laplacian([100,45,55],{'DD' 'NN' 'P'}, 20); 
    % Everything for 3D negative Laplacian with mixed boundary conditions.
    laplacian([100,45,55],{'DD' 'NN' 'P'}, 20);
    % or
    lambda = laplacian([100,45,55],{'DD' 'NN' 'P'}, 20);
    % computes the eigenvalues only

    [~,V,~] = laplacian([200 200],{'DD' 'DN'},30);
    % Eigenvectors of 2D negative Laplacian with mixed boundary conditions.

    [~,~,A] = laplacian(200,{'DN'},30);
    % 1D negative Laplacian matrix A with mixed boundary conditions.

    % Example to test if outputs correct eigenvalues and vectors:
    [lambda,V,A] = laplacian([13,10,6],{'DD' 'DN' 'P'},30);
    [Veig D] = eig(full(A)); lambdaeig = diag(D(1:30,1:30));
    max(abs(lambda-lambdaeig))  %checking eigenvalues
    subspace(V,Veig(:,1:30))    %checking the invariant subspace
    subspace(V(:,1),Veig(:,1))  %checking selected eigenvectors
    subspace(V(:,29:30),Veig(:,29:30)) %a multiple eigenvalue 
    
    % Example showing equivalence between laplacian.m and built-in MATLAB
    % DELSQ for the 2D case. The output of the last command shall be 0.
    A1 = delsq(numgrid('S',32)); % input 'S' specifies square grid.
    [~,~,A2] = laplacian([30,30]);
    norm(A1-A2,inf)
    
    Class support for inputs:
    N - row vector float double  
    B - cell array
    M - scalar float double 

    Class support for outputs:
    lambda and V  - full float double, A - sparse float double.

    Note: the actual numerical entries of A fit int8 format, but only
    double data class is currently (2010) supported for sparse matrices. 

    This program is designed to efficiently compute eigenvalues,
    eigenvectors, and the sparse matrix of the (1-3)D negative Laplacian
    on a rectangular grid for Dirichlet, Neumann, and Periodic boundary
    conditions using tensor sums of 1D Laplacians. For more information on
    tensor products, see
    http://en.wikipedia.org/wiki/Kronecker_sum_of_discrete_Laplacians
    For 2D case in MATLAB, see 
    http://www.mathworks.com/access/helpdesk/help/techdoc/ref/kron.html.

    This code is also part of the BLOPEX package: 
    http://en.wikipedia.org/wiki/BLOPEX or directly 
    http://code.google.com/p/blopex/



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
 LAPLACIAN   Sparse Negative Laplacian in 1D, 2D, or 3D




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
multinom


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 588
 -- Function File: [Y ALPHA] = multinom (X, N)
 -- Function File: [Y ALPHA] = multinom (X, N,SORT)
     Returns the terms (monomials) of the multinomial expansion of
     degree n.

          (x1 + x2 + ... + xm)^N

     X is a nT-by-m matrix where each column represents a different
     variable, the output Y has the same format.  The order of the
     terms is inherited from multinom_exp and can be controlled through
     the optional argument SORT and is passed to the function `sort'.
     The exponents are returned in ALPHA.

     See also: multinom_exp, multinom_coeff, sort





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Returns the terms (monomials) of the multinomial expansion of degree n.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
multinom_coeff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 937
 -- Function File: [C ALPHA] = multinom_coeff (M, N)
 -- Function File: [C ALPHA] = multinom_coeff (M, N,ORDER)
     Produces the coefficients of the multinomial expansion

          (x1 + x2 + ... + xm).^n

     For example, for m=3, n=3 the expansion is

          (x1+x2+x3)^3 =
                  = x1^3 + x2^3 + x3^3 +
                  +  3 x1^2 x2 + 3 x1^2 x3 + 3 x2^2 x1 + 3 x2^2 x3 +
                  + 3 x3^2 x1 + 3 x3^2 x2 + 6 x1 x2 x3

     and the coefficients are [6 3 3 3 3 3 3 1 1 1].

     The order of the coefficients is defined by the optinal argument
     ORDER.   It is passed to the function `multion_exp'. See the help
     of that function for explanation.  The multinomial coefficients
     are generated using

           /   \
           | n |                n!
           |   |  = ------------------------
           | k |     k(1)!k(2)! ... k(end)!
           \   /

     See also: multinom, multinom_exp





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Produces the coefficients of the multinomial expansion




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
multinom_exp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 700
 -- Function File: ALPHA = multinom_exp (M, N)
 -- Function File: ALPHA = multinom_exp (M, N,SORT)
     Returns the exponents of the terms in the multinomial expansion

          (x1 + x2 + ... + xm).^N

     For example, for m=2, n=3 the expansion has the terms

          x1^3, x2^3, x1^2*x2, x1*x2^2

     then `alpha = [3 0; 2 1; 1 2; 0 3]';

     The optional argument SORT is passed to function `sort' to sort
     the exponents by the maximum degree.  The example above calling `
     multinom(m,n,"ascend")' produces

     `alpha = [2 1; 1 2; 3 0; 0 3]';

     calling ` multinom(m,n,"descend")' produces

     `alpha = [3 0; 0 3; 2 1; 1 2]';

     See also: multinom, multinom_coeff, sort





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Returns the exponents of the terms in the multinomial expansion




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
psi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 201
 -- Function File: Y =  psi (X)
     Compute the psi function, for each value of X.

                 d
        psi(x) = __ log(gamma(x))
                 dx

     See also: gamma, gammainc, gammaln





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Compute the psi function, for each value of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sinint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 96
 -- Function File: Y = sinint (X)
     Compute the sine integral function.

     See also: Si





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Compute the sine integral function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
zeta


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 95
 -- Function File: Z = zeta (T)
     Compute the Riemann's Zeta function.

     See also: Si





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Compute the Riemann's Zeta function.





