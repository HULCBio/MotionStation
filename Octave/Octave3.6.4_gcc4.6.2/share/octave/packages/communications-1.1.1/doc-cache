# Created by Octave 3.6.4, Sat Mar 30 09:55:55 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 88
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ademodce


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2038
 -- Function File: Y = ademodce (X,FS,'amdsb-tc',offset)
 -- Function File: Y = ademodce (X,FS,'amdsb-tc/costas',offset)
 -- Function File: Y = ademodce (X,FS,'amdsb-sc')
 -- Function File: Y = ademodce (X,FS,'amdsb-sc/costas')
 -- Function File: Y = ademodce (X,FS,'amssb')
 -- Function File: Y = ademodce (X,FS,'qam')
 -- Function File: Y = ademodce (X,FS,'qam/cmplx')
 -- Function File: Y = ademodce (X,FS,'fm',DEV)
 -- Function File: Y = ademodce (X,FS,'pm',DEV)
 -- Function File: Y = ademodce (X,[FS,IPHS],...)
 -- Function File: Y = ademodce (...,NUM,DEN)
     Baseband demodulator for analog signals. The input signal is
     specified by X, its sampling frequency by FS and the type of
     modulation by the third argument, TYP. The default values of FS is
     1 and TYP is 'amdsb-tc'.

     If the argument FS is a two element vector, the the first element
     represents the sampling rate and the second the initial phase.

     The different types of demodulations that are available are

    'am'
    'amdsb-tc'
          Double-sideband with carrier

    'amdsb-tc/costas'
          Double-sideband with carrier and Costas phase locked loop

    'amdsb-sc'
          Double-sideband with suppressed carrier

    'amssb'
          Single-sideband with frequency domain Hilbert filtering

    'qam'
          Quadrature amplitude demodulation. In-phase in odd-columns
          and quadrature in even-columns

    'qam/cmplx'
          Quadrature amplitude demodulation with complex return value.

    'fm'
          Frequency demodulation

    'pm'
          Phase demodulation

     Additional arguments are available for the demodulations
     'amdsb-tc', 'fm', 'pm'. These arguments are

    `offset'
          The offset in the input signal for the transmitted carrier.

    `dev'
          The deviation of the phase and frequency modulation

     It is possible to specify a low-pass filter, by the numerator NUM
     and denominator DEN that will be applied to the returned vector.


   See also: ademodce, dmodce




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Baseband demodulator for analog signals.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
amdemod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 191
 -- Function File: [M] = amdemod (S, FC, FS)
     Compute the amplitude demodulation of the signal S with a carrier
     frequency of FC and a sample frequency of FS.

     See also: ammod





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the amplitude demodulation of the signal S with a carrier
frequency of F



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ammod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 190
 -- Function File: ammod (X,FC,FS)
     Create the AM modulation of the signal x with carrier frequency
     fs. Where x is sample at frequency fs.

     See also: amdemod, fmmod, fmdemod





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Create the AM modulation of the signal x with carrier frequency fs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
amodce


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1785
 -- Function File: Y = amodce (X,FS,'amdsb-tc',offset)
 -- Function File: Y = amodce (X,FS,'amdsb-sc')
 -- Function File: Y = amodce (X,FS,'amssb')
 -- Function File: Y = amodce (X,FS,'amssb/time',NUM,DEN)
 -- Function File: Y = amodce (X,FS,'qam')
 -- Function File: Y = amodce (X,FS,'fm',DEV)
 -- Function File: Y = amodce (X,FS,'pm',DEV)
 -- Function File: Y = amodce (X,[FS,IPHS],...)
     Baseband modulator for analog signals. The input signal is
     specified by X, its sampling frequency by FS and the type of
     modulation by the third argument, TYP. The default values of FS is
     1 and TYP is 'amdsb-tc'.

     If the argument FS is a two element vector, the the first element
     represents the sampling rate and the second the initial phase.

     The different types of modulations that are available are

    'am'
    'amdsb-tc'
          Double-sideband with carrier

    'amdsb-sc'
          Double-sideband with suppressed carrier

    'amssb'
          Single-sideband with frequency domain Hilbert filtering

    'amssb/time'
          Single-sideband with time domain filtering. Hilbert filter is
          used by default, but the filter can be specified

    'qam'
          Quadrature amplitude modulation

    'fm'
          Frequency modulation

    'pm'
          Phase modulation

     Additional arguments are available for the modulations 'amdsb-tc',
     'fm, 'pm' and 'amssb/time'. These arguments are

    `offset'
          The offset in the input signal for the transmitted carrier.

    `dev'
          The deviation of the phase and frequency modulation

    `num'
    `den'
          The numerator and denominator of the filter transfer function
          for the time domain filtering of the SSB modulation


   See also: ademodce, dmodce




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Baseband modulator for analog signals.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
apkconst


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1624
 -- Function File:  apkconst (NSIG)
 -- Function File:  apkconst (NSIG,AMP)
 -- Function File:  apkconst (NSIG,AMP,PHS)
 -- Function File:  apkconst (...,"n")
 -- Function File:  apkconst (...,STR)
 -- Function File: Y =  apkconst (...)
     Plots a ASK/PSK signal constellation. Argument NSIG is a real
     vector whose length determines the number of ASK radii in the
     constellation.  The values of vector NSIG determine the number of
     points in each ASK radii.

     By default the radii of each ASK modulated level is given by the
     index of NSIG. The amplitudes can be defined explictly in the
     variable AMP, which  is a vector of the same length as NSIG.

     By default the first point in each ASK radii has zero phase, and
     following points are coding in an anti-clockwise manner. If PHS is
     defined then it is a vector of the same length as NSIG defining
     the initial phase in each ASK radii.

     In addition "apkconst" takes two string arguments 'n' and and STR.
     If the string 'n' is included in the arguments, then a number is
     printed next to each constellation point giving the symbol value
     that would be mapped to this point by the "modmap" function. The
     argument STR is a plot style string (example 'r+') and determines
     the default gnuplot point style to use for plot points in the
     constellation.

     If "apskconst" is called with a return argument, then no plot is
     created. However the return value is a vector giving the in-phase
     and quadrature values of the symbols in the constellation.

   See also: dmod, ddemod, modmap, demodmap




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Plots a ASK/PSK signal constellation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
awgn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1122
 -- Function File: Y = awgn (X,SNR)
 -- Function File: Y = awgn (X,SNR,PWR)
 -- Function File: Y = awgn (X,SNR, PWR,SEED)
 -- Function File: Y = awgn (..., 'TYPE')
     Add white Gaussian noise to a voltage signal.

     The input X is assumed to be a real or complex voltage  signal. The
     returned value Y will be the same form and size as X but with
     Gaussian noise added. Unless the power is specified in PWR, the
     signal power is assumed to be 0dBW, and the noise of SNR dB will be
     added with respect to this. If PWR is a numeric value then the
     signal X is assumed to be PWR dBW, otherwise if PWR is 'measured',
     then the power in the signal will be measured and the noise added
     relative to this measured power.

     If SEED is specified, then the random number generator seed is
     initialized with this value

     By default the SNR and PWR are assumed to be in dB and dBW
     respectively. This default behaviour can be chosen with TYPE set
     to 'dB'. In the case where TYPE is set to 'linear', PWR is assumed
     to be in Watts and SNR is a ratio.

   See also: randn, wgn




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Add white Gaussian noise to a voltage signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bchpoly


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3093
 -- Function File: P =  bchpoly ()
 -- Function File: P =  bchpoly (N)
 -- Function File: P =  bchpoly (N,K)
 -- Function File: P =  bchpoly (PRIM,K)
 -- Function File: P =  bchpoly (N,K,PRIM)
 -- Function File: P =  bchpoly (...,PROBE)
 -- Function File: [P,F] =  bchpoly (...)
 -- Function File: [P,F,C] =  bchpoly (...)
 -- Function File: [P,F,C,PAR] =  bchpoly (...)
 -- Function File: [P,F,C,PAR,T] =  bchpoly (...)
     Calculates the generator polynomials for a BCH coder. Called with
     no input arguments "bchpoly" returns a list of all of the valid
     BCH codes for the codeword length 7, 15, 31, 63, 127, 255 and 511.
     A three column matrix is returned with each row representing a
     seperate valid BCH code. The first column is the codeword length,
     the second the message length and the third the error correction
     capability of the code.

     Called with a single input argument, "bchpoly" returns the valid
     BCH codes for the specified codeword length N. The output format
     is the same as above.

     When called with two or more arguments, "bchpoly" calculates the
     generator polynomial of a particular BCH code. The generator
     polynomial is returned in P as a vector representation of a
     polynomial in GF(2). The terms of the polynomial are listed
     least-significant term first.

     The desired BCH code can be specified by its codeword length N and
     its message length K. Alternatively, the primitive polynomial over
     which to calculate the polynomial can be specified as PRIM.  If a
     vector representation of the primitive polynomial is given, then
     PRIM can be specified as the first argument of two arguments, or
     as the third argument. However, if an integer representation of the
     primitive polynomial is used, then the primitive polynomial must be
     specified as the third argument.

     When called with two or more arguments, "bchpoly" can also return
     the factors F of the generator polynomial P, the cyclotomic coset
     for the Galois field over which the BCH code is calculated, the
     parity check matrix PAR and the error correction capability T. It
     should be noted that the parity check matrix is calculated with
     "cyclgen" and limitations in this function means that the parity
     check matrix is only available for codeword length upto 63. For
     codeword length longer than this PAR returns an empty matrix.

     With a string argument PROBE defined, the action of "bchpoly" is
     to calculate the error correcting capability of the BCH code
     defined by N, K and PRIM and return it in P. This is similar to a
     call to "bchpoly" with zero or one argument, except that only a
     single code is checked. Any string value for PROBE will force this
     action.

     In general the codeword length N can be expressed as `2^M-1',
     where M is an integer. However, if [N,K] is a valid BCH code, then
     a shortened BCH code of the form [N-X,K-X] can be created with the
     same generator polynomial


   See also: cyclpoly, encode, decode, cosets




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Calculates the generator polynomials for a BCH coder.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
bi2de


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 695
 -- Function File: D =  bi2de (B)
 -- Function File: D =  bi2de (B,F)
 -- Function File: D =  bi2de (B,P)
 -- Function File: D =  bi2de (B,P,F)
     Convert bit matrix to a vector of integers

     Each row of the matrix B is treated as a single integer represented
     in binary form. The elements of B, must therefore be '0' or '1'

     If P is defined then it is treated as the base of the decomposition
     and the elements of B must then lie between '0' and 'p-1'.

     The variable F defines whether the first or last element of B is
     considered to be the most-significant. Valid values of F are
     'right-msb' or 'left-msb'. By default F is 'right-msb'.

     See also: de2bi





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Convert bit matrix to a vector of integers




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
biterr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1878
 -- Function File: [NUM, RATE] =  biterr (A,B)
 -- Function File: [NUM, RATE] =  biterr (...,K)
 -- Function File: [NUM, RATE] =  biterr (...,FLAG)
 -- Function File: [NUM, RATE IND] =  biterr (...)
     Compares two matrices and returns the number of bit errors and the
     bit error rate. The binary representations of the variables A and
     B are treated and A and B can be either:

    Both matrices
          In this case both matrices must be the same size and then by
          default the the return values NUM and RATE are the overall
          number of bit errors and the overall bit error rate.

    One column vector
          In this case the column vector is used for bit error
          comparision column-wise with the matrix. The returned values
          NUM and RATE are then row vectors containing the num of bit
          errors and the bit error rate for each of the column-wise
          comparisons. The number of rows in the matrix must be the
          same as the length of the column vector

    One row vector
          In this case the row vector is used for bit error comparision
          row-wise with the matrix. The returned values NUM and RATE
          are then column vectors containing the num of bit errors and
          the bit error rate for each of the row-wise comparisons. The
          number of columns in the matrix must be the same as the
          length of the row vector

     This behaviour can be overridden with the variable FLAG. FLAG can
     take the value 'column-wise', 'row-wise' or 'overall'. A
     column-wise comparision is not possible with a row vector and
     visa-versa.

     By default the number of bits in each symbol is assumed to be give
     by the number required to represent the maximum value of A and B.
     The number of bits to represent a symbol can be overridden by the
     variable K.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compares two matrices and returns the number of bit errors and the bit
error rat



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
bsc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134
 -- Function File: Y = bsc (DATA, P)
     Send DATA into a binary symetric channel with probability P of
     error one each symbol.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Send DATA into a binary symetric channel with probability P of error
one each sy



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
comms


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1433
 -- Function File:  comms ('help')
 -- Function File:  comms ('info')
 -- Function File:  comms ('info', MOD)
 -- Function File:  comms ('test')
 -- Function File:  comms ('test', MOD)
     Manual and test code for the Octave Communications toolbox. There
     are 5 possible ways to call this function.

    `comms ('help')'
          Display this help message. Called with no arguments, this
          function also displays this help message

    `comms ('info')'
          Open the Commumications toolbox manual

    `comms ('info', MOD)'
          Open the Commumications toolbox manual at the section
          specified by MOD

    `comms ('test')'
          Run all of the test code for the Communications toolbox.

    `comms ('test', MOD)'
          Run only the test code for the Communications toolbox in the
          module MOD.

     Valid values for the varibale MOD are

    'all'
          All of the toolbox

    'random'
          The random signal generation and analysis package

    'source'
          The source coding functions of the package

    'block'
          The block coding functions

    'convol'
          The convolution coding package

    'modulation'
          The modulation package

    'special'
          The special filter functions

    'galois'
          The Galois fields package

     Please note that this function file should be used as an example
     of the use of this toolbox.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Manual and test code for the Octave Communications toolbox.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
compand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1154
 -- Function File: Y =  compand (X, MU, V, 'mu/compressor')
 -- Function File: Y =  compand (X, MU, V, 'mu/expander')
 -- Function File: Y =  compand (X, MU, V, 'A/compressor')
 -- Function File: Y =  compand (X, MU, V, 'A/expander')
     Compresses and expanding the dynamic range of a signal using a
     mu-law or or A-law algorithm.

     The mu-law compressor/expander for reducing the dynamic range, is
     used if the fourth argument of "compand" starts with 'mu/'.
     Whereas the A-law compressor/expander is used if "compand" starts
     with 'A/'.  The mu-law algorithm uses the formulation


                  V log (1 + \mu/V |x|)
              y = -------------------- sgn(x)
                      log (1 + \mu)

     while the A-law algorithm used the formulation


                  /    A / (1 + log A) x,               0 <= |x| <= V/A
                  |
              y = <    V ( 1 + log (A/V |x|) )
                  |    ----------------------- sgn(x),  V/A < |x| <= V
                  \        1 + log A

     Neither converts from or to audio file ulaw format. Use mu2lin or
     lin2mu instead.


   See also: m2ulin, lin2mu




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compresses and expanding the dynamic range of a signal using a mu-law or
or A-la



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
convenc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1121
 -- Function File: X = convenc (M, G, K)
     Compute output of an (n, K, L) convolutional encoder with vector
     input M and matrix of generator polynomials G.

     The input vector M can be of arbitrary length. G is a matrix with
     n rows and K*(L+1) columns. The rows of G are the generator
     polynomials for each of the n output bits (per K input bits).

     The output is a vector whose length is
     n*floor([length(M)+K*(L+1)-1]/K).  If unspecified, K defaults to 1.

     Example 1: Compute the output from a (2, 1, 2) convolutional
     encoder
          m  = [ 1 1 0 1 1 1 0 0 1 0 0 0];
          g1 = [1 1 1];
          g2 = [1 0 1];
          convenc (m, [g1; g2])
               => [1 1 0 1 0 1 0 0 0 1 1 0 0 1 1 1 1 1 1 0 1 1 0 0 0 0 0 0]

     Example 2: Compute the output from a (3, 2, 1) convolutional
     encoder
          m  = [0 1 1 0 0 0 1 1 ];
          g1 = [1 0 1 1];
          g2 = [1 1 0 1];
          g3 = [1 0 1 0];
          convenc (m, [g1; g2; g3], 2)
               => [1 1 1 1 1 1 1 1 0 1 0 1]

     *Caution:*: this function is not compatible with MATLAB's
     convenc().




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute output of an (n, K, L) convolutional encoder with vector input
M and mat



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
cosets


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 209
 -- Function File:  cosets (M, PRIM)
     Finds the elements of GF(2^M) with primitive polynomial PRIM, that
     share the same minimum polynomial. Returns a cell array of the
     paratitioning of GF(2^M).




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Finds the elements of GF(2^M) with primitive polynomial PRIM, that
share the sam



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
de2bi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1082
 -- Function File: B =  de2bi (D)
 -- Function File: B =  de2bi (D,N)
 -- Function File: B =  de2bi (D,N,P)
 -- Function File: B =  de2bi (D,N,P,F)
     Convert a non-negative integer to bit vector.

     The variable D must be a vector of non-negative integers. "de2bi"
     then returns a matrix where each row represents the binary
     representation of elements of D. If N is defined then the returned
     matrix will have N columns. This number of columns can be either
     larger than the minimum needed and zeros will be added to the msb
     of the binary representation or smaller than the minimum in which
     case the least-significant part of the element is returned.

     If P is defined then it is used as the base for the decomposition
     of the returned values. That is the elements of the returned value
     are between '0' and 'p-1'.

     The variable F defines whether the first or last element of B is
     considered to be the most-significant. Valid values of F are
     'right-msb' or 'left-msb'. By default F is 'right-msb'.

     See also: bi2de





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convert a non-negative integer to bit vector.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
decode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4528
 -- Function File: MSG = decode (CODE,N,K)
 -- Function File: MSG = decode (CODE,N,K,TYP)
 -- Function File: MSG = decode (CODE,N,K,TYP,OPT1)
 -- Function File: MSG = decode (CODE,N,K,TYP,OPT1,OPT2)
 -- Function File: [MSG, ERR] = decode (...)
 -- Function File: [MSG, ERR, CCODE] = decode (...)
 -- Function File: [MSG, ERR, CCODE, CERR] = decode (...)
     Top level block decoder. This function makes use of the lower level
     functions such as "cyclpoly", "cyclgen", "hammgen", and "bchenco".
     The coded message to decode is pass in CODE, the codeword length
     is N and the message length is K. This function is used to decode
     messages using either:

    A [n,k] linear block code defined by a generator matrix

    A [n,k] cyclic code defined by a generator polynomial

    A [n,k] Hamming code defined by a primitive polynomial

    A [n,k] BCH code code defined by a generator polynomial

     The type of coding to use is defined by the variable TYP. This
     variable is a string taking one of the values

    `'linear' or 'linear/binary''
          A linear block code is assumed with the message MSG being in a
          binary format. In this case the argument OPT1 is the generator
          matrix, and is required. Additionally, OPT2 containing the
          syndrome lookup table (see "syndtable") can also be passed.

    `'cyclic' or 'cyclic/binary''
          A cyclic code is assumed with the message MSG being in a
          binary format. The generator polynomial to use can be defined
          in OPT1.  The default generator polynomial to use will be
          "cyclpoly(N,K)". Additionally, OPT2 containing the syndrome
          lookup table (see "syndtable") can also be passed.

    `'hamming' or 'hamming/binary''
          A Hamming code is assumed with the message MSG being in a
          binary format. In this case N must be of an integer of the
          form `2^M-1', where M is an integer. In addition K must be
          `N-M'. The primitive polynomial to use can be defined in
          OPT1. The default primitive polynomial to use is the same as
          defined by "hammgen". The variable OPT2 should not be defined.

    `'bch' or 'bch/binary''
          A BCH code is assumed with the message MSG being in a binary
          format. The primitive polynomial to use can be defined in
          OPT2.  The error correction capability of the code can also
          be defined in OPT1. Use the empty matrix [] to let the error
          correction capability take the default value.

     In addition the argument 'binary' above can be replaced with
     'decimal', in which case the message is assumed to be a decimal
     vector, with each value representing a symbol to be coded. The
     binary format can be in two forms

    `An X-by-N matrix'
          Each row of this matrix represents a symbol to be decoded

    `A vector with length divisible by N'
          The coded symbols are created from groups of N elements of
          this vector

     The decoded message is return in MSG. The number of errors
     encountered is returned in ERR. If the coded message format is
     'decimal' or a 'binary' matrix, then ERR is a column vector having
     a length equal to the number of decoded symbols. If CODE is a
     'binary' vector, then ERR is the same length as MSG and indicated
     the number of errors in each symbol. If the value ERR is positive
     it indicates the number of errors corrected in the corresponding
     symbol. A negative value indicates an uncorrectable error. The
     corrected code is returned in CCODE in a similar format to the
     coded message MSG. The variable CERR contains similar data to ERR
     for CCODE.

     It should be noted that all internal calculations are performed in
     the binary format. Therefore for large values of N, it is
     preferable to use the binary format to pass the messages to avoid
     possible rounding errors. Additionally, if repeated calls to
     "decode" will be performed, it is often faster to create a
     generator matrix externally with the functions "hammgen" or
     "cyclgen", rather than let "decode" recalculate this matrix at
     each iteration. In this case TYP should be 'linear'. The exception
     to this case is BCH codes, where the required syndrome table is
     too large. The BCH decoder, decodes directly from the polynomial
     never explicitly forming the syndrome table.


   See also: encode, cyclgen, cyclpoly, hammgen, bchdeco, bchpoly,
syndtable




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Top level block decoder.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
deintrlv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
 -- Function File: DEINTRLVD = deintrlv (DATA, ELEMENTS)
     Restore elements of DATA according to ELEMENTS.

     See also: intrlv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Restore elements of DATA according to ELEMENTS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
demodmap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2342
 -- Function File: z =  demodmap (Y,FD,FS,'ask',M)
 -- Function File: z =  demodmap (Y,FD,FS,'fsk',M,TONE)
 -- Function File: z =  demodmap (Y,FD,FS,'msk')
 -- Function File: z =  demodmap (Y,FD,FS,'psk',M)
 -- Function File: z =  demodmap (Y,FD,FS,'qask',M)
 -- Function File: z =  demodmap (Y,FD,FS,'qask/cir',NSIG,AMP,PHS)
 -- Function File: z =  demodmap (Y,FD,FS,'qask/arb',INPHASE,QUADR)
 -- Function File: z =  demodmap (Y,FD,FS,'qask/arb',MAP)
 -- Function File: z =  demodmap (Y,[FD, OFF],...)
     Demapping of an analog signal to a digital signal. The function
     "demodmap" must have at least three input arguments and one output
     argument. Argument Y is a complex variable representing the analog
     signal to be demapped. The variables FD and FS are the sampling
     rate of the of digital signal and the sampling rate of the analog
     signal respectively. It is required that `FS/FD' is an integer.

     The available mapping of the digital signal are

    'ask'
          Amplitude shift keying

    'fsk'
          Frequency shift keying

    'msk'
          Minimum shift keying

    'psk'
          Phase shift keying

    'qask'
    'qsk'
    'qam'
          Quadraure amplitude shift keying

     In addition the 'qask', 'qsk' and 'qam' method can be modified
     with the flags '/cir' or '/arb'. That is 'qask/cir' and
     'qask/arb', etc are valid methods and give circular- and
     arbitrary-qask mappings respectively. Also the method 'fsk' and
     'msk' can be modified with the flag '/max', in which case Y is
     assumed to be a matrix with M columns, representing the symbol
     correlations.

     The variable M is the order of the modulation to use. By default
     this is 2, and in general should be specified.

     For 'qask/cir', the additional arguments are the same as for
     "apkconst", and you are referred to "apkconst" for the definitions
     of the additional variables.

     For 'qask/arb', the additional arguments INPHASE and QUADR give
     the in-phase and quadrature components of the mapping, in a
     similar mapping to the outputs of "qaskenco" with one argument.
     Similar MAP represents the in-phase and quadrature components of
     the mapping as the real and imaginary parts of the variable MAP.

   See also: modmap, ddemodce, ademodce, apkconst, qaskenco




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Demapping of an analog signal to a digital signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
egolaydec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1044
 -- Function File:  egolaydec (R)
     Given R, the received Extended Golay code, this function tries to
     decode R using the Extended Golay code parity check matrix.
     Extended Golay code (24,12) which can correct upto 3 errors.

     The received code R, needs to be of length Nx24, for encoding. We
     can decode several codes at once, if they are stacked as a matrix
     of 24columns, each code in a separate row.

     The generator G used in here is same as obtained from the function
     egolaygen.

     The function returns the error-corrected code word from the
     received word. If decoding failed, the second return value is 1,
     otherwise it is 0.

     Extended Golay code (24,12) which can correct upto 3 errors.
     Decoding algorithm follows from Lin & Costello.

     Ref: Lin & Costello, pg 128, Ch4, 'Error Control Coding', 2nd ed,
     Pearson.

           M=[rand(10,12)>0.5];
           C1=egolayenc(M);
           C1(:,1)=mod(C1(:,1)+1,2)
           C2=egolaydec(C1)


   See also: egolaygen, egolayenc




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given R, the received Extended Golay code, this function tries to
decode R using



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
egolayenc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 505
 -- Function File:  egolayenc (M)
     Given M, encode M using the Extended Golay code.

     The message M, needs to be of size Nx12, for encoding.  We can
     encode several messages, into codes at once, if they are stacked
     in the order suggested.

     The generator G used in here is same as obtained from the function
     egolaygen. Extended Golay code (24,12) which can correct upto 3
     errors.

          M=(rand(10,12)>0.5);
          C=egolayenc(M)


   See also: egolaygen, egolaydec




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Given M, encode M using the Extended Golay code.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
egolaygen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 239
 -- Function File:  egolaygen ()
     Returns the Extended Golay code (24,12) generator matrix, which
     can correct upto 3 errors. The second argument is the partiy check
     matrix, for this code.


   See also: egolaydec, egolayenc




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Returns the Extended Golay code (24,12) generator matrix, which can
correct upto



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
encode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3341
 -- Function File: CODE = encode (MSG,N,K)
 -- Function File: CODE = encode (MSG,N,K,TYP)
 -- Function File: CODE = encode (MSG,N,K,TYP,OPT)
 -- Function File: [CODE, ADDED] = encode (...)
     Top level block encoder. This function makes use of the lower level
     functions such as "cyclpoly", "cyclgen", "hammgen", and "bchenco".
     The message to code is pass in MSG, the codeword length is N and
     the message length is K. This function is used to encode messages
     using either:

    A [n,k] linear block code defined by a generator matrix

    A [n,k] cyclic code defined by a generator polynomial

    A [n,k] Hamming code defined by a primitive polynomial

    A [n,k] BCH code code defined by a generator polynomial

     The type of coding to use is defined by the variable TYP. This
     variable is a string taking one of the values

    `'linear' or 'linear/binary''
          A linear block code is assumed with the coded message CODE
          being in a binary format. In this case the argument OPT is
          the generator matrix, and is required.

    `'cyclic' or 'cyclic/binary''
          A cyclic code is assumed with the coded message CODE being in
          a binary format. The generator polynomial to use can be
          defined in OPT.  The default generator polynomial to use will
          be "cyclpoly(N,K)"

    `'hamming' or 'hamming/binary''
          A Hamming code is assumed with the coded message CODE being
          in a binary format. In this case N must be of an integer of
          the form `2^M-1', where M is an integer. In addition K must
          be `N-M'. The primitive polynomial to use can be defined in
          OPT. The default primitive polynomial to use is the same as
          defined by "hammgen".

    `'bch' or 'bch/binary''
          A BCH code is assumed with the coded message CODE being in a
          binary format. The generator polynomial to use can be defined
          in OPT.  The default generator polynomial to use will be
          "bchpoly(N,K)"

     In addition the argument 'binary' above can be replaced with
     'decimal', in which case the message is assumed to be a decimal
     vector, with each value representing a symbol to be coded. The
     binary format can be in two forms

    `An X-by-K matrix'
          Each row of this matrix represents a symbol to be coded

    `A vector'
          The symbols are created from groups of K elements of this
          vector.  If the vector length is not divisble by K, then
          zeros are added and the number of zeros added is returned in
          ADDED.

     It should be noted that all internal calculations are performed in
     the binary format. Therefore for large values of N, it is
     preferable to use the binary format to pass the messages to avoid
     possible rounding errors. Additionally, if repeated calls to
     "encode" will be performed, it is often faster to create a
     generator matrix externally with the functions "hammgen" or
     "cyclgen", rather than let "encode" recalculate this matrix at
     each iteration. In this case TYP should be 'linear'. The exception
     to this case is BCH codes, whose encoder is implemented directly
     from the polynomial and is significantly faster.


   See also: decode, cyclgen, cyclpoly, hammgen, bchenco, bchpoly




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Top level block encoder.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
eyediagram


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1488
 -- Function File:  eyediagram (X,N)
 -- Function File:  eyediagram (X,N,PER)
 -- Function File:  eyediagram (X,N,PER,OFF)
 -- Function File:  eyediagram (X,N,PER,OFF,STR)
 -- Function File:  eyediagram (X,N,PER,OFF,STR,H)
 -- Function File: H = eyediagram (...)
     Plot the eye-diagram of a signal. The signal X can be either in one
     of three forms

    A real vector
          In this case the signal is assumed to be real and represented
          by the vector X. A single eye-diagram representing this
          signal is plotted.

    A complex vector
          In this case the in-phase and quadrature components of the
          signal are plotted seperately.

    A matrix with two columns
          In this case the first column represents the in-phase and the
          second the quadrature components of a complex signal.

     Each line of the eye-diagram has N elements and the period is
     assumed to be given by PER. The time axis is then [-PER/2 PER/2].
     By default PER is 1.

     By default the signal is assumed to start at -PER/2. This can be
     overridden by the OFF variable, which gives the number of samples
     to delay the signal.

     The string STR is a plot style string (example 'r+'), and by
     default is the default gnuplot line style.

     The figure handle to use can be defined by H. If H is not given,
     then the next available figure handle is used. The figure handle
     used in returned on HOUT.

   See also: scatterplot




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Plot the eye-diagram of a signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fibodeco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 860
 -- Function File:   fibodeco (CODE)
     Returns the decoded fibonacci value from the binary vectors CODE.
     Universal codes like fibonacci codes Have a useful synchronization
     property, only for 255 maximum value we have designed these
     routines. We assume user has partitioned the code into several
     unique segments based on the suffix property of unique strings
     "11" and we just decode the parts. Partitioning the stream is as
     simple as identifying the "11" pairs that occur, at the
     terminating ends. This system implements the standard binaary
     Fibonacci codes, which means that row vectors can only contain 0
     or 1. Ref: `http://en.wikipedia.org/wiki/Fibonacci_coding'

              fibodeco({[0 1 0 0 1 1]}) %decoded to 10
              fibodeco({[1 1],[0 1 1],[0 0 1 1],[1 0 1 1]}) %[1:4]

   See also: fiboenco




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Returns the decoded fibonacci value from the binary vectors CODE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fiboenco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1121
 -- Function File:  fiboenco (NUM)
     Returns the cell-array of encoded fibonacci value from the column
     vectors NUM.  Universal codes like fibonacci codes have a useful
     synchronization property, only for 255 maximum value we have
     designed these routines. We assume user has partitioned the code
     into several unique segments based on the suffix property of
     unique elements [1 1] and we just decode the parts. Partitioning
     the stream is as simple as identifying the [1 1] pairs that occur,
     at the terminating ends. This system implements the standard
     binaary Fibonacci codes, which means that row vectors can only
     contain 0 or 1. Ref: http://en.wikipedia.org/wiki/Fibonacci_coding
     Ugly O(k.N^2) encoder.Ref: Wikipedia article accessed March, 2006.
     `http://en.wikipedia.org/wiki/Fibonacci_coding',  UCI Data
     Compression Book, `http://www.ics.uci.edu/~dan/pubs/DC-Sec3.html',
     (accessed October 2006)

               fiboenco(10) #=  code is {[ 0 1 0 0 1 1]}
               fiboenco(1:4) #= code is {[1 1],[0 1 1],[0 0 1 1],[1 0 1 1]}

   See also: fibodeco




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Returns the cell-array of encoded fibonacci value from the column
vectors NUM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
fibosplitstream


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 727
 -- Function File:   fibosplitstream (CODE)
     Returns the split data stream at the word boundaries.  Assuming
     the stream was originally encoded using `fiboenco' and this
     routine splits the stream at the points where '11' occur together
     & gives us the code-words which can later be decoded from the
     `fibodeco' This however doesnt mean that we intend to verify if
     all the codewords are correct, and infact the last symbol in th
     return list can or can-not be a valid codeword.

     A example use of `fibosplitstream' would be

          fibodeco(fibosplitstream([fiboenco(randint(1,100,[0 255])){:}]))
          fibodeco(fibosplitstream([fiboenco(1:10){:}]))

     See also: fiboenco, fibodeco





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Returns the split data stream at the word boundaries.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fmdemod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 192
 -- Function File: fmdemod (X,FC,FS)
     Create the FM demodulation of the signal x with carrier frequency
     fs. Where x is sample at frequency fs.

     See also: ammod, amdemod, fmmod





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Create the FM demodulation of the signal x with carrier frequency fs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fmmod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 190
 -- Function File: fmmod (X,FC,FS)
     Create the FM modulation of the signal x with carrier frequency
     fs. Where x is sample at frequency fs.

     See also: ammod, fmdemod, amdemod





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Create the FM modulation of the signal x with carrier frequency fs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gen2par


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 436
 -- Function File: PAR = gen2par (GEN)
 -- Function File: GEN = gen2par (PAR)
     Converts binary generator matrix GEN to the parity chack matrix
     PAR and visa-versa. The input matrix must be in standard form.
     That is a generator matrix must be k-by-n and in the form [eye(k)
     P] or [P eye(k)], and the parity matrix must be (n-k)-by-n and of
     the form [eye(n-k) P'] or [P' eye(n-k)].


   See also: cyclgen, hammgen




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Converts binary generator matrix GEN to the parity chack matrix PAR and
visa-ver



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
genqamdemod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 158
 -- Function File: [Z] = genqamdemod(Y,CONST)
     	Compute the general quadrature amplitude demodulation of y.

     See also: genqammod, qammod, qamdemod





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
	Compute the general quadrature amplitude demodulation of y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
genqammod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 556
 -- Function File: Y = genqammod (X, C)
     Modulates an information sequence of intergers X in the range `[0
     ... M-1]' onto a quadrature amplitude modulated signal Y, where
     `M = length(c) - 1' and C is a 1D vector specifing the signal
     constellation mapping to be used. An example of combined 4PAM-4PSK
     is

           d = randint(1,1e4,8);
           c = [1+j -1+j -1-j 1-j 1+sqrt(3) j*(1+sqrt(3)) -1-sqrt(3) -j*(1+sqrt(3))];
           y = genqammod(d,c);
           z = awgn(y,20);
           plot(z,'rx')

   See also: genqamdemod




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Modulates an information sequence of intergers X in the range `[0 .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gftable


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 265
 -- Function File:  gftable (M, PRIMPOLY)
     This function exists for compatiability with matlab. As the octave
     galois fields store a copy of the lookup tables for every field in
     use internally, there is no need to use this function.


   See also: gf




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
This function exists for compatiability with matlab.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
gfweight


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 820
 -- Function File: W =  gfweight (GEN)
 -- Function File: W =  gfweight (GEN,'gen')
 -- Function File: W =  gfweight (PAR,'par')
 -- Function File: W =  gfweight (P,n)
     Calculate the minimum weight or distance of a linear block code.
     The code can be either defined by its generator or parity check
     matrix, or its generator polynomial. By default if the first
     argument is a matrix, it is assumed to be the generator matrix of
     the code. The type of the matrix can be defined by a flag 'gen'
     for the generator matrix or 'par' for the parity check matrix.

     If the first argument is a vector, it is assumed that it defines
     the generator polynomial of the code. In this case a second
     argument is required that defines the codeword length.


   See also: hammgen, cyclpoly, bchpoly




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Calculate the minimum weight or distance of a linear block code.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
golombdeco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 931
 -- Function File:  golombdeco (CODE, M)
     Returns the Golomb decoded signal vector using CODE and M.
     Compulsory m is need to be specified. A restrictions is that a
     signal set must strictly be non-negative. The value of code is a
     cell array of row-vectors which have the  encoded golomb value for
     a single sample. The Golomb algorithm is,  used to encode the
     'code' and only that can be meaningfully decoded. CODE is assumed
     to have been of format generated by the function `golombenco'.
     Also the parameter M need to be a non-zero number, unless which it
     makes divide-by-zero errors.  This function works backward the
     Golomb algorithm see `golombenco' for more detials on that.
     Reference: Solomon Golomb, Run length Encodings, 1966 IEEE Trans
     Info' Theory

     An exmaple of the use of `golombdeco' is
            golombdeco(golombenco(1:4,2),2)

   See also: golombenco




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Returns the Golomb decoded signal vector using CODE and M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
golombenco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1615
 -- Function File:  golombenco (SIG, M)
     Returns the Golomb coded signal as cell array.  Also  total length
     of output code in bits can be obtained.  This function uses a M
     need to be supplied for encoding signal vector into a golomb coded
     vector. A restrictions is that a signal set must strictly be
     non-negative.  Also the parameter M need to be a non-zero number,
     unless which it makes divide-by-zero errors.  The Golomb algorithm
     [1], is used to encode the data into unary coded quotient part
     which is represented as a set of 1's separated from the K-part
     (binary) using a zero. This scheme doesnt need any kind of
     dictionaries, it is a parameterized prefix codes.  Implementation
     is close to O(N^2), but this implementation *may be* sluggish,
     though correct.  Details of the scheme are, to encode the
     remainder(r of number N) using the floor(log2(m)) bits when rem is
     in range 0:(2^ceil(log2(m)) - N), and encode it as
     r+(2^ceil(log2(m)) - N), using total of 2^ceil(log2(m)) bits in
     other instance it doesnt belong to case 1. Quotient is coded
     simply just using the unary code. Also accroding to [2] Golomb
     codes are optimal for sequences using the bernoulli probability
     model: P(n)=p^n-1.q & p+q=1, and when M=[1/log2(p)], or P=2^(1/M).

     Reference: 1. Solomon Golomb, Run length Encodings, 1966 IEEE Trans
     Info' Theory. 2. Khalid Sayood, Data Compression, 3rd Edition

     An exmaple of the use of `golombenco' is
            golombenco(1:4,2) #
            golombenco(1:10,2) #

   See also: golombdeco




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Returns the Golomb coded signal as cell array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hammgen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 784
 -- Function File: H =  hammgen (M)
 -- Function File: H =  hammgen (M,P)
 -- Function File: [H,G] =  hammgen (...)
 -- Function File: [H,G,N,K] =  hammgen (...)
     Produce the parity check and generator matrices of a Hamming code.
     The variable M defines the [N,K] Hamming code where `N = 2 ^ M -
     1' and `K = N - M'.  M must be between 3 and 16.

     The parity check matrix is generated relative to the primitive
     polynomial of GF(2^M). If P is specified the default primitive
     polynomial of GF(2^M) is overridden. P must be a valid primitive
     polynomial of the correct order for GF(2^M).

     The parity check matrix is returned in the M by N matrix H, and if
     requested the generator matrix is returned in the K by N matrix G.


   See also: gen2par




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Produce the parity check and generator matrices of a Hamming code.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
helintrlv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
 -- Function File: OUTDATA = helintrlv (DATA, COL, NGRP,STP)
     COL-by-NGRP.

     See also: heldeintrlv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
COL-by-NGRP.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
helscandeintrlv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- Function File: OUTDATA = helscandeintrlv (DATA, NROWS, NCOLS,NSHIFT)
     NROWS-by-NCOLS.

     See also: helscandeintrlv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
NROWS-by-NCOLS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
helscanintrlv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
 -- Function File: OUTDATA = helscanintrlv (DATA, NROWS, NCOLS,NSHIFT)
     NROWS-by-NCOLS.

     See also: helscandeintrlv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
NROWS-by-NCOLS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
huffmandeco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 893
 -- Function File: SIG = huffmandeco (HCODE, DICT)
     Decode signal encoded by `huffmanenco'.

     This function uses a dict built from the `huffmandict' and uses it
     to decode a signal list into a huffman list. A restriction is that
     HCODE is expected to be a binary code

     The returned SIG set that strictly belongs in the range `[1,N]'
     with `N = length(DICT)'. Also DICT can only be from the
     `huffmandict' routine. Whenever decoding fails, those signal
     values a re indicated by `-1', and we successively try to restart
     decoding from the next bit that hasn't failed in decoding,
     ad-infinitum. An example of the use of `huffmandeco' is:

          hd    = huffmandict (1:4, [0.5 0.25 0.15 0.10]);
          hcode = huffmanenco (1:4, hd);
          back  = huffmandeco (hcode, hd)
                => [1 2 3 4]

     See also: huffmandict, huffmanenco





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Decode signal encoded by `huffmanenco'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
huffmandict


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1497
 -- Function File:  huffmandict (SYMB, PROB)
 -- Function File:  huffmandict (SYMB, PROB, TOGGLE)
 -- Function File:  huffmandict (SYMB, PROB, TOGGLE, MINVAR)
     Builds a Huffman code, given a probability list. The Huffman codes
     per symbol are output as a list of strings-per-source symbol. A
     zero probability symbol is NOT assigned any codeword as this
     symbol doesn't occur in practice anyway.

     TOGGLE is an optional argument with values 1 or 0, that starts
     building a code based on 1's or 0's, defaulting to 0. Also MINVAR
     is a boolean value that is useful in choosing if you want to
     optimize buffer for transmission in the applications of Huffman
     coding, however it doesn't affect the type or average codeword
     length of the generated code. An example of the use of
     `huffmandict' is

            huffmandict(symbols, [0.5 0.25 0.15 0.1]) => CW(0,10,111,110)
            huffmandict(symbols, 0.25*ones(1,4)) => CW(11,10,01,00)

            prob=[0.5 0 0.25 0.15 0.1]
            dict=huffmandict(1:5,[0.5 0 0.25 0.15 0.1],1)
            entropy(prob)
            laverage(dict,prob)

            x =   [0.20000   0.40000   0.20000   0.10000   0.10000];
            #illustrates the minimum variance thing.
            huffmandict(1,x,0,true) #min variance tree.
            huffmandict(1,x)     #normal huffman tree.

     Reference: Dr.Rao's course EE5351 Digital Video Coding, at
     UT-Arlington.

     See also: huffmandeco, huffmanenco





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Builds a Huffman code, given a probability list.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
huffmanenco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 605
 -- Function File:  huffmanenco (SIG, DICT)
     Returns the Huffman encoded signal using DICT. This function uses
     a DICT built from the `huffmandict' and uses it to encode a signal
     list into a huffman list. A restrictions is that a signal set must
     strictly belong in the range `[1,N]' with `N = length(dict)'.
     Also DICT can only be from the `huffmandict' routine.  An exmaple
     of the use of `huffmanenco' is

          hd = huffmandict (1:4, [0.5 0.25 0.15 0.10]);
          huffmanenco (1:4, hd);
                => [1 0 1 0 0 0 0 0 1]

     See also: huffmandict, huffmandeco





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Returns the Huffman encoded signal using DICT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
intrlv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 137
 -- Function File: INTRLVD = intrlv (DATA, ELEMENTS)
     Interleaved elements of DATA according to ELEMENTS.

     See also: deintrlv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Interleaved elements of DATA according to ELEMENTS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
lloyds


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1895
 -- Function File: [TABLE, CODES] =  lloyds (SIG,INIT_CODES)
 -- Function File: [TABLE, CODES] =  lloyds (SIG,LEN)
 -- Function File: [TABLE, CODES] =  lloyds (SIG,...,TOL)
 -- Function File: [TABLE, CODES] =  lloyds (SIG,...,TOL,TYPE)
 -- Function File: [TABLE, CODES, DIST] =  lloyds (...)
 -- Function File: [TABLE, CODES, DIST, RELDIST] =  lloyds (...)
     Optimize the quantization table and codes to reduce distortion.
     This is based on the article by Lloyd

     S. Lloyd _Least squared quantization in PCM_, IEEE Trans Inform
     Thoery, Mar 1982, no 2, p129-137

     which describes an iterative technique to reduce the quantization
     error by making the intervals of the table such that each interval
     has the same area under the PDF of the training signal SIG. The
     initial codes to try can either be given in the vector INIT_CODES
     or as scalar LEN. In the case of a scalar the initial codes will
     be an equi-spaced vector of length LEN between the minimum and
     maximum value of the training signal.

     The stopping criteria of the iterative algorithm is given by

          abs(DIST(n) - DIST(n-1)) < max(TOL, abs(EPS*max(SIG))

     By default TOL is 1.e-7. The final input argument determines how
     the updated table is created. By default the centroid of the
     values of the training signal that fall within the interval
     described by CODES are used to update TABLE. If TYPE is any other
     string than "centroid", this behaviour is overriden and TABLE is
     updated as follows.

          TABLE = (CODE(2:length(CODE)) + CODE(1:length(CODE-1))) / 2

     The optimized values are returned as TABLE and CODE. In addition
     the distortion of the the optimized codes representing the
     training signal is returned as DIST. The relative distortion in
     the final iteration is also returned as RELDIST.


   See also: quantiz




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Optimize the quantization table and codes to reduce distortion.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
lz77deco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 347
 -- Function File: M = lz77deco (C, ALPH, LA, N)
     Lempel-Ziv 77 source algorithm decoding implementation. Where

    M
          message decoded (1xN).

    C
          encoded message (Mx3).

    ALPH
          size of alphabet.

    LA
          lookahead buffer size.

    N
          sliding window buffer size.

     See also: lz77enco





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Lempel-Ziv 77 source algorithm decoding implementation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
lz77enco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 298
 -- Function File: C = lz77enco (M, ALPH, LA, N)
     Lempel-Ziv 77 source algorithm implementation. Where

    C
          encoded message (Mx3).

    ALPH
          size of alphabet.

    LA
          lookahead buffer size.

    N
          sliding window buffer size.

     See also: lz77deco





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Lempel-Ziv 77 source algorithm implementation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
matdeintrlv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 171
 -- Function File: INTRLVD = matdeintrlv (DATA, NROWS, NCOLS)
     Restore elements of DATA with a tempory matrix of size
     NROWS-by-NCOLS.

     See also: matintrlv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Restore elements of DATA with a tempory matrix of size NROWS-by-NCOLS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
matintrlv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 175
 -- Function File: INTRLVD = matintrlv (DATA, NROWS, NCOLS)
     Interleaved elements of DATA with a tempory matrix of size
     NROWS-by-NCOLS.

     See also: matdeintrlv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Interleaved elements of DATA with a tempory matrix of size
NROWS-by-NCOLS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
minpol


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 262
 -- Function File:  minpol (V)
     Finds the minimum polynomial for elements of a Galois Field. For  a
     vector V with N components, representing N values in a Galois
     Field GF(2^M), return the minimum polynomial in GF(2) representing
     thos values.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Finds the minimum polynomial for elements of a Galois Field.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
modmap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2594
 -- Function File:  modmap (METHOD,...)
 -- Function File: y =  modmap (X,FD,FS,'ask',M)
 -- Function File: y =  modmap (X,FD,FS,'fsk',M,TONE)
 -- Function File: y =  modmap (X,FD,FS,'msk')
 -- Function File: y =  modmap (X,FD,FS,'psk',M)
 -- Function File: y =  modmap (X,FD,FS,'qask',M)
 -- Function File: y =  modmap (X,FD,FS,'qask/cir',NSIG,AMP,PHS)
 -- Function File: y =  modmap (X,FD,FS,'qask/arb',INPHASE,QUADR)
 -- Function File: y =  modmap (X,FD,FS,'qask/arb',MAP)
     Mapping of a digital signal to an analog signal. With no output
     arguments "modmap" plots the constellation of the mapping. In this
     case the first argument must be the string METHOD defining one of
     'ask', 'fsk', 'msk', 'qask', 'qask/cir' or 'qask/arb'. The
     arguments following the string METHOD are generally the same as
     those after the corresponding string in the fucntion call without
     output arguments.  The exception is `modmap('msk',FD)'.

     With an output argument, Y is the complex mapped analog signal. In
     this case the arguments X, FD and FS are required. The variable X
     is the digital signal to be mapped, FD is the sampling rate of the
     of digital signal and the FS is the sampling rate of the analog
     signal. It is required that `FS/FD' is an integer.

     The available mapping of the digital signal are

    'ask'
          Amplitude shift keying

    'fsk'
          Frequency shift keying

    'msk'
          Minimum shift keying

    'psk'
          Phase shift keying

    'qask'
    'qsk'
    'qam'
          Quadraure amplitude shift keying

     In addition the 'qask', 'qsk' and 'qam' method can be modified
     with the flags '/cir' or '/arb'. That is 'qask/cir' and
     'qask/arb', etc are valid methods and give circular- and
     arbitrary-qask mappings respectively.

     The additional argument M is the order of the modulation to use.
     M must be larger than the largest element of X. The variable TONE
     is the FSK tone to use in the modulation.

     For 'qask/cir', the additional arguments are the same as for
     "apkconst", and you are referred to "apkconst" for the definitions
     of the additional variables.

     For 'qask/arb', the additional arguments INPHASE and QUADR give
     the in-phase and quadrature components of the mapping, in a
     similar mapping to the outputs of "qaskenco" with one argument.
     Similar MAP represents the in-phase and quadrature components of
     the mapping as the real and imaginary parts of the variable MAP.

   See also: demodmap, dmodce, amodce, apkconst, qaskenco




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Mapping of a digital signal to an analog signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
oct2dec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 192
 -- Function File: D = oct2dec (C)
     Convert octal to decimal values.

     Each element of the octal matrix C is converted to a decimal value.

     See also: base2dec, bin2dec, dec2bin





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Convert octal to decimal values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
pamdemod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 717
 -- Function File: Y =  pamdemod (X, M)
 -- Function File: Y =  pamdemod (X, M, PHI)
 -- Function File: Y =  pamdemod (X, M, PHI, TYPE)
     Demodulates a pulse amplitude modulated signal X into an
     information sequence of integers in the range `[0 ... M-1]'.  PHI
     controls the initial phase and TYPE controls the constellation
     mapping. If TYPE is set to 'Bin' will result in binary encoding,
     in contrast, if set to 'Gray' will give Gray encoding.  An example
     of Gray-encoded 8-PAM is

          d = randint(1,1e4,8);
          y = pammod(d,8,0,'Gray');
          z = awgn(y,20);
          d_est = pamdemod(z,8,0,'Gray');
          plot(z,'rx')
          biterr(d,d_est)

   See also: pammod




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Demodulates a pulse amplitude modulated signal X into an information
sequence of



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
pammod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 645
 -- Function File: Y =  pammod (X, M)
 -- Function File: Y =  pammod (X, M, PHI)
 -- Function File: Y =  pammod (X, M, PHI, TYPE)
     Modulates an information sequence of integers X in the range `[0
     ... M-1]' onto a pulse amplitude modulated signal Y.  PHI controls
     the initial phase and TYPE controls the constellation mapping. If
     TYPE is set to 'Bin' will result in binary encoding, in contrast,
     if set to 'Gray' will give Gray encoding.  An example of
     Gray-encoded 8-PAM is

          d = randint(1,1e4,8);
          y = pammod(d,8,0,'Gray');
          z = awgn(y,20);
          plot(z,'rx')

   See also: pamdemod




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Modulates an information sequence of integers X in the range `[0 .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
prbs_generator


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1534
 Implement book keeping for a Pseudo-Random Binary Sequence ( PRBS )
 also called as a Linear Feedback Shift Register.
 
 Given a polynomial create a PRBS structure for that polynomial.
 Now all we need is to just create this polynomial and make it work.
 polynomial must be a vector containing the powers of x and an optional
 value 1. eg: x^3 + x^2 + x + 1 must be written as [3 2 1 0]
 all the coefficients are either 1 or 0. It generates only a Binary \
 sequence, and the generator polynomial need to be only a binary
 polynomial in GF(2).
 
 connections, contains a struct of vectors where each vector is the
 connection list mapping its vec(2:end) elements to the vec(1) output.
 
 Example: If you had a PRBS shift register like the diagram
 below with 4 registers we use representation by polynomial
 of [ 1 2 3 4], and feedback connections between [ 1 3 4 ].
 The output PRBS sequence is taken from the position 4.
 
  +---+    +----+   +---+   +---+
  | D |----| D  |---| D |---| D |
  +---+    +----+   +---+   +---+
    |                 |       |
    \                 /      /
    [+]---------------+------+
   1   +    0.D   + 1.D^2 + 1.D^3
 
 The code to implement this PRBS with a start state of [1 0 1 1]
 will be:
 
 prbs=prbs_generator([1 3 4],{[1 3 4]},[1 0 1 1]);
 x = prbs_sequence(prbs) #gives 15
 
 prbs_iterator( prbs, 15 ) #15 binary digits seen
 [ 1   1   0   1   0   1   1   1   1   0   0   0   1   0   0 ]
 
 See Also: This function is to be used along with functions 
 prbs_iterator, and prbs_sequence.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 Implement book keeping for a Pseudo-Random Binary Sequence ( PRBS )
 also calle



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
prbs_iterator


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1172
 This function generates the output bits from the PRBS
 state, for the number of iterations specified.

 First argument is the PRBS structure obtained from prbs_generator.
 PRBS iterations is specified in the second argument.
 PRBS start state is taken from the prbs.sregs.

 Second argument of the output is PRBS structure with a new
 state. This allows usage like: 
 
 [ seq, prbs ] =  prbs_iterator( prbs, niterations );
 
 while the state of the PRBS is updated.
 
 Example: If you had a PRBS shift register like the diagram
 below with 4 registers we use representation by polynomial
 of [ 1 2 3 4], and feedback connections between [ 1 3 4 ].
 The output PRBS sequence is taken from the position 4.
 
  +---+    +----+   +---+   +---+
  | D |----| D  |---| D |---| D |
  +---+    +----+   +---+   +---+
    |                 |       |
    \                 /      /
    [+]---------------+------+
   1   +    0.D   + 1.D^2 + 1.D^3

 The code to implement this PRBS will be 
 prbs=prbs_generator([1 3 4],{[1 3 4]},[1 0 1 1]);
 x = prbs_iterator(prbs,15)
 
 See Also: This function is to be used along with functions 
 prbs_iterator, prbs_generator and prbs_sequence.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 This function generates the output bits from the PRBS
 state, for the number of



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
prbs_sequence


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 960
 Implement book keeping for a Pseudo-Random Binary Sequence ( PRBS )
 also called as a Linear Feedback Shift Register.
 
 For the given PRBS in a intial state, compute the PRBS sequence length.
 Length is period of output when the PRBS state is same as 
 the start state of PRBS.
 
 Example: If you had a PRBS shift register like the diagram
 below with 4 registers we use representation by polynomial
 of [ 1 2 3 4], and feedback connections between [ 1 3 4 ].
 The output PRBS sequence is taken from the position 4.
 
  +---+    +----+   +---+   +---+
  | D |----| D  |---| D |---| D |
  +---+    +----+   +---+   +---+
    |                 |       |
    \                 /      /
    [+]---------------+------+
   1   +    0.D   + 1.D^2 + 1.D^3

 The code to implement this PRBS will be 
 prbs=prbs_generator([1 3 4],{[1 3 4]},[1 0 1 1]);
 x = prbs_sequence(prbs) #gives 15
 

 See Also: This function is to be used along with functions 
 prbs_generator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 Implement book keeping for a Pseudo-Random Binary Sequence ( PRBS )
 also calle



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
pskdemod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 734
 -- Function File: Y =  pamdemod (X, M)
 -- Function File: Y =  pamdemod (X, M, PHI)
 -- Function File: Y =  pamdemod (X, M, PHI, TYPE)
     Demodulates a complex-baseband phase shift keying modulated signal
     into an information sequence of integers in the range `[0 ...
     M-1]'. PHI controls the initial phase and TYPE controls the
     constellation mapping. If TYPE is set to 'Bin' will result in
     binary encoding, in contrast, if set to 'Gray' will give Gray
     encoding.  An example of Gray-encoded 8-PSK is

          d = randint(1,1e3,8);
          y = pskmod(d,8,0,'Gray');
          z = awgn(y,20);
          d_est = pskdemod(z,8,0,'Gray');
          plot(z,'rx')
          biterr(d,d_est)

   See also: pskmod




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Demodulates a complex-baseband phase shift keying modulated signal into
an infor



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
pskmod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 662
 -- Function File: Y =  pskmod (X, M)
 -- Function File: Y =  pskmod (X, M, PHI)
 -- Function File: Y =  pskmod (X, M, PHI, TYPE)
     Modulates an information sequence of integers X in the range `[0
     ... M-1]' onto a complex baseband phase shift keying modulated
     signal Y. PHI controls the initial phase and TYPE controls the
     constellation mapping. If TYPE is set to 'Bin' will result in
     binary encoding, in contrast, if set to 'Gray' will give Gray
     encoding. An example of Gray-encoded QPSK is

          d = randint(1,5e3,4);
          y = pskmod(d,4,0,'Gray');
          z = awgn(y,30);
          plot(z,'rx')

   See also: pskdemod




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Modulates an information sequence of integers X in the range `[0 .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qamdemod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 142
 -- Function File: qamdemod (X,M)
     Create the QAM demodulation of x with a size of alphabet m.

     See also: qammod, pskmod, pskdemod





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Create the QAM demodulation of x with a size of alphabet m.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
qammod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
 -- Function File: qammod (X,M)
     Create the QAM modulation of x with a size of alphabet m.

     See also: qamdemod, pskmod, pskdemod





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Create the QAM modulation of x with a size of alphabet m.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qaskdeco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1177
 -- Function File: MSG = qaskdeco (C,M)
 -- Function File: MSG = qaskdeco (INPHASE,QUADR,M)
 -- Function File: MSG = qaskdeco (...,MNMX)
     Demaps an analog signal using a square QASK constellation. The
     input signal maybe either a complex variable C, or as two real
     variables INPHASE and QUADR representing the in-phase and
     quadrature components of the signal.

     The argument M must be a positive integer power of 2. By deafult
     the same constellation as created in "qaskenco" is used by
     "qaskdeco".  If is possible to change the values of the minimum
     and maximum of the in-phase and quadrature components of the
     constellation to account for linear changes in the signal values
     in the received signal. The variable MNMX is a 2-by-2 matrix of
     the following form

              |   min in-phase      ,   max in-phase      |
              |   min quadrature    ,   max quadrature    |

     If `sqrt(M)' is an integer, then "qaskenco" uses a Gray mapping.
     Otherwise, an attempt is made to create a nearly square mapping
     with a minimum Hamming distance between adjacent constellation
     points.

   See also: qaskenco




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Demaps an analog signal using a square QASK constellation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qaskenco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1685
 -- Function File:  qaskenco (M)
 -- Function File:  qaskenco (MSG,M)
 -- Function File: Y =  qaskenco (...)
 -- Function File: [INPHASE, QUADR] = qaskenco (...)
     Map a digital signal using a square QASK constellation. The
     argument M must be a positive integer power of 2. With two input
     arguments the variable MSG represents the message to be encoded.
     The values of MSG must be between 0 and `M-1'. In all cases
     `qaskenco(M)' is equivalent to `qaskenco(1:M,M)'

     Three types of outputs can be created depending on the number of
     output arguments. That is

    No output arguments
          In this case "qaskenco" plots the constellation. Only the
          points in MSG are plotted, which in the case of a single input
          argument is all constellation points.

    A single output argument
          The returned variable is a complex variable representing the
          in-phase and quadrature components of the mapped  message
          MSG. With, a single input argument this effectively gives the
          mapping from symbols to constellation points

    Two output arguments
          This is the same as two ouput arguments, expect that the
          in-phase and quadrature components are returned explicitly.
          That is

               octave> c = qaskenco(msg, m);
               octave> [a, b] = qaskenco(msg, m);
               octave> all(c == a + 1i*b)
               ans = 1

     If `sqrt(M)' is an integer, then "qaskenco" uses a Gray mapping.
     Otherwise, an attempt is made to create a nearly square mapping
     with a minimum Hamming distance between adjacent constellation
     points.

   See also: qaskdeco




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Map a digital signal using a square QASK constellation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
qfunc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
 -- Function File: [Y] = qfunc (X)
     Compute the Q function.

     See also: erfc, erf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Compute the Q function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qfuncinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
 -- Function File: [Y] = qfuncinv (X)
     Compute the inverse Q function.

     See also: erfc, erf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Compute the inverse Q function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
quantiz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 813
 -- Function File: QIDX =  quantiz (X, TABLE)
 -- Function File: [QIDX, Q] =  quantiz (X, TABLE, CODES)
 -- Function File: [ QIDX, Q, D] =  quantiz (...)
     Quantization of an arbitrary signal relative to a paritioning.

    `qidx = quantiz(x, table)'
          Determine position of x in strictly monotonic table.  The
          first   interval, using index 0, corresponds to x <= table(1).
           Subsequent intervals are table(i-1) < x <= table(i).

    `[qidx, q] = quantiz(x, table, codes)'
          Associate each interval of the table with a code.  Use
          codes(1)   for x <= table(1) and codes(n+1) for table(n) < x
          <= table(n+1).

    `[qidx, q, d] = quantiz(...)'
          Compute distortion as mean squared distance of x from the
          corresponding quantization values.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Quantization of an arbitrary signal relative to a paritioning.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
randdeintrlv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 160
 -- Function File: INTRLVD = randdeintrlv (DATA, STATE)
     Restore elements of DATA with a random permutation.

     See also: randintrlv, intrlv, deintrlv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Restore elements of DATA with a random permutation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
randerr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 987
 -- Function File: B =  randerr (N)
 -- Function File: B =  randerr (N,M)
 -- Function File: B =  randerr (N,M,ERR)
 -- Function File: B =  randerr (N,M,ERR,SEED)
     Generate a matrix of random bit errors. The size of the matrix is
     N rows by M columns. By default M is equal to N.  Bit errors in
     the matrix are indicated by a 1.

     The variable ERR determines the number of errors per row. By
     default the return matrix B has exactly one bit error per row.  If
     ERR is a scalar, there each row of B has exactly this number of
     errors per row. If ERR is a vector then each row has a number of
     errors that is in this vector. Each number of errors has an equal
     probability. If ERR is a matrix with two rows, then the first row
     determines the number of errors and the second their probabilities.

     The variable SEED allows the random number generator to be seeded
     with a fixed value. The initial seed will be restored when
     returning.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Generate a matrix of random bit errors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
randint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 800
 -- Function File: B =  randint (N)
 -- Function File: B =  randint (N,M)
 -- Function File: B =  randint (N,M,RANGE)
 -- Function File: B =  randint (N,M,RANGE,SEED)
     Generate a matrix of random binary numbers. The size of the matrix
     is N rows by M columns. By default M is equal to N.

     The range in which the integers are generated will is determined by
     the variable RANGE. If RANGE is an integer, the value will lie in
     the range [0,RANGE-1], or [RANGE+1,0] if RANGE is negative. If
     RANGE contains two elements the intgers will lie within these two
     elements, inclusive. By default RANGE is assumed to be [0:1].

     The variable SEED allows the random number generator to be seeded
     with a fixed value. The initial seed will be restored when
     returning.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Generate a matrix of random binary numbers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
randintrlv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
 -- Function File: INTRLVD = randintrlv (DATA, STATE)
     Interleaves elements of DATA with a random permutation.

     See also: intrlv, deintrlv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Interleaves elements of DATA with a random permutation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
randsrc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 845
 -- Function File: B =  randsrc (N)
 -- Function File: B =  randsrc (N,M)
 -- Function File: B =  randsrc (N,M,ALPHABET)
 -- Function File: B =  randsrc (N,M,ALPHABET,SEED)
     Generate a matrix of random symbols. The size of the matrix is N
     rows by M columns. By default M is equal to N.

     The variable ALPHABET can be either a row vector or a matrix with
     two rows. When ALPHABET is a row vector the symbols returned in B
     are chosen with equal probability from ALPHABET. When ALPHABET has
     two rows, the second row determines the probabilty with which each
     of the symbols is chosen. The sum of the probabilities must equal
     1. By default ALPHABET is [-1 1].

     The variable SEED allows the random number generator to be seeded
     with a fixed value. The initial seed will be restored when
     returning.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Generate a matrix of random symbols.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
reedmullerdec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1165
 -- Function File:  reedmullerdec (VV,G,R,M)
     Decode the received code word VV using  the RM-generator matrix G,
     of order R, M, returning the code-word C. We use the standard
     majority logic vote method due to Irving S. Reed. The received
     word has to be a matrix of column size equal to to code-word size
     (i.e 2^m). Each row is treated as a separate received word.

     The second return value is the message M got from C.

     G is obtained from definition type construction of Reed Muller
     code, of order R, length 2^M. Use the function reedmullergen, for
     the generator matrix for the (R,M) order RM code.

     Faster code constructions (also easier) exist, but since finding
     permutation order of the basis vectors, is important, we stick
     with the standard definitions. To use decoder function
     reedmullerdec,  you need to use this specific generator function.

     see: Lin & Costello, Ch.4, "Error Control Coding", 2nd Ed, Pearson.

          G=reedmullergen(2,4);
          M=[rand(1,11)>0.5];
          C=mod(M*G,2);
          [dec_C,dec_M]=reedmullerdec(C,G,2,4)


   See also: reedmullergen, reedmullerenc




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Decode the received code word VV using  the RM-generator matrix G, of
order R, M



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
reedmullerenc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 581
 -- Function File:  reedmullerenc (MSG,R,M)
     Definition type construction of Reed Muller code, of order R,
     length 2^M. This function returns the generator matrix for the
     said order RM code.

     Encodes the given message word/block, of column size k,
     corresponding to the RM(R,M), and outputs a code matrix C, on each
     row with corresponding codeword.  The second return value is the
     G, which is generator matrix used for this code.

          MSG=[rand(10,11)>0.5];
          [C,G]=reedmullerenc(MSG,2,4);


   See also: reedmullerdec, reedmullergen




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Definition type construction of Reed Muller code, of order R, length
2^M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
reedmullergen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 848
 -- Function File:  reedmullergen (R,M)
     Definition type construction of Reed Muller code, of order R,
     length 2^M. This function returns the generator matrix for the
     said order RM code.

     RM(r,m) codes are characterized by codewords, `sum ( (m,0) + (m,1)
     + ... + (m,r)'.  Each of the codeword is got through spanning the
     space, using the finite set of m-basis codewords.  Each codeword
     is 2^M elements long.  see: Lin & Costello, "Error Control
     Coding", 2nd Ed.

     Faster code constructions (also easier) exist, but since finding
     permutation order of the basis vectors, is important, we stick
     with the standard definitions. To use decoder function
     reedmullerdec,  you need to use this specific generator function.

          G=reedmullergen(2,4);


   See also: reedmullerdec, reedmullerenc




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Definition type construction of Reed Muller code, of order R, length
2^M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ricedeco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 708
 -- Function File:  ricedeco (CODE, K)
     Returns the Rice decoded signal vector using CODE and K.
     Compulsory K is need to be specified.  A restrictions is that a
     signal set must strictly be non-negative.  The value of code is a
     cell array of row-vectors which have the encoded rice value for a
     single sample. The Rice algorithm is  used to encode the 'code'
     and only that can be meaningfully decoded. CODE is assumed to have
     been of format generated by the function `riceenco'.

     Reference: Solomon Golomb, Run length Encodings, 1966 IEEE Trans
     Info' Theory

     An exmaple of the use of `ricedeco' is
            ricedec(riceenco(1:4,2),2)

   See also: riceenco




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Returns the Rice decoded signal vector using CODE and K.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
riceenco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1101
 -- Function File:  riceenco (SIG, K)
     Returns the Rice encoded signal using K or optimal K .  Default
     optimal K is chosen between 0-7. Currently no other way to
     increase the range except to specify explicitly. Also returns K
     parameter used (in case it were to be chosen optimally) and LTOT
     the total length of output code in bits.  This function uses a K
     if supplied or by default chooses the optimal K for encoding
     signal vector into a rice coded vector.  A restrictions is that a
     signal set must strictly be non-negative.  The Rice algorithm is
     used to encode the data into unary coded quotient part which is
     represented as a set of 1's separated from the K-part (binary)
     using a zero. This scheme doesnt need any kind of dictionaries and
     its close to O(N), but this implementation *may be* sluggish,
     though correct.

     Reference: Solomon Golomb, Run length Encodings, 1966 IEEE Trans
     Info' Theory

     An exmaple of the use of `riceenco' is
            riceenco(1:4) #
            riceenco(1:10,2) #

   See also: ricedeco




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Returns the Rice encoded signal using K or optimal K .



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rledeco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 422
 -- Function File:  rledeco (MESSAGE)
     Returns decoded run-length MESSAGE.  The RLE encoded MESSAGE has
     to be in the form of a row-vector. The message format (encoded
     RLE) is like  repetition [factor, value]+.

     An example use of `rledeco' is
                   message=[1 5 2 4 3 1];
                   rledeco(message) #gives
                   ans = [    5   4   4   1   1   1]

   See also: rledeco




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Returns decoded run-length MESSAGE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rleenco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 468
 -- Function File:  rleenco (MESSAGE)
     Returns  run-length encoded MESSAGE. The rle form is built from
     MESSAGE. The original MESSAGE has to be in the form of a
     row-vector. The encoded MESSAGE format (encoded RLE) is like
     [repetition factor]+, values.

     An example use of `rleenco' is
                   message=[    5   4   4   1   1   1]
                   rleenco(message) #gives
                   ans = [1 5 2 4 3 1];

   See also: rleenco




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Returns  run-length encoded MESSAGE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rsdecof


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 832
 -- Function File:  rsdecof (IN,OUT)
 -- Function File:  rsdecof (IN,OUT,T)
     Decodes an ascii file using a Reed-Solomon coder. The input file is
     defined by IN and the result is written to the output file OUT.
     The type of coding to use is determined by whether the input file
     is 7- or 8-bit. If the input file is 7-bit, the default coding is
     [127,117].  while the default coding for an 8-bit file is a [255,
     235]. This allows for 5 or 10 error characters in 127 or 255
     symbols to be corrected respectively. The number of errors that
     can be corrected can be overridden by the variable T.

     If the file is not an integer multiple of the message size (127 or
     255) in length, then the file is padded with the EOT (ascii
     character 4) character before decoding.


   See also: rsencof




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Decodes an ascii file using a Reed-Solomon coder.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rsencof


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1070
 -- Function File:  rsencof (IN,OUT)
 -- Function File:  rsencof (IN,OUT,T)
 -- Function File:  rsencof (...,PAD)
     Encodes an ascii file using a Reed-Solomon coder. The input file is
     defined by IN and the result is written to the output file OUT.
     The type of coding to use is determined by whether the input file
     is 7- or 8-bit. If the input file is 7-bit, the default coding is
     [127,117].  while the default coding for an 8-bit file is a [255,
     235]. This allows for 5 or 10 error characters in 127 or 255
     symbols to be corrected respectively. The number of errors that
     can be corrected can be overridden by the variable T.

     If the file is not an integer multiple of the message size (127 or
     255) in length, then the file is padded with the EOT (ascii
     character 4) characters before coding. Whether these characters
     are written to the output is defined by the PAD variable. Valid
     values for PAD are "pad" (the default) and "nopad", which write or
     not the padding respectively.


   See also: rsdecof




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Encodes an ascii file using a Reed-Solomon coder.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
rsgenpoly


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1634
 -- Function File: G =  rsgenpoly (N,K)
 -- Function File: G =  rsgenpoly (N,K,P)
 -- Function File: G =  rsgenpoly (N,K,P,B,S)
 -- Function File: G =  rsgenpoly (N,K,P,B)
 -- Function File: [G, T] =  rsgenpoly (...)
     Creates a generator polynomial for a Reed-Solomon coding with
     message length of K and codelength of N. N must be greater than K
     and their difference must be even. The generator polynomial is
     returned on G as a polynomial over the Galois Field GF(2^M) where
     N is equal to `2^M-1'. If M is not integer the next highest
     integer value is used and a generator for a shorten Reed-Solomon
     code is returned.

     The elements of G represent the coefficients of the polynomial in
     descending order. If the length of G is lg, then the generator
     polynomial is given by

          G(0) * x^(lg-1) + G(1) * x^(lg-2) + ... + G(lg-1) * x + G(lg).

     If P is defined then it is used as the primitive polynomial of the
     the Galois Field GF(2^M). The default primitive polynomial will be
     used if P is equal to [].

     The variables B and S determine the form of the generator
     polynomial in the following manner.

          G = (X - A^(B*S)) * (X - A^((B+1)*S)) * ... * (X - A^((B+2*T-1)*S)).

     where T is `(N-K)/2', and A is the primitive element of the Galois
     Field. Therefore B is the first consecutive root of the generator
     polynomial and S is the primitive element to generate the the
     polynomial roots.

     If requested the variable T, which gives the error correction
     capability of the the Reed-Solomon code

   See also: gf, rsenc, rsdec




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Creates a generator polynomial for a Reed-Solomon coding with message
length of 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
scatterplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1438
 -- Function File:  scatterplot (X)
 -- Function File:  scatterplot (X,N)
 -- Function File:  scatterplot (X,N,OFF)
 -- Function File:  scatterplot (X,N,OFF,STR)
 -- Function File:  scatterplot (X,N,OFF,STR,H)
 -- Function File: H = scatterplot (...)
     Display the scatter plot of a signal. The signal X can be either in
     one of three forms

    A real vector
          In this case the signal is assumed to be real and represented
          by the vector X. The scatterplot is plotted along the x axis
          only.

    A complex vector
          In this case the in-phase and quadrature components of the
          signal are plotted seperately on the x and y axes
          respectively.

    A matrix with two columns
          In this case the first column represents the in-phase and the
          second the quadrature components of a complex signal and are
          plotted on the x and y axes respectively.

     Each point of the scatter plot is assumed to be seperated by N
     elements in the signal. The first element of the signal to plot is
     determined by OFF. By default N is 1 and OFF is 0.

     The string STR is a plot style string (example 'r+'), and by
     default is the default gnuplot point style.

     The figure handle to use can be defined by H. If H is not given,
     then the next available figure handle is used. The figure handle
     used in returned on HOUT.

   See also: eyediagram




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Display the scatter plot of a signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
shannonfanodeco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1012
 -- Function File:  shannonfanodeco (HCODE,DICT)
     Returns the original signal that was Shannonfano encoded. The
     signal was encoded using `shannonfanoenco'. This function uses a
     dict built from the `shannonfanodict' and uses it to decode a
     signal list into a shannonfano list. Restrictions include hcode is
     expected to be a binary code; returned signal set that strictly
     belongs in the `range [1,N]', with `N=length(dict)'. Also dict can
     only be from the `shannonfanodict(...)' routine. Whenever decoding
     fails, those signal values are indicated by -1, and we successively
     try to restart decoding from the next bit that hasnt failed in
     decoding, ad-infinitum.

     An example use of `shannonfanodeco' is
                   hd=shannonfanodict(1:4,[0.5 0.25 0.15 0.10])
                   hcode=shannonfanoenco(1:4,hd) #  [ 1   0   1   0   0   0   0   0   1 ]
                   shannonfanodeco(hcode,hd) # [1 2 3 4]

   See also: shannonfanoenco, shannonfanodict




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Returns the original signal that was Shannonfano encoded.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
shannonfanodict


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 654
 -- Function File:  shannonfanodict (SYMBOLS,SYMBOL_PROBABILITES)
     Returns the code dictionary for source using shanno fano algorithm.
     Dictionary is built from SYMBOL_PROBABILITIES using the shannon
     fano scheme.  Output is a dictionary cell-array, which are
     codewords, and correspond to the order of input probability.

                   CW=shannonfanodict(1:4,[0.5 0.25 0.15 0.1]);
                   assert(redundancy(CW,[0.5 0.25 0.15 0.1]),0.25841,0.001)
                   shannonfanodict(1:5,[0.35 0.17 0.17 0.16 0.15])
                   shannonfanodict(1:8,[8 7 6 5 5 4 3 2]./40)

   See also: shannonfanoenc, shannonfanodec




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Returns the code dictionary for source using shanno fano algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
shannonfanoenco


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 662
 -- Function File:  shannonfanoenco (HCODE,DICT)
     Returns the Shannon Fano encoded signal using DICT.  This function
     uses a DICT built from the `shannonfanodict' and uses it to encode
     a signal list into a shannon fano code.  Restrictions include a
     signal set that strictly belongs  in the `range [1,N]' with
     `N=length(dict)'. Also dict can only be from the
     `shannonfanodict()' routine.  An example use of `shannonfanoenco'
     is

                   hd=shannonfanodict(1:4,[0.5 0.25 0.15 0.10])
                   shannonfanoenco(1:4,hd) #  [   0   1   0   1   1   0   1   1   1   0]

   See also: shannonfanodeco, shannonfanodict




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Returns the Shannon Fano encoded signal using DICT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
symerr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1568
 -- Function File: [NUM, RATE] =  symerr (A,B)
 -- Function File: [NUM, RATE] =  symerr (...,FLAG)
 -- Function File: [NUM, RATE IND] =  symerr (...)
     Compares two matrices and returns the number of symbol errors and
     the symbol error rate. The variables A and B can be either:

    Both matrices
          In this case both matrices must be the same size and then by
          default the the return values NUM and RATE are the overall
          number of symbol errors and the overall symbol error rate.

    One column vector
          In this case the column vector is used for symbol error
          comparision column-wise with the matrix. The returned values
          NUM and RATE are then row vectors containing the num of
          symbol errors and the symbol error rate for each of the
          column-wise comparisons. The number of rows in the matrix
          must be the same as the length of the column vector

    One row vector
          In this case the row vector is used for symbol error
          comparision row-wise with the matrix. The returned values NUM
          and RATE are then column vectors containing the num of symbol
          errors and the symbol error rate for each of the row-wise
          comparisons. The number of columns in the matrix must be the
          same as the length of the row vector

     This behaviour can be overridden with the variable FLAG. FLAG can
     take the value 'column-wise', 'row-wise' or 'overall'. A
     column-wise comparision is not possible with a row vector and
     visa-versa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compares two matrices and returns the number of symbol errors and the
symbol err



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
systematize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 729
 -- Function File:  systematize (G)
     Given G, extract P partiy check matrix. Assume row-operations in
     GF(2).  G is of size KxN, when decomposed through row-operations
     into a I of size KxK identity matrix, and a parity check matrix P
     of size Kx(N-K).

     Most arbitrary code with a given generator matrix G, can be
     converted into its systematic form using this function.

     This function returns 2 values, first is default being GX the
     systematic version of the G matrix, and then the parity check
     matrix P.

            G=[1 1 1 1; 1 1 0 1; 1 0 0 1];
            [Gx,P]=systematize(G);

            Gx = [1 0 0 1; 0 1 0 0; 0 0 1 0];
            P = [1 0 0];


   See also: bchpoly, biterr




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Given G, extract P partiy check matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
vec2mat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 376
 -- Function File: M =  vec2mat (V, C)
 -- Function File: M =  vec2mat (V, C, D)
 -- Function File: [M, ADD] =  vec2mat (...)
     Converts the vector V into a C column matrix with row priority
     arrangement and with the final column padded with the value D to
     the correct length. By default D is 0. The amount of padding added
     to the matrix is returned in ADD.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Converts the vector V into a C column matrix with row priority
arrangement and w



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
wgn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1012
 -- Function File: Y = wgn (M,N,P)
 -- Function File: Y = wgn (M,N,P,IMP)
 -- Function File: Y = wgn (M,N,P,IMP,SEED,)
 -- Function File: Y = wgn (...,'TYPE')
 -- Function File: Y = wgn (...,'OUTPUT')
     Returns a M-by-N matrix Y of white Gaussian noise. P specifies the
     power of the output noise, which is assumed to be referenced to an
     impedance of 1 Ohm, unless IMP explicitly defines the impedance.

     If SEED is defined then the randn function is seeded with this
     value.

     The arguments TYPE and OUTPUT must follow the above numerial
     arguments, but can be specified in any order. TYPE specifies the
     units of P, and can be 'dB', 'dBW', 'dBm' or 'linear'. 'dB' is in
     fact the same as 'dBW' and is keep as a misnomer of Matlab. The
     units of 'linear' are in Watts.

     The OUTPUT variable should be either 'real' or 'complex'. If the
     output is complex then the power P is divided equally betwen the
     real and imaginary parts.

     See also: randn, awgn





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Returns a M-by-N matrix Y of white Gaussian noise.





