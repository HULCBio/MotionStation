# Created by Octave 3.6.4, Sat Mar 30 09:27:02 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 77
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
Anderson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Frequency-weighted coprime factorization controller reduction.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Frequency-weighted coprime factorization controller reduction.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
BMWengine


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1283
 -- Function File: SYS = BMWengine ()
 -- Function File: SYS = BMWengine ("SCALED")
 -- Function File: SYS = BMWengine ("UNSCALED")
     Model of the BMW 4-cylinder engine at ETH Zurich's control
     laboratory.
          OPERATING POINT
          Drosselklappenstellung     alpha_DK = 10.3 Grad
          Saugrohrdruck              p_s = 0.48 bar
          Motordrehzahl              n = 860 U/min
          Lambda-Messwert            lambda = 1.000
          Relativer Wandfilminhalt   nu = 1

          INPUTS
          U_1 Sollsignal Drosselklappenstellung   [Grad]
          U_2 Relative Einspritzmenge             [-]
          U_3 Zuendzeitpunkt                      [Grad KW]
          M_L Lastdrehmoment                      [Nm]

          STATES
          X_1 Drosselklappenstellung     [Grad]
          X_2 Saugrohrdruck              [bar]
          X_3 Motordrehzahl              [U/min]
          X_4 Messwert Lamba-Sonde       [-]
          X_5 Relativer Wandfilminhalt   [-]

          OUTPUTS
          Y_1 Motordrehzahl              [U/min]
          Y_2 Messwert Lambda-Sonde      [-]

          SCALING
          U_1N, X_1N   1 Grad
          U_2N, X_4N, X_5N, Y_2N   0.05
          U_3N   1.6 Grad KW
          X_2N   0.05 bar
          X_3N, Y_1N   200 U/min




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Model of the BMW 4-cylinder engine at ETH Zurich's control laboratory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
Boeing707


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 392
 -- Function File: SYS = Boeing707 ()
     Creates a linearized state-space model of a Boeing 707-321 aircraft
     at V=80 m/s (M = 0.26, GA0 = -3 deg, ALPHA0 = 4 deg, KAPPA = 50
     deg).

     System inputs: (1) thrust and (2) elevator angle.

     System outputs:  (1) airspeed and (2) pitch angle.

     *Reference*: R. Brockhaus: `Flugregelung' (Flight Control),
     Springer, 1994.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Creates a linearized state-space model of a Boeing 707-321 aircraft at
V=80 m/s 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
MDSSystem


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 156
Robust control of a mass-damper-spring system.  Type `which MDSSystem'
to locate, `edit MDSSystem' to open and simply `MDSSystem' to run the
example file.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Robust control of a mass-damper-spring system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
Madievski


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2418
Demonstration of frequency-weighted controller reduction.  The system
considered in this example has been studied by Madievski and Anderson
[1] and comprises four spinning disks.  The disks are connected by a
flexible rod, a motor applies torque to the third disk, and the angular
displacement of the first disk is the variable of interest. The
state-space model of eighth order is non-minimumphase and unstable.
The continuous-time LQG controller used in [1] is open-loop stable and
of eighth order like the plant.  This eighth-order controller shall be
reduced by frequency-weighted singular perturbation approximation (SPA).
The major aim of this reduction is the preservation of the closed-loop
transfer function.  This means that the error in approximation of the
controller K by the reduced-order controller KR is minimized by
     min ||W (K-Kr) V||
      Kr               inf
   where weights W and V are dictated by the requirement to preserve
(as far as possible) the closed-loop transfer function.  In minimizing
the error, they cause the approximation process for K to be more
accurate at certain frequencies.  Suggested by [1] is the use of the
following stability and performance enforcing weights:
                  -1                      -1
     W = (I - G K)   G,      V = (I - G K)
   This example script reduces the eighth-order controller to orders
four and two by the function call `Kr = spaconred (G, K, nr,
'feedback', '-')' where argument NR denotes the desired order (4 or 2).
The key-value pair `'feedback', '-'' allows the reduction of negative
feedback controllers while the default setting expects positive
feedback controllers.  The frequency responses of the original and
reduced-order controllers are depicted in figure 1, the step responses
of the closed loop in figure 2.  There is no visible difference between
the step responses of the closed-loop systems with original (blue) and
fourth order (green) controllers.  The second order controller (red)
causes ripples in the step response, but otherwise the behavior of the
system is unaltered.  This leads to the conclusion that function
`spaconred' is well suited to reduce the order of controllers
considerably, while stability and performance are retained.
*Reference*
[1] Madievski, A.G. and Anderson, B.D.O.  `Sampled-Data Controller
Reduction Procedure', IEEE Transactions of Automatic Control, Vol. 40,
No. 11, November 1995




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Demonstration of frequency-weighted controller reduction.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
WestlandLynx


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1265
 -- Function File: SYS = WestlandLynx ()
     Model of the Westland Lynx Helicopter about hover.
          INPUTS
          main rotor collective
          longitudinal cyclic
          lateral cyclic
          tail rotor collective

          STATES
          pitch attitude           theta       [rad]
          roll attitude            phi         [rad]
          roll rate (body-axis)    p           [rad/s]
          pitch rate (body-axis)   q           [rad/s]
          yaw rate                 xi          [rad/s]
          forward velocity         v_x         [ft/s]
          lateral velocity         v_y         [ft/s]
          vertical velocity        v_z         [ft/s]

          OUTPUTS
          heave velocity           H_dot       [ft/s]
          pitch attitude           theta       [rad]
          roll attitude            phi         [rad]
          heading rate             psi_dot     [rad/s]
          roll rate                p           [rad/s]
          pitch rate               q           [rad/s]

     *References*
     [1] Skogestad, S. and Postlethwaite I. (2005) `Multivariable
     Feedback Control: Analysis and Design: Second Edition'.  Wiley.
     `http://www.nt.ntnu.no/users/skoge/book/2nd_edition/matlab_m/matfiles.html'





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Model of the Westland Lynx Helicopter about hover.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
arx


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1948
 -- Function File: [SYS, X0] = arx (DAT, N, ...)
 -- Function File: [SYS, X0] = arx (DAT, N, OPT, ...)
 -- Function File: [SYS, X0] = arx (DAT, OPT, ...)
 -- Function File: [SYS, X0] = arx (DAT, 'NA', NA, 'NB', NB)
     Estimate ARX model using QR factorization.

          A(q) y(t) = B(q) u(t) + e(t)

     *Inputs*
    DAT
          iddata identification dataset containing the measurements,
          i.e. time-domain signals.

    N
          The desired order of the resulting model SYS.

    ...
          Optional pairs of keys and values.  `'key1', value1, 'key2',
          value2'.

    OPT
          Optional struct with keys as field names.  Struct OPT can be
          created directly or by command `options'.  `opt.key1 =
          value1, opt.key2 = value2'.

     *Outputs*
    SYS
          Discrete-time transfer function model.  If the second output
          argument X0 is returned, SYS becomes a state-space model.

    X0
          Initial state vector.  If DAT is a multi-experiment dataset,
          X0 becomes a cell vector containing an initial state vector
          for each experiment.

     *Option Keys and Values*
    'NA'
          Order of the polynomial A(q) and number of poles.

    'NB'
          Order of the polynomial B(q)+1 and number of zeros+1.  NB <=
          NA.

    'NK'
          Input-output delay specified as number of sampling instants.
          Scalar positive integer.  This corresponds to a call to
          command `nkshift', followed by padding the B polynomial with
          NK leading zeros.

     *Algorithm*
     Uses the formulae given in [1] on pages 318-319, 'Solving for the
     LS Estimate by QR Factorization'.  For the initial conditions,
     SLICOT IB01CD is used by courtesy of NICONET e.V.
     (http://www.slicot.org)

     *References*
     [1] Ljung, L. (1999) `System Identification: Theory for the User:
     Second Edition'.  Prentice Hall, New Jersey, USA.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Estimate ARX model using QR factorization.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
augw


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2979
 -- Function File: P = augw (G, W1, W2, W3)
     Extend plant for stacked S/KS/T problem.  Subsequently, the robust
     control problem can be solved by h2syn or hinfsyn.

     *Inputs*
    G
          LTI model of plant.

    W1
          LTI model of performance weight.  Bounds the largest singular
          values of sensitivity S.  Model must be empty `[]', SISO or
          of appropriate size.

    W2
          LTI model to penalize large control inputs.  Bounds the
          largest singular values of KS.  Model must be empty `[]',
          SISO or of appropriate size.

    W3
          LTI model of robustness and noise sensitivity weight.  Bounds
          the largest singular values of complementary sensitivity T.
          Model must be empty `[]', SISO or of appropriate size.

     All inputs must be proper/realizable.  Scalars, vectors and
     matrices are possible instead of LTI models.

     *Outputs*
    P
          State-space model of augmented plant.

     *Block Diagram*

              | W1 | -W1*G |     z1 = W1 r  -  W1 G u
              | 0  |  W2   |     z2 =          W2   u
          P = | 0  |  W3*G |     z3 =          W3 G u
              |----+-------|
              | I  |    -G |     e  =    r  -     G u

                                                                +------+  z1
                      +---------------------------------------->|  W1  |----->
                      |                                         +------+
                      |                                         +------+  z2
                      |                 +---------------------->|  W2  |----->
                      |                 |                       +------+
           r   +    e |   +--------+  u |   +--------+  y       +------+  z3
          ----->(+)---+-->|  K(s)  |----+-->|  G(s)  |----+---->|  W3  |----->
                 ^ -      +--------+        +--------+    |     +------+
                 |                                        |
                 +----------------------------------------+

                         +--------+
                         |        |-----> z1 (p1x1)          z1 = W1 e
           r (px1) ----->|  P(s)  |-----> z2 (p2x1)          z2 = W2 u
                         |        |-----> z3 (p3x1)          z3 = W3 y
           u (mx1) ----->|        |-----> e (px1)            e = r - y
                         +--------+

                         +--------+
                 r ----->|        |-----> z
                         |  P(s)  |
                 u +---->|        |-----+ e
                   |     +--------+     |
                   |                    |
                   |     +--------+     |
                   +-----|  K(s)  |<----+
                         +--------+

     *References*
     [1] Skogestad, S. and Postlethwaite I. (2005) `Multivariable
     Feedback Control: Analysis and Design: Second Edition'.  Wiley.

     See also: h2syn, hinfsyn, mixsyn





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Extend plant for stacked S/KS/T problem.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
bode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1239
 -- Function File:  bode (SYS)
 -- Function File:  bode (SYS1, SYS2, ..., SYSN)
 -- Function File:  bode (SYS1, SYS2, ..., SYSN, W)
 -- Function File:  bode (SYS1, 'STYLE1', ..., SYSN, 'STYLEN')
 -- Function File: [MAG, PHA, W] = bode (SYS)
 -- Function File: [MAG, PHA, W] = bode (SYS, W)
     Bode diagram of frequency response.  If no output arguments are
     given, the response is printed on the screen.

     *Inputs*
    SYS
          LTI system.  Must be a single-input and single-output (SISO)
          system.

    W
          Optional vector of frequency values.  If W is not specified,
          it is calculated by the zeros and poles of the system.
          Alternatively, the cell `{wmin, wmax}' specifies a frequency
          range, where WMIN and WMAX denote minimum and maximum
          frequencies in rad/s.

    'STYLE'
          Line style and color, e.g. 'r' for a solid red line or '-.k'
          for a dash-dotted black line.  See `help plot' for details.

     *Outputs*
    MAG
          Vector of magnitude.  Has length of frequency vector W.

    PHA
          Vector of phase.  Has length of frequency vector W.

    W
          Vector of frequency values used.

     See also: nichols, nyquist, sigma





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Bode diagram of frequency response.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bodemag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1192
 -- Function File:  bodemag (SYS)
 -- Function File:  bodemag (SYS1, SYS2, ..., SYSN)
 -- Function File:  bodemag (SYS1, SYS2, ..., SYSN, W)
 -- Function File:  bodemag (SYS1, 'STYLE1', ..., SYSN, 'STYLEN')
 -- Function File: [MAG, W] = bodemag (SYS)
 -- Function File: [MAG, W] = bodemag (SYS, W)
     Bode magnitude diagram of frequency response.  If no output
     arguments are given, the response is printed on the screen.

     *Inputs*
    SYS
          LTI system.  Must be a single-input and single-output (SISO)
          system.

    W
          Optional vector of frequency values.  If W is not specified,
          it is calculated by the zeros and poles of the system.
          Alternatively, the cell `{wmin, wmax}' specifies a frequency
          range, where WMIN and WMAX denote minimum and maximum
          frequencies in rad/s.

    'STYLE'
          Line style and color, e.g. 'r' for a solid red line or '-.k'
          for a dash-dotted black line.  See `help plot' for details.

     *Outputs*
    MAG
          Vector of magnitude.  Has length of frequency vector W.

    W
          Vector of frequency values used.

     See also: bode, nichols, nyquist, sigma





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Bode magnitude diagram of frequency response.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
bstmodred


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6097
 -- Function File: [GR, INFO] = bstmodred (G, ...)
 -- Function File: [GR, INFO] = bstmodred (G, NR, ...)
 -- Function File: [GR, INFO] = bstmodred (G, OPT, ...)
 -- Function File: [GR, INFO] = bstmodred (G, NR, OPT, ...)
     Model order reduction by Balanced Stochastic Truncation (BST)
     method.  The aim of model reduction is to find an LTI system GR of
     order NR (nr < n) such that the input-output behaviour of GR
     approximates the one from original system G.

     BST is a relative error method which tries to minimize
             -1
          ||G  (G-Gr)||    = min
                       inf

     *Inputs*
    G
          LTI model to be reduced.

    NR
          The desired order of the resulting reduced order system GR.
          If not specified, NR is chosen automatically according to the
          description of key 'ORDER'.

    ...
          Optional pairs of keys and values.  `"key1", value1, "key2",
          value2'.

    OPT
          Optional struct with keys as field names.  Struct OPT can be
          created directly or by command `options'.  `opt.key1 =
          value1, opt.key2 = value2'.

     *Outputs*
    GR
          Reduced order state-space model.

    INFO
          Struct containing additional information.
         INFO.N
               The order of the original system G.

         INFO.NS
               The order of the ALPHA-stable subsystem of the original
               system G.

         INFO.HSV
               The Hankel singular values of the phase system
               corresponding to the ALPHA-stable part of the original
               system G.  The NS Hankel singular values are ordered
               decreasingly.

         INFO.NU
               The order of the ALPHA-unstable subsystem of both the
               original system G and the reduced-order system GR.

         INFO.NR
               The order of the obtained reduced order system GR.

     *Option Keys and Values*
    'ORDER', 'NR'
          The desired order of the resulting reduced order system GR.
          If not specified, NR is the sum of NU and the number of
          Hankel singular values greater than `MAX(TOL1,NS*EPS)'; NR
          can be further reduced to ensure that `HSV(NR-NU) >
          HSV(NR+1-NU)'.

    'METHOD'
          Approximation method for the H-infinity norm.  Valid values
          corresponding to this key are:
         'SR-BTA', 'B'
               Use the square-root Balance & Truncate method.

         'BFSR-BTA', 'F'
               Use the balancing-free square-root Balance & Truncate
               method.  Default method.

         'SR-SPA', 'S'
               Use the square-root Singular Perturbation Approximation
               method.

         'BFSR-SPA', 'P'
               Use the balancing-free square-root Singular Perturbation
               Approximation method.

    'ALPHA'
          Specifies the ALPHA-stability boundary for the eigenvalues of
          the state dynamics matrix G.A.  For a continuous-time system,
          ALPHA <= 0 is the boundary value for the real parts of
          eigenvalues, while for a discrete-time system, 0 <= ALPHA <=
          1 represents the boundary value for the moduli of eigenvalues.
          The ALPHA-stability domain does not include the boundary.
          Default value is 0 for continuous-time systems and 1 for
          discrete-time systems.

    'BETA'
          Use `[G, beta*I]' as new system G to combine absolute and
          relative error methods.  BETA > 0 specifies the
          absolute/relative error weighting parameter.  A large
          positive value of BETA favours the minimization of the
          absolute approximation error, while a small value of BETA is
          appropriate for the minimization of the relative error.  BETA
          = 0 means a pure relative error method and can be used only
          if rank(G.D) = rows(G.D) which means that the feedthrough
          matrice must not be rank-deficient.  Default value is 0.

    'TOL1'
          If 'ORDER' is not specified, TOL1 contains the tolerance for
          determining the order of reduced system.  For model
          reduction, the recommended value of TOL1 lies in the interval
          [0.00001, 0.001].  TOL1 < 1.  If TOL1 <= 0 on entry, the used
          default value is TOL1 = NS*EPS, where NS is the number of
          ALPHA-stable eigenvalues of A and EPS is the machine
          precision.  If 'ORDER' is specified, the value of TOL1 is
          ignored.

    'TOL2'
          The tolerance for determining the order of a minimal
          realization of the phase system (see METHOD) corresponding to
          the ALPHA-stable part of the given system.  The recommended
          value is TOL2 = NS*EPS.  TOL2 <= TOL1 < 1.  This value is
          used by default if 'TOL2' is not specified or if TOL2 <= 0 on
          entry.

    'EQUIL', 'SCALE'
          Boolean indicating whether equilibration (scaling) should be
          performed on system G prior to order reduction.  Default
          value is true if `G.scaled == false' and false if `G.scaled
          == true'.  Note that for MIMO models, proper scaling of both
          inputs and outputs is of utmost importance.  The input and
          output scaling can *not* be done by the equilibration option
          or the `prescale' command because these functions perform
          state transformations only.  Furthermore, signals should not
          be scaled simply to a certain range.  For all inputs (or
          outputs), a certain change should be of the same importance
          for the model.

     BST is often suitable to perform model reduction in order to obtain
     low order design models for controller synthesis.

     Approximation Properties:
        * Guaranteed stability of reduced models

        * Approximates simultaneously gain and phase

        * Preserves non-minimum phase zeros

        * Guaranteed a priori error bound

     *Algorithm*
     Uses SLICOT AB09HD by courtesy of NICONET e.V.
     (http://www.slicot.org)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Model order reduction by Balanced Stochastic Truncation (BST) method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
btaconred


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6173
 -- Function File: [KR, INFO] = btaconred (G, K, ...)
 -- Function File: [KR, INFO] = btaconred (G, K, NCR, ...)
 -- Function File: [KR, INFO] = btaconred (G, K, OPT, ...)
 -- Function File: [KR, INFO] = btaconred (G, K, NCR, OPT, ...)
     Controller reduction by frequency-weighted Balanced Truncation
     Approximation (BTA).  Given a plant G and a stabilizing controller
     K, determine a reduced order controller KR such that the
     closed-loop system is stable and closed-loop performance is
     retained.

     The algorithm tries to minimize the frequency-weighted error
          ||V (K-Kr) W||    = min
                        inf
     where V and W denote output and input weightings.

     *Inputs*
    G
          LTI model of the plant.  It has m inputs, p outputs and n
          states.

    K
          LTI model of the controller.  It has p inputs, m outputs and
          nc states.

    NCR
          The desired order of the resulting reduced order controller
          KR.  If not specified, NCR is chosen automatically according
          to the description of key 'ORDER'.

    ...
          Optional pairs of keys and values.  `"key1", value1, "key2",
          value2'.

    OPT
          Optional struct with keys as field names.  Struct OPT can be
          created directly or by command `options'.  `opt.key1 =
          value1, opt.key2 = value2'.

     *Outputs*
    KR
          State-space model of reduced order controller.

    INFO
          Struct containing additional information.
         INFO.NCR
               The order of the obtained reduced order controller KR.

         INFO.NCS
               The order of the alpha-stable part of original
               controller K.

         INFO.HSVC
               The Hankel singular values of the alpha-stable part of K.
               The NCS Hankel singular values are ordered decreasingly.

     *Option Keys and Values*
    'ORDER', 'NCR'
          The desired order of the resulting reduced order controller
          KR.  If not specified, NCR is chosen automatically such that
          states with Hankel singular values INFO.HSVC > TOL1 are
          retained.

    'METHOD'
          Order reduction approach to be used as follows:
         'SR', 'B'
               Use the square-root Balance & Truncate method.

         'BFSR', 'F'
               Use the balancing-free square-root Balance & Truncate
               method.  Default method.

    'WEIGHT'
          Specifies the type of frequency-weighting as follows:
         'NONE'
               No weightings are used (V = I, W = I).

         'LEFT', 'OUTPUT'
               Use stability enforcing left (output) weighting
                              -1
                    V = (I-G*K) *G ,  W = I

         'RIGHT', 'INPUT'
               Use stability enforcing right (input) weighting
                                       -1
                    V = I ,  W = (I-G*K) *G

         'BOTH', 'PERFORMANCE'
               Use stability and performance enforcing weightings
                              -1                -1
                    V = (I-G*K) *G ,  W = (I-G*K)
               Default value.

    'FEEDBACK'
          Specifies whether K is a positive or negative feedback
          controller:
         '+'
               Use positive feedback controller.  Default value.

         '-'
               Use negative feedback controller.

    'ALPHA'
          Specifies the ALPHA-stability boundary for the eigenvalues of
          the state dynamics matrix K.A.  For a continuous-time
          controller, ALPHA <= 0 is the boundary value for the real
          parts of eigenvalues, while for a discrete-time controller, 0
          <= ALPHA <= 1 represents the boundary value for the moduli of
          eigenvalues.  The ALPHA-stability domain does not include the
          boundary.  Default value is 0 for continuous-time controllers
          and 1 for discrete-time controllers.

    'TOL1'
          If 'ORDER' is not specified, TOL1 contains the tolerance for
          determining the order of the reduced controller.  For model
          reduction, the recommended value of TOL1 is c*info.hsvc(1),
          where c lies in the interval [0.00001, 0.001].  Default value
          is info.ncs*eps*info.hsvc(1).  If 'ORDER' is specified, the
          value of TOL1 is ignored.

    'TOL2'
          The tolerance for determining the order of a minimal
          realization of the ALPHA-stable part of the given controller.
          TOL2 <= TOL1.  If not specified, ncs*eps*info.hsvc(1) is
          chosen.

    'GRAM-CTRB'
          Specifies the choice of frequency-weighted controllability
          Grammian as follows:
         'STANDARD'
               Choice corresponding to standard Enns' method [1].
               Default method.

         'ENHANCED'
               Choice corresponding to the stability enhanced modified
               Enns' method of [2].

    'GRAM-OBSV'
          Specifies the choice of frequency-weighted observability
          Grammian as follows:
         'STANDARD'
               Choice corresponding to standard Enns' method [1].
               Default method.

         'ENHANCED'
               Choice corresponding to the stability enhanced modified
               Enns' method of [2].

    'EQUIL', 'SCALE'
          Boolean indicating whether equilibration (scaling) should be
          performed on G and K prior to order reduction.  Default value
          is false if both `G.scaled == true, K.scaled == true' and
          true otherwise.  Note that for MIMO models, proper scaling of
          both inputs and outputs is of utmost importance.  The input
          and output scaling can *not* be done by the equilibration
          option or the `prescale' command because these functions
          perform state transformations only.  Furthermore, signals
          should not be scaled simply to a certain range.  For all
          inputs (or outputs), a certain change should be of the same
          importance for the model.

     *Algorithm*
     Uses SLICOT SB16AD by courtesy of NICONET e.V.
     (http://www.slicot.org)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Controller reduction by frequency-weighted Balanced Truncation
Approximation (BT



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
btamodred


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7334
 -- Function File: [GR, INFO] = btamodred (G, ...)
 -- Function File: [GR, INFO] = btamodred (G, NR, ...)
 -- Function File: [GR, INFO] = btamodred (G, OPT, ...)
 -- Function File: [GR, INFO] = btamodred (G, NR, OPT, ...)
     Model order reduction by frequency weighted Balanced Truncation
     Approximation (BTA) method.  The aim of model reduction is to find
     an LTI system GR of order NR (nr < n) such that the input-output
     behaviour of GR approximates the one from original system G.

     BTA is an absolute error method which tries to minimize
          ||G-Gr||    = min
                  inf

          ||V (G-Gr) W||    = min
                        inf
     where V and W denote output and input weightings.

     *Inputs*
    G
          LTI model to be reduced.

    NR
          The desired order of the resulting reduced order system GR.
          If not specified, NR is chosen automatically according to the
          description of key 'ORDER'.

    ...
          Optional pairs of keys and values.  `"key1", value1, "key2",
          value2'.

    OPT
          Optional struct with keys as field names.  Struct OPT can be
          created directly or by command `options'.  `opt.key1 =
          value1, opt.key2 = value2'.

     *Outputs*
    GR
          Reduced order state-space model.

    INFO
          Struct containing additional information.
         INFO.N
               The order of the original system G.

         INFO.NS
               The order of the ALPHA-stable subsystem of the original
               system G.

         INFO.HSV
               The Hankel singular values of the ALPHA-stable part of
               the original system G, ordered decreasingly.

         INFO.NU
               The order of the ALPHA-unstable subsystem of both the
               original system G and the reduced-order system GR.

         INFO.NR
               The order of the obtained reduced order system GR.

     *Option Keys and Values*
    'ORDER', 'NR'
          The desired order of the resulting reduced order system GR.
          If not specified, NR is chosen automatically such that states
          with Hankel singular values INFO.HSV > TOL1 are retained.

    'LEFT', 'OUTPUT'
          LTI model of the left/output frequency weighting V.  Default
          value is an identity matrix.

    'RIGHT', 'INPUT'
          LTI model of the right/input frequency weighting W.  Default
          value is an identity matrix.

    'METHOD'
          Approximation method for the L-infinity norm to be used as
          follows:
         'SR', 'B'
               Use the square-root Balance & Truncate method.

         'BFSR', 'F'
               Use the balancing-free square-root Balance & Truncate
               method.  Default method.

    'ALPHA'
          Specifies the ALPHA-stability boundary for the eigenvalues of
          the state dynamics matrix G.A.  For a continuous-time system,
          ALPHA <= 0 is the boundary value for the real parts of
          eigenvalues, while for a discrete-time system, 0 <= ALPHA <=
          1 represents the boundary value for the moduli of eigenvalues.
          The ALPHA-stability domain does not include the boundary.
          Default value is 0 for continuous-time systems and 1 for
          discrete-time systems.

    'TOL1'
          If 'ORDER' is not specified, TOL1 contains the tolerance for
          determining the order of the reduced model.  For model
          reduction, the recommended value of TOL1 is c*info.hsv(1),
          where c lies in the interval [0.00001, 0.001].  Default value
          is info.ns*eps*info.hsv(1).  If 'ORDER' is specified, the
          value of TOL1 is ignored.

    'TOL2'
          The tolerance for determining the order of a minimal
          realization of the ALPHA-stable part of the given model.
          TOL2 <= TOL1.  If not specified, ns*eps*info.hsv(1) is chosen.

    'GRAM-CTRB'
          Specifies the choice of frequency-weighted controllability
          Grammian as follows:
         'STANDARD'
               Choice corresponding to a combination method [4] of the
               approaches of Enns [1] and Lin-Chiu [2,3].  Default
               method.

         'ENHANCED'
               Choice corresponding to the stability enhanced modified
               combination method of [4].

    'GRAM-OBSV'
          Specifies the choice of frequency-weighted observability
          Grammian as follows:
         'STANDARD'
               Choice corresponding to a combination method [4] of the
               approaches of Enns [1] and Lin-Chiu [2,3].  Default
               method.

         'ENHANCED'
               Choice corresponding to the stability enhanced modified
               combination method of [4].

    'ALPHA-CTRB'
          Combination method parameter for defining the
          frequency-weighted controllability Grammian.  abs(alphac) <=
          1.  If alphac = 0, the choice of Grammian corresponds to the
          method of Enns [1], while if alphac = 1, the choice of
          Grammian corresponds to the method of Lin and Chiu [2,3].
          Default value is 0.

    'ALPHA-OBSV'
          Combination method parameter for defining the
          frequency-weighted observability Grammian.  abs(alphao) <= 1.
          If alphao = 0, the choice of Grammian corresponds to the
          method of Enns [1], while if alphao = 1, the choice of
          Grammian corresponds to the method of Lin and Chiu [2,3].
          Default value is 0.

    'EQUIL', 'SCALE'
          Boolean indicating whether equilibration (scaling) should be
          performed on system G prior to order reduction.  This is done
          by state transformations.  Default value is true if `G.scaled
          == false' and false if `G.scaled == true'.  Note that for
          MIMO models, proper scaling of both inputs and outputs is of
          utmost importance.  The input and output scaling can *not* be
          done by the equilibration option or the `prescale' command
          because these functions perform state transformations only.
          Furthermore, signals should not be scaled simply to a certain
          range.  For all inputs (or outputs), a certain change should
          be of the same importance for the model.

     Approximation Properties:
        * Guaranteed stability of reduced models

        * Lower guaranteed error bound

        * Guaranteed a priori error bound

     *References*
     [1] Enns, D.  `Model reduction with balanced realizations: An
     error bound and a frequency weighted generalization'.  Proc. 23-th
     CDC, Las Vegas, pp. 127-132, 1984.

     [2] Lin, C.-A. and Chiu, T.-Y.  `Model reduction via
     frequency-weighted balanced realization'.  Control Theory and
     Advanced Technology, vol. 8, pp. 341-351, 1992.

     [3] Sreeram, V., Anderson, B.D.O and Madievski, A.G.  `New results
     on frequency weighted balanced reduction technique'.  Proc. ACC,
     Seattle, Washington, pp. 4004-4009, 1995.

     [4] Varga, A. and Anderson, B.D.O.  `Square-root balancing-free
     methods for the frequency-weighted balancing related model
     reduction'.  (report in preparation)

     *Algorithm*
     Uses SLICOT AB09ID by courtesy of NICONET e.V.
     (http://www.slicot.org)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Model order reduction by frequency weighted Balanced Truncation
Approximation (B



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
care


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1627
 -- Function File: [X, L, G] = care (A, B, Q, R)
 -- Function File: [X, L, G] = care (A, B, Q, R, S)
 -- Function File: [X, L, G] = care (A, B, Q, R, [], E)
 -- Function File: [X, L, G] = care (A, B, Q, R, S, E)
     Solve continuous-time algebraic Riccati equation (ARE).

     *Inputs*
    A
          Real matrix (n-by-n).

    B
          Real matrix (n-by-m).

    Q
          Real matrix (n-by-n).

    R
          Real matrix (m-by-m).

    S
          Optional real matrix (n-by-m).  If S is not specified, a zero
          matrix is assumed.

    E
          Optional descriptor matrix (n-by-n).  If E is not specified,
          an identity matrix is assumed.

     *Outputs*
    X
          Unique stabilizing solution of the continuous-time Riccati
          equation (n-by-n).

    L
          Closed-loop poles (n-by-1).

    G
          Corresponding gain matrix (m-by-n).

     *Equations*
                         -1
          A'X + XA - XB R  B'X + Q = 0

                               -1
          A'X + XA - (XB + S) R  (B'X + S') + Q = 0

               -1
          G = R  B'X

               -1
          G = R  (B'X + S')

          L = eig (A - B*G)

                              -1
          A'XE + E'XA - E'XB R   B'XE + Q = 0

                                    -1
          A'XE + E'XA - (E'XB + S) R   (B'XE + S') + Q = 0

               -1
          G = R  B'XE

               -1
          G = R  (B'XE + S)

          L = eig (A - B*G, E)

     *Algorithm*
     Uses SLICOT SB02OD and SG02AD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: dare, lqr, dlqr, kalman





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Solve continuous-time algebraic Riccati equation (ARE).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cfconred


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4348
 -- Function File: [KR, INFO] = cfconred (G, F, L, ...)
 -- Function File: [KR, INFO] = cfconred (G, F, L, NCR, ...)
 -- Function File: [KR, INFO] = cfconred (G, F, L, OPT, ...)
 -- Function File: [KR, INFO] = cfconred (G, F, L, NCR, OPT, ...)
     Reduction of state-feedback-observer based controller by coprime
     factorization (CF).  Given a plant G, state feedback gain F and
     full observer gain L, determine a reduced order controller KR.

     *Inputs*
    G
          LTI model of the open-loop plant (A,B,C,D).  It has m inputs,
          p outputs and n states.

    F
          Stabilizing state feedback matrix (m-by-n).

    L
          Stabilizing observer gain matrix (n-by-p).

    NCR
          The desired order of the resulting reduced order controller
          KR.  If not specified, NCR is chosen automatically according
          to the description of key 'ORDER'.

    ...
          Optional pairs of keys and values.  `"key1", value1, "key2",
          value2'.

    OPT
          Optional struct with keys as field names.  Struct OPT can be
          created directly or by command `options'.  `opt.key1 =
          value1, opt.key2 = value2'.

     *Outputs*
    KR
          State-space model of reduced order controller.

    INFO
          Struct containing additional information.
         INFO.HSV
               The Hankel singular values of the extended system?!?.
               The N Hankel singular values are ordered decreasingly.

         INFO.NCR
               The order of the obtained reduced order controller KR.

     *Option Keys and Values*
    'ORDER', 'NCR'
          The desired order of the resulting reduced order controller
          KR.  If not specified, NCR is chosen automatically such that
          states with Hankel singular values INFO.HSV > TOL1 are
          retained.

    'METHOD'
          Order reduction approach to be used as follows:
         'SR-BTA', 'B'
               Use the square-root Balance & Truncate method.

         'BFSR-BTA', 'F'
               Use the balancing-free square-root Balance & Truncate
               method.  Default method.

         'SR-SPA', 'S'
               Use the square-root Singular Perturbation Approximation
               method.

         'BFSR-SPA', 'P'
               Use the balancing-free square-root Singular Perturbation
               Approximation method.

    'CF'
          Specifies whether left or right coprime factorization is to
          be used as follows:
         'LEFT', 'L'
               Use left coprime factorization.  Default method.

         'RIGHT', 'R'
               Use right coprime factorization.

    'FEEDBACK'
          Specifies whether F and L are fed back positively or
          negatively:
         '+'
               A+BK and A+LC are both Hurwitz matrices.

         '-'
               A-BK and A-LC are both Hurwitz matrices.  Default value.

    'TOL1'
          If 'ORDER' is not specified, TOL1 contains the tolerance for
          determining the order of the reduced system.  For model
          reduction, the recommended value of TOL1 is c*info.hsv(1),
          where c lies in the interval [0.00001, 0.001].  Default value
          is n*eps*info.hsv(1).  If 'ORDER' is specified, the value of
          TOL1 is ignored.

    'TOL2'
          The tolerance for determining the order of a minimal
          realization of the coprime factorization controller.  TOL2 <=
          TOL1.  If not specified, n*eps*info.hsv(1) is chosen.

    'EQUIL', 'SCALE'
          Boolean indicating whether equilibration (scaling) should be
          performed on system G prior to order reduction.  Default
          value is true if `G.scaled == false' and false if `G.scaled
          == true'.  Note that for MIMO models, proper scaling of both
          inputs and outputs is of utmost importance.  The input and
          output scaling can *not* be done by the equilibration option
          or the `prescale' command because these functions perform
          state transformations only.  Furthermore, signals should not
          be scaled simply to a certain range.  For all inputs (or
          outputs), a certain change should be of the same importance
          for the model.

     *Algorithm*
     Uses SLICOT SB16BD by courtesy of NICONET e.V.
     (http://www.slicot.org)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Reduction of state-feedback-observer based controller by coprime
factorization (



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
covar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 319
 -- Function File: [P, Q] = covar (SYS, W)
     Return the steady-state covariance.

     *Inputs*
    SYS
          LTI model.

    W
          Intensity of Gaussian white noise inputs which drive SYS.

     *Outputs*
    P
          Output covariance.

    Q
          State covariance.

     See also: lyap, dlyap





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Return the steady-state covariance.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ctrb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 379
 -- Function File: CO = ctrb (SYS)
 -- Function File: CO = ctrb (A, B)
     Return controllability matrix.

     *Inputs*
    SYS
          LTI model.

    A
          State matrix (n-by-n).

    B
          Input matrix (n-by-m).

     *Outputs*
    CO
          Controllability matrix.

     *Equation*
                       2       n-1
          Co = [ B AB A B ... A   B ]




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Return controllability matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ctrbf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 960
 -- Function File: [SYSBAR, T, K] = ctrbf (SYS)
 -- Function File: [SYSBAR, T, K] = ctrbf (SYS, TOL)
 -- Function File: [ABAR, BBAR, CBAR, T, K] = ctrbf (A, B, C)
 -- Function File: [ABAR, BBAR, CBAR, T, K] = ctrbf (A, B, C, TOL)
     If Co=ctrb(A,B) has rank r <= n = SIZE(A,1), then there is a
     similarity transformation Tc such that Tc = [t1 t2] where t1 is
     the controllable subspace and t2 is orthogonal to t1

          Abar = Tc \\ A * Tc ,  Bbar = Tc \\ B ,  Cbar = C * Tc

     and the transformed system has the form

                 | Ac    A12|           | Bc |
          Abar = |----------|,   Bbar = | ---|,  Cbar = [Cc | Cnc].
                 | 0     Anc|           |  0 |

     where (Ac,Bc) is controllable, and Cc(sI-Ac)^(-1)Bc =
     C(sI-A)^(-1)B.  and the system is stabilizable if Anc has no
     eigenvalues in the right half plane. The last output K is a vector
     of length n containing the number of controllable states.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If Co=ctrb(A,B) has rank r <= n = SIZE(A,1), then there is a similarity
transfor



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
dare


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1786
 -- Function File: [X, L, G] = dare (A, B, Q, R)
 -- Function File: [X, L, G] = dare (A, B, Q, R, S)
 -- Function File: [X, L, G] = dare (A, B, Q, R, [], E)
 -- Function File: [X, L, G] = dare (A, B, Q, R, S, E)
     Solve discrete-time algebraic Riccati equation (ARE).

     *Inputs*
    A
          Real matrix (n-by-n).

    B
          Real matrix (n-by-m).

    Q
          Real matrix (n-by-n).

    R
          Real matrix (m-by-m).

    S
          Optional real matrix (n-by-m).  If S is not specified, a zero
          matrix is assumed.

    E
          Optional descriptor matrix (n-by-n).  If E is not specified,
          an identity matrix is assumed.

     *Outputs*
    X
          Unique stabilizing solution of the discrete-time Riccati
          equation (n-by-n).

    L
          Closed-loop poles (n-by-1).

    G
          Corresponding gain matrix (m-by-n).

     *Equations*
                                    -1
          A'XA - X - A'XB (B'XB + R)   B'XA + Q = 0

                                          -1
          A'XA - X - (A'XB + S) (B'XB + R)   (B'XA + S') + Q = 0

                        -1
          G = (B'XB + R)   B'XA

                        -1
          G = (B'XB + R)   (B'XA + S')

          L = eig (A - B*G)

                                       -1
          A'XA - E'XE - A'XB (B'XB + R)   B'XA + Q = 0

                                             -1
          A'XA - E'XE - (A'XB + S) (B'XB + R)   (B'XA + S') + Q = 0

                        -1
          G = (B'XB + R)   B'XA

                        -1
          G = (B'XB + R)   (B'XA + S')

          L = eig (A - B*G, E)

     *Algorithm*
     Uses SLICOT SB02OD and SG02AD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: care, lqr, dlqr, kalman





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Solve discrete-time algebraic Riccati equation (ARE).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
dlqe


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1695
 -- Function File: [M, P, Z, E] = dlqe (A, G, C, Q, R)
 -- Function File: [M, P, Z, E] = dlqe (A, G, C, Q, R, S)
 -- Function File: [M, P, Z, E] = dlqe (A, [], C, Q, R)
 -- Function File: [M, P, Z, E] = dlqe (A, [], C, Q, R, S)
     Kalman filter for discrete-time systems.

          x[k] = Ax[k] + Bu[k] + Gw[k]   (State equation)
          y[k] = Cx[k] + Du[k] + v[k]    (Measurement Equation)
          E(w) = 0, E(v) = 0, cov(w) = Q, cov(v) = R, cov(w,v) = S

     *Inputs*
    A
          State transition matrix of discrete-time system (n-by-n).

    G
          Process noise matrix of discrete-time system (n-by-g).  If G
          is empty `[]', an identity matrix is assumed.

    C
          Measurement matrix of discrete-time system (p-by-n).

    Q
          Process noise covariance matrix (g-by-g).

    R
          Measurement noise covariance matrix (p-by-p).

    S
          Optional cross term covariance matrix (g-by-p), s = cov(w,v).
          If S is empty `[]' or not specified, a zero matrix is assumed.

     *Outputs*
    M
          Kalman filter gain matrix (n-by-p).

    P
          Unique stabilizing solution of the discrete-time Riccati
          equation (n-by-n).  Symmetric matrix.

    Z
          Error covariance (n-by-n), cov(x(k|k)-x)

    E
          Closed-loop poles (n-by-1).

     *Equations*
          x[k|k] = x[k|k-1] + M(y[k] - Cx[k|k-1] - Du[k])

          x[k+1|k] = Ax[k|k] + Bu[k] for S=0

          x[k+1|k] = Ax[k|k] + Bu[k] + G*S*(C*P*C' + R)^-1*(y[k] - C*x[k|k-1]) for non-zero S


          E = eig(A - A*M*C) for S=0

          E = eig(A - A*M*C - G*S*(C*P*C' + Rv)^-1*C) for non-zero S

     See also: dare, care, dlqr, lqr, lqe





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Kalman filter for discrete-time systems.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
dlqr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1374
 -- Function File: [G, X, L] = dlqr (SYS, Q, R)
 -- Function File: [G, X, L] = dlqr (SYS, Q, R, S)
 -- Function File: [G, X, L] = dlqr (A, B, Q, R)
 -- Function File: [G, X, L] = dlqr (A, B, Q, R, S)
 -- Function File: [G, X, L] = dlqr (A, B, Q, R, [], E)
 -- Function File: [G, X, L] = dlqr (A, B, Q, R, S, E)
     Linear-quadratic regulator for discrete-time systems.

     *Inputs*
    SYS
          Continuous or discrete-time LTI model (p-by-m, n states).

    A
          State transition matrix of discrete-time system (n-by-n).

    B
          Input matrix of discrete-time system (n-by-m).

    Q
          State weighting matrix (n-by-n).

    R
          Input weighting matrix (m-by-m).

    S
          Optional cross term matrix (n-by-m).  If S is not specified,
          a zero matrix is assumed.

    E
          Optional descriptor matrix (n-by-n).  If E is not specified,
          an identity matrix is assumed.

     *Outputs*
    G
          State feedback matrix (m-by-n).

    X
          Unique stabilizing solution of the discrete-time Riccati
          equation (n-by-n).

    L
          Closed-loop poles (n-by-1).

     *Equations*
          x[k+1] = A x[k] + B u[k],   x[0] = x0

                  inf
          J(x0) = SUM (x' Q x  +  u' R u  +  2 x' S u)
                  k=0

          L = eig (A - B*G)

     See also: dare, care, lqr





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Linear-quadratic regulator for discrete-time systems.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
dlyap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 527
 -- Function File: X = dlyap (A, B)
 -- Function File: X = dlyap (A, B, C)
 -- Function File: X = dlyap (A, B, [], E)
     Solve discrete-time Lyapunov or Sylvester equations.

     *Equations*
          AXA' - X + B = 0      (Lyapunov Equation)

          AXB' - X + C = 0      (Sylvester Equation)

          AXA' - EXE' + B = 0   (Generalized Lyapunov Equation)

     *Algorithm*
     Uses SLICOT SB03MD, SB04QD and SG03AD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: dlyapchol, lyap, lyapchol





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Solve discrete-time Lyapunov or Sylvester equations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
dlyapchol


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 478
 -- Function File: U = dlyapchol (A, B)
 -- Function File: U = dlyapchol (A, B, E)
     Compute Cholesky factor of discrete-time Lyapunov equations.

     *Equations*
          A U' U A'  -  U' U  +  B B'  =  0           (Lyapunov Equation)

          A U' U A'  -  E U' U E'  +  B B'  =  0      (Generalized Lyapunov Equation)

     *Algorithm*
     Uses SLICOT SB03OD and SG03BD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: dlyap, lyap, lyapchol





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute Cholesky factor of discrete-time Lyapunov equations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
dss


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1877
 -- Function File: SYS = dss (SYS)
 -- Function File: SYS = dss (D)
 -- Function File: SYS = dss (A, B, C, D, E, ...)
 -- Function File: SYS = dss (A, B, C, D, E, TSAM, ...)
     Create or convert to descriptor state-space model.

     *Inputs*
    SYS
          LTI model to be converted to state-space.

    A
          State matrix (n-by-n).

    B
          Input matrix (n-by-m).

    C
          Output matrix (p-by-n).

    D
          Feedthrough matrix (p-by-m).

    E
          Descriptor matrix (n-by-n).

    TSAM
          Sampling time in seconds.  If TSAM is not specified, a
          continuous-time model is assumed.

    ...
          Optional pairs of properties and values.  Type `set (dss)'
          for more information.

     *Outputs*
    SYS
          Descriptor state-space model.

     *Option Keys and Values*
    'A', 'B', 'C', 'D', 'E'
          State-space matrices.  See 'Inputs' for details.

    'STNAME'
          The name of the states in SYS.  Cell vector containing
          strings for each state.  Default names are `{'x1', 'x2', ...}'

    'SCALED'
          Logical.  If set to true, no automatic scaling is used, e.g.
          for frequency response plots.

    'TSAM'
          Sampling time.  See 'Inputs' for details.

    'INNAME'
          The name of the input channels in SYS.  Cell vector of length
          m containing strings.  Default names are `{'u1', 'u2', ...}'

    'OUTNAME'
          The name of the output channels in SYS.  Cell vector of
          length p containing strings.  Default names are `{'y1', 'y2',
          ...}'

    'NAME'
          String containing the name of the model.

    'NOTES'
          String or cell of string containing comments.

    'USERDATA'
          Any data type.

     *Equations*
            .
          E x = A x + B u
            y = C x + D u

     See also: ss, tf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Create or convert to descriptor state-space model.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
estim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 654
 -- Function File: EST = estim (SYS, L)
 -- Function File: EST = estim (SYS, L, SENSORS, KNOWN)
     Return state estimator for a given estimator gain.

     *Inputs*
    SYS
          LTI model.

    L
          State feedback matrix.

    SENSORS
          Indices of measured output signals y from SYS.  If omitted,
          all outputs are measured.

    KNOWN
          Indices of known input signals u (deterministic) to SYS.  All
          other inputs to SYS are assumed stochastic.  If argument
          KNOWN is omitted, no inputs u are known.

     *Outputs*
    EST
          State-space model of estimator.

     See also: kalman, place





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return state estimator for a given estimator gain.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
filt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2489
 -- Function File: SYS = filt (NUM, DEN, ...)
 -- Function File: SYS = filt (NUM, DEN, TSAM, ...)
     Create discrete-time transfer function model from data in DSP
     format.

     *Inputs*
    NUM
          Numerator or cell of numerators.  Each numerator must be a
          row vector containing the coefficients of the polynomial in
          ascending powers of z^-1.  num{i,j} contains the numerator
          polynomial from input j to output i.  In the SISO case, a
          single vector is accepted as well.

    DEN
          Denominator or cell of denominators.  Each denominator must
          be a row vector containing the coefficients of the polynomial
          in ascending powers of z^-1.  den{i,j} contains the
          denominator polynomial from input j to output i.  In the SISO
          case, a single vector is accepted as well.

    TSAM
          Sampling time in seconds.  If TSAM is not specified, default
          value -1 (unspecified) is taken.

    ...
          Optional pairs of properties and values.  Type `set (filt)'
          for more information.

     *Outputs*
    SYS
          Discrete-time transfer function model.

     *Option Keys and Values*
    'NUM'
          Numerator.  See 'Inputs' for details.

    'DEN'
          Denominator.  See 'Inputs' for details.

    'TFVAR'
          String containing the transfer function variable.

    'INV'
          Logical.  True for negative powers of the transfer function
          variable.

    'TSAM'
          Sampling time.  See 'Inputs' for details.

    'INNAME'
          The name of the input channels in SYS.  Cell vector of length
          m containing strings.  Default names are `{'u1', 'u2', ...}'

    'OUTNAME'
          The name of the output channels in SYS.  Cell vector of
          length p containing strings.  Default names are `{'y1', 'y2',
          ...}'

    'NAME'
          String containing the name of the model.

    'NOTES'
          String or cell of string containing comments.

    'USERDATA'
          Any data type.

     *Example*
                          3 z^-1
          H(z^-1) = -------------------
                    1 + 4 z^-1 + 2 z^-2

          octave:1> H = filt ([0, 3], [1, 4, 2])

          Transfer function 'H' from input 'u1' to output ...

                      3 z^-1
           y1:  -------------------
                1 + 4 z^-1 + 2 z^-2

          Sampling time: unspecified
          Discrete-time model.

     See also: tf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Create discrete-time transfer function model from data in DSP format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fitfrd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1168
 -- Function File: [SYS, N] = fitfrd (DAT, N)
 -- Function File: [SYS, N] = fitfrd (DAT, N, FLAG)
     Fit frequency response data with a state-space system.  If
     requested, the returned system is stable and minimum-phase.

     *Inputs*
    DAT
          LTI model containing frequency response data of a SISO system.

    N
          The desired order of the system to be fitted.  `n <=
          length(dat.w)'.

    FLAG
          The flag controls whether the returned system is stable and
          minimum-phase.
         0
               The system zeros and poles are not constrained.  Default
               value.

         1
               The system zeros and poles will have negative real parts
               in the continuous-time case, or moduli less than 1 in
               the discrete-time case.

     *Outputs*
    SYS
          State-space model of order N, fitted to frequency response
          data DAT.

    N
          The order of the obtained system.  The value of N could only
          be modified if inputs `n > 0' and `flag = 1'.

     *Algorithm*
     Uses SLICOT SB10YD by courtesy of NICONET e.V.
     (http://www.slicot.org)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Fit frequency response data with a state-space system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
fwcfconred


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3221
 -- Function File: [KR, INFO] = fwcfconred (G, F, L, ...)
 -- Function File: [KR, INFO] = fwcfconred (G, F, L, NCR, ...)
 -- Function File: [KR, INFO] = fwcfconred (G, F, L, OPT, ...)
 -- Function File: [KR, INFO] = fwcfconred (G, F, L, NCR, OPT, ...)
     Reduction of state-feedback-observer based controller by
     frequency-weighted coprime factorization (FW CF).  Given a plant
     G, state feedback gain F and full observer gain L, determine a
     reduced order controller KR by using stability enforcing frequency
     weights.

     *Inputs*
    G
          LTI model of the open-loop plant (A,B,C,D).  It has m inputs,
          p outputs and n states.

    F
          Stabilizing state feedback matrix (m-by-n).

    L
          Stabilizing observer gain matrix (n-by-p).

    NCR
          The desired order of the resulting reduced order controller
          KR.  If not specified, NCR is chosen automatically according
          to the description of key 'ORDER'.

    ...
          Optional pairs of keys and values.  `"key1", value1, "key2",
          value2'.

    OPT
          Optional struct with keys as field names.  Struct OPT can be
          created directly or by command `options'.  `opt.key1 =
          value1, opt.key2 = value2'.

     *Outputs*
    KR
          State-space model of reduced order controller.

    INFO
          Struct containing additional information.
         INFO.HSV
               The Hankel singular values of the extended system?!?.
               The N Hankel singular values are ordered decreasingly.

         INFO.NCR
               The order of the obtained reduced order controller KR.

     *Option Keys and Values*
    'ORDER', 'NCR'
          The desired order of the resulting reduced order controller
          KR.  If not specified, NCR is chosen automatically such that
          states with Hankel singular values INFO.HSV > TOL1 are
          retained.

    'METHOD'
          Order reduction approach to be used as follows:
         'SR', 'B'
               Use the square-root Balance & Truncate method.

         'BFSR', 'F'
               Use the balancing-free square-root Balance & Truncate
               method.  Default method.

    'CF'
          Specifies whether left or right coprime factorization is to
          be used as follows:
         'LEFT', 'L'
               Use left coprime factorization.

         'RIGHT', 'R'
               Use right coprime factorization.  Default method.

    'FEEDBACK'
          Specifies whether F and L are fed back positively or
          negatively:
         '+'
               A+BK and A+LC are both Hurwitz matrices.

         '-'
               A-BK and A-LC are both Hurwitz matrices.  Default value.

    'TOL1'
          If 'ORDER' is not specified, TOL1 contains the tolerance for
          determining the order of the reduced system.  For model
          reduction, the recommended value of TOL1 is c*info.hsv(1),
          where c lies in the interval [0.00001, 0.001].  Default value
          is n*eps*info.hsv(1).  If 'ORDER' is specified, the value of
          TOL1 is ignored.

     *Algorithm*
     Uses SLICOT SB16CD by courtesy of NICONET e.V.
     (http://www.slicot.org)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Reduction of state-feedback-observer based controller by
frequency-weighted copr



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gensig


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 802
 -- Function File: [U, T] = gensig (SIGTYPE, TAU)
 -- Function File: [U, T] = gensig (SIGTYPE, TAU, TFINAL)
 -- Function File: [U, T] = gensig (SIGTYPE, TAU, TFINAL, TSAM)
     Generate periodic signal.  Useful in combination with lsim.

     *Inputs*
    SIGTYPE = "SIN"
          Sine wave.

    SIGTYPE = "COS"
          Cosine wave.

    SIGTYPE = "SQUARE"
          Square wave.

    SIGTYPE = "PULSE"
          Periodic pulse.

    TAU
          Duration of one period in seconds.

    TFINAL
          Optional duration of the signal in seconds.  Default duration
          is 5 periods.

    TSAM
          Optional sampling time in seconds.  Default spacing is tau/64.

     *Outputs*
    U
          Vector of signal values.

    T
          Time vector of the signal.

     See also: lsim





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Generate periodic signal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
gram


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 462
 -- Function File: W = gram (SYS, MODE)
 -- Function File: WC = gram (A, B)
     `gram (SYS, "c")' returns the controllability gramian of the
     (continuous- or discrete-time) system SYS.  `gram (SYS, "o")'
     returns the observability gramian of the (continuous- or
     discrete-time) system SYS.  `gram (A, B)' returns the
     controllability gramian WC of the continuous-time system dx/dt = a
     x + b u; i.e., WC satisfies a Wc + m Wc' + b b' = 0.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
`gram (SYS, "c")' returns the controllability gramian of the
(continuous- or dis



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
h2syn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1997
 -- Function File: [K, N, GAMMA, RCOND] = h2syn (P, NMEAS, NCON)
     H-2 control synthesis for LTI plant.

     *Inputs*
    P
          Generalized plant.  Must be a proper/realizable LTI model.

    NMEAS
          Number of measured outputs v.  The last NMEAS outputs of P
          are connected to the inputs of controller K.  The remaining
          outputs z (indices 1 to p-nmeas) are used to calculate the
          H-2 norm.

    NCON
          Number of controlled inputs u.  The last NCON inputs of P are
          connected to the outputs of controller K.  The remaining
          inputs w (indices 1 to m-ncon) are excited by a harmonic test
          signal.

     *Outputs*
    K
          State-space model of the H-2 optimal controller.

    N
          State-space model of the lower LFT of P and K.

    GAMMA
          H-2 norm of N.

    RCOND
          Vector RCOND contains estimates of the reciprocal condition
          numbers of the matrices which are to be inverted and
          estimates of the reciprocal condition numbers of the Riccati
          equations which have to be solved during the computation of
          the controller K.  For details, see the description of the
          corresponding SLICOT algorithm.

     *Block Diagram*

          gamma = min||N(K)||             N = lft (P, K)
                   K         2

                         +--------+
                 w ----->|        |-----> z
                         |  P(s)  |
                 u +---->|        |-----+ v
                   |     +--------+     |
                   |                    |
                   |     +--------+     |
                   +-----|  K(s)  |<----+
                         +--------+

                         +--------+
                 w ----->|  N(s)  |-----> z
                         +--------+

     *Algorithm*
     Uses SLICOT SB10HD and SB10ED by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: augw, lqr, dlqr, kalman





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
H-2 control synthesis for LTI plant.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hinfsyn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2269
 -- Function File: [K, N, GAMMA, RCOND] = hinfsyn (P, NMEAS, NCON)
 -- Function File: [K, N, GAMMA, RCOND] = hinfsyn (P, NMEAS, NCON, GMAX)
     H-infinity control synthesis for LTI plant.

     *Inputs*
    P
          Generalized plant.  Must be a proper/realizable LTI model.

    NMEAS
          Number of measured outputs v.  The last NMEAS outputs of P
          are connected to the inputs of controller K.  The remaining
          outputs z (indices 1 to p-nmeas) are used to calculate the
          H-infinity norm.

    NCON
          Number of controlled inputs u.  The last NCON inputs of P are
          connected to the outputs of controller K.  The remaining
          inputs w (indices 1 to m-ncon) are excited by a harmonic test
          signal.

    GMAX
          The maximum value of the H-infinity norm of N.  It is assumed
          that GMAX is sufficiently large so that the controller is
          admissible.

     *Outputs*
    K
          State-space model of the H-infinity (sub-)optimal controller.

    N
          State-space model of the lower LFT of P and K.

    GAMMA
          L-infinity norm of N.

    RCOND
          Vector RCOND contains estimates of the reciprocal condition
          numbers of the matrices which are to be inverted and
          estimates of the reciprocal condition numbers of the Riccati
          equations which have to be solved during the computation of
          the controller K.  For details, see the description of the
          corresponding SLICOT algorithm.

     *Block Diagram*

          gamma = min||N(K)||             N = lft (P, K)
                   K         inf

                         +--------+
                 w ----->|        |-----> z
                         |  P(s)  |
                 u +---->|        |-----+ v
                   |     +--------+     |
                   |                    |
                   |     +--------+     |
                   +-----|  K(s)  |<----+
                         +--------+

                         +--------+
                 w ----->|  N(s)  |-----> z
                         +--------+

     *Algorithm*
     Uses SLICOT SB10FD and SB10DD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: augw, mixsyn





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
H-infinity control synthesis for LTI plant.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
hnamodred


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6621
 -- Function File: [GR, INFO] = hnamodred (G, ...)
 -- Function File: [GR, INFO] = hnamodred (G, NR, ...)
 -- Function File: [GR, INFO] = hnamodred (G, OPT, ...)
 -- Function File: [GR, INFO] = hnamodred (G, NR, OPT, ...)
     Model order reduction by frequency weighted optimal Hankel-norm
     (HNA) method.  The aim of model reduction is to find an LTI system
     GR of order NR (nr < n) such that the input-output behaviour of GR
     approximates the one from original system G.

     HNA is an absolute error method which tries to minimize
          ||G-Gr||  = min
                  H

          ||V (G-Gr) W||  = min
                        H
     where V and W denote output and input weightings.

     *Inputs*
    G
          LTI model to be reduced.

    NR
          The desired order of the resulting reduced order system GR.
          If not specified, NR is chosen automatically according to the
          description of key "ORDER".

    ...
          Optional pairs of keys and values.  `"key1", value1, "key2",
          value2'.

    OPT
          Optional struct with keys as field names.  Struct OPT can be
          created directly or by command `options'.  `opt.key1 =
          value1, opt.key2 = value2'.

     *Outputs*
    GR
          Reduced order state-space model.

    INFO
          Struct containing additional information.
         INFO.N
               The order of the original system G.

         INFO.NS
               The order of the ALPHA-stable subsystem of the original
               system G.

         INFO.HSV
               The Hankel singular values corresponding to the
               projection `op(V)*G1*op(W)', where G1 denotes the
               ALPHA-stable part of the original system G.  The NS
               Hankel singular values are ordered decreasingly.

         INFO.NU
               The order of the ALPHA-unstable subsystem of both the
               original system G and the reduced-order system GR.

         INFO.NR
               The order of the obtained reduced order system GR.

     *Option Keys and Values*
    'ORDER', 'NR'
          The desired order of the resulting reduced order system GR.
          If not specified, NR is the sum of INFO.NU and the number of
          Hankel singular values greater than `max(tol1,
          ns*eps*info.hsv(1)';

    'METHOD'
          Specifies the computational approach to be used.  Valid
          values corresponding to this key are:
         'DESCRIPTOR'
               Use the inverse free descriptor system approach.

         'STANDARD'
               Use the inversion based standard approach.

         'AUTO'
               Switch automatically to the inverse free descriptor
               approach in case of badly conditioned feedthrough
               matrices in V or W.  Default method.

    'LEFT', 'V'
          LTI model of the left/output frequency weighting.  The
          weighting must be antistable.
               || V (G-Gr) . ||  = min
                               H

    'RIGHT', 'W'
          LTI model of the right/input frequency weighting.  The
          weighting must be antistable.
               || . (G-Gr) W ||  = min
                               H

    'LEFT-INV', 'INV-V'
          LTI model of the left/output frequency weighting.  The
          weighting must have only antistable zeros.
               || inv(V) (G-Gr) . ||  = min
                                    H

    'RIGHT-INV', 'INV-W'
          LTI model of the right/input frequency weighting.  The
          weighting must have only antistable zeros.
               || . (G-Gr) inv(W) ||  = min
                                    H

    'LEFT-CONJ', 'CONJ-V'
          LTI model of the left/output frequency weighting.  The
          weighting must be stable.
               || V (G-Gr) . ||  = min
                               H

    'RIGHT-CONJ', 'CONJ-W'
          LTI model of the right/input frequency weighting.  The
          weighting must be stable.
               || . (G-Gr) W ||  = min
                               H

    'LEFT-CONJ-INV', 'CONJ-INV-V'
          LTI model of the left/output frequency weighting.  The
          weighting must be minimum-phase.
               || V (G-Gr) . ||  = min
                               H

    'RIGHT-CONJ-INV', 'CONJ-INV-W'
          LTI model of the right/input frequency weighting.  The
          weighting must be minimum-phase.
               || . (G-Gr) W ||  = min
                               H

    'ALPHA'
          Specifies the ALPHA-stability boundary for the eigenvalues of
          the state dynamics matrix G.A.  For a continuous-time system,
          ALPHA <= 0 is the boundary value for the real parts of
          eigenvalues, while for a discrete-time system, 0 <= ALPHA <=
          1 represents the boundary value for the moduli of eigenvalues.
          The ALPHA-stability domain does not include the boundary.
          Default value is 0 for continuous-time systems and 1 for
          discrete-time systems.

    'TOL1'
          If 'ORDER' is not specified, TOL1 contains the tolerance for
          determining the order of the reduced model.  For model
          reduction, the recommended value of TOL1 is c*info.hsv(1),
          where c lies in the interval [0.00001, 0.001].  TOL1 < 1.  If
          'ORDER' is specified, the value of TOL1 is ignored.

    'TOL2'
          The tolerance for determining the order of a minimal
          realization of the ALPHA-stable part of the given model.
          TOL2 <= TOL1 < 1.  If not specified, ns*eps*info.hsv(1) is
          chosen.

    'EQUIL', 'SCALE'
          Boolean indicating whether equilibration (scaling) should be
          performed on system G prior to order reduction.  Default
          value is true if `G.scaled == false' and false if `G.scaled
          == true'.  Note that for MIMO models, proper scaling of both
          inputs and outputs is of utmost importance.  The input and
          output scaling can *not* be done by the equilibration option
          or the `prescale' command because these functions perform
          state transformations only.  Furthermore, signals should not
          be scaled simply to a certain range.  For all inputs (or
          outputs), a certain change should be of the same importance
          for the model.

     Approximation Properties:
        * Guaranteed stability of reduced models

        * Lower guaranteed error bound

        * Guaranteed a priori error bound

     *Algorithm*
     Uses SLICOT AB09JD by courtesy of NICONET e.V.
     (http://www.slicot.org)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Model order reduction by frequency weighted optimal Hankel-norm (HNA)
method.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
hsvd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 403
 -- Function File: HSV = hsvd (SYS)
 -- Function File: HSV = hsvd (SYS, "OFFSET", OFFSET)
 -- Function File: HSV = hsvd (SYS, "ALPHA", ALPHA)
     Hankel singular values of the stable part of an LTI model.  If no
     output arguments are given, the Hankel singular values are
     displayed in a plot.

     *Algorithm*
     Uses SLICOT AB13AD by courtesy of NICONET e.V.
     (http://www.slicot.org)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Hankel singular values of the stable part of an LTI model.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
impulse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1696
 -- Function File:  impulse (SYS)
 -- Function File:  impulse (SYS1, SYS2, ..., SYSN)
 -- Function File:  impulse (SYS1, 'STYLE1', ..., SYSN, 'STYLEN')
 -- Function File:  impulse (SYS1, ..., T)
 -- Function File:  impulse (SYS1, ..., TFINAL)
 -- Function File:  impulse (SYS1, ..., TFINAL, DT)
 -- Function File: [Y, T, X] = impulse (SYS)
 -- Function File: [Y, T, X] = impulse (SYS, T)
 -- Function File: [Y, T, X] = impulse (SYS, TFINAL)
 -- Function File: [Y, T, X] = impulse (SYS, TFINAL, DT)
     Impulse response of LTI system.  If no output arguments are given,
     the response is printed on the screen.

     *Inputs*
    SYS
          LTI model.

    T
          Time vector.  Should be evenly spaced.  If not specified, it
          is calculated by the poles of the system to reflect
          adequately the response transients.

    TFINAL
          Optional simulation horizon.  If not specified, it is
          calculated by the poles of the system to reflect adequately
          the response transients.

    DT
          Optional sampling time.  Be sure to choose it small enough to
          capture transient phenomena.  If not specified, it is
          calculated by the poles of the system.

    'STYLE'
          Line style and color, e.g. 'r' for a solid red line or '-.k'
          for a dash-dotted black line.  See `help plot' for details.

     *Outputs*
    Y
          Output response array.  Has as many rows as time samples
          (length of t) and as many columns as outputs.

    T
          Time row vector.

    X
          State trajectories array.  Has `length (t)' rows and as many
          columns as states.

     See also: initial, lsim, step





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Impulse response of LTI system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
initial


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2019
 -- Function File:  initial (SYS, X0)
 -- Function File:  initial (SYS1, SYS2, ..., SYSN, X0)
 -- Function File:  initial (SYS1, 'STYLE1', ..., SYSN, 'STYLEN', X0)
 -- Function File:  initial (SYS1, ..., X0, T)
 -- Function File:  initial (SYS1, ..., X0, TFINAL)
 -- Function File:  initial (SYS1, ..., X0, TFINAL, DT)
 -- Function File: [Y, T, X] = initial (SYS, X0)
 -- Function File: [Y, T, X] = initial (SYS, X0, T)
 -- Function File: [Y, T, X] = initial (SYS, X0, TFINAL)
 -- Function File: [Y, T, X] = initial (SYS, X0, TFINAL, DT)
     Initial condition response of state-space model.  If no output
     arguments are given, the response is printed on the screen.

     *Inputs*
    SYS
          State-space model.

    X0
          Vector of initial conditions for each state.

    T
          Optional time vector.  Should be evenly spaced.  If not
          specified, it is calculated by the poles of the system to
          reflect adequately the response transients.

    TFINAL
          Optional simulation horizon.  If not specified, it is
          calculated by the poles of the system to reflect adequately
          the response transients.

    DT
          Optional sampling time.  Be sure to choose it small enough to
          capture transient phenomena.  If not specified, it is
          calculated by the poles of the system.

    'STYLE'
          Line style and color, e.g. 'r' for a solid red line or '-.k'
          for a dash-dotted black line.  See `help plot' for details.

     *Outputs*
    Y
          Output response array.  Has as many rows as time samples
          (length of t) and as many columns as outputs.

    T
          Time row vector.

    X
          State trajectories array.  Has `length (t)' rows and as many
          columns as states.

     *Example*
                             .
          Continuous Time:   x = A x ,   y = C x ,   x(0) = x0

          Discrete Time:   x[k+1] = A x[k] ,   y[k] = C x[k] ,   x[0] = x0

     See also: impulse, lsim, step





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Initial condition response of state-space model.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isctrb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1302
 -- Function File: [BOOL, NCON] = isctrb (SYS)
 -- Function File: [BOOL, NCON] = isctrb (SYS, TOL)
 -- Function File: [BOOL, NCON] = isctrb (A, B)
 -- Function File: [BOOL, NCON] = isctrb (A, B, E)
 -- Function File: [BOOL, NCON] = isctrb (A, B, [], TOL)
 -- Function File: [BOOL, NCON] = isctrb (A, B, E, TOL)
     Logical check for system controllability.  For numerical reasons,
     `isctrb (sys)' should be used instead of `rank (ctrb (sys))'.

     *Inputs*
    SYS
          LTI model.  Descriptor state-space models are possible.  If
          SYS is not a state-space model, it is converted to a minimal
          state-space realization, so beware of pole-zero cancellations
          which may lead to wrong results!

    A
          State matrix (n-by-n).

    B
          Input matrix (n-by-m).

    E
          Descriptor matrix (n-by-n).  If E is empty `[]' or not
          specified, an identity matrix is assumed.

    TOL
          Optional roundoff parameter.  Default value is 0.

     *Outputs*
    BOOL = 0
          System is not controllable.

    BOOL = 1
          System is controllable.

    NCON
          Number of controllable states.

     *Algorithm*
     Uses SLICOT AB01OD and TG01HD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: isobsv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Logical check for system controllability.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
isdetectable


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1509
 -- Function File: BOOL = isdetectable (SYS)
 -- Function File: BOOL = isdetectable (SYS, TOL)
 -- Function File: BOOL = isdetectable (A, C)
 -- Function File: BOOL = isdetectable (A, C, E)
 -- Function File: BOOL = isdetectable (A, C, [], TOL)
 -- Function File: BOOL = isdetectable (A, C, E, TOL)
 -- Function File: BOOL = isdetectable (A, C, [], [], DFLG)
 -- Function File: BOOL = isdetectable (A, C, E, [], DFLG)
 -- Function File: BOOL = isdetectable (A, C, [], TOL, DFLG)
 -- Function File: BOOL = isdetectable (A, C, E, TOL, DFLG)
     Logical test for system detectability.  All unstable modes must be
     observable or all unobservable states must be stable.

     *Inputs*
    SYS
          LTI system.

    A
          State transition matrix.

    C
          Measurement matrix.

    E
          Descriptor matrix.  If E is empty `[]' or not specified, an
          identity matrix is assumed.

    TOL
          Optional tolerance for stability.  Default value is 0.

    DFLG = 0
          Matrices (A, C) are part of a continuous-time system.
          Default Value.

    DFLG = 1
          Matrices (A, C) are part of a discrete-time system.

     *Outputs*
    BOOL = 0
          System is not detectable.

    BOOL = 1
          System is detectable.

     *Algorithm*
     Uses SLICOT AB01OD and TG01HD by courtesy of NICONET e.V.
     (http://www.slicot.org) See `isstabilizable' for description of
     computational method.

     See also: isstabilizable, isstable, isctrb, isobsv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Logical test for system detectability.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isobsv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1110
 -- Function File: [BOOL, NOBS] = isobsv (SYS)
 -- Function File: [BOOL, NOBS] = isobsv (SYS, TOL)
 -- Function File: [BOOL, NOBS] = isobsv (A, C)
 -- Function File: [BOOL, NOBS] = isobsv (A, C, E)
 -- Function File: [BOOL, NOBS] = isobsv (A, C, [], TOL)
 -- Function File: [BOOL, NOBS] = isobsv (A, C, E, TOL)
     Logical check for system observability.  For numerical reasons,
     `isobsv (sys)' should be used instead of `rank (obsv (sys))'.

     *Inputs*
    SYS
          LTI model.  Descriptor state-space models are possible.

    A
          State matrix (n-by-n).

    C
          Measurement matrix (p-by-n).

    E
          Descriptor matrix (n-by-n).  If E is empty `[]' or not
          specified, an identity matrix is assumed.

    TOL
          Optional roundoff parameter.  Default value is 0.

     *Outputs*
    BOOL = 0
          System is not observable.

    BOOL = 1
          System is observable.

    NOBS
          Number of observable states.

     *Algorithm*
     Uses SLICOT AB01OD and TG01HD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: isctrb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Logical check for system observability.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
issample


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 614
 -- Function File: BOOL = issample (TS)
 -- Function File: BOOL = issample (TS, FLG)
     Return true if TS is a valid sampling time.

     *Inputs*
    TS
          Alleged sampling time to be tested.

    FLG = 1
          Accept real scalars TS > 0.  Default Value.

    FLG = 0
          Accept real scalars TS >= 0.

    FLG = -1
          Accept real scalars TS > 0 and TS == -1.

    FLG = -10
          Accept real scalars TS >= 0 and TS == -1.

    FLG = -2
          Accept real scalars TS >= 0, TS == -1 and TS == -2.

     *Outputs*
    BOOL
          True if conditions are met and false otherwise.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return true if TS is a valid sampling time.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
isstabilizable


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1967
 -- Function File: BOOL = isstabilizable (SYS)
 -- Function File: BOOL = isstabilizable (SYS, TOL)
 -- Function File: BOOL = isstabilizable (A, B)
 -- Function File: BOOL = isstabilizable (A, B, E)
 -- Function File: BOOL = isstabilizable (A, B, [], TOL)
 -- Function File: BOOL = isstabilizable (A, B, E, TOL)
 -- Function File: BOOL = isstabilizable (A, B, [], [], DFLG)
 -- Function File: BOOL = isstabilizable (A, B, E, [], DFLG)
 -- Function File: BOOL = isstabilizable (A, B, [], TOL, DFLG)
 -- Function File: BOOL = isstabilizable (A, B, E, TOL, DFLG)
     Logical check for system stabilizability.  All unstable modes must
     be controllable or all uncontrollable states must be stable.

     *Inputs*
    SYS
          LTI system.  If SYS is not a state-space system, it is
          converted to a minimal state-space realization, so beware of
          pole-zero cancellations which may lead to wrong results!

    A
          State transition matrix.

    B
          Input matrix.

    E
          Descriptor matrix.  If E is empty `[]' or not specified, an
          identity matrix is assumed.

    TOL
          Optional tolerance for stability.  Default value is 0.

    DFLG = 0
          Matrices (A, B) are part of a continuous-time system.
          Default Value.

    DFLG = 1
          Matrices (A, B) are part of a discrete-time system.

     *Outputs*
    BOOL = 0
          System is not stabilizable.

    BOOL = 1
          System is stabilizable.

     *Algorithm*
     Uses SLICOT AB01OD and TG01HD by courtesy of NICONET e.V.
     (http://www.slicot.org)
          * Calculate staircase form (SLICOT AB01OD)
          * Extract unobservable part of state transition matrix
          * Calculate eigenvalues of unobservable part
          * Check whether
            real (ev) < -tol*(1 + abs (ev))   continuous-time
            abs (ev) < 1 - tol                discrete-time

     See also: isdetectable, isstable, isctrb, isobsv





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Logical check for system stabilizability.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
kalman


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1539
 -- Function File: [EST, G, X] = kalman (SYS, Q, R)
 -- Function File: [EST, G, X] = kalman (SYS, Q, R, S)
 -- Function File: [EST, G, X] = kalman (SYS, Q, R, [], SENSORS, KNOWN)
 -- Function File: [EST, G, X] = kalman (SYS, Q, R, S, SENSORS, KNOWN)
     Design Kalman estimator for LTI systems.

     *Inputs*
    SYS
          Nominal plant model.

    Q
          Covariance of white process noise.

    R
          Covariance of white measurement noise.

    S
          Optional cross term covariance.  Default value is 0.

    SENSORS
          Indices of measured output signals y from SYS.  If omitted,
          all outputs are measured.

    KNOWN
          Indices of known input signals u (deterministic) to SYS.  All
          other inputs to SYS are assumed stochastic.  If argument
          KNOWN is omitted, no inputs u are known.

     *Outputs*
    EST
          State-space model of the Kalman estimator.

    G
          Estimator gain.

    X
          Solution of the Riccati equation.

     *Block Diagram*
                                           u  +-------+         ^
                +---------------------------->|       |-------> y
                |    +-------+     +       y  |  est  |         ^
          u ----+--->|       |----->(+)------>|       |-------> x
                     |  sys  |       ^ +      +-------+
          w -------->|       |       |
                     +-------+       | v

          Q = cov (w, w')     R = cov (v, v')     S = cov (w, v')

     See also: care, dare, estim, lqr





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Design Kalman estimator for LTI systems.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
lqe


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1685
 -- Function File: [L, P, E] = lqe (SYS, Q, R)
 -- Function File: [L, P, E] = lqe (SYS, Q, R, S)
 -- Function File: [L, P, E] = lqe (A, G, C, Q, R)
 -- Function File: [L, P, E] = lqe (A, G, C, Q, R, S)
 -- Function File: [L, P, E] = lqe (A, [], C, Q, R)
 -- Function File: [L, P, E] = lqe (A, [], C, Q, R, S)
     Kalman filter for continuous-time systems.

          .
          x = Ax + Bu + Gw   (State equation)
          y = Cx + Du + v    (Measurement Equation)
          E(w) = 0, E(v) = 0, cov(w) = Q, cov(v) = R, cov(w,v) = S

     *Inputs*
    SYS
          Continuous or discrete-time LTI model (p-by-m, n states).

    A
          State matrix of continuous-time system (n-by-n).

    G
          Process noise matrix of continuous-time system (n-by-g).  If
          G is empty `[]', an identity matrix is assumed.

    C
          Measurement matrix of continuous-time system (p-by-n).

    Q
          Process noise covariance matrix (g-by-g).

    R
          Measurement noise covariance matrix (p-by-p).

    S
          Optional cross term covariance matrix (g-by-p), s = cov(w,v).
          If S is empty `[]' or not specified, a zero matrix is assumed.

     *Outputs*
    L
          Kalman filter gain matrix (n-by-p).

    P
          Unique stabilizing solution of the continuous-time Riccati
          equation (n-by-n).  Symmetric matrix.  If SYS is a
          discrete-time model, the solution of the corresponding
          discrete-time Riccati equation is returned.

    E
          Closed-loop poles (n-by-1).

     *Equations*
          .
          x = Ax + Bu + L(y - Cx -Du)

          E = eig(A - L*C)

     See also: dare, care, dlqr, lqr, dlqe





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Kalman filter for continuous-time systems.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
lqr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1342
 -- Function File: [G, X, L] = lqr (SYS, Q, R)
 -- Function File: [G, X, L] = lqr (SYS, Q, R, S)
 -- Function File: [G, X, L] = lqr (A, B, Q, R)
 -- Function File: [G, X, L] = lqr (A, B, Q, R, S)
 -- Function File: [G, X, L] = lqr (A, B, Q, R, [], E)
 -- Function File: [G, X, L] = lqr (A, B, Q, R, S, E)
     Linear-quadratic regulator.

     *Inputs*
    SYS
          Continuous or discrete-time LTI model (p-by-m, n states).

    A
          State matrix of continuous-time system (n-by-n).

    B
          Input matrix of continuous-time system (n-by-m).

    Q
          State weighting matrix (n-by-n).

    R
          Input weighting matrix (m-by-m).

    S
          Optional cross term matrix (n-by-m).  If S is not specified,
          a zero matrix is assumed.

    E
          Optional descriptor matrix (n-by-n).  If E is not specified,
          an identity matrix is assumed.

     *Outputs*
    G
          State feedback matrix (m-by-n).

    X
          Unique stabilizing solution of the continuous-time Riccati
          equation (n-by-n).

    L
          Closed-loop poles (n-by-1).

     *Equations*
          .
          x = A x + B u,   x(0) = x0

                  inf
          J(x0) = INT (x' Q x  +  u' R u  +  2 x' S u)  dt
                   0

          L = eig (A - B*G)

     See also: care, dare, dlqr





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Linear-quadratic regulator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
lsim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1848
 -- Function File:  lsim (SYS, U)
 -- Function File:  lsim (SYS1, SYS2, ..., SYSN, U)
 -- Function File:  lsim (SYS1, 'STYLE1', ..., SYSN, 'STYLEN', U)
 -- Function File:  lsim (SYS1, ..., U, T)
 -- Function File:  lsim (SYS1, ..., U, T, X0)
 -- Function File: [Y, T, X] = lsim (SYS, U)
 -- Function File: [Y, T, X] = lsim (SYS, U, T)
 -- Function File: [Y, T, X] = lsim (SYS, U, T, X0)
     Simulate LTI model response to arbitrary inputs.  If no output
     arguments are given, the system response is plotted on the screen.

     *Inputs*
    SYS
          LTI model.  System must be proper, i.e. it must not have more
          zeros than poles.

    U
          Vector or array of input signal.  Needs `length(t)' rows and
          as many columns as there are inputs.  If SYS is a
          single-input system, row vectors U of length `length(t)' are
          accepted as well.

    T
          Time vector.  Should be evenly spaced.  If SYS is a
          continuous-time system and T is a real scalar, SYS is
          discretized with sampling time `tsam = t/(rows(u)-1)'.  If
          SYS is a discrete-time system and T is not specified, vector
          T is assumed to be `0 : tsam : tsam*(rows(u)-1)'.

    X0
          Vector of initial conditions for each state.  If not
          specified, a zero vector is assumed.

    'STYLE'
          Line style and color, e.g. 'r' for a solid red line or '-.k'
          for a dash-dotted black line.  See `help plot' for details.

     *Outputs*
    Y
          Output response array.  Has as many rows as time samples
          (length of t) and as many columns as outputs.

    T
          Time row vector.  It is always evenly spaced.

    X
          State trajectories array.  Has `length (t)' rows and as many
          columns as states.

     See also: impulse, initial, step





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Simulate LTI model response to arbitrary inputs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
ltimodels


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 144
 -- Function File: test ltimodels
 -- Function File: ltimodels
 -- Function File: ltimodels (SYSTYPE)
     Test suite and help for LTI models.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Test suite and help for LTI models.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
lyap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 527
 -- Function File: X = lyap (A, B)
 -- Function File: X = lyap (A, B, C)
 -- Function File: X = lyap (A, B, [], E)
     Solve continuous-time Lyapunov or Sylvester equations.

     *Equations*
          AX + XA' + B = 0      (Lyapunov Equation)

          AX + XB + C = 0       (Sylvester Equation)

          AXE' + EXA' + B = 0   (Generalized Lyapunov Equation)

     *Algorithm*
     Uses SLICOT SB03MD, SB04MD and SG03AD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: lyapchol, dlyap, dlyapchol





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Solve continuous-time Lyapunov or Sylvester equations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
lyapchol


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 479
 -- Function File: U = lyapchol (A, B)
 -- Function File: U = lyapchol (A, B, E)
     Compute Cholesky factor of continuous-time Lyapunov equations.

     *Equations*
          A U' U  +  U' U A'  +  B B'  =  0           (Lyapunov Equation)

          A U' U E'  +  E U' U A'  +  B B'  =  0      (Generalized Lyapunov Equation)

     *Algorithm*
     Uses SLICOT SB03OD and SG03BD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     See also: lyap, dlyap, dlyapchol





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Compute Cholesky factor of continuous-time Lyapunov equations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
margin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3109
 -- Function File: [GAMMA, PHI, W_GAMMA, W_PHI] = margin (SYS)
 -- Function File: [GAMMA, PHI, W_GAMMA, W_PHI] = margin (SYS, TOL)
     Gain and phase margin of a system.  If no output arguments are
     given, both gain and phase margin are plotted on a bode diagram.
     Otherwise, the margins and their corresponding frequencies are
     computed and returned.  A more robust criterion to assess the
     stability of a feedback system is the sensitivity Ms computed by
     command `sensitivity'.

     *Inputs*
    SYS
          LTI model.  Must be a single-input and single-output (SISO)
          system.

    TOL
          Imaginary parts below TOL are assumed to be zero.  If not
          specified, default value `sqrt (eps)' is taken.

     *Outputs*
    GAMMA
          Gain margin (as gain, not dBs).

    PHI
          Phase margin (in degrees).

    W_GAMMA
          Frequency for the gain margin (in rad/s).

    W_PHI
          Frequency for the phase margin (in rad/s).

     *Algorithm*
     Uses command `roots' to calculate the frequencies W_GAMMA, W_PHI
     from special polynomials created from the transfer function of SYS
     as listed below in section <<Equations>>.

     *Equations*
          CONTINUOUS-TIME SYSTEMS
          Gain Margin
                  _               _
          L(jw) = L(jw)      BTW: L(jw) = L(-jw) = conj (L(jw))

          num(jw)   num(-jw)
          ------- = --------
          den(jw)   den(-jw)

          num(jw) den(-jw) = num(-jw) den(jw)

          imag (num(jw) den(-jw)) = 0
          imag (num(-jw) den(jw)) = 0

          Phase Margin
                    |num(jw)|
          |L(jw)| = |-------| = 1
                    |den(jw)|
            _     2      2
          z z = Re z + Im z

          num(jw)   num(-jw)
          ------- * -------- = 1
          den(jw)   den(-jw)

          num(jw) num(-jw) - den(jw) den(-jw) = 0

          real (num(jw) num(-jw) - den(jw) den(-jw)) = 0

          DISCRETE-TIME SYSTEMS
          Gain Margin
                                       jwT         log z
          L(z) = L(1/z)      BTW: z = e    --> w = -----
                                                    j T
          num(z)   num(1/z)
          ------ = --------
          den(z)   den(1/z)

          num(z) den(1/z) - num(1/z) den(z) = 0

          Phase Margin
                   |num(z)|
          |L(z)| = |------| = 1
                   |den(z)|

          L(z) L(1/z) = 1

          num(z)   num(1/z)
          ------ * -------- = 1
          den(z)   den(1/z)

          num(z) num(1/z) - den(z) den(1/z) = 0

          PS: How to get L(1/z)
                    4       3       2
          p(z) = a z  +  b z  +  c z  +  d z  +  e

                      -4      -3      -2      -1
          p(1/z) = a z  +  b z  +  c z  +  d z  +  e

                    -4                    2       3       4
                 = z   ( a  +  b z  +  c z  +  d z  +  e z  )

                        4       3       2                     4
                 = ( e z  +  d z  +  c z  +  b z  +  a ) / ( z  )

     See also: sensitivity, roots





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Gain and phase margin of a system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mixsyn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6953
 -- Function File: [K, N, GAMMA, RCOND] = mixsyn (G, W1, W2, W3, ...)
     Solve stacked S/KS/T H-infinity problem.  Mixed-sensitivity is the
     name given to transfer function shaping problems in which the
     sensitivity function
                       -1
          S = (I + G K)
     is shaped along with one or more other closed-loop transfer
     functions such as K S or the complementary sensitivity function
                               -1
          T = I - S = (I + G K)
     in a typical one degree-of-freedom configuration, where G denotes
     the plant and K the (sub-)optimal controller to be found.  The
     shaping of multivariable transfer functions is based on the idea
     that a satisfactory definition of gain (range of gain) for a
     matrix transfer function is given by the singular values

     of the transfer function. Hence the classical loop-shaping ideas
     of feedback design can be generalized to multivariable systems.
     In addition to the requirement that K stabilizes G, the
     closed-loop objectives are as follows [1]:
       1. For _disturbance rejection_ make

          small.

       2. For _noise attenuation_ make

          small.

       3. For _reference tracking_ make

       4. For _input usage (control energy) reduction_ make

          small.

       5. For _robust stability_ in the presence of an additive
          perturbation

          make

          small.

       6. For _robust stability_ in the presence of a multiplicative
          output perturbation

          make

          small.
          In order to find a robust controller for the so-called stacked
     S/KS/T H-infinity problem, the user function `mixsyn' minimizes
     the following criterion
                                       | W1 S   |
          min || N(K) ||           N = | W2 K S |
           K            oo             | W3 T   |
     `[K, N] = mixsyn (G, W1, W2, W3)'.  The user-defined weighting
     functions W1, W2 and W3 bound the largest singular values of the
     closed-loop transfer functions S (for performance), K S (to
     penalize large inputs) and T (for robustness and to avoid
     sensitivity to noise), respectively [1].  A few points are to be
     considered when choosing the weights.  The weigths WI must all be
     proper and stable.  Therefore if one wishes, for example, to
     minimize S at low frequencies by a weighting W1 including integral
     action,
          1
          -
          s
     needs to be approximated by
            1
          -----    where   e << 1.
          s + e
     Similarly one might be interested in weighting K S with a
     non-proper weight W2 to ensure that K is small outside the system
     bandwidth.  The trick here is to replace a non-proper term such as
                          1 + T1 s
          1 + T1 s   by   --------,   where   T2 << T1.
                          1 + T2 s
     [1, 2].

     *Inputs*
    G
          LTI model of plant.

    W1
          LTI model of performance weight.  Bounds the largest singular
          values of sensitivity S.  Model must be empty `[]', SISO or
          of appropriate size.

    W2
          LTI model to penalize large control inputs.  Bounds the
          largest singular values of KS.  Model must be empty `[]',
          SISO or of appropriate size.

    W3
          LTI model of robustness and noise sensitivity weight.  Bounds
          the largest singular values of complementary sensitivity T.
          Model must be empty `[]', SISO or of appropriate size.

    ...
          Optional arguments of `hinfsyn'.  Type `help hinfsyn' for
          more information.

     All inputs must be proper/realizable.  Scalars, vectors and
     matrices are possible instead of LTI models.

     *Outputs*
    K
          State-space model of the H-infinity (sub-)optimal controller.

    N
          State-space model of the lower LFT of P and K.

    GAMMA
          L-infinity norm of N.

    RCOND
          Vector RCOND contains estimates of the reciprocal condition
          numbers of the matrices which are to be inverted and
          estimates of the reciprocal condition numbers of the Riccati
          equations which have to be solved during the computation of
          the controller K.  For details, see the description of the
          corresponding SLICOT algorithm.

     *Block Diagram*

                                              | W1 S   |
          gamma = min||N(K)||             N = | W2 K S | = lft (P, K)
                   K         inf              | W3 T   |

                                                                +------+  z1
                      +---------------------------------------->|  W1  |----->
                      |                                         +------+
                      |                                         +------+  z2
                      |                 +---------------------->|  W2  |----->
                      |                 |                       +------+
           r   +    e |   +--------+  u |   +--------+  y       +------+  z3
          ----->(+)---+-->|  K(s)  |----+-->|  G(s)  |----+---->|  W3  |----->
                 ^ -      +--------+        +--------+    |     +------+
                 |                                        |
                 +----------------------------------------+

                         +--------+
                         |        |-----> z1 (p1x1)          z1 = W1 e
           r (px1) ----->|  P(s)  |-----> z2 (p2x1)          z2 = W2 u
                         |        |-----> z3 (p3x1)          z3 = W3 y
           u (mx1) ----->|        |-----> e (px1)            e = r - y
                         +--------+

                         +--------+
                 r ----->|        |-----> z
                         |  P(s)  |
                 u +---->|        |-----+ e
                   |     +--------+     |
                   |                    |
                   |     +--------+     |
                   +-----|  K(s)  |<----+
                         +--------+

                         +--------+
                 r ----->|  N(s)  |-----> z
                         +--------+

          Extended Plant:  P = augw (G, W1, W2, W3)
          Controller:      K = mixsyn (G, W1, W2, W3)
          Entire System:   N = lft (P, K)
          Open Loop:       L = G * K
          Closed Loop:     T = feedback (L)

     *Algorithm*
     Relies on commands `augw' and `hinfsyn', which use SLICOT SB10FD
     and SB10DD by courtesy of NICONET e.V. (http://www.slicot.org)

     *References*
     [1] Skogestad, S. and Postlethwaite I. (2005) `Multivariable
     Feedback Control: Analysis and Design: Second Edition'.  Wiley,
     Chichester, England.
     [2] Meinsma, G. (1995) `Unstable and nonproper weights in
     H-infinity control' Automatica, Vol. 31, No. 11, pp. 1655-1658

     See also: hinfsyn, augw





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Solve stacked S/KS/T H-infinity problem.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
moen4


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5469
 -- Function File: [SYS, X0, INFO] = moen4 (DAT, ...)
 -- Function File: [SYS, X0, INFO] = moen4 (DAT, N, ...)
 -- Function File: [SYS, X0, INFO] = moen4 (DAT, OPT, ...)
 -- Function File: [SYS, X0, INFO] = moen4 (DAT, N, OPT, ...)
     Estimate state-space model using combined subspace method: MOESP
     algorithm for finding the matrices A and C, and N4SID algorithm
     for finding the matrices B and D.  If no output arguments are
     given, the singular values are plotted on the screen in order to
     estimate the system order.

     *Inputs*
    DAT
          iddata set containing the measurements, i.e. time-domain
          signals.

    N
          The desired order of the resulting state-space system SYS.
          If not specified, N is chosen automatically according to the
          singular values and tolerances.

    ...
          Optional pairs of keys and values.  `'key1', value1, 'key2',
          value2'.

    OPT
          Optional struct with keys as field names.  Struct OPT can be
          created directly or by command `options'.  `opt.key1 =
          value1, opt.key2 = value2'.

     *Outputs*
    SYS
          Discrete-time state-space model.

    X0
          Initial state vector.  If DAT is a multi-experiment dataset,
          X0 becomes a cell vector containing an initial state vector
          for each experiment.

    INFO
          Struct containing additional information.
         INFO.K
               Kalman gain matrix.

         INFO.Q
               State covariance matrix.

         INFO.RY
               Output covariance matrix.

         INFO.S
               State-output cross-covariance matrix.

         INFO.L
               Noise variance matrix factor. LL'=Ry.

     *Option Keys and Values*
    'N'
          The desired order of the resulting state-space system SYS.  S
          > N > 0.

    'S'
          The number of block rows S in the input and output block
          Hankel matrices to be processed.  S > 0.  In the MOESP
          theory, S should be larger than N, the estimated dimension of
          state vector.

    'ALG', 'ALGORITHM'
          Specifies the algorithm for computing the triangular factor
          R, as follows:
         'C'
               Cholesky algorithm applied to the correlation matrix of
               the input-output data.  Default method.

         'F'
               Fast QR algorithm.

         'Q'
               QR algorithm applied to the concatenated block Hankel
               matrices.

    'TOL'
          Absolute tolerance used for determining an estimate of the
          system order.  If  TOL >= 0,  the estimate is indicated by
          the index of the last singular value greater than or equal to
          TOL.  (Singular values less than TOL are considered as zero.)
          When  TOL = 0,  an internally computed default value,  TOL =
          S*EPS*SV(1),  is used, where  SV(1)  is the maximal singular
          value, and EPS is the relative machine precision.  When TOL <
          0,  the estimate is indicated by the index of the singular
          value that has the largest logarithmic gap to its successor.
          Default value is 0.

    'RCOND'
          The tolerance to be used for estimating the rank of matrices.
          If the user sets RCOND > 0,  the given value of RCOND is used
          as a lower bound for the reciprocal condition number;  an
          m-by-n matrix whose estimated condition number is less than
          1/RCOND  is considered to be of full rank.  If the user sets
          RCOND <= 0,  then an implicitly computed, default tolerance,
          defined by RCOND = m*n*EPS,  is used instead, where EPS is the
          relative machine precision.  Default value is 0.

    'CONFIRM'
          Specifies whether or not the user's confirmation of the
          system order estimate is desired, as follows:
         TRUE
               User's confirmation.

         FALSE
               No confirmation.  Default value.

    'NOISEINPUT'
          The desired type of noise input channels.
         'N'
               No error inputs.  Default value.
                    x[k+1] = A x[k] + B u[k]
                    y[k]   = C x[k] + D u[k]

         'E'
               Return SYS as a (p-by-m+p) state-space model with both
               measured input channels u and noise channels e with
               covariance matrix RY.
                    x[k+1] = A x[k] + B u[k] + K e[k]
                    y[k]   = C x[k] + D u[k] +   e[k]

         'V'
               Return SYS as a (p-by-m+p) state-space model with both
               measured input channels u and white noise channels v
               with identity covariance matrix.
                    x[k+1] = A x[k] + B u[k] + K L v[k]
                    y[k]   = C x[k] + D u[k] +   L v[k]
                    e = L v,  L L' = Ry

         'K'
               Return SYS as a Kalman predictor for simulation.
                    ^          ^                        ^
                    x[k+1] = A x[k] + B u[k] + K(y[k] - y[k])
                    ^          ^
                    y[k]   = C x[k] + D u[k]

                    ^               ^
                    x[k+1] = (A-KC) x[k] + (B-KD) u[k] + K y[k]
                    ^          ^
                    y[k]   = C x[k] + D u[k] + 0 y[k]

     *Algorithm*
     Uses SLICOT IB01AD, IB01BD and IB01CD by courtesy of NICONET e.V.
     (http://www.slicot.org)





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Estimate state-space model using combined subspace method: MOESP
algorithm for f



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
moesp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5399
 -- Function File: [SYS, X0, INFO] = moesp (DAT, ...)
 -- Function File: [SYS, X0, INFO] = moesp (DAT, N, ...)
 -- Function File: [SYS, X0, INFO] = moesp (DAT, OPT, ...)
 -- Function File: [SYS, X0, INFO] = moesp (DAT, N, OPT, ...)
     Estimate state-space model using MOESP algorithm.  MOESP:
     Multivariable Output Error State sPace.  If no output arguments
     are given, the singular values are plotted on the screen in order
     to estimate the system order.

     *Inputs*
    DAT
          iddata set containing the measurements, i.e. time-domain
          signals.

    N
          The desired order of the resulting state-space system SYS.
          If not specified, N is chosen automatically according to the
          singular values and tolerances.

    ...
          Optional pairs of keys and values.  `'key1', value1, 'key2',
          value2'.

    OPT
          Optional struct with keys as field names.  Struct OPT can be
          created directly or by command `options'.  `opt.key1 =
          value1, opt.key2 = value2'.

     *Outputs*
    SYS
          Discrete-time state-space model.

    X0
          Initial state vector.  If DAT is a multi-experiment dataset,
          X0 becomes a cell vector containing an initial state vector
          for each experiment.

    INFO
          Struct containing additional information.
         INFO.K
               Kalman gain matrix.

         INFO.Q
               State covariance matrix.

         INFO.RY
               Output covariance matrix.

         INFO.S
               State-output cross-covariance matrix.

         INFO.L
               Noise variance matrix factor. LL'=Ry.

     *Option Keys and Values*
    'N'
          The desired order of the resulting state-space system SYS.  S
          > N > 0.

    'S'
          The number of block rows S in the input and output block
          Hankel matrices to be processed.  S > 0.  In the MOESP
          theory, S should be larger than N, the estimated dimension of
          state vector.

    'ALG', 'ALGORITHM'
          Specifies the algorithm for computing the triangular factor
          R, as follows:
         'C'
               Cholesky algorithm applied to the correlation matrix of
               the input-output data.  Default method.

         'F'
               Fast QR algorithm.

         'Q'
               QR algorithm applied to the concatenated block Hankel
               matrices.

    'TOL'
          Absolute tolerance used for determining an estimate of the
          system order.  If  TOL >= 0,  the estimate is indicated by
          the index of the last singular value greater than or equal to
          TOL.  (Singular values less than TOL are considered as zero.)
          When  TOL = 0,  an internally computed default value,  TOL =
          S*EPS*SV(1),  is used, where  SV(1)  is the maximal singular
          value, and EPS is the relative machine precision.  When TOL <
          0,  the estimate is indicated by the index of the singular
          value that has the largest logarithmic gap to its successor.
          Default value is 0.

    'RCOND'
          The tolerance to be used for estimating the rank of matrices.
          If the user sets RCOND > 0,  the given value of RCOND is used
          as a lower bound for the reciprocal condition number;  an
          m-by-n matrix whose estimated condition number is less than
          1/RCOND  is considered to be of full rank.  If the user sets
          RCOND <= 0,  then an implicitly computed, default tolerance,
          defined by RCOND = m*n*EPS,  is used instead, where EPS is the
          relative machine precision.  Default value is 0.

    'CONFIRM'
          Specifies whether or not the user's confirmation of the
          system order estimate is desired, as follows:
         TRUE
               User's confirmation.

         FALSE
               No confirmation.  Default value.

    'NOISEINPUT'
          The desired type of noise input channels.
         'N'
               No error inputs.  Default value.
                    x[k+1] = A x[k] + B u[k]
                    y[k]   = C x[k] + D u[k]

         'E'
               Return SYS as a (p-by-m+p) state-space model with both
               measured input channels u and noise channels e with
               covariance matrix RY.
                    x[k+1] = A x[k] + B u[k] + K e[k]
                    y[k]   = C x[k] + D u[k] +   e[k]

         'V'
               Return SYS as a (p-by-m+p) state-space model with both
               measured input channels u and white noise channels v
               with identity covariance matrix.
                    x[k+1] = A x[k] + B u[k] + K L v[k]
                    y[k]   = C x[k] + D u[k] +   L v[k]
                    e = L v,  L L' = Ry

         'K'
               Return SYS as a Kalman predictor for simulation.
                    ^          ^                        ^
                    x[k+1] = A x[k] + B u[k] + K(y[k] - y[k])
                    ^          ^
                    y[k]   = C x[k] + D u[k]

                    ^               ^
                    x[k+1] = (A-KC) x[k] + (B-KD) u[k] + K y[k]
                    ^          ^
                    y[k]   = C x[k] + D u[k] + 0 y[k]

     *Algorithm*
     Uses SLICOT IB01AD, IB01BD and IB01CD by courtesy of NICONET e.V.
     (http://www.slicot.org)





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Estimate state-space model using MOESP algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
n4sid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5426
 -- Function File: [SYS, X0, INFO] = n4sid (DAT, ...)
 -- Function File: [SYS, X0, INFO] = n4sid (DAT, N, ...)
 -- Function File: [SYS, X0, INFO] = n4sid (DAT, OPT, ...)
 -- Function File: [SYS, X0, INFO] = n4sid (DAT, N, OPT, ...)
     Estimate state-space model using N4SID algorithm.  N4SID:
     Numerical algorithm for Subspace State Space System IDentification.
     If no output arguments are given, the singular values are plotted
     on the screen in order to estimate the system order.

     *Inputs*
    DAT
          iddata set containing the measurements, i.e. time-domain
          signals.

    N
          The desired order of the resulting state-space system SYS.
          If not specified, N is chosen automatically according to the
          singular values and tolerances.

    ...
          Optional pairs of keys and values.  `'key1', value1, 'key2',
          value2'.

    OPT
          Optional struct with keys as field names.  Struct OPT can be
          created directly or by command `options'.  `opt.key1 =
          value1, opt.key2 = value2'.

     *Outputs*
    SYS
          Discrete-time state-space model.

    X0
          Initial state vector.  If DAT is a multi-experiment dataset,
          X0 becomes a cell vector containing an initial state vector
          for each experiment.

    INFO
          Struct containing additional information.
         INFO.K
               Kalman gain matrix.

         INFO.Q
               State covariance matrix.

         INFO.RY
               Output covariance matrix.

         INFO.S
               State-output cross-covariance matrix.

         INFO.L
               Noise variance matrix factor. LL'=Ry.

     *Option Keys and Values*
    'N'
          The desired order of the resulting state-space system SYS.  S
          > N > 0.

    'S'
          The number of block rows S in the input and output block
          Hankel matrices to be processed.  S > 0.  In the MOESP
          theory, S should be larger than N, the estimated dimension of
          state vector.

    'ALG', 'ALGORITHM'
          Specifies the algorithm for computing the triangular factor
          R, as follows:
         'C'
               Cholesky algorithm applied to the correlation matrix of
               the input-output data.  Default method.

         'F'
               Fast QR algorithm.

         'Q'
               QR algorithm applied to the concatenated block Hankel
               matrices.

    'TOL'
          Absolute tolerance used for determining an estimate of the
          system order.  If  TOL >= 0,  the estimate is indicated by
          the index of the last singular value greater than or equal to
          TOL.  (Singular values less than TOL are considered as zero.)
          When  TOL = 0,  an internally computed default value,  TOL =
          S*EPS*SV(1),  is used, where  SV(1)  is the maximal singular
          value, and EPS is the relative machine precision.  When TOL <
          0,  the estimate is indicated by the index of the singular
          value that has the largest logarithmic gap to its successor.
          Default value is 0.

    'RCOND'
          The tolerance to be used for estimating the rank of matrices.
          If the user sets RCOND > 0,  the given value of RCOND is used
          as a lower bound for the reciprocal condition number;  an
          m-by-n matrix whose estimated condition number is less than
          1/RCOND  is considered to be of full rank.  If the user sets
          RCOND <= 0,  then an implicitly computed, default tolerance,
          defined by RCOND = m*n*EPS,  is used instead, where EPS is the
          relative machine precision.  Default value is 0.

    'CONFIRM'
          Specifies whether or not the user's confirmation of the
          system order estimate is desired, as follows:
         TRUE
               User's confirmation.

         FALSE
               No confirmation.  Default value.

    'NOISEINPUT'
          The desired type of noise input channels.
         'N'
               No error inputs.  Default value.
                    x[k+1] = A x[k] + B u[k]
                    y[k]   = C x[k] + D u[k]

         'E'
               Return SYS as a (p-by-m+p) state-space model with both
               measured input channels u and noise channels e with
               covariance matrix RY.
                    x[k+1] = A x[k] + B u[k] + K e[k]
                    y[k]   = C x[k] + D u[k] +   e[k]

         'V'
               Return SYS as a (p-by-m+p) state-space model with both
               measured input channels u and white noise channels v
               with identity covariance matrix.
                    x[k+1] = A x[k] + B u[k] + K L v[k]
                    y[k]   = C x[k] + D u[k] +   L v[k]
                    e = L v,  L L' = Ry

         'K'
               Return SYS as a Kalman predictor for simulation.
                    ^          ^                        ^
                    x[k+1] = A x[k] + B u[k] + K(y[k] - y[k])
                    ^          ^
                    y[k]   = C x[k] + D u[k]

                    ^               ^
                    x[k+1] = (A-KC) x[k] + (B-KD) u[k] + K y[k]
                    ^          ^
                    y[k]   = C x[k] + D u[k] + 0 y[k]

     *Algorithm*
     Uses SLICOT IB01AD, IB01BD and IB01CD by courtesy of NICONET e.V.
     (http://www.slicot.org)





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Estimate state-space model using N4SID algorithm.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ncfsyn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4749
 -- Function File: [K, N, GAMMA, INFO] = ncfsyn (G, W1, W2, FACTOR)
     Loop shaping H-infinity synthesis.  Compute positive feedback
     controller using the McFarlane/Glover loop shaping design
     procedure [1].  Using a precompensator W1 and/or a postcompensator
     W2, the singular values of the nominal plant G are shaped to give
     a desired open-loop shape.  The nominal plant G and shaping
     functions W1, W2 are combined to form the shaped plant, GS where
     `Gs = W2 G W1'.  We assume that W1 and W2 are such that GS
     contains no hidden modes.  It is relatively easy to approximate
     the closed-loop requirements by the following open-loop objectives
     [2]:
       1. For _disturbance rejection_ make

          large; valid for frequencies at which

       2. For _noise attenuation_ make

          small; valid for frequencies at which

       3. For _reference tracking_ make

          large; valid for frequencies at which

       4. For _robust stability_ to a multiplicative output perturbation


          small; valid for frequencies at which
               .
          Then a stabilizing controller KS is synthesized for shaped
     plant GS.  The final positive feedback controller K is then
     constructed by combining the
          H-infinity
     controller KS with the shaping functions W1 and W2 such that `K =
     W1 Ks W2'.  In [1] is stated further that the given robust
     stabilization objective can be interpreted as a
          H-infinity
     problem formulation of minimizing the
          H-infinity
     norm of the frequency weighted gain from disturbances on the plant
     input and output to the controller input and output as follows:
                                        -1            -1            -1
          min || N(K) ||   ,    N = | W1   | (I - K G)   | W1   G W2   |
           K            oo          | W2 G |

     `[K, N] = ncfsyn (G, W1, W2, f)' The function `ncfsyn' - the
     somewhat cryptic name stands for _normalized coprime factorization
     synthesis_ - allows the specification of an additional argument,
     factor F.  Default value `f = 1' implies that an optimal
     controller is required, whereas `f > 1' implies that a suboptimal
     controller is required, achieving a performance that is F times
     less than optimal.

     *Inputs*
    G
          LTI model of plant.

    W1
          LTI model of precompensator.  Model must be SISO or of
          appropriate size.  An identity matrix is taken if W1 is not
          specified or if an empty model `[]' is passed.

    W2
          LTI model of postcompensator.  Model must be SISO or of
          appropriate size.  An identity matrix is taken if W2 is not
          specified or if an empty model `[]' is passed.

    FACTOR
          `factor = 1' implies that an optimal controller is required.
          `factor > 1' implies that a suboptimal controller is required,
          achieving a performance that is FACTOR times less than
          optimal.  Default value is 1.

     *Outputs*
    K
          State-space model of the H-infinity loop-shaping controller.

    N
          State-space model of the closed loop depicted below.

    GAMMA
          L-infinity norm of N.  `gamma = norm (N, inf)'.

    INFO
          Structure containing additional information.

    INFO.EMAX
          Nugap robustness.  `emax = inv (gamma)'.

    INFO.GS
          Shaped plant.  `Gs = W2 * G * W1'.

    INFO.KS
          Controller for shaped plant.  `Ks = ncfsyn (Gs)'.

    INFO.RCOND
          Estimates of the reciprocal condition numbers of the Riccati
          equations and a few other things.  For details, see the
          description of the corresponding SLICOT algorithm.

     *Block Diagram of N*

                      ^ z1              ^ z2
                      |                 |
           w1  +      |   +--------+    |            +--------+
          ----->(+)---+-->|   Ks   |----+--->(+)---->|   Gs   |----+
                 ^ +      +--------+          ^      +--------+    |
                 |                        w2  |                    |
                 |                                                 |
                 +-------------------------------------------------+

     *Algorithm*
     Uses SLICOT SB10ID, SB10KD and SB10ZD by courtesy of NICONET e.V.
     (http://www.slicot.org)

     *References*
     [1] D. McFarlane and K. Glover, `A Loop Shaping Design Procedure
     Using H-infinity Synthesis', IEEE Transactions on Automatic
     Control, Vol. 37, No. 6, June 1992.
     [2] S. Skogestad and I. Postlethwaite, `Multivariable Feedback
     Control: Analysis and Design: Second Edition'.  Wiley, Chichester,
     England, 2005.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Loop shaping H-infinity synthesis.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nichols


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1255
 -- Function File:  nichols (SYS)
 -- Function File:  nichols (SYS1, SYS2, ..., SYSN)
 -- Function File:  nichols (SYS1, SYS2, ..., SYSN, W)
 -- Function File:  nichols (SYS1, 'STYLE1', ..., SYSN, 'STYLEN')
 -- Function File: [MAG, PHA, W] = nichols (SYS)
 -- Function File: [MAG, PHA, W] = nichols (SYS, W)
     Nichols chart of frequency response.  If no output arguments are
     given, the response is printed on the screen.

     *Inputs*
    SYS
          LTI system.  Must be a single-input and single-output (SISO)
          system.

    W
          Optional vector of frequency values.  If W is not specified,
          it is calculated by the zeros and poles of the system.
          Alternatively, the cell `{wmin, wmax}' specifies a frequency
          range, where WMIN and WMAX denote minimum and maximum
          frequencies in rad/s.

    'STYLE'
          Line style and color, e.g. 'r' for a solid red line or '-.k'
          for a dash-dotted black line.  See `help plot' for details.

     *Outputs*
    MAG
          Vector of magnitude.  Has length of frequency vector W.

    PHA
          Vector of phase.  Has length of frequency vector W.

    W
          Vector of frequency values used.

     See also: bode, nyquist, sigma





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Nichols chart of frequency response.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nyquist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1262
 -- Function File:  nyquist (SYS)
 -- Function File:  nyquist (SYS1, SYS2, ..., SYSN)
 -- Function File:  nyquist (SYS1, SYS2, ..., SYSN, W)
 -- Function File:  nyquist (SYS1, 'STYLE1', ..., SYSN, 'STYLEN')
 -- Function File: [RE, IM, W] = nyquist (SYS)
 -- Function File: [RE, IM, W] = nyquist (SYS, W)
     Nyquist diagram of frequency response.  If no output arguments are
     given, the response is printed on the screen.

     *Inputs*
    SYS
          LTI system.  Must be a single-input and single-output (SISO)
          system.

    W
          Optional vector of frequency values.  If W is not specified,
          it is calculated by the zeros and poles of the system.
          Alternatively, the cell `{wmin, wmax}' specifies a frequency
          range, where WMIN and WMAX denote minimum and maximum
          frequencies in rad/s.

    'STYLE'
          Line style and color, e.g. 'r' for a solid red line or '-.k'
          for a dash-dotted black line.  See `help plot' for details.

     *Outputs*
    RE
          Vector of real parts.  Has length of frequency vector W.

    IM
          Vector of imaginary parts.  Has length of frequency vector W.

    W
          Vector of frequency values used.

     See also: bode, nichols, sigma





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Nyquist diagram of frequency response.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
obsv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 448
 -- Function File: OB = obsv (SYS)
 -- Function File: OB = obsv (A, C)
     Return observability matrix.

     *Inputs*
    SYS
          LTI model.

    A
          State matrix (n-by-n).

    C
          Measurement matrix (p-by-n).

     *Outputs*
    OB
          Observability matrix.

     *Equation*
               | C        |
               | CA       |
          Ob = | CA^2     |
               | ...      |
               | CA^(n-1) |




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Return observability matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
obsvf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 927
 -- Function File: [SYSBAR, T, K] = obsvf (SYS)
 -- Function File: [SYSBAR, T, K] = obsvf (SYS, TOL)
 -- Function File: [ABAR, BBAR, CBAR, T, K] = obsvf (A, B, C)
 -- Function File: [ABAR, BBAR, CBAR, T, K] = obsvf (A, B, C, TOL)
     If Ob=obsv(A,C) has rank r <= n = SIZE(A,1), then there is a
     similarity transformation Tc such that To = [t1;t2] where t1 is c
     and t2 is orthogonal to t1

          Abar = To \\ A * To ,  Bbar = To \\ B ,  Cbar = C * To

     and the transformed system has the form

                 | Ao     0 |           | Bo  |
          Abar = |----------|,   Bbar = | --- |,  Cbar = [Co | 0 ].
                 | A21   Ano|           | Bno |

     where (Ao,Bo) is observable, and Co(sI-Ao)^(-1)Bo = C(sI-A)^(-1)B.
     And system is detectable if Ano has no eigenvalues in the right
     half plane. The last output K is a vector of length n containing
     the number of observable states.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If Ob=obsv(A,C) has rank r <= n = SIZE(A,1), then there is a similarity
transfor



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
optiPID


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 235
Numerical optimization of a PID controller using an objective function.
The objective function is located in the file `optiPIDfun'.  Type
`which optiPID' to locate, `edit optiPID' to open and simply `optiPID'
to run the example file.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Numerical optimization of a PID controller using an objective function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
optiPIDctrl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 397
 ===============================================================================
 optiPIDctrl                      Lukas Reichlin                   February 2012
 ===============================================================================
 Return PID controller with roll-off for given parameters Kp, Ti and Td.
 ===============================================================================



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 ===============================================================================



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
optiPIDfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 464
 ===============================================================================
 optiPIDfun                       Lukas Reichlin                       July 2009
 ===============================================================================
 Objective Function
 Reference: Guzzella, L. (2007) Analysis and Synthesis of SISO Control Systems.
            vdf Hochschulverlag, Zurich
 ===============================================================================



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 ===============================================================================



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 791
 -- Function File: OPT = options ("KEY1", VALUE1, "KEY2", VALUE2, ...)
     Create options struct OPT from a number of key and value pairs.
     For use with order reduction commands.

     *Inputs*
    KEY, PROPERTY
          The name of the property.

    VALUE
          The value of the property.

     *Outputs*
    OPT
          Struct with fields for each key.

     *Example*
          octave:1> opt = options ("method", "spa", "tol", 1e-6)
          opt =

            scalar structure containing the fields:

              method = spa
              tol =  1.0000e-06

          octave:2> save filename opt
          octave:3> # save the struct 'opt' to file 'filename' for later use
          octave:4> load filename
          octave:5> # load struct 'opt' from file 'filename'





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Create options struct OPT from a number of key and value pairs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
place


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1996
 -- Function File: F = place (SYS, P)
 -- Function File: F = place (A, B, P)
 -- Function File: [F, INFO] = place (SYS, P, ALPHA)
 -- Function File: [F, INFO] = place (A, B, P, ALPHA)
     Pole assignment for a given matrix pair (A,B) such that `p = eig
     (A-B*F)'.  If parameter ALPHA is specified, poles with real parts
     (continuous-time) or moduli (discrete-time) below ALPHA are left
     untouched.

     *Inputs*
    SYS
          Continuous- or discrete-time LTI system.

    A
          State matrix (n-by-n) of a continuous-time system.

    B
          Input matrix (n-by-m) of a continuous-time system.

    P
          Desired eigenvalues of the closed-loop system state-matrix
          A-B*F.  `length (p) <= rows (A)'.

    ALPHA
          Specifies the maximum admissible value, either for real parts
          or for moduli, of the eigenvalues of A which will not be
          modified by the eigenvalue assignment algorithm.  `alpha >=
          0' for discrete-time systems.

     *Outputs*
    F
          State feedback gain matrix.

    INFO
          Structure containing additional information.

    INFO.NFP
          The number of fixed poles, i.e. eigenvalues of A having real
          parts less than ALPHA, or moduli less than ALPHA.  These
          eigenvalues are not modified by `place'.

    INFO.NAP
          The number of assigned eigenvalues.  `nap = n-nfp-nup'.

    INFO.NUP
          The number of uncontrollable eigenvalues detected by the
          eigenvalue assignment algorithm.

    INFO.Z
          The orthogonal matrix Z reduces the closed-loop system state
          matrix `A + B*F' to upper real Schur form.  Note the positive
          sign in `A + B*F'.

     *Note*
          Place is also suitable to design estimator gains:
          L = place (A.', C.', p).'
          L = place (sys.', p).'   # useful for discrete-time systems

     *Algorithm*
     Uses SLICOT SB01BD by courtesy of NICONET e.V.
     (http://www.slicot.org)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Pole assignment for a given matrix pair (A,B) such that `p = eig
(A-B*F)'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
pzmap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 684
 -- Function File:  pzmap (SYS)
 -- Function File:  pzmap (SYS1, SYS2, ..., SYSN)
 -- Function File:  pzmap (SYS1, 'STYLE1', ..., SYSN, 'STYLEN')
 -- Function File: [P, Z] = pzmap (SYS)
     Plot the poles and zeros of an LTI system in the complex plane.
     If no output arguments are given, the result is plotted on the
     screen.  Otherwise, the poles and zeros are computed and returned.

     *Inputs*
    SYS
          LTI model.

    'STYLE'
          Line style and color, e.g. 'r' for a solid red line or '-.k'
          for a dash-dotted black line.  See `help plot' for details.

     *Outputs*
    P
          Poles of SYS.

    Z
          Transmission zeros of SYS.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Plot the poles and zeros of an LTI system in the complex plane.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ramp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1699
 -- Function File:  ramp (SYS)
 -- Function File:  ramp (SYS1, SYS2, ..., SYSN)
 -- Function File:  ramp (SYS1, 'STYLE1', ..., SYSN, 'STYLEN')
 -- Function File:  ramp (SYS1, ..., T)
 -- Function File:  ramp (SYS1, ..., TFINAL)
 -- Function File:  ramp (SYS1, ..., TFINAL, DT)
 -- Function File: [Y, T, X] = ramp (SYS)
 -- Function File: [Y, T, X] = ramp (SYS, T)
 -- Function File: [Y, T, X] = ramp (SYS, TFINAL)
 -- Function File: [Y, T, X] = ramp (SYS, TFINAL, DT)
     Ramp response of LTI system.  If no output arguments are given,
     the response is printed on the screen.

          r(t) = t * h(t)

     *Inputs*
    SYS
          LTI model.

    T
          Time vector.  Should be evenly spaced.  If not specified, it
          is calculated by the poles of the system to reflect
          adequately the response transients.

    TFINAL
          Optional simulation horizon.  If not specified, it is
          calculated by the poles of the system to reflect adequately
          the response transients.

    DT
          Optional sampling time.  Be sure to choose it small enough to
          capture transient phenomena.  If not specified, it is
          calculated by the poles of the system.

    'STYLE'
          Line style and color, e.g. 'r' for a solid red line or '-.k'
          for a dash-dotted black line.  See `help plot' for details.

     *Outputs*
    Y
          Output response array.  Has as many rows as time samples
          (length of t) and as many columns as outputs.

    T
          Time row vector.

    X
          State trajectories array.  Has `length (t)' rows and as many
          columns as states.

     See also: impulse, initial, lsim, step





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Ramp response of LTI system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rlocus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 911
 -- Function File:  rlocus (SYS)
 -- Function File: [RLDATA, K] = rlocus (SYS, INCREMENT, MIN_K, MAX_K)
     Display root locus plot of the specified SISO system.

     *Inputs*
    SYS
          LTI model.  Must be a single-input and single-output (SISO)
          system.

    INCREMENT
          The increment used in computing gain values.

    MIN_K
          Minimum value of K.

    MAX_K
          Maximum value of K.

     *Outputs*
    RLDATA
          Data points plotted: in column 1 real values, in column 2 the
          imaginary values.

    K
          Gains for real axis break points.

     *Block Diagram*
           u    +         +---+      +------+             y
          ------>(+)----->| k |----->| SISO |-------+------->
                  ^ -     +---+      +------+       |
                  |                                 |
                  +---------------------------------+




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Display root locus plot of the specified SISO system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
sensitivity


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1879
 -- Function File: [MS, WS] = sensitivity (L)
 -- Function File: [MS, WS] = sensitivity (P, C)
 -- Function File: [MS, WS] = sensitivity (P, C1, C2, ...)
     Return sensitivity margin MS.  The quantity MS is simply the
     inverse of the shortest distance from the Nyquist curve to the
     critical point -1.  Reasonable values of MS are in the range from
     1.3 to 2.

          Ms = ||S(jw)||
                        inf

     If no output arguments are given, the critical distance 1/Ms is
     plotted on a Nyquist diagram.  In contrast to gain and phase
     margin as computed by command `margin', the sensitivity MS is a
     more robust criterion to assess the stability of a feedback system.

     *Inputs*
    L
          Open loop transfer function.  L can be any type of LTI
          system, but it must be square.

    P
          Plant model.  Any type of LTI system.

    C
          Controller model.  Any type of LTI system.

    C1, C2, ...
          If several controllers are specified, command `sensitivity'
          computes the sensitivity MS for each of them in combination
          with plant P.

     *Outputs*
    MS
          Sensitivity margin MS as defined in [1].  Scalar value.  If
          several controllers are specified, MS becomes a row vector
          with as many entries as controllers.

    WS
          The frequency [rad/s] corresponding to the sensitivity peak.
          Scalar value.  If several controllers are specified, WS
          becomes a row vector with as many entries as controllers.

     *Algorithm*
     Uses SLICOT AB13DD by courtesy of NICONET e.V.
     (http://www.slicot.org) to calculate the infinity norm of the
     sensitivity function.

     *References*
     [1] Astro"m, K. and Ha"gglund, T. (1995) PID Controllers: Theory,
     Design and Tuning, Second Edition.  Instrument Society of America.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Return sensitivity margin MS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
sigma


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1377
 -- Function File:  sigma (SYS)
 -- Function File:  sigma (SYS1, SYS2, ..., SYSN)
 -- Function File:  sigma (SYS1, SYS2, ..., SYSN, W)
 -- Function File:  sigma (SYS1, 'STYLE1', ..., SYSN, 'STYLEN')
 -- Function File: [SV, W] = sigma (SYS)
 -- Function File: [SV, W] = sigma (SYS, W)
     Singular values of frequency response.  If no output arguments are
     given, the singular value plot is printed on the screen.

     *Inputs*
    SYS
          LTI system.  Multiple inputs and/or outputs (MIMO systems)
          make practical sense.

    W
          Optional vector of frequency values.  If W is not specified,
          it is calculated by the zeros and poles of the system.
          Alternatively, the cell `{wmin, wmax}' specifies a frequency
          range, where WMIN and WMAX denote minimum and maximum
          frequencies in rad/s.

    'STYLE'
          Line style and color, e.g. 'r' for a solid red line or '-.k'
          for a dash-dotted black line.  See `help plot' for details.

     *Outputs*
    SV
          Array of singular values.  For a system with m inputs and p
          outputs, the array sv has `min (m, p)' rows and as many
          columns as frequency points `length (w)'.  The singular
          values at the frequency `w(k)' are given by `sv(:,k)'.

    W
          Vector of frequency values used.

     See also: bodemag, svd





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Singular values of frequency response.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
spaconred


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6224
 -- Function File: [KR, INFO] = spaconred (G, K, ...)
 -- Function File: [KR, INFO] = spaconred (G, K, NCR, ...)
 -- Function File: [KR, INFO] = spaconred (G, K, OPT, ...)
 -- Function File: [KR, INFO] = spaconred (G, K, NCR, OPT, ...)
     Controller reduction by frequency-weighted Singular Perturbation
     Approximation (SPA).  Given a plant G and a stabilizing controller
     K, determine a reduced order controller KR such that the
     closed-loop system is stable and closed-loop performance is
     retained.

     The algorithm tries to minimize the frequency-weighted error
          ||V (K-Kr) W||    = min
                        inf
     where V and W denote output and input weightings.

     *Inputs*
    G
          LTI model of the plant.  It has m inputs, p outputs and n
          states.

    K
          LTI model of the controller.  It has p inputs, m outputs and
          nc states.

    NCR
          The desired order of the resulting reduced order controller
          KR.  If not specified, NCR is chosen automatically according
          to the description of key 'ORDER'.

    ...
          Optional pairs of keys and values.  `"key1", value1, "key2",
          value2'.

    OPT
          Optional struct with keys as field names.  Struct OPT can be
          created directly or by command `options'.  `opt.key1 =
          value1, opt.key2 = value2'.

     *Outputs*
    KR
          State-space model of reduced order controller.

    INFO
          Struct containing additional information.
         INFO.NCR
               The order of the obtained reduced order controller KR.

         INFO.NCS
               The order of the alpha-stable part of original
               controller K.

         INFO.HSVC
               The Hankel singular values of the alpha-stable part of K.
               The NCS Hankel singular values are ordered decreasingly.

     *Option Keys and Values*
    'ORDER', 'NCR'
          The desired order of the resulting reduced order controller
          KR.  If not specified, NCR is chosen automatically such that
          states with Hankel singular values INFO.HSVC > TOL1 are
          retained.

    'METHOD'
          Order reduction approach to be used as follows:
         'SR', 'S'
               Use the square-root Singular Perturbation Approximation
               method.

         'BFSR', 'P'
               Use the balancing-free square-root Singular Perturbation
               Approximation method.  Default method.

    'WEIGHT'
          Specifies the type of frequency-weighting as follows:
         'NONE'
               No weightings are used (V = I, W = I).

         'LEFT', 'OUTPUT'
               Use stability enforcing left (output) weighting
                              -1
                    V = (I-G*K) *G ,  W = I

         'RIGHT', 'INPUT'
               Use stability enforcing right (input) weighting
                                       -1
                    V = I ,  W = (I-G*K) *G

         'BOTH', 'PERFORMANCE'
               Use stability and performance enforcing weightings
                              -1                -1
                    V = (I-G*K) *G ,  W = (I-G*K)
               Default value.

    'FEEDBACK'
          Specifies whether K is a positive or negative feedback
          controller:
         '+'
               Use positive feedback controller.  Default value.

         '-'
               Use negative feedback controller.

    'ALPHA'
          Specifies the ALPHA-stability boundary for the eigenvalues of
          the state dynamics matrix K.A.  For a continuous-time
          controller, ALPHA <= 0 is the boundary value for the real
          parts of eigenvalues, while for a discrete-time controller, 0
          <= ALPHA <= 1 represents the boundary value for the moduli of
          eigenvalues.  The ALPHA-stability domain does not include the
          boundary.  Default value is 0 for continuous-time controllers
          and 1 for discrete-time controllers.

    'TOL1'
          If 'ORDER' is not specified, TOL1 contains the tolerance for
          determining the order of the reduced controller.  For model
          reduction, the recommended value of TOL1 is c*info.hsvc(1),
          where c lies in the interval [0.00001, 0.001].  Default value
          is info.ncs*eps*info.hsvc(1).  If 'ORDER' is specified, the
          value of TOL1 is ignored.

    'TOL2'
          The tolerance for determining the order of a minimal
          realization of the ALPHA-stable part of the given controller.
          TOL2 <= TOL1.  If not specified, ncs*eps*info.hsvc(1) is
          chosen.

    'GRAM-CTRB'
          Specifies the choice of frequency-weighted controllability
          Grammian as follows:
         'STANDARD'
               Choice corresponding to standard Enns' method [1].
               Default method.

         'ENHANCED'
               Choice corresponding to the stability enhanced modified
               Enns' method of [2].

    'GRAM-OBSV'
          Specifies the choice of frequency-weighted observability
          Grammian as follows:
         'STANDARD'
               Choice corresponding to standard Enns' method [1].
               Default method.

         'ENHANCED'
               Choice corresponding to the stability enhanced modified
               Enns' method of [2].

    'EQUIL', 'SCALE'
          Boolean indicating whether equilibration (scaling) should be
          performed on G and K prior to order reduction.  Default value
          is false if both `G.scaled == true, K.scaled == true' and
          true otherwise.  Note that for MIMO models, proper scaling of
          both inputs and outputs is of utmost importance.  The input
          and output scaling can *not* be done by the equilibration
          option or the `prescale' command because these functions
          perform state transformations only.  Furthermore, signals
          should not be scaled simply to a certain range.  For all
          inputs (or outputs), a certain change should be of the same
          importance for the model.

     *Algorithm*
     Uses SLICOT SB16AD by courtesy of NICONET e.V.
     (http://www.slicot.org)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Controller reduction by frequency-weighted Singular Perturbation
Approximation (



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
spamodred


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7175
 -- Function File: [GR, INFO] = spamodred (G, ...)
 -- Function File: [GR, INFO] = spamodred (G, NR, ...)
 -- Function File: [GR, INFO] = spamodred (G, OPT, ...)
 -- Function File: [GR, INFO] = spamodred (G, NR, OPT, ...)
     Model order reduction by frequency weighted Singular Perturbation
     Approximation (SPA).  The aim of model reduction is to find an LTI
     system GR of order NR (nr < n) such that the input-output
     behaviour of GR approximates the one from original system G.

     SPA is an absolute error method which tries to minimize
          ||G-Gr||    = min
                  inf

          ||V (G-Gr) W||    = min
                        inf
     where V and W denote output and input weightings.

     *Inputs*
    G
          LTI model to be reduced.

    NR
          The desired order of the resulting reduced order system GR.
          If not specified, NR is chosen automatically according to the
          description of key 'ORDER'.

    ...
          Optional pairs of keys and values.  `"key1", value1, "key2",
          value2'.

    OPT
          Optional struct with keys as field names.  Struct OPT can be
          created directly or by command `options'.  `opt.key1 =
          value1, opt.key2 = value2'.

     *Outputs*
    GR
          Reduced order state-space model.

    INFO
          Struct containing additional information.
         INFO.N
               The order of the original system G.

         INFO.NS
               The order of the ALPHA-stable subsystem of the original
               system G.

         INFO.HSV
               The Hankel singular values of the ALPHA-stable part of
               the original system G, ordered decreasingly.

         INFO.NU
               The order of the ALPHA-unstable subsystem of both the
               original system G and the reduced-order system GR.

         INFO.NR
               The order of the obtained reduced order system GR.

     *Option Keys and Values*
    'ORDER', 'NR'
          The desired order of the resulting reduced order system GR.
          If not specified, NR is chosen automatically such that states
          with Hankel singular values INFO.HSV > TOL1 are retained.

    'LEFT', 'OUTPUT'
          LTI model of the left/output frequency weighting V.  Default
          value is an identity matrix.

    'RIGHT', 'INPUT'
          LTI model of the right/input frequency weighting W.  Default
          value is an identity matrix.

    'METHOD'
          Approximation method for the L-infinity norm to be used as
          follows:
         'SR', 'S'
               Use the square-root Singular Perturbation Approximation
               method.

         'BFSR', 'P'
               Use the balancing-free square-root Singular Perturbation
               Approximation method.  Default method.

    'ALPHA'
          Specifies the ALPHA-stability boundary for the eigenvalues of
          the state dynamics matrix G.A.  For a continuous-time system,
          ALPHA <= 0 is the boundary value for the real parts of
          eigenvalues, while for a discrete-time system, 0 <= ALPHA <=
          1 represents the boundary value for the moduli of eigenvalues.
          The ALPHA-stability domain does not include the boundary.
          Default value is 0 for continuous-time systems and 1 for
          discrete-time systems.

    'TOL1'
          If 'ORDER' is not specified, TOL1 contains the tolerance for
          determining the order of the reduced model.  For model
          reduction, the recommended value of TOL1 is c*info.hsv(1),
          where c lies in the interval [0.00001, 0.001].  Default value
          is info.ns*eps*info.hsv(1).  If 'ORDER' is specified, the
          value of TOL1 is ignored.

    'TOL2'
          The tolerance for determining the order of a minimal
          realization of the ALPHA-stable part of the given model.
          TOL2 <= TOL1.  If not specified, ns*eps*info.hsv(1) is chosen.

    'GRAM-CTRB'
          Specifies the choice of frequency-weighted controllability
          Grammian as follows:
         'STANDARD'
               Choice corresponding to a combination method [4] of the
               approaches of Enns [1] and Lin-Chiu [2,3].  Default
               method.

         'ENHANCED'
               Choice corresponding to the stability enhanced modified
               combination method of [4].

    'GRAM-OBSV'
          Specifies the choice of frequency-weighted observability
          Grammian as follows:
         'STANDARD'
               Choice corresponding to a combination method [4] of the
               approaches of Enns [1] and Lin-Chiu [2,3].  Default
               method.

         'ENHANCED'
               Choice corresponding to the stability enhanced modified
               combination method of [4].

    'ALPHA-CTRB'
          Combination method parameter for defining the
          frequency-weighted controllability Grammian.  abs(alphac) <=
          1.  If alphac = 0, the choice of Grammian corresponds to the
          method of Enns [1], while if alphac = 1, the choice of
          Grammian corresponds to the method of Lin and Chiu [2,3].
          Default value is 0.

    'ALPHA-OBSV'
          Combination method parameter for defining the
          frequency-weighted observability Grammian.  abs(alphao) <= 1.
          If alphao = 0, the choice of Grammian corresponds to the
          method of Enns [1], while if alphao = 1, the choice of
          Grammian corresponds to the method of Lin and Chiu [2,3].
          Default value is 0.

    'EQUIL', 'SCALE'
          Boolean indicating whether equilibration (scaling) should be
          performed on system G prior to order reduction.  Default
          value is true if `G.scaled == false' and false if `G.scaled
          == true'.  Note that for MIMO models, proper scaling of both
          inputs and outputs is of utmost importance.  The input and
          output scaling can *not* be done by the equilibration option
          or the `prescale' command because these functions perform
          state transformations only.  Furthermore, signals should not
          be scaled simply to a certain range.  For all inputs (or
          outputs), a certain change should be of the same importance
          for the model.

     *References*
     [1] Enns, D.  `Model reduction with balanced realizations: An
     error bound and a frequency weighted generalization'.  Proc. 23-th
     CDC, Las Vegas, pp. 127-132, 1984.

     [2] Lin, C.-A. and Chiu, T.-Y.  `Model reduction via
     frequency-weighted balanced realization'.  Control Theory and
     Advanced Technology, vol. 8, pp. 341-351, 1992.

     [3] Sreeram, V., Anderson, B.D.O and Madievski, A.G.  `New results
     on frequency weighted balanced reduction technique'.  Proc. ACC,
     Seattle, Washington, pp. 4004-4009, 1995.

     [4] Varga, A. and Anderson, B.D.O.  `Square-root balancing-free
     methods for the frequency-weighted balancing related model
     reduction'.  (report in preparation)

     *Algorithm*
     Uses SLICOT AB09ID by courtesy of NICONET e.V.
     (http://www.slicot.org)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Model order reduction by frequency weighted Singular Perturbation
Approximation 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
step


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1666
 -- Function File:  step (SYS)
 -- Function File:  step (SYS1, SYS2, ..., SYSN)
 -- Function File:  step (SYS1, 'STYLE1', ..., SYSN, 'STYLEN')
 -- Function File:  step (SYS1, ..., T)
 -- Function File:  step (SYS1, ..., TFINAL)
 -- Function File:  step (SYS1, ..., TFINAL, DT)
 -- Function File: [Y, T, X] = step (SYS)
 -- Function File: [Y, T, X] = step (SYS, T)
 -- Function File: [Y, T, X] = step (SYS, TFINAL)
 -- Function File: [Y, T, X] = step (SYS, TFINAL, DT)
     Step response of LTI system.  If no output arguments are given,
     the response is printed on the screen.

     *Inputs*
    SYS
          LTI model.

    T
          Time vector.  Should be evenly spaced.  If not specified, it
          is calculated by the poles of the system to reflect
          adequately the response transients.

    TFINAL
          Optional simulation horizon.  If not specified, it is
          calculated by the poles of the system to reflect adequately
          the response transients.

    DT
          Optional sampling time.  Be sure to choose it small enough to
          capture transient phenomena.  If not specified, it is
          calculated by the poles of the system.

    'STYLE'
          Line style and color, e.g. 'r' for a solid red line or '-.k'
          for a dash-dotted black line.  See `help plot' for details.

     *Outputs*
    Y
          Output response array.  Has as many rows as time samples
          (length of t) and as many columns as outputs.

    T
          Time row vector.

    X
          State trajectories array.  Has `length (t)' rows and as many
          columns as states.

     See also: impulse, initial, lsim





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Step response of LTI system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strseq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 250
 -- Function File: STRVEC = strseq (STR, IDX)
     Return a cell vector of indexed strings by appending the indices
     IDX to the string STR.

          strseq ("x", 1:3) = {"x1"; "x2"; "x3"}
          strseq ("u", [1, 2, 5]) = {"u1"; "u2"; "u5"}




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a cell vector of indexed strings by appending the indices IDX to
the stri



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
test_control


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1137
 -- Script File:  test_control
     Execute all available tests at once.  The Octave control package
     is based on the SLICOT (http://www.slicot.org) library.  SLICOT
     needs BLAS and LAPACK libraries which are also prerequisites for
     Octave itself.  In case of failing tests, it is highly recommended
     to use Netlib's reference BLAS (http://www.netlib.org/blas/) and
     LAPACK (http://www.netlib.org/lapack/) for building Octave.  Using
     ATLAS may lead to sign changes in some entries of the state-space
     matrices.  In general, these sign changes are not 'wrong' and can
     be regarded as the result of state transformations.  Such state
     transformations (but not input/output transformations) have no
     influence on the input-output behaviour of the system.  For better
     numerics, the control package uses such transformations by default
     when calculating the frequency responses and a few other things.
     However, arguments like the Hankel singular Values (HSV) must not
     change.  Differing HSVs and failing algorithms are known for using
     Framework Accelerate from Mac OS X 10.7.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Execute all available tests at once.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
tfpoly2str


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 158
 -- Function File: STR = tfpoly2str (P)
 -- Function File: STR = tfpoly2str (P, TFVAR)
     Return the string of a polynomial with string TFVAR as variable.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return the string of a polynomial with string TFVAR as variable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
tfpolyones


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Return (pxm) cell of tfpoly([1]).  For internal use only.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Return (pxm) cell of tfpoly([1]).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
tfpolyzeros


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Return (pxm) cell of tfpoly([0]).  For internal use only.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Return (pxm) cell of tfpoly([0]).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
zpk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1373
 -- Function File: S = zpk ("S")
 -- Function File: Z = zpk ("Z", TSAM)
 -- Function File: SYS = zpk (SYS)
 -- Function File: SYS = zpk (K)
 -- Function File: SYS = zpk (Z, P, K, ...)
 -- Function File: SYS = zpk (Z, P, K, TSAM, ...)
 -- Function File: SYS = zpk (Z, P, K, TSAM, ...)
     Create transfer function model from zero-pole-gain data.  This is
     just a stop-gap compatibility wrapper since zpk models are not yet
     implemented.

     *Inputs*
    SYS
          LTI model to be converted to transfer function.

    Z
          Cell of vectors containing the zeros for each channel.
          z{i,j} contains the zeros from input j to output i.  In the
          SISO case, a single vector is accepted as well.

    P
          Cell of vectors containing the poles for each channel.
          p{i,j} contains the poles from input j to output i.  In the
          SISO case, a single vector is accepted as well.

    K
          Matrix containing the gains for each channel.  k(i,j)
          contains the gain from input j to output i.

    TSAM
          Sampling time in seconds.  If TSAM is not specified, a
          continuous-time model is assumed.

    ...
          Optional pairs of properties and values.  Type `set (tf)' for
          more information.

     *Outputs*
    SYS
          Transfer function model.

     See also: tf, ss, dss, frd





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Create transfer function model from zero-pole-gain data.





