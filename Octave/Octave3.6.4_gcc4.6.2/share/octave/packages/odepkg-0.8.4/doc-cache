# Created by Octave 3.6.4, Fri Mar 29 16:52:16 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 36
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
bvp4c


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 694
 -- Function File: A = bvp4c (ODEFUN, BCFUN, SOLINIT)
     Solves the first order system of non-linear differential equations
     defined by ODEFUN with the boundary conditions defined in BCFUN.

     The structure SOLINIT defines the grid on which to compute the
     solution (SOLINIT.X), and an initial guess for the solution
     (SOLINIT.Y).  The output SOL is also a structure with the
     following fields:
        * SOL.X list of points where the solution is evaluated

        * SOL.Y solution evaluated at the points SOL.X

        * SOL.YP derivative of the solution evaluated at the points
          SOL.X

        * SOL.SOLVER = "bvp4c" for compatibility

     See also: odpkg





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Solves the first order system of non-linear differential equations
defined by OD



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ode23


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2466
 -- Function File: [] = ode23 (@FUN, SLOT, INIT, [OPT], [PAR1, PAR2,
          ...])
 -- Command: [SOL] = ode23 (@FUN, SLOT, INIT, [OPT], [PAR1, PAR2, ...])
 -- Command: [T, Y, [XE, YE, IE]] = ode23 (@FUN, SLOT, INIT, [OPT],
          [PAR1, PAR2, ...])
     This function file can be used to solve a set of non-stiff
     ordinary differential equations (non-stiff ODEs) or non-stiff
     differential algebraic equations (non-stiff DAEs) with the well
     known explicit Runge-Kutta method of order (2,3).

     If this function is called with no return argument then plot the
     solution over time in a figure window while solving the set of
     ODEs that are defined in a function and specified by the function
     handle @FUN. The second input argument SLOT is a double vector
     that defines the time slot, INIT is a double vector that defines
     the initial values of the states, OPT can optionally be a
     structure array that keeps the options created with the command
     `odeset' and PAR1, PAR2, ... can optionally be other input
     arguments of any type that have to be passed to the function
     defined by @FUN.

     If this function is called with one return argument then return
     the solution SOL of type structure array after solving the set of
     ODEs. The solution SOL has the fields X of type double column
     vector for the steps chosen by the solver, Y of type double column
     vector for the solutions at each time step of X, SOLVER of type
     string for the solver name and optionally the extended time stamp
     information XE, the extended solution information YE and the
     extended index information IE all of type double column vector
     that keep the informations of the event function if an event
     function handle is set in the option argument OPT.

     If this function is called with more than one return argument then
     return the time stamps T, the solution values Y and optionally the
     extended time stamp information XE, the extended solution
     information YE and the extended index information IE all of type
     double column vector.

     For example, solve an anonymous implementation of the Van der Pol
     equation

          fvdb = @(vt,vy) [vy(2); (1 - vy(1)^2) * vy(2) - vy(1)];

          vopt = odeset ("RelTol", 1e-3, "AbsTol", 1e-3, \
                   "NormControl", "on", "OutputFcn", @odeplot);
          ode23 (fvdb, [0 20], [2 0], vopt);

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to solve a set of non-stiff ordinary
differential



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ode23d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3606
 -- Function File: [] = ode23d (@FUN, SLOT, INIT, LAGS, HIST, [OPT],
          [PAR1, PAR2, ...])
 -- Command: [SOL] = ode23d (@FUN, SLOT, INIT, LAGS, HIST, [OPT],
          [PAR1, PAR2, ...])
 -- Command: [T, Y, [XE, YE, IE]] = ode23d (@FUN, SLOT, INIT, LAGS,
          HIST, [OPT], [PAR1, PAR2, ...])
     This function file can be used to solve a set of non-stiff delay
     differential equations (non-stiff DDEs) with a modified version of
     the well known explicit Runge-Kutta method of order (2,3).

     If this function is called with no return argument then plot the
     solution over time in a figure window while solving the set of
     DDEs that are defined in a function and specified by the function
     handle @FUN. The second input argument SLOT is a double vector
     that defines the time slot, INIT is a double vector that defines
     the initial values of the states, LAGS is a double vector that
     describes the lags of time, HIST is a double matrix and describes
     the history of the DDEs, OPT can optionally be a structure array
     that keeps the options created with the command `odeset' and PAR1,
     PAR2, ... can optionally be other input arguments of any type that
     have to be passed to the function defined by @FUN.

     In other words, this function will solve a problem of the form
          dy/dt = fun (t, y(t), y(t-lags(1), y(t-lags(2), ...)))
          y(slot(1)) = init
          y(slot(1)-lags(1)) = hist(1), y(slot(1)-lags(2)) = hist(2), ...

     If this function is called with one return argument then return
     the solution SOL of type structure array after solving the set of
     DDEs. The solution SOL has the fields X of type double column
     vector for the steps chosen by the solver, Y of type double column
     vector for the solutions at each time step of X, SOLVER of type
     string for the solver name and optionally the extended time stamp
     information XE, the extended solution information YE and the
     extended index information IE all of type double column vector
     that keep the informations of the event function if an event
     function handle is set in the option argument OPT.

     If this function is called with more than one return argument then
     return the time stamps T, the solution values Y and optionally the
     extended time stamp information XE, the extended solution
     information YE and the extended index information IE all of type
     double column vector.

     For example:
        - the following code solves an anonymous implementation of a
          chaotic behavior

               fcao = @(vt, vy, vz) [2 * vz / (1 + vz^9.65) - vy];

               vopt = odeset ("NormControl", "on", "RelTol", 1e-3);
               vsol = ode23d (fcao, [0, 100], 0.5, 2, 0.5, vopt);

               vlag = interp1 (vsol.x, vsol.y, vsol.x - 2);
               plot (vsol.y, vlag); legend ("fcao (t,y,z)");

        - to solve the following problem with two delayed state
          variables

               d y1(t)/dt = -y1(t)
               d y2(t)/dt = -y2(t) + y1(t-5)
               d y3(t)/dt = -y3(t) + y2(t-10)*y1(t-10)

          one might do the following

               function f = fun (t, y, yd)
               f(1) = -y(1);                   %% y1' = -y1(t)
               f(2) = -y(2) + yd(1,1);         %% y2' = -y2(t) + y1(t-lags(1))
               f(3) = -y(3) + yd(2,2)*yd(1,2); %% y3' = -y3(t) + y2(t-lags(2))*y1(t-lags(2))
               endfunction
               T = [0,20]
               res = ode23d (@fun, T, [1;1;1], [5, 10], ones (3,2));


   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to solve a set of non-stiff delay
differential eq



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ode23s


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1589
 -- Function File: [TOUT, XOUT] = ode23s (FUN, TSPAN, X0, OPTIONS)
     This function can be used to solve a set of stiff ordinary
     differential equations with a Rosenbrock method of order (2,3).

     All the mathematical formulas are from "The MATLAB ode suite",
     L.F. Shampine, M.W. Reichelt, pp.6-7

        - FUN: String or function-handle for the problem description.
             - signature: `xprime = fun (t,x)'

             - t:  Time (scalar).

             - x: Solution (column-vector).

             - xprime: Returned derivative (column-vector, `xprime(i) =
               dx(i) / dt').

        - TSPAN: Initial value column vector [tstart, tfinal]

        - X0: Initial value (column-vector).

        - OPTIONS: User-defined integration parameters, using "odeset".
          See `help odeset' for more details.  Option parameters
          currently accepted are: RelTol, MaxStep, InitialStep, Mass,
          Jacobian, JPattern.  If "options" is not used, these
          parameters will be given default values.  ode23s solves
          problems in the form M*y' = FUN (t, y), where M is a costant
          mass matrix, non-singular and possibly sparse. Set the filed
          MASS in OPTIONS using ODESET to specify a mass matrix.

     Example:
          f=@(t,y) [y(2); 1000*(1-y(1)^2)*y(2)-y(1)];
          opt = odeset ('Mass', [1 0; 0 1], 'MaxStep', 1e-1);
          [vt, vy] = ode23s (f, [0 2000], [2 0], opt);

     The structure of the code is based on "ode23.m", written by Marc
     Compere.

     See also: ode23, odepkg, odeset, daspk, dassl





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function can be used to solve a set of stiff ordinary differential
equation



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ode45


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2466
 -- Function File: [] = ode45 (@FUN, SLOT, INIT, [OPT], [PAR1, PAR2,
          ...])
 -- Command: [SOL] = ode45 (@FUN, SLOT, INIT, [OPT], [PAR1, PAR2, ...])
 -- Command: [T, Y, [XE, YE, IE]] = ode45 (@FUN, SLOT, INIT, [OPT],
          [PAR1, PAR2, ...])
     This function file can be used to solve a set of non-stiff
     ordinary differential equations (non-stiff ODEs) or non-stiff
     differential algebraic equations (non-stiff DAEs) with the well
     known explicit Runge-Kutta method of order (4,5).

     If this function is called with no return argument then plot the
     solution over time in a figure window while solving the set of
     ODEs that are defined in a function and specified by the function
     handle @FUN. The second input argument SLOT is a double vector
     that defines the time slot, INIT is a double vector that defines
     the initial values of the states, OPT can optionally be a
     structure array that keeps the options created with the command
     `odeset' and PAR1, PAR2, ... can optionally be other input
     arguments of any type that have to be passed to the function
     defined by @FUN.

     If this function is called with one return argument then return
     the solution SOL of type structure array after solving the set of
     ODEs. The solution SOL has the fields X of type double column
     vector for the steps chosen by the solver, Y of type double column
     vector for the solutions at each time step of X, SOLVER of type
     string for the solver name and optionally the extended time stamp
     information XE, the extended solution information YE and the
     extended index information IE all of type double column vector
     that keep the informations of the event function if an event
     function handle is set in the option argument OPT.

     If this function is called with more than one return argument then
     return the time stamps T, the solution values Y and optionally the
     extended time stamp information XE, the extended solution
     information YE and the extended index information IE all of type
     double column vector.

     For example, solve an anonymous implementation of the Van der Pol
     equation

          fvdb = @(vt,vy) [vy(2); (1 - vy(1)^2) * vy(2) - vy(1)];

          vopt = odeset ("RelTol", 1e-3, "AbsTol", 1e-3, \
                   "NormControl", "on", "OutputFcn", @odeplot);
          ode45 (fvdb, [0 20], [2 0], vopt);

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to solve a set of non-stiff ordinary
differential



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ode45d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3606
 -- Function File: [] = ode45d (@FUN, SLOT, INIT, LAGS, HIST, [OPT],
          [PAR1, PAR2, ...])
 -- Command: [SOL] = ode45d (@FUN, SLOT, INIT, LAGS, HIST, [OPT],
          [PAR1, PAR2, ...])
 -- Command: [T, Y, [XE, YE, IE]] = ode45d (@FUN, SLOT, INIT, LAGS,
          HIST, [OPT], [PAR1, PAR2, ...])
     This function file can be used to solve a set of non-stiff delay
     differential equations (non-stiff DDEs) with a modified version of
     the well known explicit Runge-Kutta method of order (4,5).

     If this function is called with no return argument then plot the
     solution over time in a figure window while solving the set of
     DDEs that are defined in a function and specified by the function
     handle @FUN. The second input argument SLOT is a double vector
     that defines the time slot, INIT is a double vector that defines
     the initial values of the states, LAGS is a double vector that
     describes the lags of time, HIST is a double matrix and describes
     the history of the DDEs, OPT can optionally be a structure array
     that keeps the options created with the command `odeset' and PAR1,
     PAR2, ... can optionally be other input arguments of any type that
     have to be passed to the function defined by @FUN.

     In other words, this function will solve a problem of the form
          dy/dt = fun (t, y(t), y(t-lags(1), y(t-lags(2), ...)))
          y(slot(1)) = init
          y(slot(1)-lags(1)) = hist(1), y(slot(1)-lags(2)) = hist(2), ...

     If this function is called with one return argument then return
     the solution SOL of type structure array after solving the set of
     DDEs. The solution SOL has the fields X of type double column
     vector for the steps chosen by the solver, Y of type double column
     vector for the solutions at each time step of X, SOLVER of type
     string for the solver name and optionally the extended time stamp
     information XE, the extended solution information YE and the
     extended index information IE all of type double column vector
     that keep the informations of the event function if an event
     function handle is set in the option argument OPT.

     If this function is called with more than one return argument then
     return the time stamps T, the solution values Y and optionally the
     extended time stamp information XE, the extended solution
     information YE and the extended index information IE all of type
     double column vector.

     For example:
        - the following code solves an anonymous implementation of a
          chaotic behavior

               fcao = @(vt, vy, vz) [2 * vz / (1 + vz^9.65) - vy];

               vopt = odeset ("NormControl", "on", "RelTol", 1e-3);
               vsol = ode45d (fcao, [0, 100], 0.5, 2, 0.5, vopt);

               vlag = interp1 (vsol.x, vsol.y, vsol.x - 2);
               plot (vsol.y, vlag); legend ("fcao (t,y,z)");

        - to solve the following problem with two delayed state
          variables

               d y1(t)/dt = -y1(t)
               d y2(t)/dt = -y2(t) + y1(t-5)
               d y3(t)/dt = -y3(t) + y2(t-10)*y1(t-10)

          one might do the following

               function f = fun (t, y, yd)
               f(1) = -y(1);                   %% y1' = -y1(t)
               f(2) = -y(2) + yd(1,1);         %% y2' = -y2(t) + y1(t-lags(1))
               f(3) = -y(3) + yd(2,2)*yd(1,2); %% y3' = -y3(t) + y2(t-lags(2))*y1(t-lags(2))
               endfunction
               T = [0,20]
               res = ode45d (@fun, T, [1;1;1], [5, 10], ones (3,2));


   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to solve a set of non-stiff delay
differential eq



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ode54


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2466
 -- Function File: [] = ode54 (@FUN, SLOT, INIT, [OPT], [PAR1, PAR2,
          ...])
 -- Command: [SOL] = ode54 (@FUN, SLOT, INIT, [OPT], [PAR1, PAR2, ...])
 -- Command: [T, Y, [XE, YE, IE]] = ode54 (@FUN, SLOT, INIT, [OPT],
          [PAR1, PAR2, ...])
     This function file can be used to solve a set of non-stiff
     ordinary differential equations (non-stiff ODEs) or non-stiff
     differential algebraic equations (non-stiff DAEs) with the well
     known explicit Runge-Kutta method of order (5,4).

     If this function is called with no return argument then plot the
     solution over time in a figure window while solving the set of
     ODEs that are defined in a function and specified by the function
     handle @FUN. The second input argument SLOT is a double vector
     that defines the time slot, INIT is a double vector that defines
     the initial values of the states, OPT can optionally be a
     structure array that keeps the options created with the command
     `odeset' and PAR1, PAR2, ... can optionally be other input
     arguments of any type that have to be passed to the function
     defined by @FUN.

     If this function is called with one return argument then return
     the solution SOL of type structure array after solving the set of
     ODEs. The solution SOL has the fields X of type double column
     vector for the steps chosen by the solver, Y of type double column
     vector for the solutions at each time step of X, SOLVER of type
     string for the solver name and optionally the extended time stamp
     information XE, the extended solution information YE and the
     extended index information IE all of type double column vector
     that keep the informations of the event function if an event
     function handle is set in the option argument OPT.

     If this function is called with more than one return argument then
     return the time stamps T, the solution values Y and optionally the
     extended time stamp information XE, the extended solution
     information YE and the extended index information IE all of type
     double column vector.

     For example, solve an anonymous implementation of the Van der Pol
     equation

          fvdb = @(vt,vy) [vy(2); (1 - vy(1)^2) * vy(2) - vy(1)];

          vopt = odeset ("RelTol", 1e-3, "AbsTol", 1e-3, \
                   "NormControl", "on", "OutputFcn", @odeplot);
          ode54 (fvdb, [0 20], [2 0], vopt);

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to solve a set of non-stiff ordinary
differential



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ode54d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3606
 -- Function File: [] = ode54d (@FUN, SLOT, INIT, LAGS, HIST, [OPT],
          [PAR1, PAR2, ...])
 -- Command: [SOL] = ode54d (@FUN, SLOT, INIT, LAGS, HIST, [OPT],
          [PAR1, PAR2, ...])
 -- Command: [T, Y, [XE, YE, IE]] = ode54d (@FUN, SLOT, INIT, LAGS,
          HIST, [OPT], [PAR1, PAR2, ...])
     This function file can be used to solve a set of non-stiff delay
     differential equations (non-stiff DDEs) with a modified version of
     the well known explicit Runge-Kutta method of order (2,3).

     If this function is called with no return argument then plot the
     solution over time in a figure window while solving the set of
     DDEs that are defined in a function and specified by the function
     handle @FUN. The second input argument SLOT is a double vector
     that defines the time slot, INIT is a double vector that defines
     the initial values of the states, LAGS is a double vector that
     describes the lags of time, HIST is a double matrix and describes
     the history of the DDEs, OPT can optionally be a structure array
     that keeps the options created with the command `odeset' and PAR1,
     PAR2, ... can optionally be other input arguments of any type that
     have to be passed to the function defined by @FUN.

     In other words, this function will solve a problem of the form
          dy/dt = fun (t, y(t), y(t-lags(1), y(t-lags(2), ...)))
          y(slot(1)) = init
          y(slot(1)-lags(1)) = hist(1), y(slot(1)-lags(2)) = hist(2), ...

     If this function is called with one return argument then return
     the solution SOL of type structure array after solving the set of
     DDEs. The solution SOL has the fields X of type double column
     vector for the steps chosen by the solver, Y of type double column
     vector for the solutions at each time step of X, SOLVER of type
     string for the solver name and optionally the extended time stamp
     information XE, the extended solution information YE and the
     extended index information IE all of type double column vector
     that keep the informations of the event function if an event
     function handle is set in the option argument OPT.

     If this function is called with more than one return argument then
     return the time stamps T, the solution values Y and optionally the
     extended time stamp information XE, the extended solution
     information YE and the extended index information IE all of type
     double column vector.

     For example:
        - the following code solves an anonymous implementation of a
          chaotic behavior

               fcao = @(vt, vy, vz) [2 * vz / (1 + vz^9.65) - vy];

               vopt = odeset ("NormControl", "on", "RelTol", 1e-3);
               vsol = ode54d (fcao, [0, 100], 0.5, 2, 0.5, vopt);

               vlag = interp1 (vsol.x, vsol.y, vsol.x - 2);
               plot (vsol.y, vlag); legend ("fcao (t,y,z)");

        - to solve the following problem with two delayed state
          variables

               d y1(t)/dt = -y1(t)
               d y2(t)/dt = -y2(t) + y1(t-5)
               d y3(t)/dt = -y3(t) + y2(t-10)*y1(t-10)

          one might do the following

               function f = fun (t, y, yd)
               f(1) = -y(1);                   %% y1' = -y1(t)
               f(2) = -y(2) + yd(1,1);         %% y2' = -y2(t) + y1(t-lags(1))
               f(3) = -y(3) + yd(2,2)*yd(1,2); %% y3' = -y3(t) + y2(t-lags(2))*y1(t-lags(2))
               endfunction
               T = [0,20]
               res = ode54d (@fun, T, [1;1;1], [5, 10], ones (3,2));


   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to solve a set of non-stiff delay
differential eq



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ode78


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2466
 -- Function File: [] = ode78 (@FUN, SLOT, INIT, [OPT], [PAR1, PAR2,
          ...])
 -- Command: [SOL] = ode78 (@FUN, SLOT, INIT, [OPT], [PAR1, PAR2, ...])
 -- Command: [T, Y, [XE, YE, IE]] = ode78 (@FUN, SLOT, INIT, [OPT],
          [PAR1, PAR2, ...])
     This function file can be used to solve a set of non-stiff
     ordinary differential equations (non-stiff ODEs) or non-stiff
     differential algebraic equations (non-stiff DAEs) with the well
     known explicit Runge-Kutta method of order (7,8).

     If this function is called with no return argument then plot the
     solution over time in a figure window while solving the set of
     ODEs that are defined in a function and specified by the function
     handle @FUN. The second input argument SLOT is a double vector
     that defines the time slot, INIT is a double vector that defines
     the initial values of the states, OPT can optionally be a
     structure array that keeps the options created with the command
     `odeset' and PAR1, PAR2, ... can optionally be other input
     arguments of any type that have to be passed to the function
     defined by @FUN.

     If this function is called with one return argument then return
     the solution SOL of type structure array after solving the set of
     ODEs. The solution SOL has the fields X of type double column
     vector for the steps chosen by the solver, Y of type double column
     vector for the solutions at each time step of X, SOLVER of type
     string for the solver name and optionally the extended time stamp
     information XE, the extended solution information YE and the
     extended index information IE all of type double column vector
     that keep the informations of the event function if an event
     function handle is set in the option argument OPT.

     If this function is called with more than one return argument then
     return the time stamps T, the solution values Y and optionally the
     extended time stamp information XE, the extended solution
     information YE and the extended index information IE all of type
     double column vector.

     For example, solve an anonymous implementation of the Van der Pol
     equation

          fvdb = @(vt,vy) [vy(2); (1 - vy(1)^2) * vy(2) - vy(1)];

          vopt = odeset ("RelTol", 1e-3, "AbsTol", 1e-3, \
                   "NormControl", "on", "OutputFcn", @odeplot);
          ode78 (fvdb, [0 20], [2 0], vopt);

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to solve a set of non-stiff ordinary
differential



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ode78d


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3606
 -- Function File: [] = ode78d (@FUN, SLOT, INIT, LAGS, HIST, [OPT],
          [PAR1, PAR2, ...])
 -- Command: [SOL] = ode78d (@FUN, SLOT, INIT, LAGS, HIST, [OPT],
          [PAR1, PAR2, ...])
 -- Command: [T, Y, [XE, YE, IE]] = ode78d (@FUN, SLOT, INIT, LAGS,
          HIST, [OPT], [PAR1, PAR2, ...])
     This function file can be used to solve a set of non-stiff delay
     differential equations (non-stiff DDEs) with a modified version of
     the well known explicit Runge-Kutta method of order (7,8).

     If this function is called with no return argument then plot the
     solution over time in a figure window while solving the set of
     DDEs that are defined in a function and specified by the function
     handle @FUN. The second input argument SLOT is a double vector
     that defines the time slot, INIT is a double vector that defines
     the initial values of the states, LAGS is a double vector that
     describes the lags of time, HIST is a double matrix and describes
     the history of the DDEs, OPT can optionally be a structure array
     that keeps the options created with the command `odeset' and PAR1,
     PAR2, ... can optionally be other input arguments of any type that
     have to be passed to the function defined by @FUN.

     In other words, this function will solve a problem of the form
          dy/dt = fun (t, y(t), y(t-lags(1), y(t-lags(2), ...)))
          y(slot(1)) = init
          y(slot(1)-lags(1)) = hist(1), y(slot(1)-lags(2)) = hist(2), ...

     If this function is called with one return argument then return
     the solution SOL of type structure array after solving the set of
     DDEs. The solution SOL has the fields X of type double column
     vector for the steps chosen by the solver, Y of type double column
     vector for the solutions at each time step of X, SOLVER of type
     string for the solver name and optionally the extended time stamp
     information XE, the extended solution information YE and the
     extended index information IE all of type double column vector
     that keep the informations of the event function if an event
     function handle is set in the option argument OPT.

     If this function is called with more than one return argument then
     return the time stamps T, the solution values Y and optionally the
     extended time stamp information XE, the extended solution
     information YE and the extended index information IE all of type
     double column vector.

     For example:
        - the following code solves an anonymous implementation of a
          chaotic behavior

               fcao = @(vt, vy, vz) [2 * vz / (1 + vz^9.65) - vy];

               vopt = odeset ("NormControl", "on", "RelTol", 1e-3);
               vsol = ode78d (fcao, [0, 100], 0.5, 2, 0.5, vopt);

               vlag = interp1 (vsol.x, vsol.y, vsol.x - 2);
               plot (vsol.y, vlag); legend ("fcao (t,y,z)");

        - to solve the following problem with two delayed state
          variables

               d y1(t)/dt = -y1(t)
               d y2(t)/dt = -y2(t) + y1(t-5)
               d y3(t)/dt = -y3(t) + y2(t-10)*y1(t-10)

          one might do the following

               function f = fun (t, y, yd)
               f(1) = -y(1);                   %% y1' = -y1(t)
               f(2) = -y(2) + yd(1,1);         %% y2' = -y2(t) + y1(t-lags(1))
               f(3) = -y(3) + yd(2,2)*yd(1,2); %% y3' = -y3(t) + y2(t-lags(2))*y1(t-lags(2))
               endfunction
               T = [0,20]
               res = ode78d (@fun, T, [1;1;1], [5, 10], ones (3,2));


   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to solve a set of non-stiff delay
differential eq



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
odebwe


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2525
 -- Function File: [] = odebwe (@FUN, SLOT, INIT, [OPT], [PAR1, PAR2,
          ...])
 -- Command: [SOL] = odebwe (@FUN, SLOT, INIT, [OPT], [PAR1, PAR2, ...])
 -- Command: [T, Y, [XE, YE, IE]] = odebwe (@FUN, SLOT, INIT, [OPT],
          [PAR1, PAR2, ...])
     This function file can be used to solve a set of stiff ordinary
     differential equations (stiff ODEs) or stiff differential
     algebraic equations (stiff DAEs) with the Backward Euler method.

     If this function is called with no return argument then plot the
     solution over time in a figure window while solving the set of
     ODEs that are defined in a function and specified by the function
     handle @FUN. The second input argument SLOT is a double vector
     that defines the time slot, INIT is a double vector that defines
     the initial values of the states, OPT can optionally be a
     structure array that keeps the options created with the command
     `odeset' and PAR1, PAR2, ... can optionally be other input
     arguments of any type that have to be passed to the function
     defined by @FUN.

     If this function is called with one return argument then return
     the solution SOL of type structure array after solving the set of
     ODEs. The solution SOL has the fields X of type double column
     vector for the steps chosen by the solver, Y of type double column
     vector for the solutions at each time step of X, SOLVER of type
     string for the solver name and optionally the extended time stamp
     information XE, the extended solution information YE and the
     extended index information IE all of type double column vector
     that keep the informations of the event function if an event
     function handle is set in the option argument OPT.

     If this function is called with more than one return argument then
     return the time stamps T, the solution values Y and optionally the
     extended time stamp information XE, the extended solution
     information YE and the extended index information IE all of type
     double column vector.

     For example, solve an anonymous implementation of the Van der Pol
     equation

          fvdb = @(vt,vy) [vy(2); (1 - vy(1)^2) * vy(2) - vy(1)];
          vjac = @(vt,vy) [0, 1; -1 - 2 * vy(1) * vy(2), 1 - vy(1)^2];
          vopt = odeset ("RelTol", 1e-3, "AbsTol", 1e-3, \
                   "NormControl", "on", "OutputFcn", @odeplot, \
                   "Jacobian",vjac);
          odebwe (fvdb, [0 20], [2 0], vopt);

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function file can be used to solve a set of stiff ordinary
differential equ



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
odeexamples


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 169
 -- Function File: [] = odeexamples ()
     Open the differential equations examples menu and allow the user
     to select a submenu of ODE, DAE, IDE or DDE examples.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open the differential equations examples menu and allow the user to
select a sub



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
odeget


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1313
 -- Function File: [VALUE] = odeget (ODESTRUCT, OPTION, [DEFAULT])
 -- Command: [VALUES] = odeget (ODESTRUCT, {OPT1, OPT2, ...}, [{DEF1,
          DEF2, ...}])
     If this function is called with two input arguments and the first
     input argument ODESTRUCT is of type structure array and the second
     input argument OPTION is of type string then return the option
     value VALUE that is specified by the option name OPTION in the
     OdePkg option structure ODESTRUCT. Optionally if this function is
     called with a third input argument then return the default value
     DEFAULT if OPTION is not set in the structure ODESTRUCT.

     If this function is called with two input arguments and the first
     input argument ODESTRUCT is of type structure array and the second
     input argument OPTION is of type cell array of strings then return
     the option values VALUES that are specified by the option names
     OPT1, OPT2, ... in the OdePkg option structure ODESTRUCT.
     Optionally if this function is called with a third input argument
     of type cell array then return the default value DEF1 if OPT1 is
     not set in the structure ODESTRUCT, DEF2 if OPT2 is not set in the
     structure ODESTRUCT, ...

     Run examples with the command
          demo odeget

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
odephas2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1625
 -- Function File: [RET] = odephas2 (T, Y, FLAG)
     Open a new figure window and plot the first result from the
     variable Y that is of type double column vector over the second
     result from the variable Y while solving. The types and the values
     of the input parameter T and the output parameter RET depend on
     the input value FLAG that is of type string. If FLAG is
    ``"init"''
          then T must be a double column vector of length 2 with the
          first and the last time step and nothing is returned from
          this function,

    ``""''
          then T must be a double scalar specifying the actual time
          step and the return value is false (resp. value 0) for 'not
          stop solving',

    ``"done"''
          then T must be a double scalar specifying the last time step
          and nothing is returned from this function.

     This function is called by a OdePkg solver function if it was
     specified in an OdePkg options structure with the `odeset'. This
     function is an OdePkg internal helper function therefore it should
     never be necessary that this function is called directly by a
     user. There is only little error detection implemented in this
     function file to achieve the highest performance.

     For example, solve an anonymous implementation of the "Van der
     Pol" equation and display the results while solving in a 2D plane
          fvdb = @(vt,vy) [vy(2); (1 - vy(1)^2) * vy(2) - vy(1)];

          vopt = odeset ('OutputFcn', @odephas2, 'RelTol', 1e-6);
          vsol = ode45 (fvdb, [0 20], [2 0], vopt);

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open a new figure window and plot the first result from the variable Y
that is o



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
odephas3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1735
 -- Function File: [RET] = odephas3 (T, Y, FLAG)
     Open a new figure window and plot the first result from the
     variable Y that is of type double column vector over the second
     and the third result from the variable Y while solving. The types
     and the values of the input parameter T and the output parameter
     RET depend on the input value FLAG that is of type string. If FLAG
     is
    ``"init"''
          then T must be a double column vector of length 2 with the
          first and the last time step and nothing is returned from
          this function,

    ``""''
          then T must be a double scalar specifying the actual time
          step and the return value is false (resp. value 0) for 'not
          stop solving',

    ``"done"''
          then T must be a double scalar specifying the last time step
          and nothing is returned from this function.

     This function is called by a OdePkg solver function if it was
     specified in an OdePkg options structure with the `odeset'. This
     function is an OdePkg internal helper function therefore it should
     never be necessary that this function is called directly by a
     user. There is only little error detection implemented in this
     function file to achieve the highest performance.

     For example, solve the "Lorenz attractor" and display the results
     while solving in a 3D plane
          function vyd = florenz (vt, vx)
            vyd = [10 * (vx(2) - vx(1));
                   vx(1) * (28 - vx(3));
                   vx(1) * vx(2) - 8/3 * vx(3)];
          endfunction

          vopt = odeset ('OutputFcn', @odephas3);
          vsol = ode23 (@florenz, [0:0.01:7.5], [3 15 1], vopt);

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open a new figure window and plot the first result from the variable Y
that is o



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
odepkg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 664
 -- Function File: [] = odepkg ()
     OdePkg is part of the GNU Octave Repository (the Octave-Forge
     project). The package includes commands for setting up various
     options, output functions etc. before solving a set of
     differential equations with the solver functions that are also
     included. At this time OdePkg is under development with the main
     target to make a package that is mostly compatible to proprietary
     solver products.

     If this function is called without any input argument then open
     the OdePkg tutorial in the Octave window. The tutorial can also be
     opened with the following command

          doc odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
OdePkg is part of the GNU Octave Repository (the Octave-Forge project).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
odepkg_event_handle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1577
 -- Function File: [SOL] = odepkg_event_handle (@FUN, TIME, Y, FLAG,
          [PAR1, PAR2, ...])
     Return the solution of the event function that is specified as the
     first input argument @FUN in form of a function handle. The second
     input argument TIME is of type double scalar and specifies the
     time of the event evaluation, the third input argument Y either is
     of type double column vector (for ODEs and DAEs) and specifies the
     solutions or is of type cell array (for IDEs and DDEs) and
     specifies the derivatives or the history values, the third input
     argument FLAG is of type string and can be of the form
    ``"init"''
          then initialize internal persistent variables of the function
          `odepkg_event_handle' and return an empty cell array of size
          4,

    ``"calc"''
          then do the evaluation of the event function and return the
          solution SOL as type cell array of size 4,

    ``"done"''
          then cleanup internal variables of the function
          `odepkg_event_handle' and return an empty cell array of size
          4.
     Optionally if further input arguments PAR1, PAR2, ... of any type
     are given then pass these parameters through `odepkg_event_handle'
     to the event function.

     This function is an OdePkg internal helper function therefore it
     should never be necessary that this function is called directly by
     a user. There is only little error detection implemented in this
     function file to achieve the highest performance.

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the solution of the event function that is specified as the
first input a



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
odepkg_examples_dae


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
 -- Function File: [] = odepkg_examples_dae ()
     Open the DAE examples menu and allow the user to select a demo
     that will be evaluated.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open the DAE examples menu and allow the user to select a demo that
will be eval



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
odepkg_examples_dde


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
 -- Function File: [] = odepkg_examples_dde ()
     Open the DDE examples menu and allow the user to select a demo
     that will be evaluated.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open the DDE examples menu and allow the user to select a demo that
will be eval



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
odepkg_examples_ide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
 -- Function File: [] = odepkg_examples_ide ()
     Open the IDE examples menu and allow the user to select a demo
     that will be evaluated.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open the IDE examples menu and allow the user to select a demo that
will be eval



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
odepkg_examples_ode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 145
 -- Function File: [] = odepkg_examples_ode ()
     Open the ODE examples menu and allow the user to select a demo
     that will be evaluated.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open the ODE examples menu and allow the user to select a demo that
will be eval



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
odepkg_structure_check


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1043
 -- Function File: [NEWSTRUCT] = odepkg_structure_check (OLDSTRUCT,
          ["SOLVER"])
     If this function is called with one input argument of type
     structure array then check the field names and the field values of
     the OdePkg structure OLDSTRUCT and return the structure as
     NEWSTRUCT if no error is found. Optionally if this function is
     called with a second input argument "SOLVER" of type string taht
     specifies the name of a valid OdePkg solver then a higher level
     error detection is performed. The function does not modify any of
     the field names or field values but terminates with an error if an
     invalid option or value is found.

     This function is an OdePkg internal helper function therefore it
     should never be necessary that this function is called directly by
     a user. There is only little error detection implemented in this
     function file to achieve the highest performance.

     Run examples with the command
          demo odepkg_structure_check

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with one input argument of type structure
array then 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
odepkg_testsuite_calcmescd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 890
 -- Function File: [MESCD] = odepkg_testsuite_calcmescd (SOLUTION,
          REFERENCE, ABSTOL, RELTOL)
     If this function is called with four input arguments of type
     double scalar or column vector then return a normalized value for
     the minimum number of correct digits MESCD that is calculated from
     the solution at the end of an integration interval SOLUTION and a
     set of reference values REFERENCE. The input arguments ABSTOL and
     RELTOL are used to calculate a reference solution that depends on
     the relative and absolute error tolerances.

     Run examples with the command
          demo odepkg_testsuite_calcmescd

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with four input arguments of type double
scalar or co



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
odepkg_testsuite_calcscd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 873
 -- Function File: [SCD] = odepkg_testsuite_calcscd (SOLUTION,
          REFERENCE, ABSTOL, RELTOL)
     If this function is called with four input arguments of type
     double scalar or column vector then return a normalized value for
     the minimum number of correct digits SCD that is calculated from
     the solution at the end of an integration interval SOLUTION and a
     set of reference values REFERENCE. The input arguments ABSTOL and
     RELTOL are unused but present because of compatibility to the
     function `odepkg_testsuite_calcmescd'.

     Run examples with the command
          demo odepkg_testsuite_calcscd

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with four input arguments of type double
scalar or co



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
odepkg_testsuite_chemakzo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 835
 -- Function File: [SOLUTION] = odepkg_testsuite_chemakzo (@SOLVER,
          RELTOL)
     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return a cell array
     SOLUTION with performance informations about the chemical AKZO
     Nobel testsuite of differential algebraic equations after solving
     (DAE-test).

     Run examples with the command
          demo odepkg_testsuite_chemakzo

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
odepkg_testsuite_hires


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 799
 -- Function File: [SOLUTION] = odepkg_testsuite_hires (@SOLVER, RELTOL)
     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return a cell array
     SOLUTION with performance informations about the HIRES testsuite
     of ordinary differential equations after solving (ODE-test).

     Run examples with the command
          demo odepkg_testsuite_hires

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
odepkg_testsuite_implakzo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 844
 -- Function File: [SOLUTION] = odepkg_testsuite_implakzo (@SOLVER,
          RELTOL)
     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return a cell array
     SOLUTION with performance informations about the chemical AKZO
     Nobel testsuite of implicit differential algebraic equations after
     solving (IDE-test).

     Run examples with the command
          demo odepkg_testsuite_implakzo

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
odepkg_testsuite_implrober


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 866
 -- Function File: [SOLUTION] = odepkg_testsuite_implrober (@SOLVER,
          RELTOL)
     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return a cell array
     SOLUTION with performance informations about the implicit form of
     the modified ROBERTSON testsuite of implicit differential
     algebraic equations after solving (IDE-test).

     Run examples with the command
          demo odepkg_testsuite_implrober

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
odepkg_testsuite_impltrans


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 839
 -- Function File: [SOLUTION] = odepkg_testsuite_impltrans (@SOLVER,
          RELTOL)
     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return the cell array
     SOLUTION with performance informations about the TRANSISTOR
     testsuite of implicit differential algebraic equations after
     solving (IDE-test).

     Run examples with the command
          demo odepkg_testsuite_impltrans

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
odepkg_testsuite_oregonator


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 829
 -- Function File: [SOLUTION] = odepkg_testsuite_oregonator (@SOLVER,
          RELTOL)
     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return a cell array
     SOLUTION with performance informations about the OREGONATOR
     testsuite of ordinary differential equations after solving
     (ODE-test).

     Run examples with the command
          demo odepkg_testsuite_oregonator

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
odepkg_testsuite_pollution


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 828
 -- Function File: [SOLUTION] = odepkg_testsuite_pollution (@SOLVER,
          RELTOL)
     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return the cell array
     SOLUTION with performance informations about the POLLUTION
     testsuite of ordinary differential equations after solving
     (ODE-test).

     Run examples with the command
          demo odepkg_testsuite_pollution

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
odepkg_testsuite_robertson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 836
 -- Function File: [SOLUTION] = odepkg_testsuite_robertson (@SOLVER,
          RELTOL)
     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return a cell array
     SOLUTION with performance informations about the modified
     ROBERTSON testsuite of differential algebraic equations after
     solving (DAE-test).

     Run examples with the command
          demo odepkg_testsuite_robertson

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
odepkg_testsuite_transistor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 832
 -- Function File: [SOLUTION] = odepkg_testsuite_transistor (@SOLVER,
          RELTOL)
     If this function is called with two input arguments and the first
     input argument @SOLVER is a function handle describing an OdePkg
     solver and the second input argument RELTOL is a double scalar
     describing the relative error tolerance then return the cell array
     SOLUTION with performance informations about the TRANSISTOR
     testsuite of differential algebraic equations after solving
     (DAE-test).

     Run examples with the command
          demo odepkg_testsuite_transistor

     This function has been ported from the "Test Set for IVP solvers"
     which is developed by the INdAM Bari unit project group "Codes and
     Test Problems for Differential Equations", coordinator F. Mazzia.

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called with two input arguments and the first input
argument



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
odeplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1551
 -- Function File: [RET] = odeplot (T, Y, FLAG)
     Open a new figure window and plot the results from the variable Y
     of type column vector over time while solving. The types and the
     values of the input parameter T and the output parameter RET
     depend on the input value FLAG that is of type string. If FLAG is
    ``"init"''
          then T must be a double column vector of length 2 with the
          first and the last time step and nothing is returned from
          this function,

    ``""''
          then T must be a double scalar specifying the actual time
          step and the return value is false (resp. value 0) for 'not
          stop solving',

    ``"done"''
          then T must be a double scalar specifying the last time step
          and nothing is returned from this function.

     This function is called by a OdePkg solver function if it was
     specified in an OdePkg options structure with the `odeset'. This
     function is an OdePkg internal helper function therefore it should
     never be necessary that this function is called directly by a
     user. There is only little error detection implemented in this
     function file to achieve the highest performance.

     For example, solve an anonymous implementation of the "Van der
     Pol" equation and display the results while solving
          fvdb = @(vt,vy) [vy(2); (1 - vy(1)^2) * vy(2) - vy(1)];

          vopt = odeset ('OutputFcn', @odeplot, 'RelTol', 1e-6);
          vsol = ode45 (fvdb, [0 20], [2 0], vopt);

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Open a new figure window and plot the results from the variable Y of
type column



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
odeprint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1760
 -- Function File: [RET] = odeprint (T, Y, FLAG)
     Display the results of the set of differential equations in the
     Octave window while solving. The first column of the screen output
     shows the actual time stamp that is given with the input arguemtn
     T, the following columns show the results from the function
     evaluation that are given by the column vector Y. The types and
     the values of the input parameter T and the output parameter RET
     depend on the input value FLAG that is of type string. If FLAG is
    ``"init"''
          then T must be a double column vector of length 2 with the
          first and the last time step and nothing is returned from
          this function,

    ``""''
          then T must be a double scalar specifying the actual time
          step and the return value is false (resp. value 0) for 'not
          stop solving',

    ``"done"''
          then T must be a double scalar specifying the last time step
          and nothing is returned from this function.

     This function is called by a OdePkg solver function if it was
     specified in an OdePkg options structure with the `odeset'. This
     function is an OdePkg internal helper function therefore it should
     never be necessary that this function is called directly by a
     user. There is only little error detection implemented in this
     function file to achieve the highest performance.

     For example, solve an anonymous implementation of the "Van der
     Pol" equation and print the results while solving
          fvdb = @(vt,vy) [vy(2); (1 - vy(1)^2) * vy(2) - vy(1)];

          vopt = odeset ('OutputFcn', @odeprint, 'RelTol', 1e-6);
          vsol = ode45 (fvdb, [0 20], [2 0], vopt);

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Display the results of the set of differential equations in the Octave
window wh



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
odeset


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1704
 -- Function File: [ODESTRUCT] = odeset ()
 -- Command: [ODESTRUCT] = odeset ("FIELD1", VALUE1, "FIELD2", VALUE2,
          ...)
 -- Command: [ODESTRUCT] = odeset (OLDSTRUCT, "FIELD1", VALUE1,
          "FIELD2", VALUE2, ...)
 -- Command: [ODESTRUCT] = odeset (OLDSTRUCT, NEWSTRUCT)
     If this function is called without an input argument then return a
     new OdePkg options structure array that contains all the necessary
     fields and sets the values of all fields to default values.

     If this function is called with string input arguments "FIELD1",
     "FIELD2", ... identifying valid OdePkg options then return a new
     OdePkg options structure with all necessary fields and set the
     values of the fields "FIELD1", "FIELD2", ... to the values VALUE1,
     VALUE2, ...

     If this function is called with a first input argument OLDSTRUCT
     of type structure array then overwrite all values of the options
     "FIELD1", "FIELD2", ... of the structure OLDSTRUCT with new values
     VALUE1, VALUE2, ... and return the modified structure array.

     If this function is called with two input argumnets OLDSTRUCT and
     NEWSTRUCT of type structure array then overwrite all values in the
     fields from the structure OLDSTRUCT with new values of the fields
     from the structure NEWSTRUCT. Empty values of NEWSTRUCT will not
     overwrite values in OLDSTRUCT.

     For a detailed explanation about valid fields and field values in
     an OdePkg structure aaray have a look at the `odepkg.pdf', Section
     'ODE/DAE/IDE/DDE options' or run the command `doc odepkg' to open
     the tutorial.

     Run examples with the command
          demo odeset

   See also: odepkg




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If this function is called without an input argument then return a new
OdePkg op





