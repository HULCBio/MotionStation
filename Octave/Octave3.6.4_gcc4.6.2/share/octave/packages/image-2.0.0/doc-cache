# Created by Octave 3.6.4, Sat Mar 30 09:30:38 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 117
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
analyze75info


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 572
 -- Function File: HEADER = analyze75info (FILENAME)
 -- Function File: HEADER = analyze75info (FILENAME, "ByteOrder", ARCH)
     Read header of an Analyze 7.5 file.

     FILENAME must be the path for an Analyze 7.5 file or the path for a
     directory with a single .hdr file can be specified.

     The optional argument `"ByteOrder"' reads the file with the
     specified ARCH ("ieee-be" or "ieee-le" for IEEE big endian or IEEE
     little endian respectively).

     HEADER is a structure with the file information.

     See also: analyze75read, analyze75write





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Read header of an Analyze 7.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
analyze75read


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 411
 -- Function File: IMAGE = analyze75read (FILENAME)
 -- Function File: IMAGE = analyze75read (HEADER)
     Read image data of an Analyze 7.5 file.

     FILENAME must be the path for an Analyze 7.5 file or the path for a
     directory with a single .hdr file can be specified. Alternatively,
     the file HEADER can be specified as returned by `analyze75info'.

     See also: analyze75info, analyze75write





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Read image data of an Analyze 7.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
analyze75write


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 504
 -- Function File: analyze75write (FILENAME, DATA, HEADER)
 -- Function File: analyze75write (FILENAME, DATA, X, Y, Z)
 -- Function File: analyze75write (FILENAME, DATA, HEADER, X, Y, Z)
     Write image data to an Analyze 7.5 file.

     FILENAME is the path to write the Analyze 7.5 file; DATA is the 3D
     image data; HEADER is a structure containing the file information;
     X, Y, Z are lists of the x,y,z coordinates (in cm) of the data
     grid.

     See also: analyze75info, analyze75read





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Write image data to an Analyze 7.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
applylut


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 554
 -- Function File: A = applylut (BW, LUT)
     Uses lookup tables to perform a neighbour operation on binary
     images.

     A = applylut(BW,LUT) returns the result of a neighbour operation
     using the lookup table LUT which can be created by makelut.

     It first computes a matrix with the index of each element in the
     lookup table. To do this, it convolves the original matrix with a
     matrix which assigns each of the neighbours a bit in the resulting
     index. Then LUT is accessed to compute the result.

     See also: makelut





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Uses lookup tables to perform a neighbour operation on binary images.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bestblk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 834
 -- Function File: SIZ =  bestblk ([M N], K)
 -- Function File: [MB NB] =  bestblk ([M N], K)
     Calculates the best size of block for block processing.

     `siz=bestblk([m,n],k)' calculates the optimal block size for block
     processing for a M-by-N image. K is the maximum side dimension of
     the block. Its default value is 100. SIZ is a row vector which
     contains row and column dimensions for the block.

     `[mb,nb]=bestblk([m,n],k)' behaves as described above but returns
     block dimensions to MB and NB.

     *Algorithm:*

     For each dimension (M and N), it follows this algorithm:

     1.- If dimension is less or equal than K, it returns the dimension
     value.

     2.- If not then returns the value between
     `round(min(dimension/10,k/2))' which minimizes padding.

     See also: blockproc





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Calculates the best size of block for block processing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
blkproc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 160
 -- Function File: B =  blkproc (A, [M,N], FUN)
     This function has been deprecated. Please use `blockproc' instead
     which has exactly the same syntax.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
This function has been deprecated.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
blockproc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1470
 -- Function File: B =  blockproc (A, [M,N], FUN)
 -- Function File: B =  blockproc (A, [M,N], FUN, ...)
 -- Function File: B =  blockproc (A, [M,N], [MBORDER,NBORDER], FUN,
          ...)
 -- Function File: B =  blockproc (A, 'indexed', ...)
     Processes image in blocks using user-supplied function.

     `B=blockproc(A,[m,n],fun)' divides image A in M-by-N blocks, and
     passes them to user-supplied function FUN, which result is
     concatenated to build returning matrix B. If padding is needed to
     build M-by-N, it is added at the bottom and right borders of the
     image.  0 is used as a padding value.

     `B=blockproc(A,[m,n],fun, ...)' behaves as described above but
     passes extra parameters to function FUN.

     `B=blockproc(A,[m,n],[mborder,nborder],fun, ...)' behaves as
     described but uses blocks which overlap with neighbour blocks.
     Overlapping dimensions are MBORDER vertically and NBORDER
     horizontally. This doesn't change the number of blocks in an image
     (which depends only on size(A) and [M,N]). Adding a border
     requires extra padding on all edges of the image. 0 is used as a
     padding value.

     `B=blockproc(A,'indexed', ...)' assumes that A is an indexed
     image, so it pads the image using proper value: 0 for uint8 and
     uint16 images and 1 for double images. Keep in mind that if
     'indexed' is not specified padding is always done using 0.

     See also: colfilt, inline, bestblk





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Processes image in blocks using user-supplied function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bmpwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 533
 -- Function File: bmpwrite (X, MAP, FILE)
     Write the bitmap X into FILE (8-bit indexed uncompressed).

     _warning_: `bmpwrite' has been deprecated in favor of `imwrite' in
     Octave core. This function will be removed from future versions of
     the 'image' package".

     The values in X are indices into the given RGB colour MAP.

 -- Function File: bmpwrite (X, FILE)
     Write the bitmap X into FILE (24-bit truecolor uncompressed).  X
     is an m x n x 3 array of R,G,B integer values in the range 0 to
     255.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Write the bitmap X into FILE (8-bit indexed uncompressed).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bwarea


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 536
 -- Function File: TOTAL = bwarea (BW)
     Estimate total area of objects on the image BW.

     The image BW can be of any class, even non-logical, in which case
     non zero valued pixels are considered to be an object.

     This algorithm is not the same as counting the number of pixels
     belonging to an object as it tries to estimate the area of the
     original object.  The value of each pixel to the total area is
     weighted in relation to its neighbour pixels.

     See also: im2bw, bweuler, bwperim, regionprops





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Estimate total area of objects on the image BW.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bwborder


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 289
 -- Function File: B =  bwborder (IM)
     Finds the borders of foreground objects in a binary image.

     B is the borders in the 0-1 matrix IM. 4-neighborhood is
     considered.

     A pixel is on the border if it is set in IM, and it has at least
     one neighbor that is not set.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Finds the borders of foreground objects in a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
bwboundaries


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1278
 -- Function File: BOUNDARIES =  bwboundaries(BW)
 -- Function File: BOUNDARIES =  bwboundaries(BW, CONN)
 -- Function File: BOUNDARIES =  bwboundaries(BW, CONN, HOLES)
 -- Function File: [BOUNDARIES, LABELS] =  bwboundaries(...)
 -- Function File: [BOUNDARIES, LABELS, NUM_LABELS] =  bwboundaries(...)
     Trace the boundaries of the objects in a binary image.

     BOUNDARIES is a cell array in which each element is the boundary
     of an object in the binary image BW. The clockwise boundary of
     each object is computed by the `boundary' function.

     By default the boundaries are computed using 8-connectivity. This
     can be changed to 4-connectivity by setting CONN to 4.

     By default `bwboundaries' computes all boundaries in the image,
     i.e.  both interior and exterior object boundaries. This behaviour
     can be changed through the HOLES input argument. If this is
     'holes', both boundary types are considered. If it is instead
     'noholes', only exterior boundaries will be traced.

     If two or more output arguments are requested, the algorithm also
     returns the labelled image computed by `bwlabel' in LABELS. The
     number of labels in this image is optionally returned in
     NUM_LABELS.

     See also: boundary, bwlabel





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Trace the boundaries of the objects in a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
bwconncomp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 946
 -- Function File: CC =  bwconncomp (BW)
 -- Function File: CC =  bwconncomp (BW, CONNECTIVITY)
     Trace the boundaries of objects in a binary image.

     `bwconncomp' traces the boundaries of objects in a binary image BW
     and returns information about them in a structure with the
     following fields.

    Connectivity
          The connectivity used in the boundary tracing.

    ImageSize
          The size of the image BW.

    NumObjects
          The number of objects in the image BW.

    PixelIdxList
          A cell array containing where each element corresponds to an
          object in BW.  Each element is represented as a vector of
          linear indices of the boundary of the given object.

     The connectivity used in the tracing is by default 4, but can be
     changed by setting the CONNECTIVITY input parameter to 8. Sadly,
     this is not yet implemented.

     See also: bwlabel, bwboundaries, ind2sub





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Trace the boundaries of objects in a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bwdist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1229
 -- Function File: D = bwdist(BW)
     Computes the distance transform of the image BW.  BW should be a
     binary 2D array, either a Boolean array or a numeric array
     containing only the values 0 and 1.  The return value D is a
     double matrix of the same size as BW.  Elements with value 0 are
     considered background pixels, elements with value 1 are considered
     object pixels. The return value for each background pixel is the
     distance (according to the chosen metric) to the closest object
     pixel. For each object pixel the return value is 0.

 -- Function File: D = bwdist(BW, METHOD)
     METHOD is a string to choose the distance metric. Currently
     available metrics are 'euclidean', 'chessboard', 'cityblock' and
     'quasi-euclidean', which may each be abbreviated to any string
     starting with 'e', 'ch', 'ci' and 'q', respectively.  If METHOD is
     not specified, 'euclidean' is the default.

 -- Function File: [D,C] = bwdist(BW, METHOD)
     If a second output argument is given, the linear index for the
     closest object pixel is returned for each pixel. (For object
     pixels, the index points to the pixel itself.) The return value C
     is a matrix the same size as BW.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Computes the distance transform of the image BW.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bweuler


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 662
 -- Function File: EUL =  bweuler (BW, N)
     Calculate the Euler number of a binary image.

     This function calculates the Euler number EUL of a binary image
     BW. This number is a scalar whose value represents the total
     number of objects in BW minus the number of holes.

     N is an optional argument that specifies the neighbourhood
     connectivity. Must either be 4 or 8. If omitted, defaults to 8.

     This function uses Bit Quads as described in "Digital Image
     Processing" to calculate euler number.

     References: W. K. Pratt, "Digital Image Processing", 3rd Edition,
     pp 593-595

     See also: bwmorph, bwperim, qtgetblk





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Calculate the Euler number of a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
bwhitmiss


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 535
 -- Function File: BW2 = bwhitmiss (BW1, SE1, SE1)
 -- Function File: BW2 = bwhitmiss (BW1, INTERVAL)
     Perform the binary hit-miss operation.

     If two structuring elements SE1 and SE1 are given, the hit-miss
     operation is defined as
          bw2 = erode(bw1, se1) & erode(!bw1, se2);
     If instead an 'interval' array is given, two structuring elements
     are computed as
          se1 = (interval ==  1)
          se2 = (interval == -1)
     and then the operation is defined as previously.

     See also: bwmorph





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Perform the binary hit-miss operation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bwmorph


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7015
 -- Function File: BW2 = bwmorph (BW, OPERATION)
 -- Function File: BW2 = bwmorph (BW, OPERATION, N)
     Perform a morphological operation on a binary image.

     BW2=bwmorph(BW,operation) performs a morphological operation
     specified by OPERATION on binary image BW. All possible operations
     and their meaning are specified in a table below.

     BW2=bwmorph(BW,operation,n) performs a morphological operation N
     times. Keep in mind that it has no sense to apply some operations
     more than once, since some of them return the same result
     regardless how many iterations we request. Those return a warning
     if are called with n>1 and they compute the result for n=1.

     N>1 is actually used for the following operations: diag, dilate,
     erode, majority, shrink, skel, spur, thicken and thin.

    `'bothat''
          Performs a bottom hat operation, a closing operation (which
          is a dilation followed by an erosion) and finally substracts
          the original image.

    `'bridge''
          Performs a bridge operation. Sets a pixel to 1 if it has two
          nonzero neighbours which are not connected, so it "bridges"
          them. There are 119 3-by-3 patterns which trigger setting a
          pixel to 1.

    `'clean''
          Performs an isolated pixel remove operation. Sets a pixel to
          0 if all of its eight-connected neighbours are 0.

    `'close''
          Performs closing operation, which is a dilation followed by
          erosion.  It uses a ones(3) matrix as structuring element for
          both operations.

    `'diag''
          Performs a diagonal fill operation. Sets a pixel to 1 if that
          eliminates eight-connectivity of the background.

    `'dilate''
          Performs a dilation operation. It uses ones(3) as structuring
          element.

    `'erode''
          Performs an erosion operation. It uses ones(3) as structuring
          element.

    `'fill''
          Performs a interior fill operation. Sets a pixel to 1 if all
          four-connected pixels are 1.

    `'hbreak''
          Performs a H-break operation. Breaks (sets to 0) pixels that
          are H-connected.

    `'majority''
          Performs a majority black operation. Sets a pixel to 1 if five
          or more pixels in a 3-by-3 window are 1. If not it is set to
          0.

    `'open''
          Performs an opening operation, which is an erosion followed
          by a dilation. It uses ones(3) as structuring element.

    `'remove''
          Performs a iterior pixel remove operation. Sets a pixel to 0
          if all of its four-connected neighbours are 1.

    `'shrink''
          Performs a shrink operation. Sets pixels to 0 such that an
          object without holes erodes to a single pixel (set to 1) at
          or near its center of mass. An object with holes erodes to a
          connected ring lying midway between each hole and its nearest
          outer boundary. It preserves Euler number.

    `'skel''
          Performs a skeletonization operation. It calculates a "median
          axis skeleton" so that points of this skeleton are at the
          same distance of its nearby borders. It preserver Euler
          number. Please read compatibility notes for more info.

          It uses the same algorithm as skel-pratt but this could
          change for compatibility in the future.

    `'skel-lantuejol''
          Performs a skeletonization operation as described in Gonzalez
          & Woods "Digital Image Processing" pp 538-540. The text
          references Lantuejoul as authour of this algorithm.

          It has the beauty of being a clean and simple approach, but
          skeletons are thicker than they need to and, in addition, not
          guaranteed to be connected.

          This algorithm is iterative. It will be applied the minimum
          value of N times or number of iterations specified in
          algorithm description. It's most useful to run this algorithm
          with `n=Inf'.

    `'skel-pratt''
          Performs a skeletonization operation as described by William
          K. Pratt in "Digital Image Processing".

    `'spur''
          Performs a remove spur operation. It sets pixel to 0 if it
          has only one eight-connected pixel in its neighbourhood.

    `'thicken''
          Performs a thickening operation. This operation "thickens"
          objects avoiding their fusion. Its implemented as a thinning
          of the background. That is, thinning on negated image.
          Finally a diagonal fill operation is performed to avoid
          "eight-connecting" objects.

    `'thin''
          Performs a thinning operation. When n=Inf, thinning sets
          pixels to 0 such that an object without holes is converted to
          a stroke equidistant from its nearest outer boundaries. If
          the object has holes it creates a ring midway between each
          hole and its near outer boundary. This differ from shrink in
          that shrink converts objects without holes to a single pixels
          and thin to a stroke. It preserves Euler number.

    `'tophat''
          Performs a top hat operation, a opening operation (which is an
          erosion followed by a dilation) and finally substracts the
          original image.

     Some useful concepts to understant operators:

     Operations are defined on 3-by-3 blocks of data, where the pixel in
     the center of the block. Those pixels are numerated as follows:

     X3  X2  X1
     X4  X   X0
     X5  X6  X7

     *Neighbourhood definitions used in operation descriptions:*
    `'four-connected''
          It refers to pixels which are connected horizontally or
          vertically to X: X1, X3, X5 and X7.

    `'eight-connected''
          It refers to all pixels which are connected to X: X0, X1, X2,
          X3, X4, X5, X6 and X7.

     *Compatibility notes:*
    `'fill''
          Checking MATLAB behaviour is needed because its documentation
          doesn't make clear if it creates a black pixel if all
          eight-connected pixels are black or if four-connected suffice
          (as we do currently following Pratt's book).

    `'skel''
          Algorithm used here is described in Pratt's book. When
          applying it to the "circles" image in MATLAB documentation,
          results are not the same. Perhaps MATLAB uses Blum's algoritm
          (for further info please read comments in code).

    `'skel-pratt''
          This option is not available in MATLAB.

    `'skel-lantuejoul''
          This option is not available in MATLAB.

    `'thicken''
          This implementation also thickens image borders. This can
          easily be avoided i necessary. MATLAB documentation doesn't
          state how it behaves.

     References: W. K. Pratt, "Digital Image Processing" Gonzalez and
     Woods, "Digital Image Processing"

     See also: imdilate, imerode, imtophat, imbothat, makelut, applylut





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Perform a morphological operation on a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bwperim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 401
 -- Function File: BW2 = bwperim(BW1)
 -- Function File: BW2 = bwperim(BW1, N)
     Find the perimeter of objects in binary images.

     A pixel is part of an object perimeter if its value is one and
     there is at least one zero-valued pixel in its neighborhood.

     By default the neighborhood of a pixel is 4 nearest pixels, but if
     N is set to 8 the 8 nearest pixels will be considered.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Find the perimeter of objects in binary images.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bwselect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 431
 -- Function File: [IMOUT, IDX] = bwselect(IM, COLS, ROWS, CONNECT)
     Select connected regions in a binary image.

    `IM'
          binary input image

    `[COLS, ROWS]'
          vectors of starting points (x,y)

    `CONNECT'
          connectedness 4 or 8. default is 8

    `IMOUT'
          the image of all objects in image im that overlap pixels in
          (cols,rows)

    `IDX'
          index of pixels in imout




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Select connected regions in a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
cmpermute


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 692
 -- Function File: [Y, NEWMAP] = cmpermute (X, MAP)
 -- Function File: [Y, NEWMAP] = cmpermute (X, MAP, INDEX)
     Reorder colors in a colormap.

     When called with only two arguments, `cmpermute' randomly
     rearranges the colormap MAP and returns a new colormap NEWMAP.  It
     also returns the indexed image Y which is the equivalent of the
     original input image X when displayed using NEWMAP.  The input
     image X must be an indexed image of class uint8 or double.

     When called with an optional third argument the order of colors in
     the new colormap is defined by INDEX.

     *Caution:* `index' should not have repeated elements or the
     function will fail.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Reorder colors in a colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cmunique


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1449
 -- Function File: [Y, NEWMAP] = cmunique (X, MAP)
 -- Function File: [Y, NEWMAP] = cmunique (RGB)
 -- Function File: [Y, NEWMAP] = cmunique (I)
     Convert an input image X to an ouput indexed image Y which uses
     the smallest colormap possible NEWMAP.

     When the input is an indexed image (X with colormap MAP) the
     output is a colormap NEWMAP from which any repeated rows have been
     eliminated.  The output image, Y, is the original input image with
     the indices adjusted to match the new, possibly smaller, colormap.

     When the input is an RGB image (an MxNx3 array), the output
     colormap will contain one entry for every unique color in the
     original image.  In the worst case the new map could have as many
     rows as the number of pixels in the original image.

     When the input is a grayscale image I, the output colormap will
     contain one entry for every unique intensity value in the original
     image.  In the worst case the new map could have as many rows as
     the number of pixels in the original image.

     Implementation Details:

     NEWMAP is always an Mx3 matrix, even if the input image is an
     intensity grayscale image I (all three RGB planes are assigned the
     same value).

     The output image is of class uint8 if the size of the new colormap
     is less than or equal to 256.  Otherwise, the output image is of
     class double.

     See also: rgb2ind, gray2ind





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Convert an input image X to an ouput indexed image Y which uses the
smallest col



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
col2im


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 957
 -- Function File: A = col2im (B, [M,N], [MM,NN], BLOCK_TYPE)
 -- Function File: A = col2im (B, [M,N], [MM,NN])
     Rearranges matrix columns into blocks.

     `A=col2im(B,[m,n],[mm,nn],block_type)' rearranges columns of
     matrix B intro blocks in a way controlled by BLOCK_TYPE param,
     which can take the following values:

    `distinct'
          It uses M-by-N distinct blocks (which are not overlapped),
          and are rearranged to form a MM-by-NN matrix A. B's height
          must be M*N and `col2im' rearranges each column to a M-by-N
          block and uses them to fill the whole matrix in left-to-right
          and then up-to-down order.

    `sliding'
          Is uses M-by-N sliding blocks. It rearranges row vector B to
          a (MM-M+1)-by-(NN-N+1) matrix A. B must be a
          1-by-(MM-M+1)*(NN-N+1).

     `A=col2im(B,[m,n],[mm,nn])' takes `distinct' as a default value
     for BLOCK_TYPE.

     See also: im2col





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Rearranges matrix columns into blocks.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
colfilt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1041
 -- Function File: colfilt (A, [R, C], [M, N], 'sliding', F,...)
     Apply filter to matrix blocks

     For each R x C overlapping subblock of A, add a column in matrix C
      F(C,...) should return a row vector which is then reshaped into a
      a matrix of size A and returned. A is processed in chunks of size
     M x N.

 -- Function File: colfilt (A, [R, C], [M, N], 'distinct', F,...)
     For each R x C non-overlapping subblock of A, add a column in
     matrix C   F(C,...) should return a matrix of size C each column
     of which is   placed back into the subblock from whence it came. A
     is processed   in chunks of size M x N.

     The present version requires that [M, N] divide size(A), but for
     compatibility it should work even if [M, N] does not divide A. Use
     the following instead:
          [r, c] = size(A);
          padA = zeros (m*ceil(r/m),n*ceil(c/n));
          padA(1:r,1:c) = A;
          B = colfilt(padA,...);
          B = B(1:r,1:c);

     The present version does not handle 'distinct'




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Apply filter to matrix blocks




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
colorgradient


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 542
 -- Function File: M = colorgradient (C, W, N)
     Define a colour map which smoothly traverses the given colors.  C
     contains the colours, one row per r,g,b value.  W(i) is the
     relative length of the transition from colour i to colour i+1 in
     the entire gradient.  The default is ones(rows(C)-1,1).  n is the
     length of the colour map.  The default is rows(colormap).

     E.g.,
          colorgradient([0,0,1; 1,1,0; 1,0,0])  # blue -> yellow -> red
          x = linspace(0,1,200);
          imagesc(x(:,ones(30,1)))';




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Define a colour map which smoothly traverses the given colors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
conndef


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 507
 -- Function File: CONN =  conndef (NUM_DIMS, TYPE)
     Creates a connectivity array.

     `conn=conndef(num_dims,type)' creates a connectivity array (CONN)
     of NUM_DIMS dimensions and which type is defined by TYPE as
     follows:
    `minimal'
          Neighbours touch the central element on a
          (NUM_DIMS-1)-dimensional surface.

    `maximal'
          Neighbours touch the central element in any way. Equivalent to
          `ones(repmat(3,1,NUM_DIMS))'.

     See also: iptcheckconn





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Creates a connectivity array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
corr2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 184
 -- Function File: R = corr2 (I,J)
     Returns the correlation coefficient between I and J.  I, J must be
     real type matrices or vectors of same size.

     See also: cov, std2





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Returns the correlation coefficient between I and J.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dilate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1098
 -- Function File: BW2 = dilate (BW1, SE)
 -- Function File: BW2 = dilate (BW1, SE, ALG)
 -- Function File: BW2 = dilate (BW1, SE, ..., N)
     Perform a dilation morphological operation on a binary image.

     _warning_: `dilate' has been deprecated in favor of `imdilate'.
     This function will be removed from future versions of the 'image'
     package".

     BW2 = dilate(BW1, SE) returns a binary image with the result of a
     dilation operation on BW1 using neighbour mask SE.

     For each point in BW1, dilate search its neighbours (which are
     defined by setting to 1 their in SE). If any of its neighbours is
     on (1), then pixel is set to 1. If all are off (0) then it is set
     to 0.

     Center of SE is calculated using floor((size(SE)+1)/2).

     Pixels outside the image are considered to be 0.

     BW2 = dilate(BW1, SE, alg) returns the result of a dilation
     operation using algorithm ALG. Only 'spatial' is implemented at
     the moment.

     BW2 = dilate(BW1, SE, ..., n) returns the result of N dilation
     operations on BW1.

     See also: erode





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Perform a dilation morphological operation on a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
edge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6148
 -- Function File: BW = edge (IM, METHOD)
 -- Function File: BW = edge (IM, METHOD, ARG1, ARG2)
 -- Function File: [BW, THRESH] = edge (...)
     Detect edges in the given image using various methods. The first
     input IM is the gray scale image in which edges are to be
     detected. The second argument controls which method is used for
     detecting the edges. The rest of the input arguments depend on the
     selected method. The first output BW is a `logical' image
     containing the edges. Most methods also returns an automatically
     computed threshold as the second output.

     The METHOD input argument can any of the following strings (the
     default value is "Sobel")

    "Sobel"
          Finds the edges in IM using the Sobel approximation to the
          derivatives. Edge points are defined as points where the
          length of the gradient exceeds a threshold and is larger than
          it's neighbours in either the horizontal or vertical
          direction. The threshold is passed to the method in the third
          input argument ARG1. If one is not given, a threshold is
          automatically computed as 4*M, where M is the mean of the
          gradient of the entire image. The optional 4th input argument
          controls the direction in which the gradient is approximated.
          It can be either "horizontal", "vertical", or "both"
          (default).

    "Prewitt"
          Finds the edges in IM using the Prewitt approximation to the
          derivatives. This method works just like "Sobel" except a
          different aproximation the gradient is used.

    "Roberts"
          Finds the edges in IM using the Roberts approximation to the
          derivatives. Edge points are defined as points where the
          length of the gradient exceeds a threshold and is larger than
          it's neighbours in either the horizontal or vertical
          direction. The threshold is passed to the method in the third
          input argument ARG1. If one is not given, a threshold is
          automatically computed as 6*M, where M is the mean of the
          gradient of the entire image. The optional 4th input argument
          can be either "thinning" (default) or "nothinning". If it is
          "thinning" a simple thinning procedure is applied to the edge
          image such that the edges are only one pixel wide. If ARG2 is
          "nothinning", this procedure is not applied.

    "Kirsch"
          Finds the edges in IM using the Kirsch approximation to the
          derivatives. Edge points are defined as points where the
          length of the gradient exceeds a threshold and is larger than
          it's neighbours in either the horizontal or vertical
          direction. The threshold is passed to the method in the third
          input argument ARG1. If one is not given, a threshold is
          automatically computed as M, where M is the mean of the
          gradient of the entire image. The optional 4th input argument
          controls the direction in which the gradient is approximated.
          It can be either "horizontal", "vertical", or "both"
          (default).

    "LoG"
          Finds edges in IM by convolving with the Laplacian of
          Gaussian (LoG) filter, and finding zero crossings. Only zero
          crossings where the filter response is larger than an
          automatically computed threshold are retained.  The threshold
          is passed to the method in the third input argument ARG1.  If
          one is not given, a threshold is automatically computed as
          0.75*M, where M is the mean of absolute value of LoG filter
          response. The optional 4th input argument sets the spread of
          the LoG filter. By default this value is 2.

    "Zerocross"
          Finds edges in the image IM by convolving it with the
          user-supplied filter ARG2 and finding zero crossings larger
          than the threshold ARG1. If ARG1 is [] a threshold is
          computed as the mean value of the absolute filter response.

    "Canny"
          Finds edges using the Canny edge detector. The optional third
          input argument ARG1 sets the thresholds used in the
          hysteresis thresholding. If ARG1 is a two dimensional vector
          it's first element is used as the lower threshold, while the
          second element is used as the high threshold. If, on the
          other hand, ARG1 is a single scalar it is used as the high
          threshold, while the lower threshold is 0.4*ARG1. The
          optional 4th input argument ARG2 is the spread of the
          low-pass Gaussian filter that is used to smooth the input
          image prior to estimating gradients. By default this scale
          parameter is 2.

    "Lindeberg"
          Finds edges using in IM using the differential geometric
          single-scale edge detector given by Tony Lindeberg. The
          optional third input argument ARG1 is the scale (spread of
          Gaussian filter) at which the edges are computed. By default
          this 2.

    "Andy"
          A.Adler's idea (c) 1999. Somewhat based on the canny method.
          The steps are
            1. Do a Sobel edge detection and to generate an image at a
               high and low threshold.

            2. Edge extend all edges in the LT image by several pixels,
               in the vertical, horizontal, and 45 degree directions.
               Combine these into edge extended (EE) image.

            3. Dilate the EE image by 1 step.

            4. Select all EE features that are connected to features in
               the HT image.

          The parameters for the method is given in a vector:
         params(1)==0 or 4 or 8
               Perform x connected dilatation (step 3).

         params(2)
               Dilatation coeficient (threshold) in step 3.

         params(3)
               Length of edge extention convolution (step 2).

         params(4)
               Coeficient of extention convolution in step 2.
          defaults = [8, 1, 3, 3]


     See also: fspecial, nonmax_supress





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Detect edges in the given image using various methods.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
entropy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 582
 -- Function File: E = entropy (IM)
 -- Function File: E = entropy (IM, NBINS)
     Computes the entropy of an image.

     The entropy of the elements of the image IM is computed as

          E = -sum (P .* log2 (P)

     where P is the distribution of the elements of IM. The distribution
     is approximated using a histogram with NBINS cells. If IM is
     `logical' then two cells are used by default. For other classes
     256 cells are used by default.

     When the entropy is computed, zero-valued cells of the histogram
     are ignored.

     See also: entropyfilt





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Computes the entropy of an image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
entropyfilt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1194
 -- Function File: E = entropyfilt (IM)
 -- Function File: E = entropyfilt (IM, DOMAIN)
 -- Function File: E = entropyfilt (IM, DOMAIN, PADDING, ...)
     Computes the local entropy in a neighbourhood around each pixel in
     an image.

     The entropy of the elements of the neighbourhood is computed as

          E = -sum (P .* log2 (P)

     where P is the distribution of the elements of IM. The distribution
     is approximated using a histogram with NBINS cells. If IM is
     `logical' then two cells are used. For other classes 256 cells are
     used.

     When the entropy is computed, zero-valued cells of the histogram
     are ignored.

     The neighbourhood is defined by the DOMAIN binary mask. Elements
     of the mask with a non-zero value are considered part of the
     neighbourhood. By default a 9 by 9 matrix containing only non-zero
     values is used.

     At the border of the image, extrapolation is used. By default
     symmetric extrapolation is used, but any method supported by the
     `padarray' function can be used. Since extrapolation is used, one
     can expect a lower entropy near the image border.

     See also: entropy, paddarray, stdfilt





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Computes the local entropy in a neighbourhood around each pixel in an
image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
erode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1076
 -- Function File: BW2 = erode (BW1, SE)
 -- Function File: BW2 = erode (BW1, SE, ALG)
 -- Function File: BW2 = erode (BW1, SE, ..., N)
     Perform an erosion morphological operation on a binary image.

     _warning_: `erode' has been deprecated in favor of `imerode'. This
     function will be removed from future versions of the 'image'
     package".

     BW2 = erosion(BW1, SE) returns a binary image with the result of
     an erosion operation on BW1 using neighbour mask SE.

     For each point in BW1, erode searchs its neighbours (which are
     defined by setting to 1 their in SE). If all neighbours are on
     (1), then pixel is set to 1. If any is off (0) then it is set to 0.

     Center of SE is calculated using floor((size(SE)+1)/2).

     Pixels outside the image are considered to be 0.

     BW2 = erode(BW1, SE, alg) returns the result of a erosion operation
     using algorithm ALG. Only 'spatial' is implemented at the moment.

     BW2 = erosion(BW1, SE, ..., n) returns the result of N erosion
     operations on BW1.

     See also: dilate





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Perform an erosion morphological operation on a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fchcode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 778
 -- Function File: FCC =  fchcode (BOUND)
     Determine the Freeman chain code for a boundary.

     `fchcode' computes the Freeman chain code for the N-connected
     boundary BOUND. N must be either 8 or 4.

     BOUND is a K-by-2 matrix containing the row/column coordinates of
     points on the boundary. Optionally, the first point can be
     repeated as the last point, resulting in a (K+1)-by-2 matrix.

     FCC is a structure containing the following elements.

           x0y0   = Row/column coordinates where the code starts (1-by-2)
           fcc    = Freeman chain code (1-by-K)
           diff   = First difference of fcc (1-by-K)

     The code uses the following directions.

           3 2 1
           4 . 0
           5 6 7

     See also: bwboundaries





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Determine the Freeman chain code for a boundary.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fftconv2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 353
 -- Function File: fftconv2 (A, B, SHAPE)
 -- Function File: fftconv2 (V1, V2, A, SHAPE)
     Convolve 2 dimensional signals using the FFT.

     This method is faster but less accurate than CONV2 for large A and
     B.  It also uses more memory. A small complex component will be
     introduced even if both A and B are real.

     See also: conv2





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convolve 2 dimensional signals using the FFT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fspecial


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3242
 -- Function File: FILTER =  fspecial(TYPE, ARG1, ARG2)
     Create spatial filters for image processing.

     TYPE determines the shape of the filter and can be
    "average"
          Rectangular averaging filter. The optional argument ARG1
          controls the size of the filter. If ARG1 is an integer N, a N
          by N filter is created. If it is a two-vector with elements N
          and M, the resulting filter will be N by M. By default a 3 by
          3 filter is created.

    "disk"
          Circular averaging filter. The optional argument ARG1
          controls the radius of the filter. If ARG1 is an integer N, a
          2 N + 1 filter is created. By default a radius of 5 is used.

    "gaussian"
          Gaussian filter. The optional argument ARG1 controls the size
          of the filter. If ARG1 is an integer N, a N by N filter is
          created. If it is a two-vector with elements N and M, the
          resulting filter will be N by M. By default a 3 by 3 filter is
          created. The optional argument ARG2 sets spread of the
          filter. By default a spread of 0.5 is used.

    "log"
          Laplacian of Gaussian. The optional argument ARG1 controls
          the size of the filter. If ARG1 is an integer N, a N by N
          filter is created. If it is a two-vector with elements N and
          M, the resulting filter will be N by M. By default a 5 by 5
          filter is created. The optional argument ARG2 sets spread of
          the filter. By default a spread of 0.5 is used.

    "laplacian"
          3x3 approximation of the laplacian. The filter is
          approximated as
               (4/(ALPHA+1))*[ALPHA/4,     (1-ALPHA)/4, ALPHA/4; ...
                              (1-ALPHA)/4, -1,          (1-ALPHA)/4;  ...
                              ALPHA/4,     (1-ALPHA)/4, ALPHA/4];
          where ALPHA is a number between 0 and 1. This number can be
          controlled via the optional input argument ARG1. By default
          it is 0.2.

    "unsharp"
          Sharpening filter. The following filter is returned
               (1/(ALPHA+1))*[-ALPHA,   ALPHA-1, -ALPHA; ...
                               ALPHA-1, ALPHA+5,  ALPHA-1; ...
                              -ALPHA,   ALPHA-1, -ALPHA];
          where ALPHA is a number between 0 and 1. This number can be
          controlled via the optional input argument ARG1. By default
          it is 0.2.

    "motion"
          Moion blur filter of width 1 pixel. The optional input
          argument ARG1 controls the length of the filter, which by
          default is 9. The argument ARG2 controls the angle of the
          filter, which by default is 0 degrees.

    "sobel"
          Horizontal Sobel edge filter. The following filter is returned
               [ 1,  2,  1;
                 0,  0,  0;
                -1, -2, -1 ]

    "prewitt"
          Horizontal Prewitt edge filter. The following filter is
          returned
               [ 1,  1,  1;
                 0,  0,  0;
                -1, -1, -1 ]

    "kirsch"
          Horizontal Kirsch edge filter. The following filter is
          returned
               [ 3,  3,  3;
                 3,  0,  3;
                -5, -5, -5 ]




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Create spatial filters for image processing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
getrangefromclass


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 716
 -- Function File: RANGE = getrangefromclass (IMG)
     Return display range of image.

     For a given image IMG, returns RANGE, a 1x2 matrix with the
     minimum and maximum values. It supports the same classes as
     `intmax' and `intmin', as well as 'logical', 'single', and
     'double'.

     For MATLAB compatibility, if IMG is of the class 'single' or
     'double', min and max are considered 0 and 1 respectively.

          getrangefromclass (ones (5)) # note that class is 'double'
               => [0   1]
          getrangefromclass (logical (ones (5)))
               => [0   1]
          getrangefromclass (int8 (ones (5)))
               => [-128  127]

     See also: intmin, intmax, bitmax





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Return display range of image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
grayslice


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 514
 -- Function File: X = grayslice (I,N)
 -- Function File: X = grayslice (I,V)
     Creates an indexed image X from an intensitiy image I using
     multiple threshold levels.  A scalar integer value N sets the
     levels to

          1  2       n-1
          -, -, ..., ---
          n  n        n

     X = grayslice(I,5);

     For irregular threshold values a real vector V can be used.  The
     values must be in the range [0,1].

     X = grayslice(I,[0.1,0.33,0.75,0.9])

     See also: im2bw, gray2ind





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Creates an indexed image X from an intensitiy image I using multiple
threshold l



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
graythresh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5762
 -- Function File: [LEVEL, SEP] = graythresh (IMG)
 -- Function File: [LEVEL, SEP] = graythresh (IMG, METHOD, OPTIONS)
 -- Function File: [LEVEL, SEP] = graythresh (HIST, ...)
     Compute global image threshold.

     Given an image IMG finds the optimal threshold value LEVEL for
     conversion to a binary image with `im2bw'.  Color images are
     converted to grayscale before LEVEL is computed.  An image
     histogram HIST can also be used to allow for preprocessing of the
     histogram.

     The optional argument METHOD is the algorithm to be used
     (default's to Otsu).  Some methods may have other OPTIONS and/or
     return an extra value SEP (see each entry for details).  The
     available METHODs are:

    Otsu (default)
          Implements Otsu's method as described in `Nobuyuki Otsu
          (1979). "A threshold selection method from gray-level
          histograms", IEEE Trans. Sys., Man., Cyber. 9 (1): 62-66'.
          This algorithm chooses the threshold to minimize the
          intraclass variance of the black and white pixels.

          The second output, SEP represents the "goodness" (or
          separability) of the threshold at LEVEL.  It is a value
          within the range [0 1], the lower bound (zero) being
          attainable by, and only by, histograms having a single
          constant gray level, and the upper bound being attainable by,
          and only by, two-valued pictures.

    concavity
          Find a global threshold for a grayscale image by choosing the
          threshold to be in the shoulder of the histogram `A.
          Rosenfeld, and P. De La Torre (1983). "Histogram concavity
          analysis as an aid in threshold selection", IEEE Transactions
          on Systems, Man, and Cybernetics, 13: 231-235'.

    Huang
          Not yet implemented.

    ImageJ
          A variation of the intermeans algorithm, this is the default
          for ImageJ.  Not yet implemented.

    intermodes
          This assumes a bimodal histogram and chooses the threshold to
          be the mean of the two peaks of the bimodal histogram `J. M.
          S. Prewitt, and M. L.  Mendelsohn (1966). "The analysis of
          cell images", Annals of the New York Academy of Sciences,
          128: 1035-1053'.

          Images with histograms having extremely unequal peaks or a
          broad and flat valley are unsuitable for this method.

    intermeans
          Iterative procedure based on the iterative intermeans
          algorithm of `T.  Ridler, and S. Calvard (1978). "Picture
          thresholding using an iterative selection method", IEEE
          Transactions on Systems, Man, and Cybernetics, 8: 630-632'
          and `H. J. Trussell (1979). "Comments on 'Picture
          thresholding using an iterative selection method'", IEEE
          Transactions on Systems, Man, and Cybernetics, 9: 311'.

          Note that several implementations of this method exist. See
          the source code for details.

    Li
          Not yet implemented.

    MaxEntropy
          Implements Kapur-Sahoo-Wong (Maximum Entropy) thresholding
          method based on the entropy of the image histogram `J. N.
          Kapur, P. K. Sahoo, and A. C. K. Wong (1985). "A new method
          for gray-level picture thresholding using the entropy of the
          histogram", Graphical Models and Image Processing, 29(3):
          273-285'.

    MaxLikelihood
          Find a global threshold for a grayscale image using the
          maximum likelihood via expectation maximization method `A. P.
          Dempster, N. M. Laird, and D. B.  Rubin (1977). "Maximum
          likelihood from incomplete data via the EM algorithm",
          Journal of the Royal Statistical Society, Series B, 39:1-38'.

    mean
          The mean intensity value. It is mostly used by other methods
          as a first guess threshold.

    MinError
          An iterative implementation of Kittler and Illingworth's
          Minimum Error thresholding `J. Kittler, and J. Illingworth
          (1986). "Minimum error thresholding", Pattern recognition,
          19: 41-47'.

          This implementation seems to converge more often than the
          original.  Nevertheless, sometimes the algorithm does not
          converge to a solution. In that case a warning is displayed
          and defaults to the initial estimate of the mean method.

    minimum
          This assumes a bimodal histogram and chooses the threshold to
          be in the valley of the bimodal histogram.  This method is
          also known as the mode method `J. M. S. Prewitt, and M. L.
          Mendelsohn (1966). "The analysis of cell images", Annals of
          the New York Academy of Sciences, 128: 1035-1053'.

          Images with histograms having extremely unequal peaks or a
          broad and flat valley are unsuitable for this method.

    moments
          Find a global threshold for a grayscale image using moment
          preserving thresholding method `W. Tsai (1985).
          "Moment-preserving thresholding: a new approach", Computer
          Vision, Graphics, and Image Processing, 29: 377-393'

    percentile
          Assumes a specific fraction of pixels (set at OPTIONS) to be
          background.  If no value is given, assumes 0.5 (equal
          distribution of background and foreground) `W Doyle (1962).
          "Operation useful for similarity-invariant pattern
          recognition", Journal of the Association for Computing
          Machinery 9: 259-267'

    RenyiEntropy
          Not yet implemented.

    Shanbhag
          Not yet implemented.

    triangle
          Not yet implemented.

    Yen
          Not yet implemented.

     See also: im2bw





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Compute global image threshold.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
histeq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 282
 -- Function File: J = histeq (I, N)
     Histogram equalization of a gray-scale image. The histogram
     contains N bins, which defaults to 64.

     I: Image in double format, with values from 0.0 to 1.0

     J: Returned image, in double format as well

     See also: imhist





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Histogram equalization of a gray-scale image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
hough_circle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 776
 -- Function File: ACCUM = hough_circle (BW, R)
     Perform the Hough transform for circles with radius R on the
     black-and-white image BW.

     As an example, the following shows how to compute the Hough
     transform for circles with radius 3 or 7 in the image IM
          bw = edge(im);
          accum = hough_circle(bw, [3, 7]);
     If IM is an NxM image ACCUM will be an NxMx2 array, where
     ACCUM(:,:,1) will contain the Hough transform for circles with
     radius 3, and ACCUM(:,:,2) for radius 7. To find good circles you
     now need to find local maximas in ACCUM, which can be a hard
     problem.  If you find a local maxima in ACCUM(row, col, 1) it
     means that a good circle exists with center (row,col) and radius 3.

     See also: houghtf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Perform the Hough transform for circles with radius R on the
black-and-white ima



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
houghtf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2203
 -- Function File: H = houghtf (BW)
 -- Function File: H = houghtf (BW, METHOD)
 -- Function File: H = houghtf (BW, METHOD, ARG)
     Perform the Hough transform for lines or circles.

     The METHOD argument chooses between the Hough transform for lines
     and circles. It can be either "line" (default) or "circle".

     *Line Detection*

     If METHOD is "line", the function will compute the Hough transform
     for lines. A line is parametrised in R and THETA as
          R = x*cos(THETA) + y*sin(THETA),
     where R is distance between the line and the origin, while THETA
     is the angle of the vector from the origin to this closest point.
     The result H is an N by M matrix containing the Hough transform.
     Here, N is the number different values of R that has been
     attempted.  This is computed as `2*diag_length - 1', where
     `diag_length' is the length of the diagonal of the input image. M
     is the number of different values of THETA. These can be set
     through the third input argument ARG. This must be a vector of
     real numbers, and is by default `pi*(-90:90)/180'.

     *Circle Detection*

     If METHOD is "circle" the function will compute the Hough
     transform for circles. The circles are parametrised in R which
     denotes the radius of the circle. The third input argument ARG
     must be a real vector containing the possible values of R.  If the
     input image is N by M, then the result H will be an N by M by K
     array, where K denotes the number of different values of R.

     As an example, the following shows how to compute the Hough
     transform for circles with radius 3 or 7 in the image IM
          bw = edge(im);
          H = houghtf(bw, "circle", [3, 7]);
     Here H will be an NxMx2 array, where H(:,:,1) will contain the
     Hough transform for circles with radius 3, and H(:,:,2) for radius
     7.  To find good circles you now need to find local maximas in H.
     If you find a local maxima in H(row, col, 1) it means that a good
     circle exists with center (row,col) and radius 3. One way to
     locate maximas is to use the `immaximas' function.

     See also: hough_line, hough_circle, immaximas





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Perform the Hough transform for lines or circles.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
im2bw


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 763
 -- Function File: BW = im2bw (IMG, threshold)
 -- Function File: BW = im2bw (X, CMAP, threshold)
     Convert image to binary, black and white, by threshold.

     The input image IMG can either be a grayscale or RGB image.  In
     the later case, IMG is first converted to grayscale with
     `rgb2gray'.  Input can also be an indexed image X in which case
     the colormap CMAP needs to be specified.

     The value of THRESHOLD should be in the range [0,1] independently
     of the class of IMG.  Values from other classes can be converted
     to the correct value with `im2double' for example.  For an
     automatic threshold, consider using `graythresh'.

          bw = im2bw (img, graythresh (img));

     See also: graythresh, ind2gray, rgb2gray





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Convert image to binary, black and white, by threshold.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
im2col


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1681
 -- Function File: B = im2col (A, [M, N], BLOCK_TYPE)
 -- Function File: B = im2col (A, [M, N])
 -- Function File: B = im2col (A, 'indexed', ...)
     Rearranges image blocks into columns.

     `B=im2col(A, [m, n], blocktype)' rearranges blocks in A into
     columns in a way that's determined by BLOCK_TYPE, which can take
     the following values:

    `distinct'
          Rearranges each distinct M-by-N block in image A into a
          column of B. Blocks are scanned from left to right and the up
          to bottom in A, and columns are added to B from left to
          right. If A's size is not multiple M-by-N it is padded.

    `sliding'
          Rearranges any M-by-N sliding block of A in a column of B,
          without any padding, so only sliding blocks which can be
          built using a full M-by-N neighbourhood are taken.  In
          consequence, B has M*N rows and (MM-M+1)*(NN-N+1) columns
          (where MM and NN are the size of A).

          This case is thought to be used applying operations on
          columns of B (for instance using sum(:)), so that result is a
          1-by-(MM-M+1)*(NN-N+1) vector, that is what the complementary
          function `col2im' expects.

     `B=im2col(A,[m,n])' takes `distinct' as a default value for
     BLOCK_TYPE.

     `B=im2col(A,'indexed', ...)' will treat A as an indexed image, so
     it will pad using 1 if A is double. All other cases (incluing
     indexed matrices with uint8 and uint16 types and non-indexed
     images) will use 0 as padding value.

     Any padding needed in 'distinct' processing will be added at right
     and bottom edges of the image.

     See also: col2im





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Rearranges image blocks into columns.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
im2double


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 824
 -- Function File: IM2 = im2double (IM1)
 -- Function File: IM2 = im2double (IM1, "indexed")
     Convert input image IM1 to double precision.

     The following images type are supported: double, single, uint8,
     uint16, int16, binary (logical), indexed. If IM1 is an indexed
     images, the second argument must be a string with the value
     `indexed'.

     Processing will depend on the class of the input image IM1:
        * uint8, uint16, int16 - output will be rescaled for the
          interval [0 1] with the limits of the class;

        * double - output will be the same as input;

        * single - output will have the same values as input but the
          class will double;

        * indexed, logical - converted to double class.

     See also: im2bw, im2int16, im2single, im2uint8, im2uint16





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Convert input image IM1 to double precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
im2int16


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 507
 -- Function File: IM2 = im2int16 (IM1)
     Convert input image IM1 to int16 precision.

     The following images type are supported: double, single, uint8,
     uint16, int16, binary (logical).

     Processing will depend on the class of the input image IM1:
        * int16 - returns the same as input

        * uint8, double, single, uint16, logical - output will be
          rescaled for the interval of the uint16 class [0 65535]

     See also: im2bw, im2double, im2single, im2uint8, im2uint16





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Convert input image IM1 to int16 precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
im2single


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 824
 -- Function File: IM2 = im2single (IM1)
 -- Function File: IM2 = im2single (IM1, "indexed")
     Convert input image IM1 to single precision.

     The following images type are supported: double, single, uint8,
     uint16, int16, binary (logical), indexed. If IM1 is an indexed
     images, the second argument must be a string with the value
     `indexed'.

     Processing will depend on the class of the input image IM1:
        * uint8, uint16, int16 - output will be rescaled for the
          interval [0 1] with the limits of the class;

        * single - output will be the same as input;

        * double - output will have the same values as input but the
          class will single;

        * indexed, logical - converted to single class.

     See also: im2bw, im2double, im2int16, im2uint8, im2uint16





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Convert input image IM1 to single precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
im2uint16


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 800
 -- Function File: IM2 = im2uint16 (IM1)
 -- Function File: IM2 = im2uint16 (IM1, "indexed")
     Convert input image IM1 to uint16 precision.

     The following images type are supported: double, single, uint8,
     uint16, int16, binary (logical), indexed. If IM1 is an indexed
     images, the second argument must be a string with the value
     `indexed'.

     Processing will depend on the class of the input image IM1:
        * uint16 - returns the same as input

        * uint8, double, single, int16, logical - output will be
          rescaled for the interval of the uint16 class [0 65535]

        * indexed - depends on the input class. If double, no value can
          be above the max of the uint16 class (65535).

     See also: im2bw, im2double, im2int16, im2single, im2uint8





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Convert input image IM1 to uint16 precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
im2uint8


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 782
 -- Function File: IM2 = im2uint8 (IM1)
 -- Function File: IM2 = im2uint8 (IM1, "indexed")
     Convert input image IM1 to uint16 precision.

     The following images type are supported: double, single, uint8,
     uint16, int16, binary (logical), indexed. If IM1 is an indexed
     images, the second argument must be a string with the value
     `indexed'.

     Processing will depend on the class of the input image IM1:
        * uint8 - returns the same as input

        * uint16, double, single, int16, logical - output will be
          rescaled for the interval of the uint8 class [0 255]

        * indexed - depends on the input class. No value can be above
          the max of the uint8 class (255).

     See also: im2bw, im2double, im2int16, im2single, im2uint16





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Convert input image IM1 to uint16 precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
imabsdiff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 787
 -- Function File: OUT = imabsdiff (A, B)
 -- Function File: OUT = imabsdiff (A, B, CLASS)
     Return absolute difference of image or constant to an image.

     If A and B are two images of same size and class, returns the
     absolute difference between B and A.

     The class of OUT will be the same as A unless A is logical in
     which case OUT will be double. Alternatively, the class can be
     specified with CLASS.

     _Note 1_: you can force output class to be logical by specifying
     CLASS. This is incompatible with MATLAB which will _not_ honour
     request to return a logical matrix.

     _Note 2_: the values are truncated to the mininum value of the
     output class.

     See also: imadd, imcomplement, imdivide, imlincomb, immultiply,
     imsubtract





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Return absolute difference of image or constant to an image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
imadd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 811
 -- Function File: OUT = imadd (A, B)
 -- Function File: OUT = imadd (A, B, CLASS)
     Add image or constant to an image.

     If A and B are two images of same size and class, the images are
     added. Alternatively, if B is a floating-point scalar, its value
     is added to the image A.

     The class of OUT will be the same as A unless A is logical in
     which case OUT will be double. Alternatively, it can be specified
     with CLASS.

     _Note 1_: you can force output class to be logical by specifying
     CLASS. This is incompatible with MATLAB which will _not_ honour
     request to return a logical matrix.

     _Note 2_: the values are truncated to the maximum value of the
     output class.

     See also: imabsdiff, imcomplement, imdivide, imlincomb,
     immultiply, imsubtract





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Add image or constant to an image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imadjust


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3594
 -- Function File: J = imadjust (I)
 -- Function File: J = imadjust (I,[LOW_IN;HIGH_IN])
 -- Function File: J = imadjust (I,[LOW_IN;HIGH_IN],[LOW_OUT;HIGH_OUT])
 -- Function File: J = imadjust (..., GAMMA)
 -- Function File: NEWMAP = imadjust (MAP, ...)
 -- Function File: RGB_OUT = imadjust (RGB, ...)
     Adjust image or colormap values to a specified range.

     `J=imadjust(I)' adjusts intensity image I values so that 1% of
     data on lower and higher values (2% in total) of the image is
     saturated; choosing for that the corresponding lower and higher
     bounds (using `stretchlim') and mapping them to 0 and 1. J is an
     image of the same size as I which contains mapped values.  This is
     equivalent to `imadjust(I,stretchlim(I))'.

     `J=imadjust(I,[low_in;high_in])' behaves as described but uses
     LOW_IN and HIGH_IN values instead of calculating them. It maps
     those values to 0 and 1; saturates values lower than first limit
     to 0 and values higher than second to 1; and finally maps all
     values between limits linearly to a value between 0 and 1. If `[]'
     is passes as `[low_in;high_in]' value, then `[0;1]' is taken as a
     default value.

     `J=imadjust(I,[low_in;high_in],[low_out;high_out])' behaves as
     described but maps output values between LOW_OUT and HIGH_OUT
     instead of 0 and 1. A default value `[]' can also be used for this
     parameter, which is taken as `[0;1]'.

     `J=imadjust(...,gamma)' takes, in addition of 3 parameters
     explained above, an extra parameter GAMMA, which specifies the
     shape of the mapping curve between input elements and output
     elements, which is linear (as taken if this parameter is omitted).
     If GAMMA is above 1, then function is weighted towards lower
     values, and if below 1, towards higher values.

     `newmap=imadjust(map,...)' applies a transformation to a colormap
     MAP, which output is NEWMAP. This transformation is the same as
     explained above, just using a map instead of an image.  LOW_IN,
     HIGH_IN, LOW_OUT, HIGH_OUT and GAMMA can be scalars, in which case
     the same values are applied for all three color components of a
     map; or it can be 1-by-3 vectors, to define unique mappings for
     each component.

     `RGB_out=imadjust(RGB,...)' adjust RGB image RGB (a M-by-N-by-3
     array) the same way as specified in images and colormaps.  Here
     too LOW_IN, HIGH_IN, LOW_OUT, HIGH_OUT and GAMMA can be scalars or
     1-by-3 matrices, to specify the same mapping for all planes, or
     unique mappings for each.

     The formula used to realize the mapping (if we omit saturation) is:

     `J = low_out + (high_out - low_out) .* ((I - low_in) / (high_in -
     low_in)) .^ gamma;'

     *Compatibility notes:*

        * Prior versions of imadjust allowed `[low_in; high_in]' and
          `[low_out; high_out]' to be row vectors. Compatibility with
          this behaviour has been keeped, although preferred form is
          vertical vector (since it extends nicely to 2-by-3 matrices
          for RGB images and colormaps).

        * Previous version of imadjust, if `low_in>high_in' it
          "negated" output.  Now it is negated if `low_out>high_out',
          for compatibility with MATLAB.

        * Class of I is not considered, so limit values are not
          modified depending on class of the image, just treated "as
          is". When Octave 2.1.58 is out, limits will be multiplied by
          255 for uint8 images and by 65535 for uint16 as in MATLAB.

     See also: stretchlim, brighten





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Adjust image or colormap values to a specified range.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imbothat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 445
 -- Function File: B = imbothat (A, SE)
     Perform morphological bottom hat filtering.

     The image A must be a grayscale or binary image, and SE must be a
     structuring element. Both must have the same class, e.g., if A is a
     logical matrix, SE must also be logical.

     A bottom-hat transform is also known as 'black', or 'closing',
     top-hat transform.

     See also: imerode, imdilate, imopen, imclose, imtophat, mmgradm





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Perform morphological bottom hat filtering.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imclose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 370
 -- Function File: B = imclose (A, SE)
     Perform morphological closing on a given image.  The image A must
     be a grayscale or binary image, and SE must be a structuring
     element.

     The closing corresponds to a dilation followed by an erosion of
     the image, i.e.
          B = imerode(imdilate(A, se), se);

     See also: imdilate, imerode, imclose





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Perform morphological closing on a given image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
imcomplement


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 412
 -- Function File: B = imcomplement(A)
     Computes the complement image. Intuitively this corresponds to the
     intensity of bright and dark regions being reversed.

     For binary images, the complement is computed as `!A', for floating
     point images it is computed as `1 - A', and for integer images as
     `intmax(class(A)) - A'.

     See also: imadd, imdivide, imlincomb, immultiply, imsubtract





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Computes the complement image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imcrop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 421
 -- Function File: CROPPED = imcrop (IMG)
     Crop image.

     Displays the image IMG in a figure window and waits for user to
     select two points to define the bounding box.  First click on the
     top left and then on the bottom right corner of the region.  The
     function will not return until two valid points in the correct
     order are selected.

     Returns the CROPPED image.

     See also: imshow





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
Crop image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imdilate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 685
 -- Function File: B = imdilate (A, SE)
     Perform morphological dilation on a given image.

     The image A must be a grayscale or binary image, and SE a
     structuring element. Both must have the same class, e.g., if A is a
     logical matrix, SE must also be logical. Note that the erosion
     algorithm is different for each class, being much faster for
     logical matrices. As such, if you have a binary matrix, you should
     use `logical' first. This will also reduce the memory usage of
     your code.

     The center of SE is calculated using floor((size(SE)+1)/2).

     Pixels outside the image are considered to be 0.

     See also: imerode, imopen, imclose





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Perform morphological dilation on a given image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imdither


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1024
 -- Function File: [Y, NEWMAP] = imdither (IMG)
 -- Function File: [Y, NEWMAP] = imdither (IMG, COLORS)
 -- Function File: [Y, NEWMAP] = imdither (IMG, COLORS, DITHTYPE)
 -- Function File: [Y, NEWMAP] = imdither (IMG, MAP)
 -- Function File: [Y, NEWMAP] = imdither (IMG, MAP, COLORS)
 -- Function File: [Y, NEWMAP] = imdither(IMG, MAP, COLORS, DITHTYPE)
     Reduce the number a colors of rgb or indexed image.

     Note: this requires the ImageMagick "convert" utility.  get this
     from www.imagemagick.org if required additional documentation of
     options is available from the convert man page.

     where DITHTYPE is a value from list:

        * "None"

        * "FloydSteinberg" (default)

        * "Riemersma"

     COLORS is a maximum number of colors in result map

     TODO: Add facility to use already created colormap over "-remap"
     option

     BUGS: This function return a 0-based indexed images when colormap
     size is lower or equals to 256 like at cmunique code

     See also: cmunique





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Reduce the number a colors of rgb or indexed image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imdivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 621
 -- Function File: OUT = imdivide (A, B)
 -- Function File: OUT = imdivide (A, B, CLASS)
     Divide image by another image or constant.

     If A and B are two images of same size and class, A is divided by
     B. Alternatively, if B is a floating-point scalar, A is divided by
     it.

     The class of OUT will be the same as A unless A is logical in
     which case OUT will be double. Alternatively, it can be specified
     with CLASS.

     _Note_: the values are truncated to the mininum value of the output
     class.

     See also: imabsdiff, imadd, imcomplement, immultiply, imlincomb,
     imsubtract





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Divide image by another image or constant.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imerode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 684
 -- Function File: B = imerode (A, SE)
     Perform morphological erosion on a given image.

     The image A must be a grayscale or binary image, and SE a
     structuring element. Both must have the same class, e.g., if A is a
     logical matrix, SE must also be logical. Note that the erosion
     algorithm is different for each class, being much faster for
     logical matrices. As such, if you have a binary matrix, you should
     use `logical' first. This will also reduce the memory usage of
     your code.

     The center of SE is calculated using floor((size(SE)+1)/2).

     Pixels outside the image are considered to be 0.

     See also: imdilate, imopen, imclose





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Perform morphological erosion on a given image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imfilter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1460
 -- Function File: J = imfilter(I, F)
 -- Function File: J = imfilter(I, F, OPTIONS, ...)
     Computes the linear filtering of the image I and the filter F.
     The computation is performed using double precision floating point
     numbers, but the class of the input image is preserved as the
     following example shows.
          I = 255*ones(100, 100, "uint8");
          f = fspecial("average", 3);
          J = imfilter(I, f);
          class(J)
          => ans = uint8

     The function also accepts a number of optional arguments that
     control the details of the filtering. The following options is
     currently accepted
    `S'
          If a scalar input argument is given, the image is padded with
          this scalar as part of the filtering. The default value is 0.

    `"symmetric"'
          The image is padded symmetrically.

    `"replicate"'
          The image is padded using the border of the image.

    `"circular"'
          The image is padded by circular repeating of the image
          elements.

    `"same"'
          The size of the output image is the same as the input image.
          This is the default behaviour.

    `"full"'
          Returns the full filtering result.

    `"corr"'
          The filtering is performed using correlation. This is the
          default behaviour.

    `"conv"'
          The filtering is performed using convolution.

     See also: conv2, filter2, fspecial, padarray





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Computes the linear filtering of the image I and the filter F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imhist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 815
 -- Function File:  imhist (I)
 -- Function File:  imhist (I, N)
 -- Function File:  imhist (X, CMAP)
 -- Function File: [COUNTS, X] = imhist (...)
     Produce histogram counts of image I.

     The second argument can either be N, a scalar that specifies the
     number of bins; or CMAP, a colormap in which case X is expected to
     be an indexed image. If not specified, N defauls to 2 for binary
     images, and 256 for grayscale images.

     If output is requested, COUNTS is the number of counts for each
     bin and X is a range for the bins so that `stem (X, COUNTS)' will
     show the histogram.

     Since a colorbar is not displayed under the histogram, calling
     this function to visualize the histogram of an indexed image may
     not be very helpful.

     See also: hist, histc, histeq





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Produce histogram counts of image I.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
imlincomb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 920
 -- Function File: OUT = imlincomb (FAC, IMG)
 -- Function File: OUT = imlincomb (FAC1, IMG1, FAC2, IMG2, ...)
 -- Function File: OUT = imlincomb (..., CLASS)
     Combine images linearly.

     Returns the computed image as per:

     OUT = FAC1*IMG1 + FAC2*IMG2 + ... + FACn*IMGn

     The images IMG1..n must all be of same size and class. The factors
     FAC1..n must all be floating-point scalars.

     The class of OUT will be the same as IMGs unless IMGs are logical
     in which case OUT will be double. Alternatively, it can be
     specified with CLASS.

     If applying several arithmetic operations on images, `imlincomb'
     is more precise since calculations are performed at double
     precision.

     _Note 1_: you can force output class to be logical by specifying
     CLASS though it possibly doesn't make a lot of sense.

     See also: imadd, imcomplement, imdivide, immultiply, imsubtract





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Combine images linearly.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
immaximas


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1102
 -- Function File: [R, C] = immaximas (IM, RADIUS)
 -- Function File: [R, C] = immaximas (IM, RADIUS, THRESH)
 -- Function File: [R, C, ...] = immaximas (...)
 -- Function File: [..., VAL] = immaximas (...)
     Finds local spatial maximas of the given image. A local spatial
     maxima is defined as an image point with a value that is larger
     than all neighbouring values in a square region of width
     2*RADIUS+1. By default RADIUS is 1, such that a 3 by 3
     neighbourhood is searched. If the THRESH input argument is
     supplied, only local maximas with a value greater than THRESH are
     retained.

     The output vectors R and C contain the row-column coordinates of
     the local maximas. The actual values are computed to sub-pixel
     precision by fitting a parabola to the data around the pixel. If
     IM is N-dimensional, then N vectors will be returned.

     If IM is N-dimensional, and N+1 outputs are requested, then the
     last output will contain the image values at the maximas. Currently
     this value is not interpolated.

     See also: ordfilt2, ordfiltn





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Finds local spatial maximas of the given image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
immultiply


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 635
 -- Function File: OUT = immultiply (A, B)
 -- Function File: OUT = immultiply (A, B, CLASS)
     Multiply image by another image or constant.

     If A and B are two images of same size and class, the images are
     multiplied. Alternatively, if B is a floating-point scalar, A is
     multiplie by it.

     The class of OUT will be the same as A unless A is logical in
     which case OUT will be double. Alternatively, it can be specified
     with CLASS.

     _Note_: the values are truncated to the mininum value of the output
     class.

     See also: imabsdiff, imadd, imcomplement, imdivide, imlincomb,
     imsubtract





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Multiply image by another image or constant.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imnoise


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 561
 -- Function File: B = imnoise (A, TYPE)
 -- Function File: B = imnoise (..., OPTIONS)
     Add noise to image A.

    `imnoise (A, 'gaussian' [, mean [, var]])'
          additive gaussian noise: B = A + noise defaults to mean=0,
          var=0.01

    `imnoise (A, 'salt & pepper' [, density])'
          lost pixels: A = 0 or 1 for density*100% of the pixels
          defaults to density=0.05, or 5%

    `imnoise (A, 'speckle' [, var])'
          multiplicative gaussian noise: B = A + A*noise defaults to
          var=0.04

     See also: rand, randn





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Add noise to image A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imopen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 369
 -- Function File: B = imopen (A, SE)
     Perform morphological opening on a given image.  The image A must
     be a grayscale or binary image, and SE must be a structuring
     element.

     The opening corresponds to an erosion followed by a dilation of
     the image, i.e.
          B = imdilate(imerode(A, se), se);

     See also: imdilate, imerode, imclose





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Perform morphological opening on a given image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
impad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 986
 -- Function File:  impad(A, XPAD, YPAD, [PADDING, [CONST]])
     Pad (augment) a matrix for application of image processing
     algorithms.

     Pads the input image A with XPAD(1) elements from left, XPAD(2),
     elements from right, YPAD(1) elements from above and YPAD(2)
     elements from below.  Values of padding elements are determined
     from the optional arguments PADDING and CONST. PADDING is one of

    `"zeros"'
          pad with zeros (default)

    `"ones"'
          pad with ones

    `"constant"'
          pad with a value obtained from the optional fifth argument
          const

    `"symmetric"'
          pad with values obtained from A so that the padded image
          mirrors A starting from edges of A

    `"reflect"'
          same as symmetric, but the edge rows and columns are not used
          in the padding

    `"replicate"'
          pad with values obtained from A so that the padded image
          repeates itself in two dimensions





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Pad (augment) a matrix for application of image processing algorithms.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
imperspectivewarp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1744
 -- Function File: WARPED = imperspectivewarp(IM, P, INTERP, BBOX,
          EXTRAPVAL)
 -- Function File: [ WARPED, VALID] = imperspectivewarp(...)
     Applies the spatial perspective homogeneous transformation P to
     the image IM.  The transformation matrix P must be a 3x3
     homogeneous matrix, or 2x2 or 2x3 affine transformation matrix.

     The resulting image WARPED is computed using an interpolation
     method that can be selected through the INTERP argument. This must
     be one of the following strings
    `"nearest"'
          Nearest neighbor interpolation.

    `"linear"'
    `"bilinear"'
          Bilinear interpolation. This is the default behavior.

    `"cubic"'
    `"bicubic"'
          Bicubic interpolation.

     By default the resulting image contains the entire warped image.
     In some situation you only parts of the warped image. The argument
     BBOX controls this, and can be one of the following strings
    `"loose"'
          The entire warped result is returned. This is the default
          behavior.

    `"crop"'
          The central part of the image of the same size as the input
          image is returned.

    `"same"'
          The size and coordinate system of the input image is keept.

     All values of the result that fall outside the original image will
     be set to EXTRAPVAL. For images of class `double' EXTRAPVAL
     defaults to `NA' and for other classes it defaults to 0.

     The optional output VALID is a matrix of the same size as WARPED
     that contains the value 1 in pixels where WARPED contains an
     interpolated value, and 0 in pixels where WARPED contains an
     extrapolated value.

     See also: imremap, imrotate, imresize, imshear, interp2





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Applies the spatial perspective homogeneous transformation P to the
image IM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imremap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1386
 -- Function File: WARPED = imremap(IM, XI, YI)
 -- Function File: WARPED = imremap(IM, XI, YI, INTERP, EXTRAPVAL)
 -- Function File: [ WARPED, VALID ] = imremap(...)
     Applies any geometric transformation to the image IM.

     The arguments XI and YI are lookup tables that define the resulting
     image
          WARPED(y,x) = IM(YI(y,x), XI(y,x))
     where IM is assumed to be a continuous function, which is achieved
     by interpolation. Note that the image IM is expressed in a (X,
     Y)-coordinate system and not a (row, column) system.

     The argument INTERP selects the used interpolation method, and
     most be one of the following strings
    `"nearest"'
          Nearest neighbor interpolation.

    `"linear"'
    `"bilinear"'
          Bilinear interpolation. This is the default behavior.

    `"cubic"'
    `"bicubic"'
          Bicubic interpolation.

     All values of the result that fall outside the original image will
     be set to EXTRAPVAL. For images of class `double' EXTRAPVAL
     defaults to `NA' and for other classes it defaults to 0.

     The optional output VALID is a matrix of the same size as WARPED
     that contains the value 1 in pixels where WARPED contains an
     interpolated value, and 0 in pixels where WARPED contains an
     extrapolated value.

     See also: imperspectivewarp, imrotate, imresize, imshear, interp2





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Applies any geometric transformation to the image IM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imresize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 821
 -- Function File: B = imresize (A, M)
     Scales the image A by a factor M using bicubic neighbour
     interpolation. If M is less than 1 the image size will be reduced,
     and if M is greater than 1 the image will be enlarged.

 -- Function File: B = imresize (A, M, INTERP)
     Same as above except INTERP interpolation is performed instead of
     using nearest neighbour. INTERP can be any interpolation method
     supported by interp2.  By default, bicubic interpolation is used.

 -- Function File: B = imresize (A, [MROW MCOL])
     Scales the image A to be of size MROWxMCOL.

 -- Function File: B = imresize (A, [MROW MCOL], INTERP)
     Same as above except INTERP interpolation is performed. INTERP can
     be any interpolation method supported by interp2.

     See also: imremap, imrotate, interp2





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Scales the image A by a factor M using bicubic neighbour interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imrotate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2137
 -- Function File:  imrotate(IMGPRE, THETA, METHOD, BBOX, EXTRAPVAL)
     Rotation of a 2D matrix about its center.

     Input parameters:

     IMGPRE   a gray-level image matrix

     THETA    the rotation angle in degrees counterclockwise

     METHOD
          "nearest" neighbor: fast, but produces aliasing effects
          (default).

          "bilinear" interpolation: does anti-aliasing, but is slightly
          slower.

          "bicubic" interpolation: does anti-aliasing, preserves edges
          better than bilinear interpolation, but gray levels may
          slightly overshoot at sharp edges. This is probably the best
          method for most purposes, but also the slowest.

          "Fourier" uses Fourier interpolation, decomposing the rotation
          matrix into 3 shears. This method often results in different
          artifacts than homography-based methods.  Instead of slightly
          blurry edges, this method can result in ringing artifacts
          (little waves near high-contrast edges).  However, Fourier
          interpolation is better at maintaining the image information,
          so that unrotating will result in an image closer to the
          original than the other methods.

     BBOX
          "loose" grows the image to accommodate the rotated image
          (default).

          "crop" rotates the image about its center, clipping any part
          of the image that is moved outside its boundaries.

     EXTRAPVAL sets the value used for extrapolation. The default value
         is `NA' for images represented using doubles, and 0 otherwise.
         This argument is ignored of Fourier interpolation is used.

     Output parameters:

     IMGPOST  the rotated image matrix

     H        the homography mapping original to rotated pixel
             coordinates. To map a coordinate vector c = [x;y] to its
            rotated location, compute round((H * [c; 1])(1:2)).

     VALID    a binary matrix describing which pixels are valid,
              and which pixels are extrapolated. This output is
             not available if Fourier interpolation is used.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Rotation of a 2D matrix about its center.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
imrotate_Fourier


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 579
 -- Function File:  imrotate(M, THETA, METHOD, BBOX)
     Rotation of a 2D matrix.

     Applies a rotation of THETA degrees to matrix M.

     The METHOD argument is not implemented, and is only included for
     compatibility with Matlab.  This function uses Fourier
     interpolation, decomposing the rotation matrix into 3 shears.

     BBOX can be either 'loose' or 'crop'.  'loose' allows the image to
     grow to accomodate the rotated image.  'crop' keeps the same size
     as the original, clipping any part of the image that is moved
     outside the bounding box.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Rotation of a 2D matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imshear


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1176
 -- Function File:  imshear (M, AXIS, ALPHA, BBOX)
     Applies a shear to the image M.

     The argument M is either a matrix or an RGB image.

     AXIS is the axis along which the shear is to be applied, and can
     be either 'x' or 'y'.  For example, to shear sideways is to shear
     along the 'x' axis. Choosing 'y' causes an up/down shearing.

     ALPHA is the slope of the shear. For an 'x' shear, it is the
     horizontal shift (in pixels) applied to the pixel above the
     center. For a 'y' shear, it is the vertical shift (in pixels)
     applied to the pixel just to the right of the center pixel.

     NOTE: ALPHA does NOT need to be an integer.

     BBOX can be one of 'loose', 'crop' or 'wrap'.  'loose' allows the
     image to grow to accomodate the new transformed image.  'crop'
     keeps the same size as the original, clipping any part of the image
     that is moved outside the bounding box.  'wrap' keeps the same
     size as the original, but does not clip the part of the image that
     is outside the bounding box. Instead, it wraps it back into the
     image.

     If called with only 3 arguments, BBOX is set to 'loose' by default.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Applies a shear to the image M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imsmooth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7353
 -- Function File: J = imsmooth(I, NAME, OPTIONS)
     Smooth the given image using several different algorithms.

     The first input argument I is the image to be smoothed. If it is
     an RGB image, each color plane is treated separately.  The
     variable NAME must be a string that determines which algorithm will
     be used in the smoothing. It can be any of the following strings

    "Gaussian"
          Isotropic Gaussian smoothing. This is the default.

    "Average"
          Smoothing using a rectangular averaging linear filter.

    "Disk"
          Smoothing using a circular averaging linear filter.

    "Median"
          Median filtering.

    "Bilateral"
          Gaussian bilateral filtering.

    "Perona & Malik"
    "Perona and Malik"
    "P&M"
          Smoothing using nonlinear isotropic diffusion as described by
          Perona and Malik.

    "Custom Gaussian"
          Gaussian smoothing with a spatially varying covariance matrix.

     In all algorithms the computation is done in double precision
     floating point numbers, but the result has the same type as the
     input. Also, the size of the smoothed image is the same as the
     input image.

     *Isotropic Gaussian smoothing*

     The image is convolved with a Gaussian filter with spread SIGMA.
     By default SIGMA is 0.5, but this can be changed. If the third
     input argument is a scalar it is used as the filter spread.

     The image is extrapolated symmetrically before the convolution
     operation.

     *Rectangular averaging linear filter*

     The image is convolved with N by M rectangular averaging filter.
     By default a 3 by 3 filter is used, but this can e changed. If the
     third input argument is a scalar N a N by N filter is used. If the
     third input argument is a two-vector `[N, M]' a N by M filter is
     used.

     The image is extrapolated symmetrically before the convolution
     operation.

     *Circular averaging linear filter*

     The image is convolved with circular averaging filter. By default
     the filter has a radius of 5, but this can e changed. If the third
     input argument is a scalar R the radius will be R.

     The image is extrapolated symmetrically before the convolution
     operation.

     *Median filtering*

     Each pixel is replaced with the median of the pixels in the local
     area. By default, this area is 3 by 3, but this can be changed. If
     the third input argument is a scalar N the area will be N by N,
     and if it's a two-vector [N, M] the area will be N by M.

     The image is extrapolated symmetrically before the filtering is
     performed.

     *Gaussian bilateral filtering*

     The image is smoothed using Gaussian bilateral filtering as
     described by Tomasi and Manduchi [2]. The filtering result is
     computed as
          J(x0, y0) = k * SUM SUM I(x,y) * w(x, y, x0, y0, I(x0,y0), I(x,y))
                           x   y
     where `k' a normalisation variable, and
          w(x, y, x0, y0, I(x0,y0), I(x,y))
            = exp(-0.5*d([x0,y0],[x,y])^2/SIGMA_D^2)
              * exp(-0.5*d(I(x0,y0),I(x,y))^2/SIGMA_R^2),
     with `d' being the Euclidian distance function. The two paramteres
     SIGMA_D and SIGMA_R control the amount of smoothing. SIGMA_D is
     the size of the spatial smoothing filter, while SIGMA_R is the size
     of the range filter. When SIGMA_R is large the filter behaves
     almost like the isotropic Gaussian filter with spread SIGMA_D, and
     when it is small edges are preserved better. By default SIGMA_D is
     2, and SIGMA_R is 10/255 for floating points images (with integer
     images this is multiplied with the maximal possible value
     representable by the integer class).

     The image is extrapolated symmetrically before the filtering is
     performed.

     *Perona and Malik*

     The image is smoothed using nonlinear isotropic diffusion as
     described by Perona and Malik [1]. The algorithm iteratively
     updates the image using

          I += lambda * (g(dN).*dN + g(dS).*dS + g(dE).*dE + g(dW).*dW)

     where `dN' is the spatial derivative of the image in the North
     direction, and so forth. The function G determines the behaviour
     of the diffusion.  If g(x) = 1 this is standard isotropic
     diffusion.

     The above update equation is repeated ITER times, which by default
     is 10 times. If the third input argument is a positive scalar,
     that number of updates will be performed.

     The update parameter LAMBDA affects how much smoothing happens in
     each iteration. The algorithm can only be proved stable is LAMBDA
     is between 0 and 0.25, and by default it is 0.25. If the fourth
     input argument is given this parameter can be changed.

     The function G in the update equation determines the type of the
     result.  By default `G(D) = exp(-(D./K).^2)' where K = 25.  This
     choice gives privileges to high-contrast edges over low-contrast
     ones.  An alternative is to set `G(D) = 1./(1 + (D./K).^2)', which
     gives privileges to wide regions over smaller ones. The choice of G
     can be controlled through the fifth input argument. If it is the
     string `"method1"', the first mentioned function is used, and if
     it is "METHOD2" the second one is used. The argument can also be a
     function handle, in which case the given function is used. It
     should be noted that for stability reasons, G should return values
     between 0 and 1.

     The following example shows how to set `G(D) = exp(-(D./K).^2)'
     where K = 50.  The update will be repeated 25 times, with LAMBDA =
     0.25.

          G = @(D) exp(-(D./50).^2);
          J = imsmooth(I, "p&m", 25, 0.25, G);

     *Custom Gaussian Smoothing*

     The image is smoothed using a Gaussian filter with a spatially
     varying covariance matrix. The third and fourth input arguments
     contain the Eigenvalues of the covariance matrix, while the fifth
     contains the rotation of the Gaussian.  These arguments can be
     matrices of the same size as the input image, or scalars.  In the
     last case the scalar is used in all pixels. If the rotation is not
     given it defaults to zero.

     The following example shows how to increase the size of an Gaussian
     filter, such that it is small near the upper right corner of the
     image, and large near the lower left corner.

          [LAMBDA1, LAMBDA2] = meshgrid (linspace (0, 25, columns (I)), linspace (0, 25, rows (I)));
          J = imsmooth (I, "Custom Gaussian", LAMBDA1, LAMBDA2);

     The implementation uses an elliptic filter, where only
     neighbouring pixels with a Mahalanobis' distance to the current
     pixel that is less than 3 are used to compute the response. The
     response is computed using double precision floating points, but
     the result is of the same class as the input image.

     *References*

     [1] P. Perona and J. Malik, "Scale-space and edge detection using
     anisotropic diffusion", IEEE Transactions on Pattern Analysis and
     Machine Intelligence, 12(7):629-639, 1990.

     [2] C. Tomasi and R. Manduchi, "Bilateral Filtering for Gray and
     Color Images", Proceedings of the 1998 IEEE International
     Conference on Computer Vision, Bombay, India.

     See also: imfilter, fspecial





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Smooth the given image using several different algorithms.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
imsubtract


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1215
 -- Function File: OUT = imsubtract (A, B)
 -- Function File: OUT = imsubtract (A, B, CLASS)
     Subtract image or constant to an image.

     If A and B are two images of same size and class, B is subtracted
     to A. Alternatively, if B is a floating-point scalar, its value is
     subtracted to the image A.

     The class of OUT will be the same as A unless A is logical in
     which case OUT will be double. Alternatively, it can be specified
     with CLASS.

     _Note 1_: you can force output class to be logical by specifying
     CLASS. This is incompatible with MATLAB which will _not_ honour
     request to return a logical matrix.

     _Note 2_: the values are truncated to the mininum value of the
     output class.

     _NOte 3_: values are truncated before the operation so if input
     images are unsigned integers and the request output class is a
     signed integer, it may lead to unexpected results:

          imsubtract (uint8 ([23 190]), uint8 ([24 200]), "int8")
               => -1  0

     Because both 190 and 200 were truncated to 127 before subtraction,
     their difference is zero.

     See also: imabsdiff, imadd, imcomplement, imdivide, imlincomb,
     immultiply





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Subtract image or constant to an image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imtophat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 477
 -- Function File: B = imtophat (A, SE)
     Perform morphological top hat filtering.

     The image A must be a grayscale or binary image, and SE must be a
     structuring element. Both must have the same class, e.g., if A is a
     logical matrix, SE must also be logical.

     A 'black', or 'closing', top-hat transform is also known as
     bottom-hat transform and so that is the same `imbothat'.

     See also: imerode, imdilate, imopen, imclose, imbothat, mmgradm





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Perform morphological top hat filtering.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
imtranslate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 315
 -- Function File: Y = imtranslate (M, X, Y)
 -- Function File: Y = imtranslate (M, X, Y, BBOX)
     Translate a 2D image by (x,y) using Fourier interpolation.

     M is a matrix, and is translated to the right by X pixels and
     translated up by Y pixels.

     BBOX can be either 'crop' or 'wrap' (default).





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Translate a 2D image by (x,y) using Fourier interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
iptcheckconn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 666
 -- Function File:  iptcheckconn (CON, FUNC_NAME, VAR_NAME, POS)
     Check if argument is valid connectivity.

     If CON is not a valid connectivity argument, gives a properly
     formatted error message. FUNC_NAME is the name of the function to
     be used on the error message, VAR_NAME the name of the argument
     being checked (for the error message), and POS the position of the
     argument in the input.

     A valid connectivity argument must be either double or logical. It
     must also be either a scalar from set [1 4 6 8 18 26], or a
     symmetric matrix with all dimensions of size 3, with only 0 or 1
     as values, and 1 at its center.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Check if argument is valid connectivity.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
iptcheckmap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 602
 -- Function File:  iptcheckmap (IN, FUNC_NAME, VAR_NAME, POS)
     Check if argument is valid colormap.

     If IN is not a valid colormap, gives a properly formatted error
     message.  FUNC_NAME is the name of the function to be used on the
     error message, VAR_NAME the name of the argument being checked
     (for the error message), and POS the position of the argument in
     the input.

     A valid colormap is a 2-D matrix with 3 columns of doubles with
     values between 0 and 1 (inclusive), that refer to the intensity
     levels of red, green and blue.

     See also: colormap





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Check if argument is valid colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
iptchecknargin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 445
 -- Function File:  iptchecknargin (LOW, HIGH, IN, FUNC_NAME)
     Checks for correct number of arguments.

     This function returns an error unless IN is between the values of
     LOW and HIGH. It does nothing otherwise. They all must be non
     negative scalar integers. HIGH can also be Inf.

     FUNC_NAME is the name of the function to be used on the error
     message.

     See also: error, nargin, nargout, narginchk, nargoutchk





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Checks for correct number of arguments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
iptcheckstrs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 618
 -- Function File: VALID = iptcheckstrs (IN, VALID_STR, FUNC_NAME,
          VAR_NAME, POS)
     Check if argument is a valid string.

     If IN is not a string, present in the cell array of strings
     VALID_STR gives a properly formatted error message. Otherwise,
     VALID is the matched string. The performed matching is
     case-insensitive.

     FUNC_NAME is the name of the function to be used on the error
     message, VAR_NAME the name of the argument being checked (for the
     error message), and POS the position of the argument in the input.

     See also: strcmp, strcmpi, find, validatestring





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Check if argument is a valid string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
iptnum2ordinal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 412
 -- Function File: ORD = iptnum2ordinal (NUM)
     Convert number to ordinal string.

     NUM must be a real positive integer which will be converted to a
     string with its ordinal form ORD.

          iptnum2ordinal (1)
                => first
          iptnum2ordinal (12)
               => twelfth
          iptnum2ordinal (21)
               => 21st

     See also: num2str, sprintf, int2str, mat2str





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Convert number to ordinal string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
iradon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2228
 -- Function: RECON = iradon (PROJ, THETA, INTERP, FILTER, SCALING,
          OUTPUT_SIZE)
     Performs filtered back-projection on the projections in PROJ to
     reconstruct an approximation of the original image.

     PROJ should be a matrix whose columns are projections of an image
     (or slice).  Each element of THETA is used as the angle (in
     degrees) that the corresponding column of PROJ was projected at.
     If THETA is omitted, it is assumed that projections were taken at
     evenly spaced angles between 0 and 180 degrees.  THETA can also be
     a scalar, in which case it is taken as the angle between
     projections if more than one projection is provided.

     INTERP determines the type of interpolation that is used in the
     back-projection.  It must be one of the types accepted by
     `interp1', and defaults to 'Linear' if it is omitted.

     FILTER and SCALING determine the type of rho filter to apply.  See
     the help for `rho_filter' for their use.

     OUTPUT_SIZE sets the edge length of the output image (it is always
     square).  This argument does not scale the image.  If it is
     omitted, the length is taken to be
     2 * floor (size (proj, 1) / (2 * sqrt (2))).

     If PROJ was obtained using `radon', there is no guarantee that the
     reconstructed image will be exactly the same size as the original.

 -- Function: [RECON, FILT] = iradon (...)
     This form also returns the filter frequency response in the vector
     FILT.

   Performs filtered back-projection in order to reconstruct an image
based on its projections.

   Filtered back-projection is the most common means of reconstructing
images from CT scans.  It is a two step process: First, each of the
projections is filtered with a `rho filter', so named due to its
frequency domain definition, which is simply |rho|, where rho is the
radial axis in a polar coordinate system.  Second, the filtered
projections are each `smeared' across the image space.  This is the
back-projection part.

   Usage example:
       P = phantom ();
       projections = radon (P, 1:179);
       reconstruction = iradon (filtered_projections, 1:179, 'Spline', 'Hann');
       figure, imshow (reconstruction, [])




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Performs filtered back-projection on the projections in PROJ to
reconstruct an a



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
isbw


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 489
 -- Function File: BOOL = isbw (IMG)
 -- Function File: BOOL = isbw (IMG, LOGIC)
     Return true if IMG is a black and white image.

     The optional argument LOGIC defines what is considered a black and
     white image. Possible values are the strings `logical' or
     `non-logical'. The first defines it as a logical matrix, while the
     second defines it as a matrix where the only values are 1 and 0.
     Defaults to `logical'.

     See also: isgray, isind, islogical, isrgb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Return true if IMG is a black and white image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
iscolormap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 289
 -- Function File:  iscolormap (CMAP)
     Return true if CMAP is a colormap.

     A colormap is an N row by 3 column matrix.  The columns contain
     red, green, and blue intensities respectively.  All entries must
     be between 0 and 1 inclusive.

     See also: colormap, rgbplot





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return true if CMAP is a colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isgray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 464
 -- Function File: BOOL = isgray (IMG)
     Return true if IMG is a grayscale image.

     A variable is considereed to be a gray scale image if it is
     2-dimensional, non-sparse matrix, and:
        * is of class double and all values are in the range [0, 1];

        * is of class uint8, uint16 or int16.

     Note that grayscale time-series image have 4 dimensions
     (NxMx1xtime) but isgray will still return false.

     See also: isbw, isind, isrgb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return true if IMG is a grayscale image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 476
 -- Function File: BOOL = isind (IMG)
     Return true if IMG is an indexed image.

     A variable is considereed to be an indexed image if it is
     2-dimensional, non-sparse matrix and:
        * is of class double and all values are integers greater than
          or equal to 1;

        * is of class uint8 or uint16.

     Note that indexed time-series image have 4 dimensions (NxMx1xtime)
     but isind will still return false.

     See also: isbw, isgray, isrgb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Return true if IMG is an indexed image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isrgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 452
 -- Function File: BOOL =  isrgb (IMG)
     Return true if IMG is a RGB image.

     A variable is considereed to be a RGB image if it is 3-dimensional,
     non-sparse matrix, of size MxNx3 and:
        * is of class double and all values are in the range [0, 1];

        * is of class uint8 or uint16.

     Note that RGB time-series image have 4 dimensions (NxMx3xtime) but
     isrgb will still return false.

     See also: isbw, isgray, isind





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return true if IMG is a RGB image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
label2rgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1740
 -- Function File: RGB = label2rgb(L)
 -- Function File: RGB = label2rgb(L, MAP)
 -- Function File: RGB = label2rgb(L, MAP, BACKGROUND)
 -- Function File: RGB = label2rgb(L, MAP, BACKGROUND, ORDER)
     Converts a labeled image to an RGB image.

     label2rgb(L) returns a color image, where the background color
     (the background is the zero-labeled pixels) is white, and all other
     colors come from the `jet' colormap.

     label2rgb(L, MAP) uses colors from the given colormap.  MAP can be
        * A string containing the name of a function to be called to
          produce a colormap. The default value is "jet".

        * A handle to a function to be called to produce a colormap.

        * A N-by-3 colormap matrix.

     label2rgb(L, MAP, BACKGROUND) sets the background color.
     BACKGROUND can be a 3-vector corresponding to the wanted RGB
     color, or one of the following strings
    `"b"'
          The background color will be blue.

    `"c"'
          The background color will be cyan.

    `"g"'
          The background color will be green.

    `"k"'
          The background color will be black.

    `"m"'
          The background color will be magenta.

    `"r"'
          The background color will be red.

    `"w"'
          The background color will be white. This is the default
          behavior.

    `"y"'
          The background color will be yellow.

     label2rgb(L, MAP, BACKGROUND, ORDER) allows for random
     permutations of the colormap. ORDER must be one of the following
     strings
    `"noshuffle"'
          The colormap is not permuted in any ways. This is the default.

    `"shuffle"'
          The used colormap is permuted randomly.

     See also: bwlabel, ind2rgb





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Converts a labeled image to an RGB image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
makelut


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 822
 -- Function File: LUT = makelut (FUN, N)
 -- Function File: LUT = makelut (FUN, N, P1, P2, ...)
     Create a lookup table which can be used by applylut.

     lut = makelut(fun,n) returns a vector which can be used by applylut
     as a lookup table.

     FUN can be a function object as created by inline, or simply a
     string which contains the name of a function. FUN should accept a
     N-by-N matrix whose elements are binary (0 or 1) and returns an
     scalar (actually anything suitable to be included in a vector).

     makelut calls FUN with all possible matrices and builds a vector
     with its result, suitable to be used by applylut. The length of
     this vector is 2^(N^2), so 16 for 2-by-2 and 512 for 3-by-3.

     makelut also passes parameters P1, P2, .... to FUN.

     See also: applylut





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Create a lookup table which can be used by applylut.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
mat2gray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1186
 -- Function File: I = mat2gray (M)
 -- Function File: I = mat2gray (M, [MIN MAX])
     Convert a matrix to an intensity image.

     The returned matrix I is a grayscale image, of double class and in
     the range of values [0, 1]. The optional arguments MIN and MAX will
     set the limits of the conversion; values in M below MIN and above
     MAX will be set to 0 and 1 on I respectively.

     MAX and MIN default to the maximum and minimum values of M.

     If MIN is larger than MAX, the `inverse' will be returned. Values
     in M above MAX will be set to 0 while the ones below MIN will be
     set to 1.

     *Caution:* For compatibility with MATLAB, if MIN and MAX are equal
     (either from being actually being set manually or automatically
     calculated from the M min and max values, Octave's mat2gray will
     truncate all values between [0 1]. For example

          mat2gray ([-2 0 0.5 0.9 5], [2 2])
               => [0  0  0.5  0.9  1]
          mat2gray ([0.5 0.5 0.5])
               => [0.5  0.5  0.5]
          mat2gray ([4 4 4])
               => [1  1  1]

     See also: gray2ind, ind2gray, rgb2gray, im2double, im2uin16,
     im2uint8, im2int16





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Convert a matrix to an intensity image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
mean2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 228
 -- Function File: M= mean2 (I)
     Compute the mean value of the 2D image I.

     Note that M will be of class double, independently of the input
     class.  This is equivalent to `mean (I(:))'.

     See also: mean, std2





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Compute the mean value of the 2D image I.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
medfilt2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 533
 -- Function File:  medfilt2(A, [DOMAIN, PADDING])
     Two dimensional median filtering.

     Replaces elements of A with the median of their neighbours defined
     by true elements of logical matrix DOMAIN. The default DOMAIN is a
     3 by 3 matrix with all elements equal to 1. If DOMAIN is 1 by 2
     row vector, the domain matrix will be logical(ones(DOMAIN(2),
     DOMAIN(1))).

     Optional variable PADDING defines the padding used in augmenting
     the borders of A. See impad for details.

     See also: ordfilt2





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Two dimensional median filtering.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
mmgradm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 608
 -- Function File: GRAD = mmgradm(A, SE)
 -- Function File: GRAD = mmgradm(A, SE_DIL, SE_ERO)
     Calculates the morphological gradient GRAD of a given image A.

     In the first form, the same structuring element SE is used for
     dilation and erosion. In the second form, SE_DIL and SE_ERO are the
     corresponding structuring elements used for dilation and erosion

     The image A must be a grayscale or a binary image.

     The morphological gradient of a image corresponds to its erosion
     subtracted to its dilation.

     See also: imerode, imdilate, imopen, imclose, imtophat, imbothat





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Calculates the morphological gradient GRAD of a given image A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nlfilter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1006
 -- Function File: B =  nlfilter (A, [M,N], FUN)
 -- Function File: B =  nlfilter (A, [M,N], FUN, ...)
 -- Function File: B =  nlfilter (A,'indexed', ...)
     Processes image in sliding blocks using user-supplied function.

     `B=nlfilter(A,[m,n],fun)' passes sliding M-by-N blocks to
     user-supplied function FUN. A block is build for every pixel in A,
     such as it is centered within the block.  FUN must return a
     scalar, and it is used to create matrix B. NLFILTER pads the
     M-by-N block at the edges if necessary.

     Center of block is taken at ceil([M,N]/2).

     `B=nlfilter(A,[m,n],fun, ...)' behaves as described above but
     passes extra parameters to function FUN.

     `B=nlfilter(A,'indexed', ...)' assumes that A is an indexed image,
     so it pads the image using proper value: 0 for uint8 and uint16
     images and 1 for double images. Keep in mind that if 'indexed' is
     not specified padding is always done using 0.

     See also: colfilt, blkproc, inline





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Processes image in sliding blocks using user-supplied function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
normxcorr2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 296
 -- Function File: CC = normxcorr2 (TEMPLATE, IMG)
 -- Function File: CC = normxcorr2 (TEMPLATE, IMG)
     Compute the normalized 2D cross correlation.

     The output matrix CC shows the correlation coefficients of TEMPLATE
     for each position in IMG.

     See also: conv2, corr2, xcorr2





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Compute the normalized 2D cross correlation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ordfilt2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 690
 -- Function File:  ordfilt2(A, NTH, DOMAIN, [S, PADDING])
     Two dimensional ordered filtering.

     Ordered filter replaces an element of A with the NTH element of
     the sorted set of neighbours defined by the logical (boolean)
     matrix DOMAIN.  Neighbour elements are selected to the sort if the
     corresponding element in the DOMAIN matrix is true.

     The optional variable S is a matrix of size(DOMAIN).  Values of S
     corresponding to nonzero values of domain are added to values
     obtained from A when doing the sorting.

     Optional variable PADDING determines how the matrix A is padded
     from the edges. See impad for details.

     See also: medfilt2





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Two dimensional ordered filtering.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ordfiltn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 705
 -- Function File:  ordfiltn(A, NTH, DOMAIN, [S, PADDING])
     Two dimensional ordered filtering.

     Ordered filter replaces an element of A with the NTH element of
     the sorted set of neighbours defined by the logical (boolean)
     matrix DOMAIN.  Neighbour elements are selected to the sort if the
     corresponding element in the DOMAIN matrix is true.

     The optional variable S is a matrix of size(DOMAIN).  Values of S
     corresponding to nonzero values of domain are added to values
     obtained from A when doing the sorting.

     Optional variable PADDING determines how the matrix A is padded
     from the edges. See `padarray' for details.

     See also: ordfilt2, padarray





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Two dimensional ordered filtering.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
padarray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1881
 -- Function File: B = padarray (A, PADSIZE)
 -- Function File: B = padarray (A, PADSIZE, PADVAL)
 -- Function File: B = padarray (A, PADSIZE, PADVAL, DIRECTION)
     Pads an array in a configurable way.

     B = padarray(A,padsize) pads an array A with zeros, where PADSIZE
     defines the amount of padding to add in each dimension (it must be
     a vector of positive integers).

     Each component of PADSIZE defines the number of elements of
     padding that will be added in the corresponding dimension. For
     instance, [4,5] adds 4 elements of padding in first dimension
     (vertical) and 5 in second dimension (horizontal).

     B = padarray(A,padsize,padval) pads A using the value specified by
     PADVAL. PADVAL can be a scalar or a string. Possible values are:

    0
          Pads with 0 as described above. This is the default behaviour.

    Scalar
          Pads using PADVAL as a padding value.

    "Circular"
          Pads with a circular repetition of elements in A (similar to
          tiling A).

    "Replicate"
          Pads replicating values of A which are at the border of the
          array.

    "Symmetric"
          Pads with a mirror reflection of A.

    "Reflect"
          Same as "symmetric", but the borders are not used in the
          padding.

     B = padarray(A,padsize,padval,direction) pads A defining the
     direction of the pad. Possible values are:

    "Both"
          For each dimension it pads before the first element the number
          of elements defined by PADSIZE and the same number again after
          the last element. This is the default value.

    "Pre"
          For each dimension it pads before the first element the
          number of elements defined by PADSIZE.

    "Post"
          For each dimension it pads after the last element the number
          of elements defined by PADSIZE.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Pads an array in a configurable way.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
phantom


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2255
 -- Function: P = phantom ('Shepp-Logan', N)
     Produces the Shepp-Logan phantom, with size N x N.  If N is
     omitted, 256 is used.

 -- Function: P = phantom ('Modified Shepp-Logan', N)
     Produces a modified version of the Shepp-Logan phantom which has
     higher contrast than the original,  with size N x N.  If N is
     omitted, 256 is used.

 -- Function: P = phantom (ELLIPSES, N)
     Produces a custom phantom using the ellipses described in ELLIPSES.
     Each row of ELLIPSES describes one ellipse, and must have 6
     columns: {I, a, b, x0, y0, phi}:
    I
          is the additive intensity of the ellipse

    a
          is the length of the major axis

    b
          is the length of the minor axis

    x0
          is the horizontal offset of the centre of the ellipse

    y0
          is the vercal offset of the centre of the ellipse

    phi
          is the counterclockwise rotation of the ellipse in degrees,
          measured as the angle between the x axis and the ellipse
          major axis.


     The image bounding box in the algorithm is {[-1, -1], [1, 1]}, so
     the values of a, b, x0, y0 should all be specified with this in
     mind.  If N is omitted, 256 is used.

 -- Function: P = phantom (N)
     Creates a modified Shepp-Logan phantom with size N x N.

 -- Function: P =  phantom ()
     Creates a modified Shepp-Logan phantom with size 256 x 256.

   Create a Shepp-Logan or modified Shepp-Logan phantom.

   A phantom is a known object (either real or purely mathematical) that
is used for testing image reconstruction algorithms.  The Shepp-Logan
phantom is a popular mathematical model of a cranial slice, made up of
a set of ellipses.  This allows rigorous testing of computed tomography
(CT) algorithms as it can be analytically transformed with the radon
transform (see the function `radon').

   Example:

       P = phantom (512);
       imshow (P, []);

   References:

   Shepp, L. A.; Logan, B. F.; Reconstructing Interior Head Tissue
from X-Ray Transmissions, IEEE Transactions on Nuclear Science,  Feb.
1974, p. 232.

   Toft, P.; "The Radon Transform - Theory and Implementation", Ph.D.
thesis,  Department of Mathematical Modelling, Technical University  of
Denmark, June 1996.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Produces the Shepp-Logan phantom, with size N x N.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
poly2mask


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1182
 -- Function File: BW =  poly2mask (X,Y,M,N)
     Convert a polygon to a region mask.

     BW=poly2mask(x,y,m,n) converts a polygon, specified by a list of
     vertices in X and Y and returns in a M-by-N logical mask BW the
     filled polygon. Region inside the polygon is set to 1, values
     outside the shape are set to 0.

     X and Y should always represent a closed polygon, first and last
     points should be coincident. If they are not poly2mask will close
     it for you. If X or Y are fractional they are nearest integer.

     If all the polygon or part of it falls outside the masking area
     (1:m,1:n), it is discarded or clipped.

     This function uses scan-line polygon filling algorithm as described
     in http://www.cs.rit.edu/~icss571/filling/ with some minor
     modifications: capability of clipping and scan order, which can
     affect the results of the algorithm (algorithm is described not to
     reach ymax, xmax border when filling to avoid enlarging shapes). In
     this function we scan the image backwards (we begin at ymax and end
     at ymin), and we don't reach ymin, xmin, which we believe should be
     compatible with MATLAB.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Convert a polygon to a region mask.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qtdecomp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2394
 -- Function File: S = qtdecomp (I)
 -- Function File: S = qtdecomp (I, THRESHOLD)
 -- Function File: S = qtdecomp (I, THRESHOLD, MINDIM)
 -- Function File: S = qtdecomp (I, THRESHOLD, [MINDIM MAXDIM])
 -- Function File: S = qtdecomp (I, FUN)
 -- Function File: S = qtdecomp (I, FUN, P1, P2, ...)
     Performs quadtree decomposition.

     qtdecomp decomposes a square image I into four equal-sized blocks.
     Then it performs some kind of test on each block to decide if it
     should decompose them further. This process is repeated
     iteratively until there's no block left to be decomposed.

     Note that blocks are not decomposed if their dimensions are not
     even.

     The output is a sparse matrix whose non-zero elements determine the
     position of the block (the element is at top-left position in the
     block) and size of each block (the value of the element determines
     length of a side of the square-shaped block).

     S = qtdecomp(I) decomposes an intensity image I as described
     above. By default it doesn't split a block if all elements are
     equal.

     S = qtdecomp(I, threshold) decomposes an image as decribed, but
     only splits a block if the maximum value in the block minus the
     minimum value is greater than THRESHOLD, which is a value between
     0 and 1. If I is of class uint8, THRESHOLD is multiplied by 255
     before use. Also, ifI is of class uint16, THRESHOLD is multiplied
     by 65535.

     S = qtdecomp(I, threshold, mindim) decomposes an image using the
     THRESHOLD as just described, but doesn't produce blocks smaller
     than mindim.

     S = qtdecomp(I, threshold, [mindim maxdim]) decomposes an image as
     described, but produces blocks that can't be bigger than maxdim. It
     decomposes to maxdim even if it isn't needed if only THRESHOLD was
     considered.

     S = qtdecomp(I, fun) decomposes an image I and uses function FUN
     to decide if a block should be splitted or not. FUN is called with
     a m-by-m-by-k  array of m-by-m blocks to be considered, and should
     return a vector of size k, whose elements represent each block in
     the stacked array. FUN sets the corresponding value to 1 if the
     block should be split, and 0 otherwise.

     S = qtdecomp(I, fun, ...) behaves as qtdecomp(I, fun) but passes
     extra parameters to FUN.

     See also: qtgetblk, qtsetblk





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Performs quadtree decomposition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qtgetblk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 907
 -- Function File: [VALS] = qtgetblk (I, S, DIM)
 -- Function File: [VALS,IDX] = qtgetblk (I, S, DIM)
 -- Function File: [VALS,R,C] = qtgetblk (I, S, DIM)
     Obtain block values from a quadtree decomposition.

     [vals]=qtgetblk(I,S,dim) returns a dim-by-dim-by-k array in VALS
     which contains the dim-by-dim blocks in the quadtree decomposition
     (S, which is returned by qtdecomp) of I. If there are no blocks,
     an empty matrix is returned.

     [vals,idx]=qtgetblk(I,S,dim) returns VALS as described above.  In
     addition, it returns IDX, a vector which contains the linear
     indices of the upper left corner of each block returned (the same
     result as find(full(S)==dim)).

     [vals,r,c]=qtgetblk(I,S,dim) returns VALS as described, and two
     vectors, R and C, which contain the row and column coordinates of
     the blocks returned.

     See also: qtdecomp, qtsetblk





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Obtain block values from a quadtree decomposition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qtsetblk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 414
 -- Function File: J = qtsetblk (I, S, DIM, VALS)
     Set block values in a quadtree decomposition.

     J=qtsetblk(I,S,dim,vals) sets all the DIM-by-DIM blocks in the
     quadtree decomposition (S returned by qtdecomp) of I to DIM-by-DIM
     blocks in VALS, which is itself a DIM-by-DIM-by-k array. k is the
     number of DIM-by-DIM blocks in the quadtree decomposition.

     See also: qtdecomp, qtgetblk





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Set block values in a quadtree decomposition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
radon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 346
 -- Function File: [RT,XP] = radon(I, THETA)
 -- Function File: [RT,XP] = radon(I)
     Calculates the 2D-Radon transform of the matrix I at angles given
     in THETA. To each element of THETA corresponds a column in RT.
     The variable XP represents the x-axis of the rotated coordinate.
     If THETA is not defined, then 0:179 is assumed.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Calculates the 2D-Radon transform of the matrix I at angles given in
THETA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
rangefilt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 865
 -- Function File: R = rangefilt (IM)
 -- Function File: R = rangefilt (IM, DOMAIN)
 -- Function File: R = rangefilt (IM, DOMAIN, PADDING, ...)
     Computes the local intensity range in a neighbourhood around each
     pixel in an image.

     The intensity range of the pixels of a neighbourhood is computed as

          R = max (X) - min (X)

     where X is the value of the pixels in the neighbourhood,

     The neighbourhood is defined by the DOMAIN binary mask. Elements
     of the mask with a non-zero value are considered part of the
     neighbourhood. By default a 3 by 3 matrix containing only non-zero
     values is used.

     At the border of the image, extrapolation is used. By default
     symmetric extrapolation is used, but any method supported by the
     `padarray' function can be used.

     See also: paddarray, entropyfilt, stdfilt





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Computes the local intensity range in a neighbourhood around each pixel
in an im



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
readexif


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 672
 -- Function File: EXIF = readexif(FILENAME, THUMBNAIL)
     Read EXIF information from JPEG image data.

     The exif tag information are returned in the EXIF data structure.
     Integer ratios are expressed as column vector.  For example, a
     focal number of 2.8 is expressed as FNumber=[28; 10]. Otherwise
     all data are returned by the type as specified in the IFD
     structures.

     The filename for the thumbnail image is optional.  If given, the
     thumbnail jpeg image will be stored to file THUMBNAIL.

     Reference: JEITA CP-3451, Exchangeable image file format for
     digital still cameras: Exif Version 2.2

     See also: imwrite, imfinfo





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Read EXIF information from JPEG image data.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
regionprops


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2688
 -- Function File: PROPS =  regionprops (BW)
 -- Function File: PROPS =  regionprops (BW, PROPERTIES, ...)
     Compute object properties in a binary image.

     `regionprops' computes various properties of the individual
     objects (as identified by `bwlabel') in the binary image BW. The
     result is a structure array containing an entry per property per
     object.

     The following properties can be computed:

    "Area"
          The number of pixels in the object.

    "BoundingBox"
    "bounding_box"
          The bounding box of the object. This is represented as a
          4-vector where the first two entries are the x and y
          coordinates of the upper left corner of the bounding box, and
          the two last entries are the width and the height of the box.

    "Centroid"
          The center coordinate of the object.

    "EulerNumber"
    "euler_number"
          The Euler number of the object (see `bweuler' for details).

    "Extent"
          The area of the object divided by the area of the bounding
          box.

    "FilledArea"
    "filled_area"
          The area of the object including possible holes.

    "FilledImage"
    "filled_image"
          A binary image with the same size as the object's bounding
          box that contains the object with all holes removed.

    "Image"
          An image with the same size as the bounding box that contains
          the original pixels.

    "MaxIntensity"
    "max_intensity"
          The maximum intensity inside the object.

    "MeanIntensity"
    "mean_intensity"
          The mean intensity inside the object.

    "MinIntensity"
    "min_intensity"
          The minimum intensity inside the object.

    "Perimeter"
          The length of the boundary of the object.

    "PixelIdxList"
    "pixel_idx_list"
          The indices of the pixels in the object.

    "PixelList"
    "pixel_list"
          The actual pixel values inside the object. This is only
          useful for grey scale images.

    "PixelValues"
    "pixel_values"
          The pixel values inside the object represented as a vector.

    "WeightedCentroid"
    "weighted_centroid"
          The centroid of the object where pixel values are used as
          weights.

     The requested properties can either be specified as several input
     arguments or as a cell array of strings. As a short-hand it is
     also possible to give the following strings as arguments.

    "basic"
          The following properties are computed: "Area", "Centroid" and
          "BoundingBox". This is the default.

    "all"
          All properties are computed.

     See also: bwlabel, bwperim, bweuler





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Compute object properties in a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
rgb2gray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 479
 -- Function File: GRAY = rgb2gray (RGB)
     Convert RGB image or colormap to grayscale.

     If RGB is an RGB image, the conversion to grayscale is weighted
     based on the luminance values (see `rgb2ntsc').  Supported classes
     are single, double,  uint8 and uint16.

     If RGB is a colormap it is converted into the YIQ space of ntsc.
     The luminance value (Y) is taken to create a gray colormap.

     See also: mat2gray, ntsc2rgb, rgb2ind, rgb2ntsc, rgb2ycbcr





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Convert RGB image or colormap to grayscale.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
rgb2ycbcr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 399
 -- Function File: B = rgb2ycbcr (A)
     Perform colour convertion from RGB to YCbCr on a given image.

     The image A must be a NxMx3 image. The conversion The convertion
     changes the image from the RGB color model to YCbCr e.g.
          imOut = rgb2ycbcr(imIn);
     Currently this function only works with `uint8' and will always
     return an `uint8' matrix.

     See also: cmunique





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Perform colour convertion from RGB to YCbCr on a given image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rgbplot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 445
 -- Function File:  rgbplot (CMAP)
 -- Function File: H = rgbplot (...)
     Plot the components of a colormap.

     The first column is plotted in red, the second column in green, and
     the third column in blue.  The values are between 0 and 1 and
     represent the intensity of the RGB components in the given indexed
     color.

     The optional return value H is a graphics handle to the created
     plot.

     See also: colormap





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Plot the components of a colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
rho_filter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2383
 -- Function: FILTERED = rho_filter (PROJ, TYPE, SCALING)
     Filters the parallel ray projections in the columns of PROJ,
     according to the filter type chosen by TYPE.  TYPE can be chosen
     from
        * 'none'

        * 'Ram-Lak' (default)

        * 'Shepp-Logan'

        * 'Cosine'

        * 'Hann'

        * 'Hamming'

     If given, SCALING determines the proportion of frequencies below
     the nyquist frequency that should be passed by the filter.  The
     window function is compressed accordingly, to avoid an abrupt
     truncation of the frequency response.

 -- Function: [FILTERED, FILTER] = rho_filter (...)
     This form also returns the frequency response of the filter in the
     vector FILTER.


   Performs rho filtering on the parallel ray projections provided.

   Rho filtering is performed as part of the filtered back-projection
method of CT image reconstruction.  It is the filtered part of the name.
The simplest rho filter is the Ramachadran-Lakshminarayanan (Ram-Lak),
which is simply |rho|, where rho is the radial component of spatial
frequency.  However, this can cause unwanted amplification of noise,
which is what the other types attempt to minimise, by introducing
roll-off into the response.  The Hann and Hamming filters multiply the
standard response by a Hann or Hamming window, respectively.  The
cosine filter is the standard response multiplied by a cosine shape,
and the Shepp-Logan filter multiplies the response with a sinc shape.
The 'none' filter performs no filtering, and is included for
completeness and to enable incorporating this function easily into
scripts or functions that may offer the ability to choose to apply no
filtering.

   This function is designed to be used by the function `iradon', but
has been exposed to facilitate custom inverse radon transforms and to
more clearly break down the process for educational purposes.  The
operations
         filtered = rho_filter (proj);
         reconstruction = iradon (filtered, 1, 'linear', 'none');
   are exactly equivalent to
         reconstruction = iradon (proj, 1, 'linear', 'Ram-Lak');

   Usage example:
       P = phantom ();
       projections = radon (P);
       filtered_projections = rho_filter (projections, 'Hamming');
       reconstruction = iradon (filtered_projections, 1, 'linear', 'none');
       figure, imshow (reconstruction, [])




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Filters the parallel ray projections in the columns of PROJ, according
to the fi



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
roicolor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 552
 -- Function File: BW = roicolor (A, LOW, HIGH)
 -- Function File: BW =  roicolor (A,V)
     Select a Region Of Interest of an image based on color.

     BW = roicolor(A,low,high) selects a region of interest (ROI) of an
     image A returning a black and white image in a logical array (1 for
     pixels inside ROI and 0 outside ROI), which is formed by all pixels
     whose values lie within the colormap range specified by [LOW HIGH].

     BW = roicolor(A,v) selects a region of interest (ROI) formed by all
     pixels that match values in V.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Select a Region Of Interest of an image based on color.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
std2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
 -- Function File: S = std2 (I)
     Returns the standard deviation for a 2d real type matrix.  Uses
     `std (I(:))'

     See also: mean2, std





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Returns the standard deviation for a 2d real type matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
stdfilt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1069
 -- Function File: S = stdfilt (IM)
 -- Function File: S = stdfilt (IM, DOMAIN)
 -- Function File: S = stdfilt (IM, DOMAIN, PADDING, ...)
     Computes the local standard deviation in a neighbourhood around
     each pixel in an image.

     The standard deviation of the pixels of a neighbourhood is
     computed as

          S = sqrt ((sum (X - MU).^2)/(N-1))

     where MU is the mean value of the pixels in the neighbourhood, N
     is the number of pixels in the neighbourhood. So, an unbiased
     estimator is used.

     The neighbourhood is defined by the DOMAIN binary mask. Elements
     of the mask with a non-zero value are considered part of the
     neighbourhood. By default a 3 by 3 matrix containing only non-zero
     values is used.

     At the border of the image, extrapolation is used. By default
     symmetric extrapolation is used, but any method supported by the
     `padarray' function can be used. Since extrapolation is used, one
     can expect a lower deviation near the image border.

     See also: std2, paddarray, entropyfilt





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Computes the local standard deviation in a neighbourhood around each
pixel in an



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
stretchlim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1940
 -- Function File: LOW_HIGH =  stretchlim (I,TOL)
 -- Function File: LOW_HIGH =  stretchlim (I)
 -- Function File: LOW_HIGH =  stretchlim (RGB,TOL)
 -- Function File: LOW_HIGH =  stretchlim (RGB)
     Finds limits to contrast stretch an image

     `LOW_HIGH=stretchlim(I,TOL)' returns a vector LOW_HIGH which
     contains a pair of intensities which can be used in `imadjust' to
     stretch the contrast of an image, first of them will be lower
     value (`imadjust' would assign 0 to it) and second is the upper
     bound. TOL specifies the fraction of the image to saturate at
     lower and upper limits. It can be a vector of length 2:
     `[LOW_FRACT, HIGH_FRACT]', or it can be a scalar, in that case
     `[LOW_FRACT, HIGH_FRACT]=[TOL, 1-TOL]'.

     TOL can't be larger than 0.50 and for TOL=0 then
     `LOW_HIGH=[min(I(:)), max(I(:))]'.

     `LOW_HIGH=stretchlim(I)' behaves as described but defaults TOL to
     `[0.01, 0.99]'.

     `LOW_HIGH=stretchlim(RGB,TOL)' returns a 2-by-3 matrix in LOW_HIGH
     of lower and upper values to saturate for each plane of the RGB
     image in M-by-N-by-3 array RGB. TOL is a vector or a scalar, as
     described above, and the same fractions are applied for each plane.

     `LOW_HIGH=stretchlim(RGB)' uses `[0.01, 0.99]' as default value
     for TOL.

     *Notes:*

     Values in LOW_HIGH are of type double and comprised between 0 and
     1 regardless class of input image.

     *Compatibility notes:*

        * int* and uint* types are still not implemented (waiting for
          support in Octave 2.1.58).

        * This function tries to find limits that are nearer to saturate
          requested interval. So, for instance, if you requested a 5%
          and it has to choose between discarding a 1% and a 7%, it
          will choose the later despite being more than requested. This
          should be test against MATLAB behaviour.

     See also: imadjust





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Finds limits to contrast stretch an image




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
tiff_tag_read


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2203
 -- Function File: [VALUE, OFFSET] = tiff_tag_read (FILE, TAG)
 -- Function File: [VALUE, OFFSET] = tiff_tag_read (FILE, TAG, IFD)
 -- Function File: [VALUE, OFFSET] = tiff_tag_read (FILE, TAG, "all")
     Read value of TAGs from TIFF files.

     FILE must be a TIFF file and TAG should be a tag ID. To check
     multiple tags, TAG can be a vector. If IFD is supplied, only those
     IFDs (Image File Directory) will be read. As with TAG, multiple
     IFDs can be checked by using a vector or with the string `all'. By
     default, only the first IFD is read.

     VALUE and OFFSET will be a matrix with a number of rows and
     columns equal to the number of TAGs and IFDs requested. The index
     relate to the same order as the input. OFFSET has the same
     structure as VALUE and when equal to 1 its matching value on VALUE
     will be an offset to a position in the file.

     TAGs that can't be found will have a value of 0 and the
     corresponding OFFSET will be 2.

     If an error occurs when reading FILE (such as lack of permissions
     of file is not a TIFF file), OFFSET is set to -1 and VALUE
     contains the error message.

     See the following examples:
          ## read value of tag 258 on IFD 1 (`off' will be 1 if `val' is an offset or 2 if not found)
          [val, off] = tiff_tag_read (filepath, 258);

          ## read value 258, 262, 254 o IFD 1 (`val' and `off' will be a 1x3 matrix)
          [val, off] = tiff_tag_read (filepath, [258 262 254]);
          if (off(1) == -1), error ("something happpened: %s", val); endif
          off(2,1)   # will be 1 if val(2,1) is an offset to a file position or 2 if tag was not found
          val(2,1)   # value of tag 262 on IFD 1

          ## read value 258, 262, 254 on the first 10 IFDs 1 (`val' and `off' will be a 1x10 matrix)
          [val, off] = tiff_tag_read (filepath, [258 262 254], 1:10);
          val(2,5)   # value of tag 262 on IFD 5

          ## read value 258, 262, 254 o IFD 1 (`val' and `off' will be a 1x3 matrix)
          [val, off] = tiff_tag_read (filepath, [258 262 254], "all");
          val(2,end)   # value of tag 262 on the last IFD

     See also: imread, imfinfo, readexif





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Read value of TAGs from TIFF files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
uintlut


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 250
 -- Function File: B = uintlut (A, LUT)
     Computes matrix B by using A as an index to lookup table LUT.

     B = uintlut(A, LUT) calculates a matrix B by using LUT as a lookup
     table indexed by values in A.

     B class is the same as LUT.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Computes matrix B by using A as an index to lookup table LUT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
wavelength2rgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1190
 -- Function File: RGB = wavelength2rgb (WAVELENGTH)
 -- Function File: RGB = wavelength2rgb (WAVELENGTH, CLASS)
 -- Function File: RGB = wavelength2rgb (WAVELENGTH, CLASS, GAMMA)
     Convert wavelength in nm into an RGB value set.

     Given a N-dimensional matrix WAVELENGTH with color values in nm,
     returns a RGB image with N+3 dimensions.

          wavelength2rgb (400)
              => [0.51222 0.00000 0.70849]

          wavelength2rgb ([400 410])
              (:,:,1)=> 0.51222   0.49242
              (:,:,2)=> 0         0
              (:,:,3)=> 0.70849   0.85736

     The RGB class can be specified with CLASS.  Possible values are
     double (default), single, uint8, uint16, and int16.

          wavelength2rgb (400)
              => 0.51222  0.00000  0.70849

          wavelength2rgb (400, "uint8")
              => 131    0  181

     The luminance of colors can be adjusted with GAMMA which must a
     scalar value in the range [0 1]. Defaults to 0.8.

     Reference:
        *
          `http://stackoverflow.com/questions/2374959/algorithm-to-convert-any-positive-integer-to-an-rgb-value'

        * `http://www.midnightkite.com/color.html' per Dan Bruton




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Convert wavelength in nm into an RGB value set.





