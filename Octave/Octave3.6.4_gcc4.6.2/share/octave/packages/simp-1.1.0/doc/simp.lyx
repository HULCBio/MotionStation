#LyX 1.5.6 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Single Interval Mathematics Package for Octave
\end_layout

\begin_layout Author
Simone Pernice
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Author and version
\end_layout

\begin_layout Standard
I am Simone Pernice the writer of the SIMP package.
 If you find any bug or you want to add features, you can contact me at
 pernice@libero.it.
 You can find further details on my web site: simonepernice.freehostia.com
\end_layout

\begin_layout Standard
List of versions of this document:
\end_layout

\begin_layout Itemize
Version 1.0, Turin 14th December 2008, initial draft
\end_layout

\begin_layout Itemize
Version 1.1, Palermo 2nd January 2009, few fixes to the documentation and
 added the new function intFormInt 
\end_layout

\begin_layout Section
Preface
\end_layout

\begin_layout Standard
I am an electrical engineer, I worked both on hardware and software fields.
 Designing an electrical circuit is quite complex because the characteristics
 of the components involved have huge tolerance some about 5%, while others
 50%.
 The target is to have the circuit working in the worst case of the components
 and of the environment! That involves to compute several times the same
 equation putting inside the worst or best case values.
 Some time ago I was designing a simple circuit when I though: 
\begin_inset Quotes eld
\end_inset

What if I use intervals instead of numbers? I may get the best and worst
 case in just one step!
\begin_inset Quotes erd
\end_inset

.
 Then I looked on the Internet for Interval Mathematics: I discovered it
 was invented in the '50s 
\begin_inset LatexCommand cite
key "key-1"

\end_inset

.
 Although its not very spread it is a powerful tool: a calculator with finite
 precision can be used to compute calculus requiring infinite precision
 because the solution is a range where the actual value lay.
 
\end_layout

\begin_layout Standard
Therefore I looked for an open source calculator able to manage intervals
 instead of real numbers.
 Unfortunately I was not able to find anything.
 There are just few libraries for the C++ language and packages for proprietary
 software.
 I was thinking to develop a calculator on my own, but it would have required
 a lot of effort and long time.
 Then I discovered Octave
\begin_inset LatexCommand cite
key "key-6"

\end_inset

.
 By the way Octave is a great tool that can be used by every engineer for
 its daily work.
 After a look at Octave's tutorial 
\begin_inset LatexCommand cite
key "key-3"

\end_inset

 I decided to write a package to work on intervals in Octave.
 It was the right choice, because it took just three days to make it while
 building a new program from scratch would have taken weeks.
 The package extends the basic arithmetic functions to single interval mathemati
cs, it is called SIMP.
 As far as I know it is not possible to overload Octave operators with m
 script files, therefore I made new functions working on matrix to extend
 the basic operations to intervals.
 In Octave it is possible to write the first few chars of a function and
 then push the TAB key to get the list of the functions compatible.
 Moreover it is really simple to build intermediate variables.
 That makes not too long using the SIMP functions for standard calculations.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand prettyref
reference "sec:Introduction"

\end_inset

 shows why numbers are not the best tool when computing real world entities.
 
\begin_inset LatexCommand prettyref
reference "sec:Intervals"

\end_inset

 explains what is an interval and how a function can be extended to work
 on intervals.
 
\begin_inset LatexCommand prettyref
reference "sec:Issues-with-interval"

\end_inset

 explains some issues to be aware when making interval calculations, which
 are not present in the number computation.
 
\begin_inset LatexCommand prettyref
reference "sec:Single-Interval-Mathematics"

\end_inset

 shows some examples to explain how the SIMP package can be used.
 Eventually the 
\begin_inset LatexCommand prettyref
reference "sec:Functions"

\end_inset

 provides the detailed list of functions available.
\end_layout

\begin_layout Section
Introduction
\begin_inset LatexCommand label
name "sec:Introduction"

\end_inset

 
\end_layout

\begin_layout Standard
SIMP is a simple interval calculator.
 Intervals can be used instead of floating point number to automatically
 take into account the tolerance of the values used in calculation.
 All functions can be extended to interval: therefore it is possible to
 apply all the functions to intervals to get the final result as an interval.
 If you understand what intervals are, you can go directly to 
\begin_inset LatexCommand prettyref
reference "sec:Single-Interval-Mathematics"

\end_inset

 to read some examples and then to 
\begin_inset LatexCommand prettyref
reference "sec:Functions"

\end_inset

 to see all the functions available.
\end_layout

\begin_layout Standard
Every day we need to compute the result of a lot of simple mathematical
 equations.
 For example the cost of the apples bought at the supermarket is given by
 the apple cost per kilo times the number of kilos bought: 
\begin_inset Formula $applePrice=appleCostPerKilo\times kilosOfAppleBought$
\end_inset

.
\end_layout

\begin_layout Standard
When we need the result of those mathematical expressions, we put the values
 on the right side of the equation and we got its result on the left side.
 Well, we usually put wrong numbers on the right side and therefore there
 is no doubt we get wrong results.
 There are a lot of reasons why we put wrong values, below some of them
 follows: 
\end_layout

\begin_layout Enumerate
Most of the values are measured, therefore they are known within a given
 tolerance (looking for accuracy and precision on Wikipedia will provide
 interesting information on that matter); 
\end_layout

\begin_layout Enumerate
Some values have an infinite number of digits after the decimal point (real
 number), like for 
\begin_inset Formula $\pi$
\end_inset

 (the ratio between a circumference and its diameter); 
\end_layout

\begin_layout Enumerate
Some values change with time or samples (or whatever), like the weight of
 a person (which can change of 5% during a day) or the current gain of a
 BJT (which can change of 50% on the samples of the same series); 
\end_layout

\begin_layout Enumerate
Some value are estimation or guess: something like between a minimum and
 a maximum.
 
\end_layout

\begin_layout Standard
For example if a pipe brakes and you want to buy a new one you need its
 diameter.
 If you do not have a caliber, you may measure its circumference and divide
 it by 
\begin_inset Formula $\pi$
\end_inset

 (3.1415...):
\begin_inset Formula $diameter=\frac{circumference}{\pi}$
\end_inset

.
\end_layout

\begin_layout Standard
Here there are two errors: the circumference is known within the tolerance
 given by your meter, moreover 
\begin_inset Formula $\pi$
\end_inset

 has an infinite number of digits while only few of them can be used in
 the operation.
 You may think the error is negligible, the result is enough accurate to
 buy a new pipe in a hardware shop.
 However the not infinite accuracy of those operation avoid the use of computers
 as automatic theorem demonstration tools and so on...
 This kind of issue is quite common on engineer design.
 What engineers do is to be sure their design will work in the worst case
 or in most of the cases (usually more than 99.9%).
 
\end_layout

\begin_layout Standard
Here a simple example follows.
 Let us say you want to repaint the walls of your living room completely
 messed up by your children.
 You need to compute how many paint cans you need to buy.
 The equation is quite simple:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
paintCans=\frac{2\times\left(roomWidth+roomLength\right)\times roomHeight}{paintLitersPerCan\times paintEfficiency}\label{eq:paintCans}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where paintEfficiency is how many square meters of surface can be painted
 with a liter of paint.
 The problem here is that usually we do not have a long enough meter to
 measure the room width and length, it is much simpler to count the number
 of steps to go through it (1 step is about 1m, let us say from 0.9 to 1.1m).
 Moreover the paint provider usually declare a paint efficiency range.
 Let us put below the data: 
\end_layout

\begin_layout Itemize
roomWidth = 6 (from 5.4m to 6.6m)
\end_layout

\begin_layout Itemize
steps roomLength = 4 (from 3.6m to 4.4m)
\end_layout

\begin_layout Itemize
steps roomHeight = 3 (it is assumed correct because its tolerance is much
 smaller than the other pieces)
\end_layout

\begin_layout Itemize
meters paintEfficiency = from 0.7 to 1.3 square meters per liter (1 liter
 per square meter in average) 
\end_layout

\begin_layout Itemize
paintLitersPerCan = 40 (it is assumed correct because its tolerance is much
 smaller than the other pieces)
\end_layout

\begin_layout Standard
To compute the average result just put average values in 
\begin_inset LatexCommand eqref
reference "eq:paintCans"

\end_inset

.
 We get: 
\begin_inset Formula $paintCans=\frac{2\times\left(6+4\right)\times3}{40\times1}=1.5$
\end_inset


\end_layout

\begin_layout Standard
paint cans, which means two unless you are able to buy just half of a can.
 
\end_layout

\begin_layout Standard
Are you satisfied with that result? I am not.
 What if I have underestimated something? As every engineer I would check
 what happens in the worst case, which means 1.1m step and efficiency of
 just 0.8.
 Again just substituting those values in 
\begin_inset LatexCommand eqref
reference "eq:paintCans"

\end_inset

, we get: 
\begin_inset Formula $paintCans=\frac{2\times\left(6.6+4.4\right)\times3}{40\times0.7}=2.36$
\end_inset

.
 That is really interesting: in the worst case I would miss 0.36 cans, it
 makes sense to buy three cans to avoid to go back to the hardware shop
 to buy one more (in the worst case).
 
\end_layout

\begin_layout Standard
More happy with the result now? I am not completely satisfied, I am asking
 myself: what if in the best case I need just 1 can? In that case probably
 I need more accurate data because the result range would be too wide.
 Eventually from 
\begin_inset LatexCommand eqref
reference "eq:paintCans"

\end_inset

 we get: 
\begin_inset Formula $paintCans=\frac{2\times\left(5.4+3.6\right)\times3}{40\times1.3}=1.04$
\end_inset

.
 Which means two cans.
 I am satisfied, I have to buy at least two cans, but probably I may need
 one more.
 In the next paragraph you will see how to do all this stuff in one step
 using Octave and SIMP! 
\end_layout

\begin_layout Section
Intervals
\begin_inset LatexCommand label
name "sec:Intervals"

\end_inset

 
\end_layout

\begin_layout Standard
As you saw in the example above a lot of computations are required to get
 an idea of the range where the result of the equation lay.
 To get the worst case, you need to think carefully at the equation because
 some time you need to put the higher value (like for steps in 
\begin_inset LatexCommand prettyref
reference "eq:paintCans"

\end_inset

) while other times the smallest (like for efficiency in 
\begin_inset LatexCommand prettyref
reference "eq:paintCans"

\end_inset

) to get the worst case and vice versa for the best.
 There is a much simpler way to work with that issue.
 You can use intervals instead of number
\begin_inset LatexCommand cite
key "key-1,key-2"

\end_inset

.
 An interval is:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
[a1,a2]=\left\{ \forall x\in\mathbb{R\mid\mathit{a1}\leqslant\mathit{x}\leqslant\mathit{a2}}\right\} ;a1,a2\in\mathbb{R\cup\left\{ -\infty,+\infty\right\} ;\mathit{a1}\leqslant\mathit{a2};}\label{eq:interval}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In few words, [a, b] is the set of real numbers among a and b.
 Please note that intervals suit perfectly in all the cases where numbers
 do not fit (some were showed in the 
\begin_inset LatexCommand prettyref
reference "sec:Introduction"

\end_inset

).
 
\end_layout

\begin_layout Standard
Moreover when it is correct to use a number, it is possible to use a degenerate
 interval like [a, a].
 That means intervals can replace real numbers in every computation.
 
\end_layout

\begin_layout Standard
It is possible also to define functions that work on intervals instead of
 numbers:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
f\left([a1,a2],[b1,b2],...\right)=\left\{ \forall f(a,b,...)\in\mathbb{R}\mid\exists a\in[a1,a2],b\in[b1,b2],...\right\} \label{eq:functionOnInterval}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Please note, with that definition it is possible to extend every function
 (like addition, multiplication, square, square root, ...) to work on intervals.
 
\end_layout

\begin_layout Standard
Note also sometime a function may generate several intervals as result.
 As an example consider the following division: 
\begin_inset Formula $[4,4]/[-2,2]=[-\infty,-2]\cup[2,+\infty]$
\end_inset

, it generates two interval as result.
 However SIMP works only on single interval function, for that reason if
 you try to divide for a interval containing 0 in SIMP, you will get an
 error.
\end_layout

\begin_layout Standard
Eventually note that usually computing the interval result of a function
 applied to intervals requires a lot of steps.
 Therefore sometime we may be satisfied to find, in a short time, a bigger
 interval containing the smallest interval where the solution must lay.
 
\end_layout

\begin_layout Standard
In the example above you would have:
\end_layout

\begin_layout Itemize
roomWidth = [5.4, 6.6] meters 
\end_layout

\begin_layout Itemize
roomLength = [3.6, 4.4] meters 
\end_layout

\begin_layout Itemize
roomHeight = 3 = [3, 3] meters
\end_layout

\begin_layout Itemize
paintEfficiency = [0.7, 1.3] square meters per liter 
\end_layout

\begin_layout Itemize
paintLitersPerCan = 40 = [40, 40] liters per can
\end_layout

\begin_layout Standard
Now you have just to compute the equation once with extended function to
 get [1.04, 2.36] cans.
 SIMP, the Octave package I developed, extends all the basic mathematical
 functions and it provides functions to extend all other available Octave
 functions.
 
\end_layout

\begin_layout Section
Issues with interval computation
\begin_inset LatexCommand label
name "sec:Issues-with-interval"

\end_inset

 
\end_layout

\begin_layout Standard
There are few issues you need to know about interval computations because
 they do not happen in standard mathematics
\begin_inset LatexCommand cite
key "key-2"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Variables independence 
\end_layout

\begin_layout Standard
All the variables you use to make a computation are independent from each
 other, although they are the same instance of variable for you.
 For example the perimeter of a rectangle (which was also used in a piece
 of the equation 
\begin_inset LatexCommand ref
reference "eq:paintCans"

\end_inset

) can be written in several ways.
 If the dimensions of the rectangle are b and h we can write:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
perimeter=2(h+b)\label{eq:perimetersmall}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
perimeter=h+h+b+b\label{eq:perimeterbig}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In standard mathematics they are the same, while in interval mathematics
 we have the interval 
\begin_inset Formula $equation(\ref{eq:perimetersmall})\subseteqq equation(\ref{eq:perimeterbig})$
\end_inset

.
 The reason is that every interval that appears in the equation is not dependent
 from each other, therefore in equation 
\begin_inset LatexCommand ref
reference "eq:perimeterbig"

\end_inset

 is like having four different dimensions (h, h', b and b').
 
\end_layout

\begin_layout Standard
What is important to remember is that: 
\emph on
Every variable should appear just once in the equation (if possible) in
 order to get the smallest interval possible as result.
\end_layout

\begin_layout Subsection
Hyper-cube Overlapping
\end_layout

\begin_layout Standard
The result of a set of simultaneous equations involving intervals is 
\emph on
always
\emph default
 an hyper-cube.
 For example if we have two simultaneous equations in the unknowns x and
 y the result will be a couple of intervals which draw a rectangle on the
 Cartesian plane.
 However the solution of a couple of simultaneous equations may be smaller,
 for example a segment on the Cartesian plane.
 In that case the rectangle will contain the segment.
 There is no way to solve that, just remember the solution is usually a
 super set of the actual one.
\end_layout

\begin_layout Section
Introduction on how the package works 
\begin_inset LatexCommand label
name "sec:Single-Interval-Mathematics"

\end_inset


\end_layout

\begin_layout Subsection
How to run SIMP in Octave
\end_layout

\begin_layout Standard
Octave 
\begin_inset LatexCommand cite
key "key-6"

\end_inset

 is a powerful numeric calculator, which is what is required for design.
 It is open source and freely available on a lot of platform.
 I suggest to play with Octave to understand its basic functions
\begin_inset LatexCommand cite
key "key-3,key-4"

\end_inset

 before using SIMP package.
 
\end_layout

\begin_layout Subsubsection
Install SIMP
\end_layout

\begin_layout Standard
First of all you have to install the SIMP package in Octave.
 To do that just run Octave from the directory where was downloaded the
 package and execute the following command:
\end_layout

\begin_layout Itemize
pkg install simp.tar.gz
\end_layout

\begin_layout Standard
From the next execution of Octave, it will automatically load the new functions.
 Therefore SIMP functions will be available as the standard Octave ones.
\end_layout

\begin_layout Subsubsection
Remove SIMP
\end_layout

\begin_layout Standard
If for some reason you want to remove the SIMP package, you can write:
\end_layout

\begin_layout Itemize
pkg uninstall simp.tar.gz
\end_layout

\begin_layout Standard
From the next execution of Octave all the SIMP functions will not be available.
\end_layout

\begin_layout Subsection
Some example
\end_layout

\begin_layout Standard
SIMP works on matrix, interpreted as intervals.
 The basic interval is: [min, max], which in Octave is a row vector made
 by two elements.
 The added functions work on those matrixes.
 For example to add the intervals [5.4, 6.6] and [3.6, 4.4] it is possible to
 write:
\end_layout

\begin_layout Itemize
addInt ([5.4, 6.6], [3.6, 4.4])
\end_layout

\begin_layout Description
> ans = [9, 11]
\end_layout

\begin_layout Standard
addInt stands for add intervals.
 All SIMP functions end with the word 
\begin_inset Quotes eld
\end_inset

Int
\begin_inset Quotes erd
\end_inset

.
 It is possible to use scalar number instead of intervals.
 Every scalar is computed like: 
\begin_inset Formula $s=[s,s]$
\end_inset

.
 Therefore the following computations give the same result:
\end_layout

\begin_layout Itemize
addInt ([5.4, 6.6], 3.6)
\end_layout

\begin_layout Description
> ans = [9, 10.2]
\end_layout

\begin_layout Itemize
addInt ([5.4, 6.6], [3.6, 3.6])
\end_layout

\begin_layout Description
> ans = [9, 10.2]
\end_layout

\begin_layout Standard
Octave supports variable declaration, therefore it is possible to write:
\end_layout

\begin_layout Itemize
roomWidth = [5.4, 6.6];
\end_layout

\begin_layout Itemize
roomLength =[3.6, 4.4];
\end_layout

\begin_layout Itemize
addInt (roomWidth, roomLength)
\end_layout

\begin_layout Description
> ans = [9, 11]
\end_layout

\begin_layout Standard
Now we know enough Octave syntax to compute the equation 
\begin_inset LatexCommand ref
reference "eq:paintCans"

\end_inset

:
\end_layout

\begin_layout Itemize
roomHeight = 3;
\end_layout

\begin_layout Itemize
paintEfficiency = [0.7, 1.3]; 
\end_layout

\begin_layout Itemize
paintLitersPerCan = 40; 
\end_layout

\begin_layout Itemize
divInt(mulInt(2, addInt (roomWidth, roomLength), roomHeight), mulInt(paintLiters
PerCan, paintEfficiency)) 
\end_layout

\begin_layout Description
> ans = [1.0385, 2.3571]
\end_layout

\begin_layout Standard
Sometime the intervals are expressed in terms of tolerance.
 The electronic resistors are sold in several tolerance classes: 1%, 2%,
 5%.
 There is a SIMP function to easily make an interval from a tolerance.
 For example a resistor of 10KOhms with 5% of tolerance can be converted
 in an interval:
\end_layout

\begin_layout Itemize
tollToInt (10000, 5)
\end_layout

\begin_layout Description
> ans = [9500, 10500]
\end_layout

\begin_layout Standard
If the tolerance is not symmetric, for example +5% and -10%:
\end_layout

\begin_layout Itemize
tollToInt (10000, 5, -10)
\end_layout

\begin_layout Description
> ans = [9000, 10500]
\end_layout

\begin_layout Standard
It is also possible to convert values from engineer notation to interval:
\end_layout

\begin_layout Itemize
intFormInt([
\begin_inset Quotes eld
\end_inset

10K+-5%
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Description
> ans = [9500, 10500]
\end_layout

\begin_layout Itemize
intFormInt([
\begin_inset Quotes eld
\end_inset

10K+5%-10%
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Description
> ans = [9000, 10500]
\end_layout

\begin_layout Standard
All the computations are done among intervals in SIMP.
 Therefore there is a SIMP function to convert an interval in engineer notation
 (in the hypothesis that the tolerance is symmetrical):
\end_layout

\begin_layout Itemize
engFormInt([9500, 10500])
\end_layout

\begin_layout Description
> ans = 
\begin_inset Quotes eld
\end_inset

10K+-5%
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Eventually those functions work on vectors of intervals which may be useful
 to compute functions.
 It is possible to compute operation on vectors of the same size (element
 by element) or scalar by vector.
 In that case the scalar is expanded to a vector of the same size of the
 others.
 That is really useful for the functions where a x vector can be used to
 compute a y in just one time.
\end_layout

\begin_layout Itemize
vect1 = [1 2;3 4;5 6]
\end_layout

\begin_layout Description
> vect1 = 
\end_layout

\begin_layout Description
> 1 2
\end_layout

\begin_layout Description
> 3 4
\end_layout

\begin_layout Description
> 5 6
\end_layout

\begin_layout Itemize
addInt (vect1, vect1, 1)
\end_layout

\begin_layout Description
> vect1 = 
\end_layout

\begin_layout Description
> 3 5
\end_layout

\begin_layout Description
> 7 9
\end_layout

\begin_layout Description
> 11 13
\end_layout

\begin_layout Standard
As you can see SIMP can be used just like a calculator.
 The basic operations are applied on intervals instead of scalar.
 That makes really simple to evaluate equations where some data is uncertain.
\end_layout

\begin_layout Section
Functions
\begin_inset LatexCommand label
name "sec:Functions"

\end_inset


\end_layout

\begin_layout Standard
This section describes the functions provided in the SIMP package.
\end_layout

\begin_layout Subsection
Intervals
\end_layout

\begin_layout Standard
All the SIMP functions work on vector of intervals as input.
 
\end_layout

\begin_layout Standard
A vector of intervals is a matrix with two columns and many rows: every
 row describes an interval.
 The matrix is composed by real numbers.
\end_layout

\begin_layout Standard
An interval is a degenerate vector with two columns and only one row.
 The first value is the interval minimum, the second is the interval maximum.
 Therefore [1.1, 2.1] is an interval with 1.1 as lower boundary and 2.1 as upper
 boundary.
\end_layout

\begin_layout Standard
A real number is meant as a case of degenerate interval with maximum and
 minimum values coincident.
 Therefore 5 is like [5, 5].
\end_layout

\begin_layout Standard
It is useful working on vector because the same operation can be applied
 to several intervals in one step.
 All the vectors involved must have the same number of rows (intervals),
 with the exception of scalar and single interval.
 They are automatically expanded to the number of rows (intervals) that
 matches the other inputs.
\end_layout

\begin_layout Subsection
valtol100ToInt (v1, ptol, ntol)
\begin_inset LatexCommand label
name "sub:valtol100ToInt-(v,-ptol,"

\end_inset


\end_layout

\begin_layout Standard
valtol100ToInt produces an interval with center value given by the scalar
 v1, and positive and negative tolerance express in percentage given by
 ptol and ntol.
 ntol is optional, if ntol is not present it is assumed equal to -ptol.
\end_layout

\begin_layout Subsection
intToTol (v1)
\end_layout

\begin_layout Standard
intToTol produces the tolerance of the vector of interval v1, in the hypothesis
 that the actual value is in the average point between minimum and maximum.
 
\end_layout

\begin_layout Subsection
intToTol100 (v1)
\end_layout

\begin_layout Standard
intToTol100 produces the tolerance (expressed in percentage) of the vector
 of interval v1, in the hypothesis that the actual value is in the average
 point between minimum and maximum.
\end_layout

\begin_layout Subsection
intToVal (v1)
\end_layout

\begin_layout Standard
intToVal produces the central value of the vector of intervals v1, in the
 hypothesis that the actual value is in the average point.
\end_layout

\begin_layout Subsection
engFormInt (v1)
\begin_inset LatexCommand label
name "sub:engFormInt-(a)"

\end_inset


\end_layout

\begin_layout Standard
engFormInt returns a vector of strings representing the intervals in the
 vector v1 in engineer notation.
 As value it returns the average between minimum and maximum which means
 symmetric tolerance.
\end_layout

\begin_layout Standard
The engineer notation is obtained finding the exponent (multiple of three)
 so that the mantissa is between 1 and 1000, then the exponent is converted
 into a letter as per the following list:
\end_layout

\begin_layout Itemize
Y = 
\begin_inset Formula $10^{24}$
\end_inset


\end_layout

\begin_layout Itemize
Z = 
\begin_inset Formula $10^{21}$
\end_inset


\end_layout

\begin_layout Itemize
E = 
\begin_inset Formula $10^{18}$
\end_inset


\end_layout

\begin_layout Itemize
P = 
\begin_inset Formula $10^{15}$
\end_inset


\end_layout

\begin_layout Itemize
T = 
\begin_inset Formula $10^{12}$
\end_inset


\end_layout

\begin_layout Itemize
G = 
\begin_inset Formula $10^{9}$
\end_inset


\end_layout

\begin_layout Itemize
M = 
\begin_inset Formula $10^{6}$
\end_inset


\end_layout

\begin_layout Itemize
K = 
\begin_inset Formula $10^{3}$
\end_inset


\end_layout

\begin_layout Itemize
nothing = 
\begin_inset Formula $10^{0}$
\end_inset


\end_layout

\begin_layout Itemize
m = 
\begin_inset Formula $10^{-3}$
\end_inset


\end_layout

\begin_layout Itemize
u = 
\begin_inset Formula $10^{-6}$
\end_inset


\end_layout

\begin_layout Itemize
n = 
\begin_inset Formula $10^{-9}$
\end_inset


\end_layout

\begin_layout Itemize
p = 
\begin_inset Formula $10^{-12}$
\end_inset


\end_layout

\begin_layout Itemize
f = 
\begin_inset Formula $10^{-15}$
\end_inset


\end_layout

\begin_layout Itemize
a = 
\begin_inset Formula $10^{-18}$
\end_inset


\end_layout

\begin_layout Itemize
z = 
\begin_inset Formula $10^{-21}$
\end_inset


\end_layout

\begin_layout Itemize
y = 
\begin_inset Formula $10^{-24}$
\end_inset


\end_layout

\begin_layout Standard
Eventually the tolerance is added in form of percentage: 
\begin_inset Quotes eld
\end_inset

+-
\begin_inset Quotes erd
\end_inset

 tolerance in percentage 
\begin_inset Quotes eld
\end_inset

%
\begin_inset Quotes erd
\end_inset

.
 Please note that the tolerance is symmetric which is not always the actual
 case.
 For example engFormInt([9500, 10500]) = 
\begin_inset Quotes eld
\end_inset

10K+-10%
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Note that with other functions (
\begin_inset LatexCommand prettyref
reference "sub:valtol100ToInt-(v,-ptol,"

\end_inset

) it is possible to define intervals with not symmetric tolerance, they
 will not be converted properly back by 
\begin_inset LatexCommand prettyref
reference "sub:engFormInt-(a)"

\end_inset

.
\end_layout

\begin_layout Subsection
intFormInt (string)
\end_layout

\begin_layout Standard
intFormInt returns a vector of intervals given a vector of strings (or a
 single string) representing the number in engineer notation.
 See 
\begin_inset LatexCommand prettyref
reference "sub:engFormInt-(a)"

\end_inset

 for details on engineer notation.
 For example intFormInt(
\begin_inset Quotes eld
\end_inset

10K+-10%
\begin_inset Quotes erd
\end_inset

) = [9500, 10500].
 
\end_layout

\begin_layout Standard
Although it is not orthogonal to 
\begin_inset LatexCommand prettyref
reference "sub:engFormInt-(a)"

\end_inset

, it evaluates also expression with not symmetric tolerance: 10K+5%-10%
 is converted to [9000, 10500].
 That was done because not symmetric tolerance is quite common in practice.
\end_layout

\begin_layout Subsection
addInt (v1, v2, v3, ...) 
\end_layout

\begin_layout Standard
addInt adds the given vector of intervals.
 It returns 
\begin_inset Formula $v1+v2+v3+\ldots$
\end_inset

 .
 They must have the same number of rows or be single interval or be scalars.
 At least two vectors are required.
\end_layout

\begin_layout Subsection
negateInt (v1)
\end_layout

\begin_layout Standard
negateInt negates the given vector of intervals.
 It returns 
\begin_inset Formula $-v1$
\end_inset

.
\end_layout

\begin_layout Subsection
subInt (v1, v2, v3, ...)
\end_layout

\begin_layout Standard
subInt subtracts the given vector of intervals.
 It returns 
\begin_inset Formula $v1-v2-v3-\ldots$
\end_inset

 .
 They must have the same number of rows or be single interval or be scalar.
 At least two vectors are required.
\end_layout

\begin_layout Subsection
mulInt (v1, v2, v3, ...)
\end_layout

\begin_layout Standard
mulInt multiplies the given vector of intervals.
 It returns 
\begin_inset Formula $v1\cdot v2\cdot v3\cdot\ldots$
\end_inset

 .
 They must have the same number of rows or be single interval or be scalar.
 At least two vectors are required.
\end_layout

\begin_layout Subsection
invertInt (v1)
\end_layout

\begin_layout Standard
invertInt inverts the given vector of intervals.
 It returns 
\begin_inset Formula $\frac{1}{v1}$
\end_inset

.
\end_layout

\begin_layout Subsection
invertAddInt (v1, v2, v3, ...)
\end_layout

\begin_layout Standard
invertAddInt adds the inverse of the given vector of intervals and then
 inverts again the result.
 It returns 
\begin_inset Formula $\frac{1}{\frac{1}{v1}+\frac{1}{v2}+\frac{1}{v3}+\cdots}$
\end_inset

.
 They must have the same number of rows or be single interval or be scalar.
 At least two vectors are required.
\end_layout

\begin_layout Subsection
divInt (v1, v2, v3, ...)
\end_layout

\begin_layout Standard
divInt divides the given vector of intervals.
 It returns 
\begin_inset Formula $\frac{\frac{v1}{v2}}{v3}\ldots$
\end_inset

 .
 They must have the same number of rows or be single interval or be scalar.
 The vectors v2, v3, ...
 must not include 0.
 At least two vectors are required.
\end_layout

\begin_layout Subsection
powerInt (v1, n)
\end_layout

\begin_layout Standard
powerInt rise the given vector of intervals to the power of n.
 It returns 
\begin_inset Formula $v1^{n}$
\end_inset

.
\end_layout

\begin_layout Subsection
sqrInt (v1)
\end_layout

\begin_layout Standard
sqrInt squares the given vector of intervals.
 It returns 
\begin_inset Formula $v1^{2}$
\end_inset

.
\end_layout

\begin_layout Subsection
sqrtInt (v1)
\end_layout

\begin_layout Standard
sqrtInt square roots the given vector of intervals.
 It returns 
\begin_inset Formula $\sqrt{v1}$
\end_inset

.
\end_layout

\begin_layout Subsection
sqrAddInt (v1, v2, v3, ...)
\end_layout

\begin_layout Standard
addSqrInt adds the square of the given vector of intervals and then it squares
 root the result.
 It returns 
\begin_inset Formula $\sqrt{v1^{2}+v2^{2}+v3^{2}+\ldots}$
\end_inset

.
 They must have the same number of rows or be single interval or be scalar.
 At least two vectors are required.
\end_layout

\begin_layout Subsection
dB10ToLinInt (v1)
\end_layout

\begin_layout Standard
db10ToLinInt rises 10 to the power of v1 tens.
 It returns 
\begin_inset Formula $10^{\frac{v1}{10}}$
\end_inset

.
\end_layout

\begin_layout Subsection
linToDB10Int (v1)
\end_layout

\begin_layout Standard
linToDB10Int produces 10 times the logarithm of v1.
 It returns 
\begin_inset Formula $10log_{10}(v1)$
\end_inset

.
\end_layout

\begin_layout Subsection
dB20ToLinInt (v1)
\end_layout

\begin_layout Standard
db10ToLinInt rises 10 to the power of v1 twenties.
 It returns 
\begin_inset Formula $10^{\frac{v1}{20}}$
\end_inset

.
\end_layout

\begin_layout Subsection
linToDB20Int (v1)
\end_layout

\begin_layout Standard
linToDB10Int produces 20 times the logarithm of v1.
 It returns 
\begin_inset Formula $20log_{10}(v1)$
\end_inset

.
\end_layout

\begin_layout Subsection
linSpaceTol100Int (begin, end, numberOfIntervals, tolerance)
\end_layout

\begin_layout Standard
linSpaceTol100Int produces a vector of numberOfIntervals intervals equally
 spaced between begin and end, with the given tolerance.
\end_layout

\begin_layout Subsection
logSpaceTol100Int (begin, end, numberOfIntervals, tolerance)
\end_layout

\begin_layout Standard
linSpaceTol100Int produces a vector of numberOfIntervals intervals equally
 spaced between 
\begin_inset Formula $10^{begin}$
\end_inset

 and 
\begin_inset Formula $10^{end}$
\end_inset

, with the given tolerance.
\end_layout

\begin_layout Subsection
monotonicFunctionInt (f, x)
\end_layout

\begin_layout Standard
monotonicFunctionInt produces the y vector of interval obtained applying
 the monotonic function f to the vector of interval x.
 If f is not monotonic, y may be wrong.
\end_layout

\begin_layout Subsection
functionInt (f, x, nOfPoint)
\end_layout

\begin_layout Standard
functionInt try to produces the y vector of interval obtained applying the
 function f to the vector of interval x.
 The function is checked for monotonicity on the given number of point.
 nOfPoint is optional, default is 10.
\end_layout

\begin_layout Subsection
plotInt (x, y)
\end_layout

\begin_layout Standard
plotInt plots the interval of vector y respect to the interval of vector
 x.
 Those curves, for every x interval center point, goes through ymin and
 ymax.
 x and y must have the same rows.
\end_layout

\begin_layout Subsection
errorBarInt (x, y)
\end_layout

\begin_layout Standard
For every x center point, plots the y tolerance.
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Biography
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-1"

\end_inset

http://en.wikipedia.org/wiki/Interval_arithmetic
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-2"

\end_inset

http://www.cs.utep.edu/interval-comp/hayes.pdf
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-6"

\end_inset

http://www.octave.org
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-3"

\end_inset

http://www-mdp.eng.cam.ac.uk/web/CD/engapps/octave/octavetut.pdf
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
key "key-4"

\end_inset

http://www.gnu.org/software/octave/docs.html
\end_layout

\end_body
\end_document
