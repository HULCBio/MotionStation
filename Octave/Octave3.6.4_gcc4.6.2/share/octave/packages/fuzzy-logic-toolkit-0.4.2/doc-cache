# Created by Octave 3.6.4, Sat Mar 30 10:11:40 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 50
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
addmf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1402
 -- Function File: FIS = addmf (FIS, IN_OR_OUT, VAR_INDEX, MF_NAME,
          MF_TYPE, MF_PARAMS)
     Add a membership function to an existing FIS structure and return
     the updated FIS.

     The types of the arguments are expected to be:
          FIS: an FIS structure

          IN_OR_OUT: 'input' or 'output' (case-insensitive)

          VAR_INDEX: valid index of an FIS input/output variable

          MF_NAME: a string

          MF_TYPE: a string

          MF_PARAMS: a vector

     If MF_TYPE is one of the built-in membership functions, then the
     number and values of the parameters must satisfy the membership
     function requirements for the specified MF_TYPE.

     Note that addmf will allow the user to add membership functions or
     membership function names for a given input or output variable that
     duplicate mfs or mf names already entered.

     Also, constant and linear membership functions are not restricted
     to FIS structure outputs or to Sugeno-type FIS structures, and the
     result of using them for FIS inputs or Mamdani-type FIS outputs
     has not yet been tested.

     To run the demonstration code, type demo('addmf') at the Octave
     prompt.  This demo creates two FIS input variables and associated
     membership functions and then produces two figures showing the
     term sets for the two FIS inputs.

     See also: rmmf, setfis





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Add a membership function to an existing FIS structure and return the
updated FI



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
addrule


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1627
 -- Function File: FIS = addrule (FIS, RULE_MATRIX)
     Add a list of rules to an existing FIS structure and return the
     updated FIS.

     Each row of the RULE_MATRIX represents one rule and has the form:
          [in1_mf ... inM_mf out1_mf ... outN_mf weight connect]

     where:

          in<i>_mf == membership function index for input i

          out<j>_mf == membership function index for output j

          weight == relative weight of the rule (0 <= weight <= 1)

          connect == antecedent connective (1 == and; 2 == or)

     To express:
          "not" - prepend a minus sign to the membership function index

          "somewhat" - append ".05" to the membership function index

          "very" - append ".20" to the membership function index

          "extremely" - append ".30" to the membership function index

          "very very" - append ".40" to the membership function index

          custom hedge - append .xy, where x.y is the degree to which
          the membership   value should be raised, to the membership
          function index

     To omit an input or output, use 0 for the membership function
     index.  The consequent connective is always "and".

     For example, to express:
          "If (input_1 is mf_2) or (input_3 is not mf_1) or (input_4 is very mf_1),
           then (output_1 is mf_2) and (output_2 is mf_1^0.3)."

     with weight 1, the corresponding row of RULE_MATRIX would be:
          [2   0   -1   4.2   2   1.03   1   2]

     For a complete example that uses addrule, see
     heart_disease_demo_1.m.

     See also: heart_disease_demo_1, showrule





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Add a list of rules to an existing FIS structure and return the updated
FIS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
addvar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 640
 -- Function File: FIS = addvar (FIS, IN_OR_OUT, VAR_NAME, VAR_RANGE)
     Add an input or output variable to an existing FIS structure and
     return the updated FIS.

     The types of the arguments are expected to be:
          FIS - an FIS structure

          IN_OR_OUT - either 'input' or 'output' (case-insensitive)

          VAR_NAME - a string

          VAR_RANGE - a vector [x1 x2] of two real numbers

     The vector components x1 and x2, which must also satisfy x1 <= x2,
     specify the lower and upper bounds of the variable's domain.

     To run the demonstration code, type demo('addvar') at the Octave
     prompt.





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Add an input or output variable to an existing FIS structure and return
the upda



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
algebraic_product


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 784
 -- Function File: RETVAL = algebraic_product (X)
 -- Function File: RETVAL = algebraic_product (X, Y)
     Return the algebraic product of the input.  The algebraic product
     of two real scalars x and y is: x * y

     For one vector argument, apply the algebraic product to all of
     elements of the vector. (The algebraic product is associative.)
     For one two-dimensional matrix argument, return a vector of the
     algebraic product of each column.

     For two vectors or matrices of identical dimensions, or for one
     scalar and one vector or matrix argument, return the pair-wise
     product.

     See also: algebraic_sum, bounded_difference, bounded_sum,
     drastic_product, drastic_sum, einstein_product, einstein_sum,
     hamacher_product, hamacher_sum





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Return the algebraic product of the input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
algebraic_sum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 777
 -- Function File: RETVAL = algebraic_sum (X, Y)
 -- Function File: RETVAL = algebraic_sum (X, Y)
     Return the algebraic sum of the input.  The algebraic sum of two
     real scalars x and y is: x + y - x * y

     For one vector argument, apply the algebraic sum to all of
     elements of the vector. (The algebraic sum is associative.) For
     one two-dimensional matrix argument, return a vector of the
     algebraic sum of each column.

     For two vectors or matrices of identical dimensions, or for one
     scalar and one vector or matrix argument, return the pair-wise
     algebraic sum.

     See also: algebraic_product, bounded_difference, bounded_sum,
     drastic_product, drastic_sum, einstein_product, einstein_sum,
     hamacher_product, hamacher_sum





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return the algebraic sum of the input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
bounded_difference


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 818
 -- Function File: RETVAL = bounded_difference (X)
 -- Function File: RETVAL = bounded_difference (X, Y)
     Return the bounded difference of the input.  The bounded
     difference of two real scalars x and y is: max (0, x + y - 1)

     For one vector argument, apply the bounded difference to all of
     the elements of the vector. (The bounded difference is
     associative.) For one two-dimensional matrix argument, return a
     vector of the bounded difference of each column.

     For two vectors or matrices of identical dimensions, or for one
     scalar and one vector or matrix argument, return the pair-wise
     bounded difference.

     See also: algebraic_product, algebraic_sum, bounded_sum,
     drastic_product, drastic_sum, einstein_product, einstein_sum,
     hamacher_product, hamacher_sum





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return the bounded difference of the input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
bounded_sum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 761
 -- Function File: RETVAL = bounded_sum (X)
 -- Function File: RETVAL = bounded_sum (X, Y)
     Return the bounded sum of the input.  The bounded sum of two real
     scalars x and y is: min (1, x + y)

     For one vector argument, apply the bounded sum to all of elements
     of the vector. (The bounded sum is associative.) For one
     two-dimensional matrix argument, return a vector of the bounded
     sum of each column.

     For two vectors or matrices of identical dimensions, or for one
     scalar and one vector or matrix argument, return the pair-wise
     bounded sum.

     See also: algebraic_product, algebraic_sum, bounded_difference,
     drastic_product, drastic_sum, einstein_product, einstein_sum,
     hamacher_product, hamacher_sum





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return the bounded sum of the input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
cubic_approx_demo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 561
 -- Script File:  cubic_approx_demo
     Demonstrate the use of the Octave Fuzzy Logic Toolkit to
     approximate a non-linear function using a Sugeno-type FIS with
     linear output functions.

     The demo:
        - reads an FIS structure from a file

        - plots the input membership functions

        - plots the (linear) output functions

        - plots the FIS output as a function of the input

     See also: heart_disease_demo_1, heart_disease_demo_2,
     investment_portfolio_demo, linear_tip_demo, mamdani_tip_demo,
     sugeno_tip_demo





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Demonstrate the use of the Octave Fuzzy Logic Toolkit to approximate a
non-linea



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
defuzz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1345
 -- Function File: CRISP_X = defuzz (X, Y, DEFUZZ_METHOD)
 -- Function File: CRISP_X = defuzz ([X1 X2 ... XN], [Y1 Y2 ... YN],
          DEFUZZ_METHOD)
     For a given domain, set of fuzzy function values, and
     defuzzification method, return the defuzzified (crisp) value of
     the fuzzy function.

     The arguments X and Y must be either two real numbers or two
     equal-length, non-empty vectors of reals, with the elements of X
     strictly increasing. DEFUZZ_METHOD must be a (case-sensitive)
     string corresponding to a defuzzification method. Defuzz handles
     both built-in and custom defuzzification methods.

     The built-in defuzzification methods are:
    `centroid'
          Return the x-value of the centroid.

    `bisector'
          Return the x-value of the vertical bisector of the area.

    `mom'
          Return the mean x-value of the points with maximum y-values.

    `som'
          Return the smallest (absolute) x-value of the points with
          maximum y-values.

    `lom'
          Return the largest (absolute) x-value of the points with
          maximum y-values.

    `wtaver'
          Return the weighted average of the x-values, with the
          y-values used as weights.

    `wtsum'
          Return the weighted sum of the x-values, with the y-values
          used as weights.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain, set of fuzzy function values, and defuzzification
method, re



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
drastic_product


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 857
 -- Function File: RETVAL = drastic_product (X)
 -- Function File: RETVAL = drastic_product (X, Y)
     Return the drastic product of the input.  The drastic product of
     two real scalars x and y is:
          min (x, y)     if max (x, y) == 1
          0              otherwise

     For one vector argument, apply the drastic product to all of the
     elements of the vector. (The drastic product is associative.) For
     one two-dimensional matrix argument, return a vector of the
     drastic product of each column.

     For two vectors or matrices of identical dimensions, or for one
     scalar and one vector or matrix argument, return the pair-wise
     drastic product.

     See also: algebraic_product, algebraic_sum, bounded_difference,
     bounded_sum, drastic_sum, einstein_product, einstein_sum,
     hamacher_product, hamacher_sum





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return the drastic product of the input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
drastic_sum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 829
 -- Function File: RETVAL = drastic_sum (X)
 -- Function File: RETVAL = drastic_sum (X, Y)
     Return the drastic sum of the input.  The drastic sum of two real
     scalars x and y is:
          max (x, y)     if min (x, y) == 0
          1              otherwise

     For one vector argument, apply the drastic sum to all of the
     elements of the vector. (The drastic sum is associative.) For one
     two-dimensional matrix argument, return a vector of the drastic sum
     of each column.

     For two vectors or matrices of identical dimensions, or for one
     scalar and one vector or matrix argument, return the pair-wise
     drastic sum.

     See also: algebraic_product, algebraic_sum, bounded_difference,
     bounded_sum, drastic_product, einstein_product, einstein_sum,
     hamacher_product, hamacher_sum





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return the drastic sum of the input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dsigmf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1299
 -- Function File: Y = dsigmf (X, PARAMS)
 -- Function File: Y = dsigmf ([X1 X2 ... XN], [A1 C1 A2 C2])
     For a given domain X and parameters PARAMS (or [A1 C1 A2 C2]),
     return the corresponding Y values for the difference between two
     sigmoidal membership functions.

     The argument X must be a real number or a non-empty list of
     strictly increasing real numbers, and A1, C1, A2, and C2 must be
     real numbers. This membership function satisfies the equation:
          f(x) = 1/(1 + exp(-a1*(x - c1))) - 1/(1 + exp(-a2*(x - c2)))

     and in addition, is bounded above and below by 1 and 0 (regardless
     of the value given by the formula above).

     If the parameters A1 and A2 are positive and C1 and C2 are far
     enough apart with C1 < C2, then:
          (a1)/4 ~ the rising slope at c1

          c1 ~ the left inflection point

          (-a2)/4 ~ the falling slope at c2

          c2 ~ the right inflection point

     and at each inflection point, the value of the function is about
     0.5:
          f(c1) ~ f(c2) ~ 0.5.

     Here, the symbol ~ means "approximately equal".

     To run the demonstration code, type demo('dsigmf') at the Octave
     prompt.

     See also: gauss2mf, gaussmf, gbellmf, pimf, psigmf, sigmf, smf,
     trapmf, trimf, zmf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain X and parameters PARAMS (or [A1 C1 A2 C2]), return
the corres



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
einstein_product


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 817
 -- Function File: RETVAL = einstein_product (X)
 -- Function File: RETVAL = einstein_product (X, Y)
     Return the Einstein product of the input.  The Einstein product of
     two real scalars x and y is: (x * y) / (2 - (x + y - x * y))

     For one vector argument, apply the Einstein product to all of the
     elements of the vector. (The Einstein product is associative.) For
     one two-dimensional matrix argument, return a vector of the
     Einstein product of each column.

     For two vectors or matrices of identical dimensions, or for one
     scalar and one vector or matrix argument, return the pair-wise
     Einstein product.

     See also: algebraic_product, algebraic_sum, bounded_difference,
     bounded_sum, drastic_product, drastic_sum, einstein_sum,
     hamacher_product, hamacher_sum





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Return the Einstein product of the input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
einstein_sum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 779
 -- Function File: RETVAL = einstein_sum (X)
 -- Function File: RETVAL = einstein_sum (X, Y)
     Return the Einstein sum of the input.  The Einstein sum of two
     real scalars x and y is: (x + y) / (1 + x * y)

     For one vector argument, apply the Einstein sum to all of the
     elements of the vector. (The Einstein sum is associative.) For one
     two-dimensional matrix argument, return a vector of the Einstein
     sum of each column.

     For two vectors or matrices of identical dimensions, or for one
     scalar and one vector or matrix argument, return the pair-wise
     Einstein sum.

     See also: algebraic_product, algebraic_sum, bounded_difference,
     bounded_sum, drastic_product, drastic_sum, einstein_product,
     hamacher_product, hamacher_sum





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return the Einstein sum of the input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
evalfis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7875
 -- Function File: OUTPUT = evalfis (USER_INPUT, FIS)
 -- Function File: OUTPUT = evalfis (USER_INPUT, FIS, NUM_POINTS)
 -- Function File: [OUTPUT, RULE_INPUT, RULE_OUTPUT, FUZZY_OUTPUT] =
evalfis (USER_INPUT, FIS)
 -- Function File: [OUTPUT, RULE_INPUT, RULE_OUTPUT, FUZZY_OUTPUT] =
evalfis (USER_INPUT, FIS, NUM_POINTS)
     Return the crisp output(s) of an FIS for each row in a matrix of
     crisp input values.  Also, for the last row of USER_INPUT, return
     the intermediate results:

    RULE_INPUT
          a matrix of the degree to which each FIS rule matches each
          FIS input variable

    RULE_OUTPUT
          a matrix of the fuzzy output for each (rule, FIS output) pair

    FUZZY_OUTPUT
          a matrix of the aggregated output for each FIS output variable

     The optional argument NUM_POINTS specifies the number of points
     over which to evaluate the fuzzy values. The default value of
     NUM_POINTS is 101.

     Argument USER_INPUT:

     USER_INPUT is a matrix of crisp input values. Each row represents
     one set of crisp FIS input values. For an FIS that has N inputs,
     an input matrix of z sets of input values will have the form:

          [input_11 input_12 ... input_1N]  <-- 1st row is 1st set of inputs
          [input_21 input_22 ... input_2N]  <-- 2nd row is 2nd set of inputs
          [             ...              ]                 ...
          [input_z1 input_z2 ... input_zN]  <-- zth row is zth set of inputs

     Return value OUTPUT:

     OUTPUT is a matrix of crisp output values. Each row represents the
     set of crisp FIS output values for the corresponding row of
     USER_INPUT. For an FIS that has M outputs, an OUTPUT matrix
     corresponding to the preceding input matrix will have the form:

          [output_11 output_12 ... output_1M]  <-- 1st row is 1st set of outputs
          [output_21 output_22 ... output_2M]  <-- 2nd row is 2nd set of outputs
          [               ...               ]                 ...
          [output_z1 output_z2 ... output_zM]  <-- zth row is zth set of outputs

     The intermediate result RULE_INPUT:

     The matching degree for each (rule, input value) pair is specified
     by the RULE_INPUT matrix. For an FIS that has Q rules and N input
     variables, the matrix will have the form:
                   in_1  in_2 ...  in_N
          rule_1 [mu_11 mu_12 ... mu_1N]
          rule_2 [mu_21 mu_22 ... mu_2N]
                 [            ...      ]
          rule_Q [mu_Q1 mu_Q2 ... mu_QN]

     Evaluation of hedges and "not":

     Each element of each FIS rule antecedent and consequent indicates
     the corresponding membership function, hedge, and whether or not
     "not" should be applied to the result. The index of the membership
     function to be used is given by the positive whole number portion
     of the antecedent/consequent vector entry, the hedge is given by
     the fractional portion (if any), and "not" is indicated by a minus
     sign. A "0" as the integer portion in any position in the rule
     indicates that the corresponding FIS input or output variable is
     omitted from the rule.

     For custom hedges and the four built-in hedges "somewhat," "very,"
     "extremely," and "very very," the membership function value
     (without the hedge or "not") is raised to the power corresponding
     to the hedge. All hedges are rounded to 2 digits.

     For example, if "mu(x)" denotes the matching degree of the input
     to the corresponding membership function without a hedge or "not,"
     then the final matching degree recorded in RULE_INPUT will be
     computed by applying the hedge and "not" in two steps. First, the
     hedge is applied:

          (fraction == .05) <=>  somewhat x       <=>  mu(x)^0.5  <=>  sqrt(mu(x))
          (fraction == .20) <=>  very x           <=>  mu(x)^2    <=>  sqr(mu(x))
          (fraction == .30) <=>  extremely x      <=>  mu(x)^3    <=>  cube(mu(x))
          (fraction == .40) <=>  very very x      <=>  mu(x)^4
          (fraction == .dd) <=>  <custom hedge> x <=>  mu(x)^(dd/10)

     After applying the appropriate hedge, "not" is calculated by:
          minus sign present           <=> not x         <=> 1 - mu(x)
          minus sign and hedge present <=> not <hedge> x <=> 1 - mu(x)^(dd/10)

     Hedges and "not" in the consequent are handled similarly.

     The intermediate result RULE_OUTPUT:

     For either a Mamdani-type FIS (that is, an FIS that does not have
     constant or linear output membership functions) or a Sugeno-type
     FIS (that is, an FIS that has only constant and linear output
     membership functions), RULE_OUTPUT specifies the fuzzy output for
     each (rule, FIS output) pair.  The format of rule_output depends
     on the FIS type.

     For a Mamdani-type FIS, RULE_OUTPUT is a NUM_POINTS x (Q * M)
     matrix, where Q is the number of rules and M is the number of FIS
     output variables. Each column of this matrix gives the y-values of
     the fuzzy output for a single (rule, FIS output) pair.

                           Q cols            Q cols              Q cols
                      ---------------   ---------------     ---------------
                      out_1 ... out_1   out_2 ... out_2 ... out_M ... out_M
                   1 [                                                     ]
                   2 [                                                     ]
                 ... [                                                     ]
          num_points [                                                     ]

     For a Sugeno-type FIS, RULE_OUTPUT is a 2 x (Q * M) matrix.  Each
     column of this matrix gives the (location, height) pair of the
     singleton output for a single (rule, FIS output) pair.

                         Q cols            Q cols                  Q cols
                    ---------------   ---------------         ---------------
                    out_1 ... out_1   out_2 ... out_2   ...   out_M ... out_M
          location [                                                         ]
            height [                                                         ]

     The intermediate result FUZZY_OUTPUT:

     The format of FUZZY_OUTPUT depends on the FIS type ('mamdani' or
     'sugeno').

     For either a Mamdani-type FIS or a Sugeno-type FIS, FUZZY_OUTPUT
     specifies the aggregated fuzzy output for each FIS output.

     For a Mamdani-type FIS, the aggregated FUZZY_OUTPUT is a
     NUM_POINTS x M matrix. Each column of this matrix gives the
     y-values of the fuzzy output for a single FIS output, aggregated
     over all rules.

                      out_1  out_2  ...  out_M
                   1 [                        ]
                   2 [                        ]
                 ... [                        ]
          num_points [                        ]

     For a Sugeno-type FIS, the aggregated output for each FIS output
     is a 2 x L matrix, where L is the number of distinct singleton
     locations in the RULE_OUTPUT for that FIS output:

                    singleton_1  singleton_2 ... singleton_L
          location [                                        ]
            height [                                        ]

     Then FUZZY_OUTPUT is a vector of M structures, each of which has
     an index and one of these matrices.

     Examples:

     Seven examples of using evalfis are shown in:
        * cubic_approx_demo.m

        * heart_disease_demo_1.m

        * heart_disease_demo_2.m

        * investment_portfolio_demo.m

        * linear_tip_demo.m

        * mamdani_tip_demo.m

        * sugeno_tip_demo.m

     See also: cubic_approx_demo, heart_disease_demo_1,
     heart_disease_demo_2, investment_portfolio_demo, linear_tip_demo,
     mamdani_tip_demo, sugeno_tip_demo





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the crisp output(s) of an FIS for each row in a matrix of crisp
input val



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
evalmf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1688
 -- Function File: Y = evalmf (X, PARAM, MF_TYPE)
 -- Function File: Y = evalmf (X, PARAM, MF_TYPE, HEDGE)
 -- Function File: Y = evalmf (X, PARAM, MF_TYPE, HEDGE, NOT_FLAG)
 -- Function File: Y = evalmf ([X1 X2 ... XN], [PARAM1 ... ], MF_TYPE)
 -- Function File: Y = evalmf ([X1 X2 ... XN], [PARAM1 ... ], MF_TYPE,
          HEDGE)
 -- Function File: Y = evalmf ([X1 X2 ... XN], [PARAM1 ... ], MF_TYPE,
          HEDGE, NOT_FLAG)
     For a given domain, set of parameters, membership function type,
     and optional hedge and not_flag, return the corresponding y-values
     for the membership function.

     The argument X must be a real number or a non-empty list of
     strictly increasing real numbers, PARAM must be a valid parameter
     or a vector of valid parameters for MF_TYPE, and MF_TYPE must be a
     string corresponding to a membership function type. Evalmf handles
     both built-in and custom membership functions.

     For custom hedges and the four built-in hedges "somewhat", "very",
     "extremely", and "very very", raise the membership function values
     to the power corresponding to the hedge.

          (fraction == .05) <=>  somewhat x       <=>  mu(x)^0.5  <=>  sqrt(mu(x))
          (fraction == .20) <=>  very x           <=>  mu(x)^2    <=>  sqr(mu(x))
          (fraction == .30) <=>  extremely x      <=>  mu(x)^3    <=>  cube(mu(x))
          (fraction == .40) <=>  very very x      <=>  mu(x)^4
          (fraction == .dd) <=>  <custom hedge> x <=>  mu(x)^(dd/10)

     The NOT_FLAG negates the membership function using:
          mu(not(x)) = 1 - mu(x)

     To run the demonstration code, type demo('evalmf') at the Octave
     prompt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain, set of parameters, membership function type, and
optional he



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
fcm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3875
 -- Function File: CLUSTER_CENTERS = fcm (INPUT_DATA, NUM_CLUSTERS)
 -- Function File: CLUSTER_CENTERS = fcm (INPUT_DATA, NUM_CLUSTERS,
          OPTIONS)
 -- Function File: CLUSTER_CENTERS = fcm (INPUT_DATA, NUM_CLUSTERS, [M,
          MAX_ITERATIONS, EPSILON, DISPLAY_INTERMEDIATE_RESULTS])
 -- Function File: [CLUSTER_CENTERS, SOFT_PARTITION, OBJ_FCN_HISTORY] =
fcm (INPUT_DATA, NUM_CLUSTERS)
 -- Function File: [CLUSTER_CENTERS, SOFT_PARTITION, OBJ_FCN_HISTORY] =
fcm (INPUT_DATA, NUM_CLUSTERS, OPTIONS)
 -- Function File: [CLUSTER_CENTERS, SOFT_PARTITION, OBJ_FCN_HISTORY] =
fcm (INPUT_DATA, NUM_CLUSTERS, [M, MAX_ITERATIONS, EPSILON,
          DISPLAY_INTERMEDIATE_RESULTS])
     Using the Fuzzy C-Means algorithm, calculate and return the soft
     partition of a set of unlabeled data points.

     Also, if DISPLAY_INTERMEDIATE_RESULTS is true, display intermediate
     results after each iteration. Note that because the initial cluster
     prototypes are randomly selected locations in the ranges
     determined by the input data, the results of this function are
     nondeterministic.

     The required arguments to fcm are:
          INPUT_DATA - a matrix of input data points; each row
          corresponds to one point

          NUM_CLUSTERS - the number of clusters to form

     The optional arguments to fcm are:
          M - the parameter (exponent) in the objective function;
          default = 2.0

          MAX_ITERATIONS - the maximum number of iterations before
          stopping; default = 100

          EPSILON - the stopping criteria; default = 1e-5

          DISPLAY_INTERMEDIATE_RESULTS - if 1, display results after
          each iteration, and if 0, do not; default = 1

     The default values are used if any of the optional arguments are
     missing or evaluate to NaN.

     The return values are:
          CLUSTER_CENTERS - a matrix of the cluster centers; each row
          corresponds to one point

          SOFT_PARTITION - a constrained soft partition matrix

          OBJ_FCN_HISTORY - the values of the objective function after
          each iteration

     Three important matrices used in the calculation are X (the input
     points to be clustered), V (the cluster centers), and Mu (the
     membership of each data point in each cluster). Each row of X and
     V denotes a single point, and Mu(i, j) denotes the membership
     degree of input point X(j, :) in the cluster having center V(i, :).

     X is identical to the required argument INPUT_DATA; V is identical
     to the output CLUSTER_CENTERS; and Mu is identical to the output
     SOFT_PARTITION.

     If n denotes the number of input points and k denotes the number of
     clusters to be formed, then X, V, and Mu have the dimensions:

                                        1    2   ...  #features
                                   1 [                           ]
             X  =  input_data  =   2 [                           ]
                                 ... [                           ]
                                   n [                           ]

                                             1    2   ...  #features
                                        1 [                           ]
             V  =  cluster_centers  =   2 [                           ]
                                      ... [                           ]
                                        k [                           ]

                                             1    2   ...   n
                                        1 [                    ]
             Mu  =  soft_partition  =   2 [                    ]
                                      ... [                    ]
                                        k [                    ]

     See also: gustafson_kessel, partition_coeff, partition_entropy,
     xie_beni_index





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Using the Fuzzy C-Means algorithm, calculate and return the soft
partition of a 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
gauss2mf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1578
 -- Function File: Y = gauss2mf (X, PARAMS)
 -- Function File: Y = gauss2mf ([X1 X2 ... XN], [SIG1 C1 SIG2 C2])
     For a given domain X and parameters PARAMS (or [SIG1 C1 SIG2 C2]),
     return the corresponding Y values for the two-sided Gaussian
     composite membership function. This membership function is a
     smooth curve calculated from two Gaussian membership functions as
     follows:

     Given parameters SIG1, C1, SIG2, and C2, that define two Gaussian
     membership functions, let:

          f1(x) = exp((-(x - c1)^2)/(2 * sig1^2))     if x <= c1
                  1                                   otherwise

          f2(x) = 1                                   if x <= c2
                  exp((-(x - c2)^2)/(2 * sig2^2))     otherwise

     Then gauss2mf is given by:

          f(x) = f1(x) * f2(x)

     The argument X must be a real number or a non-empty vector of
     strictly increasing real numbers, and SIG1, C1, SIG2, and C2 must
     be real numbers.  Gauss2mf always returns a continuously
     differentiable curve with values in the range [0, 1].

     If C1 < C2, gauss2mf is a normal membership function (has a
     maximum value of 1), with the rising curve identical to that of
     f1(x) and a falling curve identical to that of f2(x), above. If C1
     >= C2, gauss2mf returns a subnormal membership function (has a
     maximum value less than 1).

     To run the demonstration code, type demo('gauss2mf') at the Octave
     prompt.

     See also: dsigmf, gaussmf, gbellmf, pimf, psigmf, sigmf, smf,
     trapmf, trimf, zmf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain X and parameters PARAMS (or [SIG1 C1 SIG2 C2]),
return the co



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gaussmf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1322
 -- Function File: Y = gaussmf (X, PARAMS)
 -- Function File: Y = gaussmf ([X1 X2 ... XN], [SIG C])
     For a given domain X and parameters PARAMS (or [SIG C]), return
     the corresponding Y values for the Gaussian membership function.
     This membership function is shaped like the Gaussian (normal)
     distribution, but scaled to have a maximum value of 1. By
     contrast, the area under the Gaussian distribution curve is 1.

     The argument X must be a real number or a non-empty vector of
     strictly increasing real numbers, and SIG and C must be real
     numbers.  This membership function satisfies the equation:
          f(x) = exp((-(x - c)^2)/(2 * sig^2))

     which always returns values in the range [0, 1].

     Just as for the Gaussian (normal) distribution, the parameters SIG
     and C represent:
          sig^2 == the variance (a measure of the width of the curve)

          c == the center (the mean; the x value of the peak)

     For larger values of SIG, the curve is flatter, and for smaller
     values of sig, the curve is narrower. The Y value at the center is
     always 1:
          f(c) == 1

     To run the demonstration code, type demo('gaussmf') at the Octave
     prompt.

     See also: dsigmf, gauss2mf, gbellmf, pimf, psigmf, sigmf, smf,
     trapmf, trimf, zmf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain X and parameters PARAMS (or [SIG C]), return the
correspondin



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gbellmf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1457
 -- Function File: Y = gbellmf (X, PARAMS)
 -- Function File: Y = gbellmf ([X1 X2 ... XN], [A B C])
     For a given domain X and parameters PARAMS (or [A B C]), return
     the corresponding Y values for the generalized bell-shaped
     membership function.

     The argument X must be a real number or a non-empty vector of
     strictly increasing real numbers, A, B, and C must be real numbers,
     A must be non-zero, and B must be an integer. This membership
     function satisfies the equation:
          f(x) = 1/(1 + (abs((x - c)/a))^(2 * b))
     which always returns values in the range [0, 1].

     The parameters A, B, and C give:
          a == controls the width of the curve at f(x) = 0.5;
               f(c-a) = f(c+a) = 0.5
          b == controls the slope of the curve at x = c-a and x = c+a;
               f'(c-a) = b/2a and f'(c+a) = -b/2a
          c == the center of the curve

     This membership function has a value of 0.5 at the two points c -
     a and c + a, and the width of the curve at f(x) == 0.5 is 2 * |a|:
          f(c - a) == f(c + a) == 0.5
          2 * |a| == the width of the curve at f(x) == 0.5

     The generalized bell-shaped membership function is continuously
     differentiable and is symmetric about the line x = c.

     To run the demonstration code, type demo('gbellmf') at the Octave
     prompt.

     See also: dsigmf, gauss2mf, gaussmf, pimf, psigmf, sigmf, smf,
     trapmf, trimf, zmf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain X and parameters PARAMS (or [A B C]), return the
correspondin



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gensurf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1864
 -- Function File:  gensurf (FIS)
 -- Function File:  gensurf (FIS, INPUT_AXES)
 -- Function File:  gensurf (FIS, INPUT_AXES, OUTPUT_AXES)
 -- Function File:  gensurf (FIS, INPUT_AXES, OUTPUT_AXES, GRIDS)
 -- Function File:  gensurf (FIS, INPUT_AXES, OUTPUT_AXES, GRIDS,
          REF_INPUT)
 -- Function File:  gensurf (FIS, INPUT_AXES, OUTPUT_AXES, GRIDS,
          REF_INPUT, NUM_POINTS)
 -- Function File: [X, Y, Z] = gensurf (...)
     Generate and plot a surface (or 2-dimensional curve) showing one
     FIS output as a function of two (or one) of the FIS inputs. The
     reference input is used for all FIS inputs that are not in the
     input_axes vector.

     Grids, which specifies the number of grids to show on the input
     axes, may be a scalar or a vector of length 2. If a scalar, then
     both axes will use the same number of grids. If a vector of length
     2, then the grids on the two axes are controlled separately.

     Num_points specifies the number of points to use when evaluating
     the FIS.

     The final form "[x, y, z] = gensurf(...)" suppresses plotting.

     Default values for arguments not supplied are:
        * input_axes == [1 2]

        * output_axis == 1

        * grids == [15 15]

        * ref_input == []

        * num_points == 101

     Six demo scripts that use gensurf are:
        * cubic_approx_demo.m

        * heart_disease_demo_1.m

        * heart_disease_demo_2.m

        * investment_portfolio_demo.m

        * linear_tip_demo.m

        * mamdani_tip_demo.m

        * sugeno_tip_demo.m

     Current limitation: The form of gensurf that suppresses plotting
     (the final form above) is not yet implemented.

     See also: cubic_approx_demo, heart_disease_demo_1,
     heart_disease_demo_2, investment_portfolio_demo, linear_tip_demo,
     mamdani_tip_demo, sugeno_tip_demo, plotmf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Generate and plot a surface (or 2-dimensional curve) showing one FIS
output as a



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getfis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2828
 -- Function File: RETVAL = getfis (FIS)
 -- Function File: RETVAL = getfis (FIS, PROPERTY)
 -- Function File: RETVAL = getfis (FIS, IN_OR_OUT, VAR_INDEX)
 -- Function File: RETVAL = getfis (FIS, IN_OR_OUT, VAR_INDEX,
          VAR_PROPERTY)
 -- Function File: RETVAL = getfis (FIS, IN_OR_OUT, VAR_INDEX, MF,
          MF_INDEX)
 -- Function File: RETVAL = getfis (FIS, IN_OR_OUT, VAR_INDEX, MF,
          MF_INDEX, MF_PROPERTY)
     Return or print the property (field) values of an FIS structure
     specified by the arguments. There are six forms of getfis:

    # Arguments
          Action Taken

    1
          Print (some) properties of an FIS structure on standard
          output.  Return the empty set.

    2
          Return a specified property of the FIS structure. The
          properties that may be specified are: name, type, version,
          numinputs, numoutputs, numinputmfs, numoutputmfs, numrules,
          andmethod, ormethod, impmethod, addmethod, defuzzmethod,
          inlabels, outlabels, inrange, outrange, inmfs, outmfs,
          inmflabels, outmflabels, inmftypes, outmftypes, inmfparams,
          outmfparams, and rulelist.

    3
          Print the properties of a specified input or output variable
          of the FIS structure. Return the empty set.

    4
          Return a specified property of an input or output variable.
          The properties that may be specified are: name, range, nummfs,
          and mflabels.

    5
          Print the properties of a specified membership function of the
          FIS structure. Return the empty set.

    6
          Return a specified property of a membership function. The
          properties that may be specified are: name, type, and params.

     The types of the arguments are expected to be:
    FIS
          an FIS structure

    PROPERTY
          a string; one of: 'name', 'type', 'version', 'numinputs',
          'numoutputs', 'numinputmfs', 'numoutputmfs', 'numrules',
          'andmethod', 'ormethod', 'impmethod', 'addmethod',
          'defuzzmethod' 'inlabels', 'outlabels', 'inrange',
          'outrange', 'inmfs', 'outmfs', 'inmflabels', 'outmflabels',
          'inmftypes', 'outmftypes', 'inmfparams', 'outmfparams', and
          'rulelist' (case-insensitive)

    IN_OR_OUT
          either 'input' or 'output' (case-insensitive)

    VAR_INDEX
          a valid integer index of an input or output FIS variable

    VAR_PROPERTY
          a string; one of: 'name', 'range', 'nummfs', and 'mflabels'

    MF
          the string 'mf'

    MF_INDEX
          a valid integer index of a membership function

    MF_PROPERTY
          a string; one of 'name', 'type', or 'params'

     Note that all of the strings representing properties above are case
     insensitive.

     See also: setfis, showfis





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return or print the property (field) values of an FIS structure
specified by the



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
gustafson_kessel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4487
 -- Function File: CLUSTER_CENTERS = gustafson_kessel (INPUT_DATA,
          NUM_CLUSTERS)
 -- Function File: CLUSTER_CENTERS = gustafson_kessel (INPUT_DATA,
          NUM_CLUSTERS, CLUSTER_VOLUME)
 -- Function File: CLUSTER_CENTERS = gustafson_kessel (INPUT_DATA,
          NUM_CLUSTERS, CLUSTER_VOLUME, OPTIONS)
 -- Function File: CLUSTER_CENTERS = gustafson_kessel (INPUT_DATA,
          NUM_CLUSTERS, CLUSTER_VOLUME, [M, MAX_ITERATIONS, EPSILON,
          DISPLAY_INTERMEDIATE_RESULTS])
 -- Function File: [CLUSTER_CENTERS, SOFT_PARTITION, OBJ_FCN_HISTORY] =
gustafson_kessel (INPUT_DATA, NUM_CLUSTERS)
 -- Function File: [CLUSTER_CENTERS, SOFT_PARTITION, OBJ_FCN_HISTORY] =
gustafson_kessel (INPUT_DATA, NUM_CLUSTERS, CLUSTER_VOLUME)
 -- Function File: [CLUSTER_CENTERS, SOFT_PARTITION, OBJ_FCN_HISTORY] =
gustafson_kessel (INPUT_DATA, NUM_CLUSTERS, CLUSTER_VOLUME, OPTIONS)
 -- Function File: [CLUSTER_CENTERS, SOFT_PARTITION, OBJ_FCN_HISTORY] =
gustafson_kessel (INPUT_DATA, NUM_CLUSTERS, CLUSTER_VOLUME, [M,
          MAX_ITERATIONS, EPSILON, DISPLAY_INTERMEDIATE_RESULTS])
     Using the Gustafson-Kessel algorithm, calculate and return the
     soft partition of a set of unlabeled data points.

     Also, if DISPLAY_INTERMEDIATE_RESULTS is true, display intermediate
     results after each iteration. Note that because the initial cluster
     prototypes are randomly selected locations in the ranges
     determined by the input data, the results of this function are
     nondeterministic.

     The required arguments to gustafson_kessel are:
          INPUT_DATA - a matrix of input data points; each row
          corresponds to one point

          NUM_CLUSTERS - the number of clusters to form

     The third (optional) argument to gustafson_kessel is a vector of
     cluster volumes.  If omitted, a vector of 1's will be used as the
     default.

     The fourth (optional) argument to gustafson_kessel is a vector
     consisting of:
          M - the parameter (exponent) in the objective function;
          default = 2.0

          MAX_ITERATIONS - the maximum number of iterations before
          stopping; default = 100

          EPSILON - the stopping criteria; default = 1e-5

          DISPLAY_INTERMEDIATE_RESULTS - if 1, display results after
          each iteration, and if 0, do not; default = 1

     The default values are used if any of the four elements of the
     vector are missing or evaluate to NaN.

     The return values are:
          CLUSTER_CENTERS - a matrix of the cluster centers; each row
          corresponds to one point

          SOFT_PARTITION - a constrained soft partition matrix

          OBJ_FCN_HISTORY - the values of the objective function after
          each iteration

     Three important matrices used in the calculation are X (the input
     points to be clustered), V (the cluster centers), and Mu (the
     membership of each data point in each cluster). Each row of X and
     V denotes a single point, and Mu(i, j) denotes the membership
     degree of input point X(j, :) in the cluster having center V(i, :).

     X is identical to the required argument INPUT_DATA; V is identical
     to the output CLUSTER_CENTERS; and Mu is identical to the output
     SOFT_PARTITION.

     If n denotes the number of input points and k denotes the number of
     clusters to be formed, then X, V, and Mu have the dimensions:

                                        1    2   ...  #features
                                   1 [                           ]
             X  =  input_data  =   2 [                           ]
                                 ... [                           ]
                                   n [                           ]

                                             1    2   ...  #features
                                        1 [                           ]
             V  =  cluster_centers  =   2 [                           ]
                                      ... [                           ]
                                        k [                           ]

                                             1    2   ...   n
                                        1 [                    ]
             Mu  =  soft_partition  =   2 [                    ]
                                      ... [                    ]
                                        k [                    ]

     See also: fcm, partition_coeff, partition_entropy, xie_beni_index





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Using the Gustafson-Kessel algorithm, calculate and return the soft
partition of



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
hamacher_product


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 811
 -- Function File: RETVAL = hamacher_product (X)
 -- Function File: RETVAL = hamacher_product (X, Y)
     Return the Hamacher product of the input.  The Hamacher product of
     two real scalars x and y is: (x * y) / (x + y - x * y)

     For one vector argument, apply the Hamacher product to all of the
     elements of the vector. (The Hamacher product is associative.) For
     one two-dimensional matrix argument, return a vector of the
     Hamacher product of each column.

     For two vectors or matrices of identical dimensions, or for one
     scalar and one vector or matrix argument, return the pair-wise
     Hamacher product.

     See also: algebraic_product, algebraic_sum, bounded_difference,
     bounded_sum, drastic_product, drastic_sum, einstein_product,
     einstein_sum, hamacher_sum





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Return the Hamacher product of the input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
hamacher_sum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 791
 -- Function File: RETVAL = hamacher_sum (X)
 -- Function File: RETVAL = hamacher_sum (X, Y)
     Return the Hamacher sum of the input.  The Hamacher sum of two
     real scalars x and y is: (x + y - 2 * x * y) / (1 - x * y)

     For one vector argument, apply the Hamacher sum to all of the
     elements of the vector. (The Hamacher sum is associative.) For one
     two-dimensional matrix argument, return a vector of the Hamacher
     sum of each column.

     For two vectors or matrices of identical dimensions, or for one
     scalar and one vector or matrix argument, return the pair-wise
     Hamacher sum.

     See also: algebraic_product, algebraic_sum, bounded_difference,
     bounded_sum, drastic_product, drastic_sum, einstein_product,
     einstein_sum, hamacher_product





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return the Hamacher sum of the input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
heart_disease_demo_1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 708
 -- Script File:  heart_disease_demo_1
     Demonstrate the use of newfis, addvar, addmf, addrule, and evalfis
     to build and evaluate an FIS. Also demonstrate the use of the
     algebraic product and sum as the T-norm/S-norm pair, and
     demonstrate the use of hedges in the FIS rules.

     The demo:
        - builds an FIS

        - plots the input membership functions

        - plots the constant output functions

        - displays the FIS rules in verbose format in the Octave window

        - plots the FIS output as a function of the inputs

     See also: cubic_approx_demo, heart_disease_demo_2,
     investment_portfolio_demo, linear_tip_demo, mamdani_tip_demo,
     sugeno_tip_demo





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Demonstrate the use of newfis, addvar, addmf, addrule, and evalfis to
build and 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
heart_disease_demo_2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 583
 -- Script File:  heart_disease_demo_2
     Demonstrate the use of the Octave Fuzzy Logic Toolkit to read and
     evaluate a Sugeno-type FIS stored in a file.

     The demo:
        - reads the FIS structure from a file

        - plots the input membership functions

        - plots the (constant) output functions

        - plots the FIS output as a function of the inputs

        - evaluates the Sugeno-type FIS for four inputs

     See also: cubic_approx_demo, heart_disease_demo_1,
     investment_portfolio_demo, linear_tip_demo, mamdani_tip_demo,
     sugeno_tip_demo





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Demonstrate the use of the Octave Fuzzy Logic Toolkit to read and
evaluate a Sug



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
investment_portfolio_demo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 986
 -- Script File:  investment_portfolio_demo
     Demonstrate the use of the Octave Fuzzy Logic Toolkit to read and
     evaluate a Mamdani-type FIS stored in a file. Also demonstrate the
     use of hedges and weights in the FIS rules, the use of the
     Einstein product and sum as the T-norm/S-norm pair, and the
     non-standard use of the Einstein sum as the aggregation method.

     The demo:
        - reads the FIS structure from a file

        - plots the input and output membership functions

        - plots the FIS output as a function of the inputs

        - plots the output of the 4 individual rules for (Age,
          Risk-Tolerance) = (40, 7)

        - plots the aggregated fuzzy output and the crisp output for
          (Age, Risk-Tolerance) = (40, 7)

        - shows the rules in verbose format in the Octave window

     See also: cubic_approx_demo, heart_disease_demo_1,
     heart_disease_demo_2, linear_tip_demo, mamdani_tip_demo,
     sugeno_tip_demo





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Demonstrate the use of the Octave Fuzzy Logic Toolkit to read and
evaluate a Mam



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
linear_tip_demo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 523
 -- Script File:  linear_tip_demo
     Demonstrate the use of linear output membership functions to
     simulate constant membership functions.

     The demo:
        - reads the FIS structure from a file

        - plots the input membership functions

        - plots the FIS output as a function of the inputs

        - evaluates the Sugeno-type FIS for six inputs

     See also: cubic_approx_demo, heart_disease_demo_1,
     heart_disease_demo_2, investment_portfolio_demo, mamdani_tip_demo,
     sugeno_tip_demo





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Demonstrate the use of linear output membership functions to simulate
constant m



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
mamdani_tip_demo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 790
 -- Script File:  mamdani_tip_demo
     Demonstrate the use of the Octave Fuzzy Logic Toolkit to read and
     evaluate a Mamdani-type FIS stored in a file.

     The demo:
        - reads the FIS structure from a file

        - plots the input and output membership functions

        - plots each of the two FIS outputs as a function of the inputs

        - plots the output of the 4 individual rules for (Food-Quality,
          Service) = (4, 6)

        - plots the aggregated fuzzy output and the crisp output for
          (Food-Quality, Service) = (4, 6)

        - displays the FIS rules in symbolic format in the Octave window

     See also: cubic_approx_demo, heart_disease_demo_1,
     heart_disease_demo_2, investment_portfolio_demo, linear_tip_demo,
     sugeno_tip_demo





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Demonstrate the use of the Octave Fuzzy Logic Toolkit to read and
evaluate a Mam



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
newfis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1207
 -- Function File: A = newfis (FIS_NAME)
 -- Function File: A = newfis (FIS_NAME, FIS_TYPE)
 -- Function File: A = newfis (FIS_NAME, FIS_TYPE, AND_METHOD)
 -- Function File: A = newfis (FIS_NAME, FIS_TYPE, AND_METHOD,
          OR_METHOD)
 -- Function File: A = newfis (FIS_NAME, FIS_TYPE, AND_METHOD,
          OR_METHOD, IMP_METHOD)
 -- Function File: A = newfis (FIS_NAME, FIS_TYPE, AND_METHOD,
          OR_METHOD, IMP_METHOD, AGG_METHOD)
 -- Function File: A = newfis (FIS_NAME, FIS_TYPE, AND_METHOD,
          OR_METHOD, IMP_METHOD, AGG_METHOD, DEFUZZ_METHOD)
 -- Function File: A = newfis (FIS_NAME, FIS_TYPE, AND_METHOD,
          OR_METHOD, IMP_METHOD, AGG_METHOD, DEFUZZ_METHOD, FIS_VERSION)
     Create and return a new FIS structure using the argument values
     provided.  Only the first argument is required. If fewer than
     eight arguments are given, then some or all of the following
     default arguments will be used:
        * FIS_TYPE = 'mamdani'

        * AND_METHOD = 'min'

        * OR_METHOD = 'max'

        * IMP_METHOD = 'min'

        * AGG_METHOD = 'max'

        * DEFUZZ_METHOD = 'centroid'

        * FIS_VERSION = 1.0

     See also: addmf, addrule, addvar, setfis





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Create and return a new FIS structure using the argument values
provided.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
partition_coeff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 653
 -- Function File: VPC = partition_coeff (SOFT_PARTITION)
     Return the partition coefficient for a given soft partition.

     The argument to partition_coeff is:
          SOFT_PARTITION - the membership degree of each input data
          point in each cluster

     The return value is:
          VPC - the partition coefficient for the given soft partition

     For demos of this function, please type:
          demo 'fcm'
          demo 'gustafson_kessel'

     For more information about the SOFT_PARTITION matrix, please see
     the documentation for function fcm.

     See also: fcm, gustafson_kessel, partition_entropy, xie_beni_index





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Return the partition coefficient for a given soft partition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
partition_entropy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 745
 -- Function File: VPE = partition_entropy (SOFT_PARTITION, A)
     Return the partition entropy for a given soft partition.

     The arguments to partition_entropy are:
          SOFT_PARTITION - the membership degree of each input data
          point in each cluster

          A - the log base to use in the calculation; must be a real
          number a > 1

     The return value is:
          VPE - the partition entropy for the given soft partition

     For demos of this function, please type:
          demo 'fcm'
          demo 'gustafson_kessel'

     For more information about the SOFT_PARTITION matrix, please see
     the documentation for function fcm.

     See also: fcm, gustafson_kessel, partition_coeff, xie_beni_index





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the partition entropy for a given soft partition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pimf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1120
 -- Function File: Y = pimf (X, PARAMS)
 -- Function File: Y = pimf ([X1 X2 ... XN], [A B C D])
     For a given domain X and parameters PARAMS (or [A B C D]), return
     the corresponding Y values for the pi-shaped membership function.

     The argument X must be a real number or a non-empty vector of real
     numbers, and A, B, C, and D must be real numbers, with A < B <= C
     < D. This membership function satisfies:
                  0                             if x <= a
                  2 * ((x - a)/(b - a))^2       if a < x <= (a + b)/2
                  1 - 2 * ((x - b)/(b - a))^2   if (a + b)/2 < x < b
          f(x) =  1                             if b <= x <= c
                  1 - 2 * ((x - c)/(d - c))^2   if c < x <= (c + d)/2
                  2 * ((x - d)/(d - c))^2       if (c + d)/2 < x < d
                  0                             if x >= d

     which always returns values in the range [0, 1].

     To run the demonstration code, type demo('pimf') at the Octave
     prompt.

     See also: dsigmf, gauss2mf, gaussmf, gbellmf, psigmf, sigmf, smf,
     trapmf, trimf, zmf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain X and parameters PARAMS (or [A B C D]), return the
correspond



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
plotmf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2016
 -- Function File:  plotmf (FIS, IN_OR_OUT, VAR_INDEX)
 -- Function File:  plotmf (FIS, IN_OR_OUT, VAR_INDEX, Y_LOWER_LIMIT)
 -- Function File:  plotmf (FIS, IN_OR_OUT, VAR_INDEX, Y_LOWER_LIMIT,
          Y_UPPER_LIMIT)
     Plot the membership functions defined for the specified FIS input
     or output variable on a single set of axes. Fuzzy output
     membership functions are represented by the [0, 1]-valued fuzzy
     functions, and constant output membership functions are
     represented by unit-valued singleton spikes.  Linear output
     membership functions, however, are represented by two-dimensional
     lines y = ax + c, regardless of how many dimensions the linear
     function is defined to have. In effect, all of the other dimensions
     of the linear function are set to 0.

     If both constant and linear membership functions are used for a
     single FIS output, then two sets of axes are used: one for the
     constant membership functions, and another for the linear
     membership functions. To plot both constant and linear membership
     functions together, or to plot constant membership functions as
     horizontal lines instead of unit-valued spikes, represent the
     constant membership functions using 'linear' functions, with 0 for
     all except the last parameter, and with the desired constant value
     as the last parameter.

     The types of the arguments are expected to be:
        * FIS - an FIS structure

        * IN_OR_OUT - either 'input' or 'output' (case-insensitive)

        * VAR_INDEX - an FIS input or output variable index

        * Y_LOWER_LIMIT - a real scalar (default value = -0.1)

        * Y_UPPER_LIMIT - a real scalar (default value = 1.1)

     Six examples that use plotmf are:
        * cubic_approx_demo.m

        * heart_disease_demo_1.m

        * heart_disease_demo_2.m

        * investment_portfolio_demo.m

        * linear_tip_demo.m

        * mamdani_tip_demo.m

        * sugeno_tip_demo.m

     See also: gensurf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Plot the membership functions defined for the specified FIS input or
output vari



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
psigmf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1229
 -- Function File: Y = psigmf (X, PARAMS)
 -- Function File: Y = psigmf ([X1 X2 ... XN], [A1 C1 A2 C2])
     For a given domain X and parameters PARAMS (or [A1 C1 A2 C2]),
     return the corresponding Y values for the product of two sigmoidal
     membership functions.

     The argument X must be a real number or a non-empty vector of
     strictly increasing real numbers, and A1, C1, A2, and C2 must be
     real numbers. This membership function satisfies the equation:
          f(x) = (1/(1 + exp(-a1*(x - c1)))) * (1/(1 + exp(-a2*(x - c2))))

     The function is bounded above by 1 and below by 0.

     If A1 is positive, A2 is negative, and C1 and C2 are far enough
     apart with C1 < C2, then:
          (a1)/4 ~ the rising slope at c1

          c1 ~ the left inflection point

          (a2)/4 ~ the falling slope at c2

          c2 ~ the right inflection point

     and at each inflection point, the value of the function is about
     0.5:
          f(c1) ~ f(c2) ~ 0.5.

     (Here, the symbol ~ means "approximately equal".)

     To run the demonstration code, type demo('psigmf') at the Octave
     prompt.

     See also: dsigmf, gauss2mf, gaussmf, gbellmf, pimf, sigmf, smf,
     trapmf, trimf, zmf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain X and parameters PARAMS (or [A1 C1 A2 C2]), return
the corres



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
readfis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 870
 -- Function File: FIS = readfis ()
 -- Function File: FIS = readfis (FILENAME)
     Read the information in an FIS file, and using this information,
     create and return an FIS structure. If called without any
     arguments or with an empty string as an argument, present the user
     with a file dialog GUI. If called with a FILENAME that does not
     end with '.fis', append '.fis' to the FILENAME. The FILENAME is
     expected to be a string.

     Three examples of the input file format:
        * heart_disease_risk.fis

        * mamdani_tip_calculator.fis

        * sugeno_tip_calculator.fis

     Six example scripts that use readfis:
        * cubic_approx_demo.m

        * heart_disease_demo_2.m

        * investment_portfolio_demo.m

        * linear_tip_demo.m

        * mamdani_tip_demo.m

        * sugeno_tip_demo.m

     See also: writefis





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Read the information in an FIS file, and using this information, create
and retu



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rmmf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 604
 -- Function File: FIS = rmmf (FIS, IN_OR_OUT, VAR_INDEX, MF, MF_INDEX)
     Remove a membership function from an existing FIS structure and
     return the updated FIS.

     The types of the arguments are expected to be:
        * FIS - an FIS structure

        * IN_OR_OUT - either 'input' or 'output' (case-insensitive)

        * VAR_INDEX - an FIS input or output variable index

        * MF - the string 'mf'

        * MF_INDEX - a string

     Note that rmmf will allow the user to delete membership functions
     that are currently in use by rules in the FIS.

     See also: addmf, rmvar





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Remove a membership function from an existing FIS structure and return
the updat



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rmvar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 541
 -- Function File: FIS = rmvar (FIS, IN_OR_OUT, VAR_INDEX)
     Remove an input or output variable from an existing FIS structure
     and return the updated FIS.

     The types of the arguments are expected to be:
        * FIS - an FIS structure

        * IN_OR_OUT - either 'input' or 'output' (case-insensitive)

        * VAR_INDEX - an FIS input or output variable index

     Note that rmvar will allow the user to delete an input or output
     variable that is currently in use by rules in the FIS.

     See also: addvar, rmmf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Remove an input or output variable from an existing FIS structure and
return the



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
setfis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2047
 -- Function File: FIS = setfis (FIS, PROPERTY, PROPERTY_VALUE)
 -- Function File: FIS = setfis (FIS, IN_OR_OUT, VAR_INDEX,
          VAR_PROPERTY, VAR_PROPERTY_VALUE)
 -- Function File: FIS = setfis (FIS, IN_OR_OUT, VAR_INDEX, MF,
          MF_INDEX, MF_PROPERTY, MF_PROPERTY_VALUE)
     Set a property (field) value of an FIS structure and return the
     updated FIS. There are three forms of setfis:

    # Arguments
          Action Taken

    3
          Set a property of the FIS structure. The properties that may
          be set are: name, type, andmethod, ormethod, impmethod,
          addmethod, defuzzmethod, and version.

    5
          Set a property of an input or output variable of the FIS
          structure. The properties that may be set are: name and range.

    7
          Set a property of a membership function. The properties that
          may be set are: name, type, and params.

     The types of the arguments are expected to be:
    FIS
          an FIS structure

    PROPERTY
          a string; one of 'name', 'type', 'andmethod', 'ormethod',
          'impmethod', 'addmethod', 'defuzzmethod', and 'version'
          (case-insensitive)

    PROPERTY_VALUE
          a number (if property is 'version'); a string (otherwise)

    IN_OR_OUT
          either 'input' or 'output' (case-insensitive)

    VAR_INDEX
          a valid integer index of an input or output FIS variable

    VAR_PROPERTY
          a string; either 'name' or 'range'

    VAR_PROPERTY_VALUE
          a string (if var_property is 'name') or a vector range (if
          var_property is 'range')

    MF
          the string 'mf'

    MF_INDEX
          a valid integer index of a membership function

    MF_PROPERTY
          a string; one of 'name', 'type', or 'params'

    MF_PROPERTY_VALUE
          a string (if mf_property is 'name' or 'type'); an array (if
          mf_property is 'params')

     Note that all of the strings representing properties above are case
     insensitive.

     See also: newfis, getfis, showfis





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Set a property (field) value of an FIS structure and return the updated
FIS.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
showfis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
 -- Function File:  showfis (FIS)
     Print all of the property (field) values of the FIS structure and
     its substructures.

     See also: getfis, showrule





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Print all of the property (field) values of the FIS structure and its
substructu



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
showrule


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1239
 -- Function File:  showrule (FIS)
 -- Function File:  showrule (FIS, INDEX_LIST)
 -- Function File:  showrule (FIS, INDEX_LIST, FORMAT)
 -- Function File:  showrule (FIS, INDEX_LIST, 'VERBOSE', LANGUAGE)
 -- Function File:  showrule (FIS, INDEX_LIST, 'VERBOSE', 'CUSTOM',
          "AND" "OR" "IF" "THEN" "IS" "ISN'T" "SOMEWHAT" "VERY"
          "EXTREMELY" "VERY VERY")
     Show the rules for an FIS structure in verbose, symbolic, or
     indexed format.  Built in languages for the 'verbose' format are:
     English, Chinese (or Mandarin, Pinyin), Russian (or Pycckii,
     Russkij), French (or Francais), Spanish (or Espanol), and German
     (or Deutsch). The names of the languages are case-insensitive,
     Chinese is written in Pinyin, and Russian is transliterated.

     To use a custom language, enter 'verbose' and 'custom' for the
     third and fourth parameters, respectively, and a cell array of ten
     strings (to specify the custom language) corresponding to the
     English {"and" "or" "If" "then" "is" "isn't" "somewhat" "very"
     "extremely" "very very"} for the fifth parameter.

     To run the demonstration code, type demo('showrule') at the Octave
     prompt.

     See also: addrule, getfis, showfis





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Show the rules for an FIS structure in verbose, symbolic, or indexed
format.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
sigmf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 900
 -- Function File: Y = sigmf (X, PARAMS)
 -- Function File: Y = sigmf ([X1 X2 ... XN], [A C])
     For a given domain X and parameters PARAMS (or [A C]), return the
     corresponding Y values for the sigmoidal membership function.

     The argument X must be a real number or a non-empty vector of
     strictly increasing real numbers, and A and C must be real
     numbers. This membership function satisfies the equation:
          f(x) = 1/(1 + exp(-a*(x - c)))

     which always returns values in the range [0, 1].

     The parameters a and c specify:
          a == the slope at c

          c == the inflection point

     and at the inflection point, the value of the function is 0.5:
          f(c) == 0.5.

     To run the demonstration code, type demo('sigmf') at the Octave
     prompt.

     See also: dsigmf, gauss2mf, gaussmf, gbellmf, pimf, psigmf, smf,
     trapmf, trimf, zmf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain X and parameters PARAMS (or [A C]), return the
corresponding 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
smf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 923
 -- Function File: Y = smf (X, PARAMS)
 -- Function File: Y = smf ([X1 X2 ... XN], [A B])
     For a given domain X and parameters PARAMS (or [A B]), return the
     corresponding Y values for the S-shaped membership function.

     The argument X must be a real number or a non-empty vector of
     strictly increasing real numbers, and A and B must be real
     numbers, with A < B. This membership function satisfies:
                  0                                if x <= a
          f(x) =  2 * ((x - a)/(b - a))^2          if a < x <= (a + b)/2
                  1 - 2 * ((x - b)/(b - a))^2      if (a + b)/2 < x < b
                  1                                if x >= b

     which always returns values in the range [0, 1].

     To run the demonstration code, type demo('smf') at the Octave
     prompt.

     See also: dsigmf, gauss2mf, gaussmf, gbellmf, pimf, psigmf, sigmf,
     trapmf, trimf, zmf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain X and parameters PARAMS (or [A B]), return the
corresponding 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
sugeno_tip_demo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 829
 -- Script File:  sugeno_tip_demo
     Demonstrate the use of the Octave Fuzzy Logic Toolkit to read and
     evaluate a Sugeno-type FIS with multiple outputs stored in a text
     file. Also demonstrate the use of hedges in the FIS rules and the
     Einstein product and sum as the T-norm/S-norm pair.

     The demo:
        - reads the FIS structure from a file

        - plots the input membership functions

        - plots the (constant) output functions

        - plots each of the three FIS outputs as a function of the
          inputs

        - displays the FIS rules in verbose format in the Octave window

        - evaluates the Sugeno-type FIS for six inputs

     See also: cubic_approx_demo, heart_disease_demo_1,
     heart_disease_demo_2, investment_portfolio_demo, linear_tip_demo,
     mamdani_tip_demo





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Demonstrate the use of the Octave Fuzzy Logic Toolkit to read and
evaluate a Sug



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
trapmf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1096
 -- Function File: Y = trapmf (X, PARAMS)
 -- Function File: Y = trapmf ([X1 X2 ... XN], [A B C D])
     For a given domain X and parameters PARAMS (or [A B C D]), return
     the corresponding Y values for the trapezoidal membership
     function. The argument X must be a real number or a non-empty
     vector of strictly increasing real numbers, and parameters A, B, C,
     and D must satisfy the inequalities: A < B <= C < D. None of the
     parameters A, B, C, D are required to be in the domain X. The
     minimum and maximum values of the trapezoid are assumed to be 0
     and 1.

     The parameters [A B C D] correspond to the x values of the corners
     of the trapezoid:

                 1-|      --------
                   |     /        \
                   |    /          \
                   |   /            \
                 0-----------------------
                      a   b      c   d

     To run the demonstration code, type demo('trapmf') at the Octave
     prompt.

     See also: dsigmf, gauss2mf, gaussmf, gbellmf, pimf, psigmf, sigmf,
     smf, trimf, zmf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain X and parameters PARAMS (or [A B C D]), return the
correspond



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
trimf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1032
 -- Function File: Y = trimf (X, PARAMS)
 -- Function File: Y = trimf ([X1 X2 ... XN], [A B C])
     For a given domain X and parameters PARAMS (or [A B C]), return
     the corresponding Y values for the triangular membership function.

     The argument X must be a real number or a non-empty vector of
     strictly increasing real numbers, and parameters A, B, and C must
     be real numbers that satisfy A < B < C. None of the parameters A,
     B, and C are required to be in the domain X. The minimum and
     maximum values of the triangle are assumed to be 0 and 1.

     The parameters [A B C] correspond to the x values of the vertices
     of the triangle:

          1-|         /\
            |        /  \
            |       /    \
            |      /      \
          0-----------------------
                  a   b   c

     To run the demonstration code, type demo('trimf') at the Octave
     prompt.

     See also: dsigmf, gauss2mf, gaussmf, gbellmf, pimf, psigmf, sigmf,
     smf, trapmf, trimf_demo, zmf





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain X and parameters PARAMS (or [A B C]), return the
correspondin



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
writefis


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1404
 -- Function File:  writefis (FIS)
 -- Function File:  writefis (FIS, FILENAME)
 -- Function File:  writefis (FIS, FILENAME, DIALOG)
     Save the specified FIS currently in the Octave workspace to a file
     named by the user. There are three forms of writefis:

    # Arguments
          Action Taken

    1
          Open a dialog GUI to help the user choose a directory and name
          for the output file.

    2
          Do not open a dialog GUI. Save the FIS to a file in the
          current directory with the specified FILENAME. If the
          specified FILENAME does not end in '.fis', append '.fis' to
          the FILENAME.

    3
          Open a dialog GUI with the specified FILENAME in the
          'filename' textbox of the GUI. If the specified FILENAME does
          not end in '.fis', append '.fis' to the FILENAME.

     The types of the arguments are expected to be:
    FIS
          an FIS structure satisfying is_fis (see private/is_fis.m)

    FILENAME
          a string; if the string does not already end with the
          extension ".fis", then ".fis" is added

    DIALOG
          the string 'dialog' (case insensitive)

     Note: The GUI dialog requires zenity to be installed on the system.

     Known error: When using the file dialog, if the user clicks
     "Cancel" instead of saving the file, an error message is generated.

     See also: readfis





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Save the specified FIS currently in the Octave workspace to a file
named by the 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
xie_beni_index


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 933
 -- Function File: VXB = xie_beni_index (INPUT_DATA, CLUSTER_CENTERS,
          SOFT_PARTITION)
     Return the Xie-Beni validity index for a given soft partition.

     The arguments to xie_beni_index are:
          INPUT_DATA - a matrix of input data points; each row
          corresponds to one point

          CLUSTER_CENTERS - a matrix of cluster centers; each row
          corresponds to one point

          SOFT_PARTITION - the membership degree of each input data
          point in each cluster

     The return value is:
          VXB - the Xie-Beni validity index for the given partition

     For demos of this function, please type:
          demo 'fcm'
          demo 'gustafson_kessel'

     For more information about the INPUT_DATA, CLUSTER_CENTERS, and
     SOFT_PARTITION matrices, please see the documentation for function
     fcm.

     See also: fcm, gustafson_kessel, partition_coeff, partition_entropy





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return the Xie-Beni validity index for a given soft partition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
zmf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1178
 -- Function File: Y = zmf (X, PARAMS)
 -- Function File: Y = zmf ([X1 X2 ... XN], [A B])
     For a given domain X and parameters PARAMS (or [A B]), return the
     corresponding Y values for the Z-shaped membership function.

     The argument X must be a real number or a non-empty vector of
     strictly increasing real numbers, and A and B must be real
     numbers, with A < B. This membership function satisfies:
                  1                                if x <= a
          f(x) =  1 - 2 * ((x - a)/(b - a))^2      if a < x <= (a + b)/2
                  2 * ((x - b)/(b - a))^2          if (a + b)/2 < x < b
                  0                                if x >= b

     which always returns values in the range [0, 1].

     The parameters a and b specify:
          a == the rightmost point at which f(x) = 1

          b == the leftmost point at which f(x) = 0

     At the midpoint of the segment [a, b], the function value is 0.5:
          f((a + b)/2) = 0.5

     To run the demonstration code, type demo('zmf') at the Octave
     prompt.

     See also: dsigmf, gauss2mf, gaussmf, gbellmf, pimf, psigmf, sigmf,
     smf, trapmf, trimf, zmf_demo





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a given domain X and parameters PARAMS (or [A B]), return the
corresponding 





