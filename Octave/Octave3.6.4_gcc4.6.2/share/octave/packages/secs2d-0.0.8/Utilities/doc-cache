# Created by Octave 3.6.4, Sat Mar 30 12:21:28 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 42
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
UDXappend2Ddata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 521

   UDXappend2Ddata(filename,p,t,u,attr_name,attr_rank,attr_shape)

   Apends data to a file in DX form.
   Only one variable can be written to the file
   variable must be a scalar, vector or tensor of doubles   
   mesh data in the file must be consistent with this variable

   x
   attr_name  = name of the variable                   (type string)
   attr_rank  = rank of variable data                  (0 for scalar, 1 for vector, etc.)
   attr_shape = number of components of variable data  (assumed 1 for scalar)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67

   UDXappend2Ddata(filename,p,t,u,attr_name,attr_rank,attr_shape)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
UDXoutput2Ddata


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 457

   UDXoutput2Ddata(filename,p,t,u,attr_name,attr_rank,attr_shape,endfile)

   Outputs data in DX form.
   Only one variable can be written to the file
   variable must be a scalar, vector or tensor of doubles   

   x
   attr_name  = name of the variable                   (type string)
   attr_rank  = rank of variable data                  (0 for scalar, 1 for vector, etc.)
   attr_shape = number of components of variable data  (assumed 1 for scalar)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75

   UDXoutput2Ddata(filename,p,t,u,attr_name,attr_rank,attr_shape,endfile)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
UDXoutput2Dtimeseries


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 455

   UDXoutput2Dtimeseries(filename,p,t,u,attr_name,attr_rank,attr_shape,time)

   Outputs data in DX form.
   Only one variable can be written to the file
   variable must be a scalar, vector or tensor of doubles   

   attr_name  = name of the variable                   (type string)
   attr_rank  = rank of variable data                  (0 for scalar, 1 for vector, etc.)
   attr_shape = number of components of variable data  (assumed 1 for scalar)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78

   UDXoutput2Dtimeseries(filename,p,t,u,attr_name,attr_rank,attr_shape,time)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
URREcyclingpattern


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 181
 prcomputes cycling pattern for RRE extrapolation:

 -1         = Do Nothing
 0          = extrapolate
 1..RRErank = store

 RREpattern = URREcyclingpattern(RREnnit,RRErank,toll);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
 prcomputes cycling pattern for RRE extrapolation:




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
Ubern


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 156

 [bp,bn]=Ubern(x)

 calcola la funzione di Bernoulli
 B(x)=x/(exp(x)-1) in corrispondenza dei
 due argomenti Z e -Z, ricordando che risulta
 B(-Z)=Z+B(Z)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19

 [bp,bn]=Ubern(x)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
Ucolumns


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 129

	function r=columns(m)

       Note: octave already has this function, 
             this is here only for matlab compatibility



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24

	function r=columns(m)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
Ucompconst


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
 C = Ucompconst (imesh,coeffn,coeffe)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
 C = Ucompconst (imesh,coeffn,coeffe)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
Ucomplap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
 L = Ufastcomplap (mesh,coeff)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
 L = Ufastcomplap (mesh,coeff)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
Ucompmass2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
  Bmat	= Ucompmass2 (imesh,Bvect,Cvect);



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
  Bmat	= Ucompmass2 (imesh,Bvect,Cvect);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
Udescaling


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
  [odata,omesh] = Udescaling(imesh,idata);



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
  [odata,omesh] = Udescaling(imesh,idata);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
Udopdepmob


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
 Udopdepmob (mu,par,D);



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
 Udopdepmob (mu,par,D);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
Udrawedge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
 Udrawedge(mesh); 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
 Udrawedge(mesh); 




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
Udriftdepmob


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
 mob = Ufielddepmob(imesh,u0,F,vsat,b) 
 Computes field dependent mobility



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
 mob = Ufielddepmob(imesh,u0,F,vsat,b) 
 Computes field dependent mobility




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
Udriftdiffusion


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 134

  c=Udriftdiffusion(mesh,Dsides,guess,M,U,V,u)
 solves the drift diffusion equation
 $ -div ( u ( \nabla n - n \nabla V)) + M = U $




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

  c=Udriftdiffusion(mesh,Dsides,guess,M,U,V,u)
 solves the drift diffusion equa



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
Udriftdiffusion2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 144

  c=Udriftdiffusion(mesh,Dsides,guess,M,U,V,Vth,u)
 solves the drift diffusion equation
 $ -div ( u ( \nabla (n Vth) - n \nabla V)) + M = U $




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80

  c=Udriftdiffusion(mesh,Dsides,guess,M,U,V,Vth,u)
 solves the drift diffusion 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
Ufielddepmob


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
 mob = Ufielddepmob(imesh,u0,F,vsat,b) 
 Computes field dependent mobility



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
 mob = Ufielddepmob(imesh,u0,F,vsat,b) 
 Computes field dependent mobility




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
Ufvsgcurrent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
 [jx,jy]=Udrawcurrent(omesh,n,psi,psith,coeffe);



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
 [jx,jy]=Udrawcurrent(omesh,n,psi,psith,coeffe);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
Ufvsgcurrent2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
 [jx,jy]=Udrawcurrent2(omesh,n,psi,psith,coeffe);



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
 [jx,jy]=Udrawcurrent2(omesh,n,psi,psith,coeffe);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
Ufvsgcurrent3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 786
 -- Function File: [JX,JY] = Ufvsgcurrent3 (MESH, U, ALPHA, GAMMA, ETA,
          BETA);
     Builds the Scharfetter-Gummel approximation of the vector field

     J(U) = ALPHA* GAMMA * (ETA * grad U - BETA * U))

     where:
        - ALPHA is an element-wise constant scalar function

        - ETA, U, GAMMA are piecewise linear conforming scalar functions

        - BETA  is an element-wise constant vector function

     J(U) is an element-wise constant vector function

     Instead of passing the vector field BETA directly one can pass a
     piecewise linear conforming scalar function PHI as the last input.
     In such case BETA = grad PHI is assumed.  If PHI is a single
     scalar value BETA is assumed to be 0 in the whole domain.

     See also: Uscharfettergummel3





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Builds the Scharfetter-Gummel approximation of the vector field




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
Uinvfermidirac


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
  [fd]=Uinvfermidirac(eta,par);



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
  [fd]=Uinvfermidirac(eta,par);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
Uise2pde


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 595
 [mesh,data]=ise2pde3(grid_file,pref,data_file,load_data,out_file)
 ise2pde3
 estrae dati dal formato DF-ISE di ISE a pdetool di Matlab
 grid_file contiene il nome del file di griglia da estrarre
 pref un prefisso che verra' dato ai files temporanei creati da grep
 data_file e' un cell array delle file da estrarre
 load_data e' un cell array che contiene i nomi delle grandezze da estrarre 
 out_file e' il nome del file matlab opzionale per salvare i dati estratti

 17-3-2004 ver 3.1 
 Marco Bellini marco_bellini_1@yahoo.it
 14.02.2007 ver 3.2
 Octave porting and bug fixes Carlo de Falco 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 [mesh,data]=ise2pde3(grid_file,pref,data_file,load_data,out_file)
 ise2pde3
 es



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
Ujoinmeshes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
  mesh=Ujoinmeshes(mesh1,mesh2,side1,side2)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
  mesh=Ujoinmeshes(mesh1,mesh2,side1,side2)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
Umeshproperties


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71

 mesh=Umeshproperties(mesh)
 precomputes some useful mesh properties




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70

 mesh=Umeshproperties(mesh)
 precomputes some useful mesh properties




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
Umsh2pdetool


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30


  loadgmshmesh(filename);





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
Umshcreatemesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49


 omesh=Umshcreatemesh(geometry,scalefactor);





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
Unodesonside


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
 Dnodes=Unodesonside(mesh,Dsides);



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
 Dnodes=Unodesonside(mesh,Dsides);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
Updegrad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 157
 [Fx,Fy]=Updegrad(mesh,F);

 computes piecewise constant
 gradient of a piecewise linear
 scalar function F defined on
 the mesh structure described by mesh



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
 [Fx,Fy]=Updegrad(mesh,F);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
Updemesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
 Udrawedge(mesh); 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
 Udrawedge(mesh); 




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
Updesurf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
 Updemesh(varargin); 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
 Updemesh(varargin); 




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
Urows


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22

	function r=rows(m)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21

	function r=rows(m)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
Urrextrapolation


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
  s = Urrextrapolation(X)
  RRE vector extrapolation see 
  Smith, Ford & Sidi SIREV 29 II 06/1987



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
  s = Urrextrapolation(X)
  RRE vector extrapolation see 
  Smith, Ford & Sidi S



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
Uscaling


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
 [odata,omesh] = Uscaling(imesh,idata);



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
 [odata,omesh] = Uscaling(imesh,idata);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Uscharfettergummel2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 368

 SG=Ufastscharfettergummel2(mesh,v,acoeff,bcoeff)
 

 Builds the Scharfetter-Gummel  matrix for the 
 the discretization of the LHS 
 of the Drift-Diffusion equation:

 $ -\div (a(x) (\grad (b(x) u) -  b(x) u \grad v'(x) ))= f $

 where a(x) is piecewise constant
 and v(x),b(x) is piecewise linear, so that 
 v'(x) is still piecewise constant
 and u is the unknown




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53

 SG=Ufastscharfettergummel2(mesh,v,acoeff,bcoeff)
 




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Uscharfettergummel3


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1554
 -- Function File: S = Uscharfettergummel3 (MESH, ALPHA, GAMMA, ETA,
          BETA)
     Builds the Scharfetter-Gummel matrix for the discretization of the
     LHS of the equation:

     -div (ALPHA * GAMMA (ETA grad u - BETA u )) = f

     where:
        - ALPHA is an element-wise constant scalar function

        - ETA, GAMMA are piecewise linear conforming scalar functions

        - BETA  is an element-wise constant vector function

     Instead of passing the vector field BETA directly one can pass a
     piecewise linear conforming scalar function PHI as the last input.
     In such case BETA = grad PHI is assumed.  If PHI is a single
     scalar value BETA is assumed to be 0 in the whole domain.

     Example:
          [mesh.p,mesh.e,mesh.t] = Ustructmesh([0:1/3:1],[0:1/3:1],1,1:4);
          mesh = Umeshproperties(mesh);
          x = mesh.p(1,:)';
          Dnodes = Unodesonside(mesh,[2,4]);
          Nnodes = columns(mesh.p); Nelements = columns(mesh.t);
          Varnodes = setdiff(1:Nnodes,Dnodes);
          alpha  = ones(Nelements,1); eta = .1*ones(Nnodes,1);
          beta   = [ones(1,Nelements);zeros(1,Nelements)];
          gamma  = ones(Nnodes,1);
          f      = Ucompconst(mesh,ones(Nnodes,1),ones(Nelements,1));
          S = Uscharfettergummel3(mesh,alpha,gamma,eta,beta);
          u = zeros(Nnodes,1);
          u(Varnodes) = S(Varnodes,Varnodes)\f(Varnodes);
          uex = x - (exp(10*x)-1)/(exp(10)-1);
          assert(u,uex,1e-7)

     See also: Ucomplap, Ucompconst, Ucompmass2, Uscharfettergummel





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Builds the Scharfetter-Gummel matrix for the discretization of the LHS
of the eq



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
Usmoothguess


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
 guess = Usmoothguess(mesh,new,old,Dsides);



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
 guess = Usmoothguess(mesh,new,old,Dsides);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
Ustructmesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
 [p,e,t]=Ustructmesh(x,y,region,sides,varargin)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
 [p,e,t]=Ustructmesh(x,y,region,sides,varargin)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
Ustructmesh_left


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
 [p,e,t]=Ustructmesh(x,y,region,sides)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
 [p,e,t]=Ustructmesh(x,y,region,sides)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
Ustructmesh_random


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
 [p,e,t]=Ustructmesh(x,y,region,sides)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
 [p,e,t]=Ustructmesh(x,y,region,sides)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
Ustructmesh_right


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
 [p,e,t]=Ustructmesh(x,y,region,sides)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
 [p,e,t]=Ustructmesh(x,y,region,sides)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
Usubdomains2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
  [e,t]=Usubdomains(p,t,rcts,sidelist);



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
  [e,t]=Usubdomains(p,t,rcts,sidelist);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
Usubmesh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 201

  [omesh,onodes,oelements]=Usubmesh(imesh,intrfc,sdl,short)

 builds the mesh structure for
 the given list
 of subdomains sdl

 NOTE: the intrfc parameter is unused and only kept 
       as a legacy



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61

  [omesh,onodes,oelements]=Usubmesh(imesh,intrfc,sdl,short)




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
constants


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 844
 This file is part of 

            SECS2D - A 2-D Drift--Diffusion Semiconductor Device Simulator
         -------------------------------------------------------------------
            Copyright (C) 2004-2006  Carlo de Falco



  SECS2D is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  SECS2D is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with SECS2D; If not, see <http://www.gnu.org/licenses/>.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
 This file is part of 






