# Created by Octave 3.6.4, Fri Mar 29 16:55:09 2013 Jerusalem Daylight Time <unknown@NITH02>
# name: cache
# type: cell
# rows: 3
# columns: 9
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
adresamp2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 342
 -- Function File: [XS, YS] = adresamp2 (X, Y, N, EPS)
     Perform an adaptive resampling of a planar curve.  The arrays X
     and Y specify x and y coordinates of the points of the curve.  On
     return, the same curve is approximated by XS, YS that have length N
     and the angles between successive segments are approximately equal.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Perform an adaptive resampling of a planar curve.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
majle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3339
MAJLE	(Weak) Majorization check
    S = MAJLE(X,Y) checks if the real part of X is (weakly) majorized by
    the real part of Y, where X and Y must be numeric (full or sparse)
    arrays. It returns S=0, if there is no weak majorization of X by Y,
    S=1, if there is a weak majorization of X by Y, or S=2, if there is a
    strong majorization of X by Y. The shapes of X and Y are ignored.
    NUMEL(X) and NUMEL(Y) may be different, in which case one of them is
    appended with zeros to match the sizes with the other and, in case of
    any negative components, a special warning is issued.  

    S = MAJLE(X,Y,MAJLETOL) allows in addition to specify the tolerance in
    all inequalities [S,Z] = MAJLE(X,Y,MAJLETOL) also outputs a row vector
    Z, which appears in the definition of the (weak) majorization. In the
    traditional case, where the real vectors X and Y are of the same size,
    Z = CUMSUM(SORT(Y,'descend')-SORT(X,'descend')). Here, X is weakly
    majorized by Y, if MIN(Z)>0, and strongly majorized if MIN(Z)=0, see
    http://en.wikipedia.org/wiki/Majorization

    The value of MAJLETOL depends on how X and Y have been computed, i.e.,
    on what the level of error in X or Y is. A good minimal starting point
    should be MAJLETOL=eps*MAX(NUMEL(X),NUMEL(Y)). The default is 0. 

    % Examples:
    x = [2 2 2]; y = [1 2 3]; s = majle(x,y)
    % returns the value 2.
    x = [2 2 2]; y = [1 2 4]; s = majle(x,y)
    % returns the value 1.
    x = [2 2 2]; y = [1 2 2]; s = majle(x,y)
    % returns the value 0.
    x = [2 2 2]; y = [1 2 2]; [s,z] = majle(x,y)
    % also returns the vector z = [ 0 0 -1].
    x = [2 2 2]; y = [1 2 2]; s = majle(x,y,1)
    % returns the value 2.
    x = [2 2]; y = [1 2 2]; s = majle(x,y)
    % returns the value 1 and warns on tailing with zeros
    x = [2 2]; y = [-1 2 2]; s = majle(x,y)
    % returns the value 0 and gives two warnings on tailing with zeros
    x = [2 -inf]; y = [4 inf]; [s,z] = majle(x,y)
    % returns s = 1 and z = [Inf   Inf].
    x = [2 inf]; y = [4 inf]; [s,z] = majle(x,y)
    % returns  s = 1 and z = [NaN NaN] and a warning on NaNs in z.
    x=speye(2); y=sparse([0 2; -1 1]); s = majle(x,y) 
    % returns the value 2.
    x = [2 2; 2 2]; y = [1 3 4]; [s,z] = majle(x,y) %and 
    x = [2 2; 2 2]+i; y = [1 3 4]-2*i; [s,z] = majle(x,y)
    % both return s = 2 and z = [2 3 2 0]. 
    x = [1 1 1 1 0]; y = [1 1 1 1 1 0 0]'; s = majle(x,y)
    % returns the value 1 and warns on tailing with zeros

    % One can use this function to check numerically the validity of the
    Schur-Horn,Lidskii-Mirsky-Wielandt, and Gelfand-Naimark theorems: 
    clear all; n=100; majleTol=n*n*eps;
    A = randn(n,n); A = A'+A; eA = -sort(-eig(A)); dA = diag(A);
    majle(dA,eA,majleTol) % returns the value 2
    % which is the Schur-Horn theorem; and 
    B=randn(n,n); B=B'+B; eB=-sort(-eig(B)); 
    eAmB=-sort(-eig(A-B));
    majle(eA-eB,eAmB,majleTol) % returns the value 2 
    % which is the Lidskii-Mirsky-Wielandt theorem; finally
    A = randn(n,n); sA = -sort(-svd(A)); 
    B = randn(n,n); sB = -sort(-svd(B));
    sAB = -sort(-svd(A*B));
    majle(log2(sAB)-log2(sA), log2(sB), majleTol) % retuns the value 2
    majle(log2(sAB)-log2(sB), log2(sA), majleTol) % retuns the value 2
    % which are the log versions of the Gelfand-Naimark theorems



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
MAJLE	(Weak) Majorization check
    S = MAJLE(X,Y) checks if the real part of X 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
pararrayfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1005
 -- Function File: [O1, O2, ...] = pararrayfun (NPROC, FUN, A1, A2, ...)
 -- Function File:  pararrayfun (nproc, fun, ..., "UniformOutput", VAL)
 -- Function File:  pararrayfun (nproc, fun, ..., "ErrorHandler",
          ERRFUNC)
     Evaluates a function for corresponding elements of an array.
     Argument and options handling is analogical to `parcellfun',
     except that arguments are arrays rather than cells. If cells occur
     as arguments, they are treated as arrays of singleton cells.
     Arrayfun supports one extra option compared to parcellfun:
     "Vectorized".  This option must be given together with
     "ChunksPerProc" and it indicates that FUN is able to operate on
     vectors rather than just scalars, and returns a vector. The same
     must be true for ERRFUNC, if given.  In this case, the array is
     split into chunks which are then directly served to FUNC for
     evaluation, and the results are concatenated to output arrays.

     See also: parcellfun, arrayfun





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Evaluates a function for corresponding elements of an array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
parcellfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2496
 -- Function File: [O1, O2, ...] = parcellfun (NPROC, FUN, A1, A2, ...)
 -- Function File:  parcellfun (nproc, fun, ..., "UniformOutput", VAL)
 -- Function File:  parcellfun (nproc, fun, ..., "ErrorHandler",
          ERRFUNC)
 -- Function File:  parcellfun (nproc, fun, ..., "VerboseLevel", VAL)
 -- Function File:  parcellfun (nproc, fun, ..., "ChunksPerProc", VAL)
     Evaluates a function for multiple argument sets using multiple
     processes.  NPROC should specify the number of processes. A
     maximum recommended value is equal to number of CPUs on your
     machine or one less.  FUN is a function handle pointing to the
     requested evaluating function.  A1, A2 etc. should be cell arrays
     of equal size.  O1, O2 etc. will be set to corresponding output
     arguments.

     The UniformOutput and ErrorHandler options are supported with
     meaning identical to "cellfun".  A VerboseLevel option controlling
     the level output is supported.  A value of 0 is quiet, 1 is
     normal, and 2 or more enables debugging output.  The ChunksPerProc
     option control the number of chunks which contains elementary
     jobs. This option particularly useful when time execution of
     function is small. Setting this option to 100 is a good choice in
     most cases.

     Notice that jobs are served from a single first-come first-served
     queue, so the number of jobs executed by each process is generally
     unpredictable.  This means, for example, that when using this
     function to perform Monte-Carlo simulations one cannot expect
     results to be exactly reproducible.  The pseudo random number
     generators of each process are initialised with a unique state.
     This currently works only for new style generators.

     NOTE: this function is implemented using "fork" and a number of
     pipes for IPC.  Suitable for systems with an efficient "fork"
     implementation (such as GNU/Linux), on other systems (Windows) it
     should be used with caution.  Also, if you use a multithreaded
     BLAS, it may be wise to turn off multi-threading when using this
     function.

     CAUTION: This function should be regarded as experimental.
     Although all subprocesses should be cleared in theory, there is
     always a danger of a subprocess hanging up, especially if
     unhandled errors occur. Under GNU and compatible systems, the
     following shell command may be used to display orphaned Octave
     processes: ps -ppid 1 | grep octave





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Evaluates a function for multiple argument sets using multiple
processes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
safeprod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 395
 -- Function File: P = safeprod (X, DIM)
 -- Function File: [P, E] = safeprod (X, DIM)
     This function forms product(s) of elements of the array X along
     the dimension specified by DIM, analogically to `prod', but avoids
     overflows and underflows if possible. If called with 2 output
     arguments, P and E are computed so that the product is `P * 2^E'.

     See also: prod, log2





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function forms product(s) of elements of the array X along the
dimension sp



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tablify


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1165
 -- Function File: [Y1, ...] = tablify (X1, ...)
     Create a table out of the input arguments, if possible.  The table
     is created by extending row and column vectors to like dimensions.
     If the dimensions of input vectors are not commensurate an error
     will occur. Dimensions are commensurate if they have the same
     number of rows and columns, a single row and the same number of
     columns, or the same number of rows and a single column.  In other
     words, vectors will only be extended along singleton dimensions.

     For example:

          [a, b] = tablify ([1 2; 3 4], 5)
          => a = [ 1, 2; 3, 4 ]
          => b = [ 5, 5; 5, 5 ]

          [a, b, c] = tablify (1, [1 2 3 4], [5;6;7])
          =>
          b = [ 1 1 1 1; 1 1 1 1; 1 1 1 1]
          => b = [ 1 2 3 4; 1 2 3 4; 1 2 3 4]
          => c = [ 5 5 5 5; 6 6 6 6; 7 7 7 7 ]

     The following example attempts to expand vectors that do not have
     commensurate dimensions and will produce an error.

          tablify([1 2],[3 4 5])

     Note that use of array operations and broadcasting is more
     efficient for many situations.

     See also: common_size





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Create a table out of the input arguments, if possible.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
unresamp2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 341
 -- Function File: [XS, YS] = unresamp2 (X, Y, N)
     Perform a uniform resampling of a planar curve.  The arrays X and
     Y specify x and y coordinates of the points of the curve.  On
     return, the same curve is approximated by XS, YS that have length N
     and the distances between successive points are approximately
     equal.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Perform a uniform resampling of a planar curve.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
unvech


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 477
 -- Function File: M = unvech (V, SCALE)
     Performs the reverse of `vech' on the vector V.

     Given a Nx1 array V describing the lower triangular part of a
     matrix (as obtained from `vech'), it returns the full matrix.

     The upper triangular part of the matrix will be multiplied by
     SCALE such that 1 and -1 can be used for symmetric and
     antisymmetric matrix respectively.  SCALE must be a scalar and
     defaults to 1.

     See also: vech, ind2sub





# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Performs the reverse of `vech' on the vector V.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ztvals


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 291
 -- Function File:  function ztvals (X, TOL)
     Replaces tiny elements of the vector X by zeros.  Equivalent to
            X(abs(X) < TOL * norm (X, Inf)) = 0
     TOL specifies the chopping tolerance. It defaults to 1e-10 for
     double precision and 1e-5 for single precision inputs.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Replaces tiny elements of the vector X by zeros.





