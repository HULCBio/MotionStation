<html lang="en">
<head>
<title>Three-Dimensional Plots - GNU Octave</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Octave">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="High_002dLevel-Plotting.html#High_002dLevel-Plotting" title="High-Level Plotting">
<link rel="prev" href="Two_002dDimensional-Plots.html#Two_002dDimensional-Plots" title="Two-Dimensional Plots">
<link rel="next" href="Plot-Annotations.html#Plot-Annotations" title="Plot Annotations">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Three-Dimensional-Plots"></a>
<a name="Three_002dDimensional-Plots"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Plot-Annotations.html#Plot-Annotations">Plot Annotations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Two_002dDimensional-Plots.html#Two_002dDimensional-Plots">Two-Dimensional Plots</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="High_002dLevel-Plotting.html#High_002dLevel-Plotting">High-Level Plotting</a>
<hr>
</div>

<h4 class="subsection">15.2.2 Three-Dimensional Plots</h4>

<p>The function <code>mesh</code> produces mesh surface plots.  For example,

<pre class="example">     tx = ty = linspace (-8, 8, 41)';
     [xx, yy] = meshgrid (tx, ty);
     r = sqrt (xx .^ 2 + yy .^ 2) + eps;
     tz = sin (r) ./ r;
     mesh (tx, ty, tz);
</pre>
   <p class="noindent">produces the familiar &ldquo;sombrero&rdquo; plot shown in <a href="fig_003amesh.html#fig_003amesh">fig:mesh</a>.  Note
the use of the function <code>meshgrid</code> to create matrices of X and Y
coordinates to use for plotting the Z data.  The <code>ndgrid</code> function
is similar to <code>meshgrid</code>, but works for N-dimensional matrices.

   <div class="float">
<a name="fig_003amesh"></a><div align="center"><img src="mesh.png" alt="mesh.png"></div>
   <p><strong class="float-caption">Figure 15.5: Mesh plot.</strong></p></div>

   <p>The <code>meshc</code> function is similar to <code>mesh</code>, but also produces a
plot of contours for the surface.

   <p>The <code>plot3</code> function displays arbitrary three-dimensional data,
without requiring it to form a surface.  For example,

<pre class="example">     t = 0:0.1:10*pi;
     r = linspace (0, 1, numel (t));
     z = linspace (0, 1, numel (t));
     plot3 (r.*sin(t), r.*cos(t), z);
</pre>
   <p class="noindent">displays the spiral in three dimensions shown in <a href="fig_003aplot3.html#fig_003aplot3">fig:plot3</a>.

   <div class="float">
<a name="fig_003aplot3"></a><div align="center"><img src="plot3.png" alt="plot3.png"></div>
   <p><strong class="float-caption">Figure 15.6: Three-dimensional spiral.</strong></p></div>

   <p>Finally, the <code>view</code> function changes the viewpoint for
three-dimensional plots.

<!-- mesh scripts/plot/mesh.m -->
   <p><a name="doc_002dmesh"></a>

<div class="defun">
&mdash; Function File:  <b>mesh</b> (<var>x, y, z</var>)<var><a name="index-mesh-1237"></a></var><br>
&mdash; Function File:  <b>mesh</b> (<var>z</var>)<var><a name="index-mesh-1238"></a></var><br>
&mdash; Function File:  <b>mesh</b> (<var><small class="dots">...</small>, c</var>)<var><a name="index-mesh-1239"></a></var><br>
&mdash; Function File:  <b>mesh</b> (<var>hax, <small class="dots">...</small></var>)<var><a name="index-mesh-1240"></a></var><br>
&mdash; Function File: <var>h</var> = <b>mesh</b> (<var><small class="dots">...</small></var>)<var><a name="index-mesh-1241"></a></var><br>
<blockquote><p>Plot a mesh given matrices <var>x</var>, and <var>y</var> from <code>meshgrid</code> and
a matrix <var>z</var> corresponding to the <var>x</var> and <var>y</var> coordinates of
the mesh.  If <var>x</var> and <var>y</var> are vectors, then a typical vertex
is (<var>x</var>(j), <var>y</var>(i), <var>z</var>(i,j)).  Thus, columns of <var>z</var>
correspond to different <var>x</var> values and rows of <var>z</var> correspond
to different <var>y</var> values.

        <p>The color of the mesh is derived from the <code>colormap</code>
and the value of <var>z</var>.  Optionally the color of the mesh can be
specified independent of <var>z</var>, by adding a fourth matrix, <var>c</var>.

        <p>The optional return value <var>h</var> is a graphics handle to the created
surface object. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dcolormap.html#doc_002dcolormap">colormap</a>, <a href="doc_002dcontour.html#doc_002dcontour">contour</a>, <a href="doc_002dmeshgrid.html#doc_002dmeshgrid">meshgrid</a>, <a href="doc_002dsurf.html#doc_002dsurf">surf</a>. 
</p></blockquote></div>

<!-- meshc scripts/plot/meshc.m -->
   <p><a name="doc_002dmeshc"></a>

<div class="defun">
&mdash; Function File:  <b>meshc</b> (<var>x, y, z</var>)<var><a name="index-meshc-1242"></a></var><br>
<blockquote><p>Plot a mesh and contour given matrices <var>x</var>, and <var>y</var> from
<code>meshgrid</code> and a matrix <var>z</var> corresponding to the <var>x</var> and
<var>y</var> coordinates of the mesh.  If <var>x</var> and <var>y</var> are vectors,
then a typical vertex is (<var>x</var>(j), <var>y</var>(i), <var>z</var>(i,j)).  Thus,
columns of <var>z</var> correspond to different <var>x</var> values and rows of
<var>z</var> correspond to different <var>y</var> values. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dmeshgrid.html#doc_002dmeshgrid">meshgrid</a>, <a href="doc_002dmesh.html#doc_002dmesh">mesh</a>, <a href="doc_002dcontour.html#doc_002dcontour">contour</a>. 
</p></blockquote></div>

<!-- meshz scripts/plot/meshz.m -->
   <p><a name="doc_002dmeshz"></a>

<div class="defun">
&mdash; Function File:  <b>meshz</b> (<var>x, y, z</var>)<var><a name="index-meshz-1243"></a></var><br>
<blockquote><p>Plot a curtain mesh given matrices <var>x</var>, and <var>y</var> from
<code>meshgrid</code> and a matrix <var>z</var> corresponding to the <var>x</var> and
<var>y</var> coordinates of the mesh.  If <var>x</var> and <var>y</var> are vectors,
then a typical vertex is (<var>x</var>(j), <var>y</var>(i), <var>z</var>(i,j)).  Thus,
columns of <var>z</var> correspond to different <var>x</var> values and rows of
<var>z</var> correspond to different <var>y</var> values. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dmeshgrid.html#doc_002dmeshgrid">meshgrid</a>, <a href="doc_002dmesh.html#doc_002dmesh">mesh</a>, <a href="doc_002dcontour.html#doc_002dcontour">contour</a>. 
</p></blockquote></div>

<!-- hidden scripts/plot/hidden.m -->
   <p><a name="doc_002dhidden"></a>

<div class="defun">
&mdash; Function File:  <b>hidden</b> (<var>mode</var>)<var><a name="index-hidden-1244"></a></var><br>
&mdash; Function File:  <b>hidden</b> ()<var><a name="index-hidden-1245"></a></var><br>
<blockquote><p>Manipulation the mesh hidden line removal.  Called with no argument
the hidden line removal is toggled.  The argument <var>mode</var> can be either
'on' or 'off' and the set of the hidden line removal is set accordingly. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dmesh.html#doc_002dmesh">mesh</a>, <a href="doc_002dmeshc.html#doc_002dmeshc">meshc</a>, <a href="doc_002dsurf.html#doc_002dsurf">surf</a>. 
</p></blockquote></div>

<!-- surf scripts/plot/surf.m -->
   <p><a name="doc_002dsurf"></a>

<div class="defun">
&mdash; Function File:  <b>surf</b> (<var>x, y, z</var>)<var><a name="index-surf-1246"></a></var><br>
&mdash; Function File:  <b>surf</b> (<var>z</var>)<var><a name="index-surf-1247"></a></var><br>
&mdash; Function File:  <b>surf</b> (<var><small class="dots">...</small>, c</var>)<var><a name="index-surf-1248"></a></var><br>
&mdash; Function File:  <b>surf</b> (<var>hax, <small class="dots">...</small></var>)<var><a name="index-surf-1249"></a></var><br>
&mdash; Function File: <var>h</var> = <b>surf</b> (<var><small class="dots">...</small></var>)<var><a name="index-surf-1250"></a></var><br>
<blockquote><p>Plot a surface given matrices <var>x</var>, and <var>y</var> from <code>meshgrid</code> and
a matrix <var>z</var> corresponding to the <var>x</var> and <var>y</var> coordinates of
the mesh.  If <var>x</var> and <var>y</var> are vectors, then a typical vertex
is (<var>x</var>(j), <var>y</var>(i), <var>z</var>(i,j)).  Thus, columns of <var>z</var>
correspond to different <var>x</var> values and rows of <var>z</var> correspond
to different <var>y</var> values.

        <p>The color of the surface is derived from the <code>colormap</code> and
the value of <var>z</var>.  Optionally the color of the surface can be
specified independent of <var>z</var>, by adding a fourth matrix, <var>c</var>.

        <p>The optional return value <var>h</var> is a graphics handle to the created
surface object. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dcolormap.html#doc_002dcolormap">colormap</a>, <a href="doc_002dcontour.html#doc_002dcontour">contour</a>, <a href="doc_002dmeshgrid.html#doc_002dmeshgrid">meshgrid</a>, <a href="doc_002dmesh.html#doc_002dmesh">mesh</a>. 
</p></blockquote></div>

<!-- surfc scripts/plot/surfc.m -->
   <p><a name="doc_002dsurfc"></a>

<div class="defun">
&mdash; Function File:  <b>surfc</b> (<var>x, y, z</var>)<var><a name="index-surfc-1251"></a></var><br>
<blockquote><p>Plot a surface and contour given matrices <var>x</var>, and <var>y</var> from
<code>meshgrid</code> and a matrix <var>z</var> corresponding to the <var>x</var> and
<var>y</var> coordinates of the mesh.  If <var>x</var> and <var>y</var> are vectors,
then a typical vertex is (<var>x</var>(j), <var>y</var>(i), <var>z</var>(i,j)).  Thus,
columns of <var>z</var> correspond to different <var>x</var> values and rows of
<var>z</var> correspond to different <var>y</var> values. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dmeshgrid.html#doc_002dmeshgrid">meshgrid</a>, <a href="doc_002dsurf.html#doc_002dsurf">surf</a>, <a href="doc_002dcontour.html#doc_002dcontour">contour</a>. 
</p></blockquote></div>

<!-- surfl scripts/plot/surfl.m -->
   <p><a name="doc_002dsurfl"></a>

<div class="defun">
&mdash; Function File:  <b>surfl</b> (<var>x, y, z</var>)<var><a name="index-surfl-1252"></a></var><br>
&mdash; Function File:  <b>surfl</b> (<var>z</var>)<var><a name="index-surfl-1253"></a></var><br>
&mdash; Function File:  <b>surfl</b> (<var>x, y, z, L</var>)<var><a name="index-surfl-1254"></a></var><br>
&mdash; Function File:  <b>surfl</b> (<var>x, y, z, L, P</var>)<var><a name="index-surfl-1255"></a></var><br>
&mdash; Function File:  <b>surfl</b> (<var><small class="dots">...</small>, "light"</var>)<var><a name="index-surfl-1256"></a></var><br>
<blockquote><p>Plot a lighted surface given matrices <var>x</var>, and <var>y</var> from
<code>meshgrid</code> and
a matrix <var>z</var> corresponding to the <var>x</var> and <var>y</var> coordinates of
the mesh.  If <var>x</var> and <var>y</var> are vectors, then a typical vertex
is (<var>x</var>(j), <var>y</var>(i), <var>z</var>(i,j)).  Thus, columns of <var>z</var>
correspond to different <var>x</var> values and rows of <var>z</var> correspond
to different <var>y</var> values.

        <p>The light direction can be specified using <var>L</var>.  It can be
given as 2-element vector [azimuth, elevation] in degrees or as 3-element
vector [lx, ly, lz]. 
The default value is rotated 45° counter-clockwise from the current view.

        <p>The material properties of the surface can specified using a 4-element vector
<var>P</var> = [<var>AM</var> <var>D</var> <var>SP</var> <var>exp</var>] which defaults to
<var>p</var> = [0.55 0.6 0.4 10].
          <dl>
<dt>"AM" strength of ambient light
<br><dt>"D" strength of diffuse reflection
<br><dt>"SP" strength of specular reflection
<br><dt>"EXP" specular exponent<dd></dl>

        <p>The default lighting mode "cdata", changes the cdata property to give the
impression
of a lighted surface.  Please note: the alternative "light" mode, which
creates a light
object to illuminate the surface is not implemented (yet).

        <p>Example:

     <pre class="example">          colormap (bone (64));
          surfl (peaks);
          shading interp;
</pre>
        <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
     <!-- A simple blank line produces the correct behavior. -->
     <!-- @sp 1 -->
     <p class="noindent"><strong>See also:</strong> <a href="doc_002dsurf.html#doc_002dsurf">surf</a>, <a href="doc_002ddiffuse.html#doc_002ddiffuse">diffuse</a>, <a href="doc_002dspecular.html#doc_002dspecular">specular</a>, <a href="doc_002dsurface.html#doc_002dsurface">surface</a>. 
</p></blockquote></div>

<!-- surfnorm scripts/plot/surfnorm.m -->
   <p><a name="doc_002dsurfnorm"></a>

<div class="defun">
&mdash; Function File:  <b>surfnorm</b> (<var>x, y, z</var>)<var><a name="index-surfnorm-1257"></a></var><br>
&mdash; Function File:  <b>surfnorm</b> (<var>z</var>)<var><a name="index-surfnorm-1258"></a></var><br>
&mdash; Function File: [<var>nx</var>, <var>ny</var>, <var>nz</var>] = <b>surfnorm</b> (<var><small class="dots">...</small></var>)<var><a name="index-surfnorm-1259"></a></var><br>
&mdash; Function File:  <b>surfnorm</b> (<var>h, <small class="dots">...</small></var>)<var><a name="index-surfnorm-1260"></a></var><br>
<blockquote><p>Find the vectors normal to a meshgridded surface.  The meshed gridded
surface is defined by <var>x</var>, <var>y</var>, and <var>z</var>.  If <var>x</var> and
<var>y</var> are not defined, then it is assumed that they are given by

     <pre class="example">          [<var>x</var>, <var>y</var>] = meshgrid (1:size (<var>z</var>, 1),
                             1:size (<var>z</var>, 2));
</pre>
        <p>If no return arguments are requested, a surface plot with the normal
vectors to the surface is plotted.  Otherwise the components of the normal
vectors at the mesh gridded points are returned in <var>nx</var>, <var>ny</var>,
and <var>nz</var>.

        <p>The normal vectors are calculated by taking the cross product of the
diagonals of each of the quadrilaterals in the meshgrid to find the
normal vectors of the centers of these quadrilaterals.  The four nearest
normal vectors to the meshgrid points are then averaged to obtain the
normal to the surface at the meshgridded points.

        <p>An example of the use of <code>surfnorm</code> is

     <pre class="example">          surfnorm (peaks (25));
</pre>
        <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
     <!-- A simple blank line produces the correct behavior. -->
     <!-- @sp 1 -->
     <p class="noindent"><strong>See also:</strong> <a href="doc_002dsurf.html#doc_002dsurf">surf</a>, <a href="doc_002dquiver3.html#doc_002dquiver3">quiver3</a>. 
</p></blockquote></div>

<!-- isosurface scripts/plot/isosurface.m -->
   <p><a name="doc_002disosurface"></a>

<div class="defun">
&mdash; Function File: [<var>fv</var>] = <b>isosurface</b> (<var>val, iso</var>)<var><a name="index-isosurface-1261"></a></var><br>
&mdash; Function File: [<var>fv</var>] = <b>isosurface</b> (<var>x, y, z, val, iso</var>)<var><a name="index-isosurface-1262"></a></var><br>
&mdash; Function File: [<var>fv</var>] = <b>isosurface</b> (<var><small class="dots">...</small>, "noshare", "verbose"</var>)<var><a name="index-isosurface-1263"></a></var><br>
&mdash; Function File: [<var>fvc</var>] = <b>isosurface</b> (<var><small class="dots">...</small>, col</var>)<var><a name="index-isosurface-1264"></a></var><br>
&mdash; Function File: [<var>f</var>, <var>v</var>] = <b>isosurface</b> (<var>x, y, z, val, iso</var>)<var><a name="index-isosurface-1265"></a></var><br>
&mdash; Function File: [<var>f</var>, <var>v</var>, <var>c</var>] = <b>isosurface</b> (<var>x, y, z, val, iso, col</var>)<var><a name="index-isosurface-1266"></a></var><br>
&mdash; Function File:  <b>isosurface</b> (<var>x, y, z, val, iso, col, opt</var>)<var><a name="index-isosurface-1267"></a></var><br>
<blockquote>
        <p>If called with one output argument and the first input argument
<var>val</var> is a three-dimensional array that contains the data of an
isosurface geometry and the second input argument <var>iso</var> keeps the
isovalue as a scalar value then return a structure array <var>fv</var>
that contains the fields <var>Faces</var> and <var>Vertices</var> at computed
points <samp><span class="command">[x, y, z] = meshgrid (1:l, 1:m, 1:n)</span></samp>.  The output
argument <var>fv</var> can directly be taken as an input argument for the
<samp><span class="command">patch</span></samp> function.

        <p>If called with further input arguments <var>x</var>, <var>y</var> and <var>z</var>
which are three&ndash;dimensional arrays with the same size than <var>val</var>
then the volume data is taken at those given points.

        <p>The string input argument "noshare" is only for compatibility and
has no effect.  If given the string input argument
"verbose" then print messages to the command line interface about the
current progress.

        <p>If called with the input argument <var>col</var> which is a
three-dimensional array of the same size than <var>val</var> then take
those values for the interpolation of coloring the isosurface
geometry.  Add the field <var>FaceVertexCData</var> to the structure
array <var>fv</var>.

        <p>If called with two or three output arguments then return the
information about the faces <var>f</var>, vertices <var>v</var> and color data
<var>c</var> as seperate arrays instead of a single structure array.

        <p>If called with no output argument then directly process the
isosurface geometry with the <samp><span class="command">patch</span></samp> command.

        <p>For example,

     <pre class="example">          [x, y, z] = meshgrid (1:5, 1:5, 1:5);
          val = rand (5, 5, 5);
          isosurface (x, y, z, val, .5);
</pre>
        <p class="noindent">will directly draw a random isosurface geometry in a graphics window. 
Another example for an isosurface geometry with different additional
coloring
<!-- Set example in small font to prevent overfull line -->

     <pre class="smallexample">          N = 15;    # Increase number of vertices in each direction
          iso = .4;  # Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure (); # Open another figure window
          
          subplot (2,2,1); view (-38, 20);
          [f, v] = isosurface (x, y, z, c, iso);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          set (gca, "PlotBoxAspectRatioMode", "manual", ...
                    "PlotBoxAspectRatio", [1 1 1]);
          # set (p, "FaceColor", "green", "FaceLighting", "phong");
          # light ("Position", [1 1 5]); # Available with the JHandles package
          
          subplot (2,2,2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "blue");
          set (gca, "PlotBoxAspectRatioMode", "manual", ...
                    "PlotBoxAspectRatio", [1 1 1]);
          # set (p, "FaceColor", "none", "FaceLighting", "phong");
          # light ("Position", [1 1 5]);
          
          subplot (2,2,3); view (-38, 20);
          [f, v, c] = isosurface (x, y, z, c, iso, y);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          set (gca, "PlotBoxAspectRatioMode", "manual", ...
                    "PlotBoxAspectRatio", [1 1 1]);
          # set (p, "FaceLighting", "phong");
          # light ("Position", [1 1 5]);
          
          subplot (2,2,4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", c, ...
                     "FaceColor", "interp", "EdgeColor", "blue");
          set (gca, "PlotBoxAspectRatioMode", "manual", ...
                    "PlotBoxAspectRatio", [1 1 1]);
          # set (p, "FaceLighting", "phong");
          # light ("Position", [1 1 5]);
</pre>
        <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
     <!-- A simple blank line produces the correct behavior. -->
     <!-- @sp 1 -->
     <p class="noindent"><strong>See also:</strong> <a href="doc_002disonormals.html#doc_002disonormals">isonormals</a>, <a href="doc_002disocolors.html#doc_002disocolors">isocolors</a>. 
</p></blockquote></div>

<!-- isonormals scripts/plot/isonormals.m -->
   <p><a name="doc_002disonormals"></a>

<div class="defun">
&mdash; Function File: [<var>n</var>] = <b>isonormals</b> (<var>val, v</var>)<var><a name="index-isonormals-1268"></a></var><br>
&mdash; Function File: [<var>n</var>] = <b>isonormals</b> (<var>val, p</var>)<var><a name="index-isonormals-1269"></a></var><br>
&mdash; Function File: [<var>n</var>] = <b>isonormals</b> (<var>x, y, z, val, v</var>)<var><a name="index-isonormals-1270"></a></var><br>
&mdash; Function File: [<var>n</var>] = <b>isonormals</b> (<var>x, y, z, val, p</var>)<var><a name="index-isonormals-1271"></a></var><br>
&mdash; Function File: [<var>n</var>] = <b>isonormals</b> (<var><small class="dots">...</small>, "negate"</var>)<var><a name="index-isonormals-1272"></a></var><br>
&mdash; Function File:  <b>isonormals</b> (<var><small class="dots">...</small>, p</var>)<var><a name="index-isonormals-1273"></a></var><br>
<blockquote>
        <p>If called with one output argument and the first input argument
<var>val</var> is a three-dimensional array that contains the data for an
isosurface geometry and the second input argument <var>v</var> keeps the
vertices of an isosurface then return the normals <var>n</var> in form of
a matrix with the same size than <var>v</var> at computed points
<samp><span class="command">[x, y, z] = meshgrid (1:l, 1:m, 1:n)</span></samp>.  The output argument
<var>n</var> can be taken to manually set <var>VertexNormals</var> of a patch.

        <p>If called with further input arguments <var>x</var>, <var>y</var> and <var>z</var>
which are three&ndash;dimensional arrays with the same size than <var>val</var>
then the volume data is taken at those given points.  Instead of the
vertices data <var>v</var> a patch handle <var>p</var> can be passed to this
function.

        <p>If given the string input argument "negate" as last input argument
then compute the reverse vector normals of an isosurface geometry.

        <p>If no output argument is given then directly redraw the patch that is
given by the patch handle <var>p</var>.

        <p>For example:
<!-- Set example in small font to prevent overfull line -->

     <pre class="smallexample">          function [] = isofinish (p)
            set (gca, "PlotBoxAspectRatioMode", "manual", ...
                      "PlotBoxAspectRatio", [1 1 1]);
            set (p, "VertexNormals", -get (p,"VertexNormals")); # Revert normals
            set (p, "FaceColor", "interp");
            ## set (p, "FaceLighting", "phong");
            ## light ("Position", [1 1 5]); # Available with JHandles
          endfunction
          
          N = 15;    # Increase number of vertices in each direction
          iso = .4;  # Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure (); # Open another figure window
          
          subplot (2,2,1); view (-38, 20);
          [f, v, cdat] = isosurface (x, y, z, c, iso, y);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          isofinish (p); ## Call user function isofinish
          
          subplot (2,2,2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          isonormals (x, y, z, c, p); # Directly modify patch
          isofinish (p);
          
          subplot (2,2,3); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          n = isonormals (x, y, z, c, v); # Compute normals of isosurface
          set (p, "VertexNormals", n);    # Manually set vertex normals
          isofinish (p);
          
          subplot (2,2,4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, ...
                     "FaceColor", "interp", "EdgeColor", "none");
          isonormals (x, y, z, c, v, "negate"); # Use reverse directly
          isofinish (p);
</pre>
        <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
     <!-- A simple blank line produces the correct behavior. -->
     <!-- @sp 1 -->
     <p class="noindent"><strong>See also:</strong> <a href="doc_002disosurface.html#doc_002disosurface">isosurface</a>, <a href="doc_002disocolors.html#doc_002disocolors">isocolors</a>. 
</p></blockquote></div>

<!-- isocolors scripts/plot/isocolors.m -->
   <p><a name="doc_002disocolors"></a>

<div class="defun">
&mdash; Function File: [<var>cd</var>] = <b>isocolors</b> (<var>c, v</var>)<var><a name="index-isocolors-1274"></a></var><br>
&mdash; Function File: [<var>cd</var>] = <b>isocolors</b> (<var>x, y, z, c, v</var>)<var><a name="index-isocolors-1275"></a></var><br>
&mdash; Function File: [<var>cd</var>] = <b>isocolors</b> (<var>x, y, z, r, g, b, v</var>)<var><a name="index-isocolors-1276"></a></var><br>
&mdash; Function File: [<var>cd</var>] = <b>isocolors</b> (<var>r, g, b, v</var>)<var><a name="index-isocolors-1277"></a></var><br>
&mdash; Function File: [<var>cd</var>] = <b>isocolors</b> (<var><small class="dots">...</small>, p</var>)<var><a name="index-isocolors-1278"></a></var><br>
&mdash; Function File:  <b>isocolors</b> (<var><small class="dots">...</small></var>)<var><a name="index-isocolors-1279"></a></var><br>
<blockquote>
        <p>If called with one output argument and the first input argument
<var>c</var> is a three-dimensional array that contains color values and
the second input argument <var>v</var> keeps the vertices of a geometry
then return a matrix <var>cd</var> with color data information for the
geometry at computed points
<samp><span class="command">[x, y, z] = meshgrid (1:l, 1:m, 1:n)</span></samp>.  The output argument
<var>cd</var> can be taken to manually set FaceVertexCData of a patch.

        <p>If called with further input arguments <var>x</var>, <var>y</var> and <var>z</var>
which are three&ndash;dimensional arrays of the same size than <var>c</var>
then the color data is taken at those given points.  Instead of the
color data <var>c</var> this function can also be called with RGB values
<var>r</var>, <var>g</var>, <var>b</var>.  If input argumnets <var>x</var>, <var>y</var>,
<var>z</var> are not given then again <samp><span class="command">meshgrid</span></samp> computed values
are taken.

        <p>Optionally, the patch handle <var>p</var> can be given as the last input
argument to all variations of function calls instead of the vertices
data <var>v</var>.  Finally, if no output argument is given then directly
change the colors of a patch that is given by the patch handle
<var>p</var>.

        <p>For example:

     <pre class="example">          function [] = isofinish (p)
            set (gca, "PlotBoxAspectRatioMode", "manual", ...
                      "PlotBoxAspectRatio", [1 1 1]);
            set (p, "FaceColor", "interp");
            ## set (p, "FaceLighting", "flat");
            ## light ("Position", [1 1 5]); ## Available with JHandles
          endfunction
          
          N = 15;    # Increase number of vertices in each direction
          iso = .4;  # Change isovalue to .1 to display a sphere
          lin = linspace (0, 2, N);
          [x, y, z] = meshgrid (lin, lin, lin);
          c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
          figure (); # Open another figure window
          
          subplot (2,2,1); view (-38, 20);
          [f, v] = isosurface (x, y, z, c, iso);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          cdat = rand (size (c));       # Compute random patch color data
          isocolors (x, y, z, cdat, p); # Directly set colors of patch
          isofinish (p);                # Call user function isofinish
          
          subplot (2,2,2); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          [r, g, b] = meshgrid (lin, 2-lin, 2-lin);
          cdat = isocolors (x, y, z, c, v); # Compute color data vertices
          set (p, "FaceVertexCData", cdat); # Set color data manually
          isofinish (p);
          
          subplot (2,2,3); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          cdat = isocolors (r, g, b, c, p); # Compute color data patch
          set (p, "FaceVertexCData", cdat); # Set color data manually
          isofinish (p);
          
          subplot (2,2,4); view (-38, 20);
          p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
          r = g = b = repmat ([1:N] / N, [N, 1, N]); # Black to white
          cdat = isocolors (x, y, z, r, g, b, v);
          set (p, "FaceVertexCData", cdat);
          isofinish (p);
</pre>
        <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
     <!-- A simple blank line produces the correct behavior. -->
     <!-- @sp 1 -->
     <p class="noindent"><strong>See also:</strong> <a href="doc_002disosurface.html#doc_002disosurface">isosurface</a>, <a href="doc_002disonormals.html#doc_002disonormals">isonormals</a>.

        </blockquote></div>

<!-- diffuse scripts/plot/diffuse.m -->
   <p><a name="doc_002ddiffuse"></a>

<div class="defun">
&mdash; Function File:  <b>diffuse</b> (<var>sx, sy, sz, lv</var>)<var><a name="index-diffuse-1280"></a></var><br>
<blockquote><p>Calculate diffuse reflection strength of a surface defined by the normal
vector elements <var>sx</var>, <var>sy</var>, <var>sz</var>. 
The light vector can be specified using parameter <var>lv</var>.  It can be
given as 2-element vector [azimuth, elevation] in degrees or as 3-element
vector [lx, ly, lz]. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dspecular.html#doc_002dspecular">specular</a>, <a href="doc_002dsurfl.html#doc_002dsurfl">surfl</a>. 
</p></blockquote></div>

<!-- specular scripts/plot/specular.m -->
   <p><a name="doc_002dspecular"></a>

<div class="defun">
&mdash; Function File:  <b>specular</b> (<var>sx, sy, sz, lv, vv</var>)<var><a name="index-specular-1281"></a></var><br>
&mdash; Function File:  <b>specular</b> (<var>sx, sy, sz, lv, vv, se</var>)<var><a name="index-specular-1282"></a></var><br>
<blockquote><p>Calculate specular reflection strength of a surface defined by the normal
vector elements <var>sx</var>, <var>sy</var>, <var>sz</var> using Phong's approximation. 
The light and view vectors can be specified using parameter <var>lv</var> and
<var>vv</var> respectively. 
Both can be given as 2-element vectors [azimuth, elevation] in degrees or as
3-element
vector [x, y, z].  An optional 6th argument describes the specular exponent
(spread) <var>se</var>. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dsurfl.html#doc_002dsurfl">surfl</a>, <a href="doc_002ddiffuse.html#doc_002ddiffuse">diffuse</a>. 
</p></blockquote></div>

<!-- meshgrid scripts/plot/meshgrid.m -->
   <p><a name="doc_002dmeshgrid"></a>

<div class="defun">
&mdash; Function File: [<var>xx</var>, <var>yy</var>, <var>zz</var>] = <b>meshgrid</b> (<var>x, y, z</var>)<var><a name="index-meshgrid-1283"></a></var><br>
&mdash; Function File: [<var>xx</var>, <var>yy</var>] = <b>meshgrid</b> (<var>x, y</var>)<var><a name="index-meshgrid-1284"></a></var><br>
&mdash; Function File: [<var>xx</var>, <var>yy</var>] = <b>meshgrid</b> (<var>x</var>)<var><a name="index-meshgrid-1285"></a></var><br>
<blockquote><p>Given vectors of <var>x</var> and <var>y</var> and <var>z</var> coordinates, and
returning 3 arguments, return three-dimensional arrays corresponding
to the <var>x</var>, <var>y</var>, and <var>z</var> coordinates of a mesh.  When
returning only 2 arguments, return matrices corresponding to the
<var>x</var> and <var>y</var> coordinates of a mesh.  The rows of <var>xx</var> are
copies of <var>x</var>, and the columns of <var>yy</var> are copies of <var>y</var>. 
If <var>y</var> is omitted, then it is assumed to be the same as <var>x</var>,
and <var>z</var> is assumed the same as <var>y</var>. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dmesh.html#doc_002dmesh">mesh</a>, <a href="doc_002dcontour.html#doc_002dcontour">contour</a>. 
</p></blockquote></div>

<!-- ndgrid scripts/plot/ndgrid.m -->
   <p><a name="doc_002dndgrid"></a>

<div class="defun">
&mdash; Function File: [<var>y1</var>, <var>y2</var>, <small class="dots">...</small>, <var>y</var>n] = <b>ndgrid</b> (<var>x1, x2, <small class="dots">...</small>, xn</var>)<var><a name="index-ndgrid-1286"></a></var><br>
&mdash; Function File: [<var>y1</var>, <var>y2</var>, <small class="dots">...</small>, <var>y</var>n] = <b>ndgrid</b> (<var>x</var>)<var><a name="index-ndgrid-1287"></a></var><br>
<blockquote><p>Given n vectors <var>x1</var>, <small class="dots">...</small> <var>x</var>n, <code>ndgrid</code> returns
n arrays of dimension n. The elements of the i-th output argument
contains the elements of the vector <var>x</var>i repeated over all
dimensions different from the i-th dimension.  Calling ndgrid with
only one input argument <var>x</var> is equivalent of calling ndgrid with
all n input arguments equal to <var>x</var>:

        <p>[<var>y1</var>, <var>y2</var>, <small class="dots">...</small>,  <var>y</var>n] = ndgrid (<var>x</var>, <small class="dots">...</small>, <var>x</var>)
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dmeshgrid.html#doc_002dmeshgrid">meshgrid</a>. 
</p></blockquote></div>

<!-- plot3 scripts/plot/plot3.m -->
   <p><a name="doc_002dplot3"></a>

<div class="defun">
&mdash; Function File:  <b>plot3</b> (<var>args</var>)<var><a name="index-plot3-1288"></a></var><br>
<blockquote><p>Produce three-dimensional plots.  Many different combinations of
arguments are possible.  The simplest form is

     <pre class="example">          plot3 (<var>x</var>, <var>y</var>, <var>z</var>)
</pre>
        <p class="noindent">in which the arguments are taken to be the vertices of the points to
be plotted in three dimensions.  If all arguments are vectors of the
same length, then a single continuous line is drawn.  If all arguments
are matrices, then each column of the matrices is treated as a
separate line.  No attempt is made to transpose the arguments to make
the number of rows match.

        <p>If only two arguments are given, as

     <pre class="example">          plot3 (<var>x</var>, <var>c</var>)
</pre>
        <p class="noindent">the real and imaginary parts of the second argument are used
as the <var>y</var> and <var>z</var> coordinates, respectively.

        <p>If only one argument is given, as

     <pre class="example">          plot3 (<var>c</var>)
</pre>
        <p class="noindent">the real and imaginary parts of the argument are used as the <var>y</var>
and <var>z</var> values, and they are plotted versus their index.

        <p>Arguments may also be given in groups of three as

     <pre class="example">          plot3 (<var>x1</var>, <var>y1</var>, <var>z1</var>, <var>x2</var>, <var>y2</var>, <var>z2</var>, ...)
</pre>
        <p class="noindent">in which each set of three arguments is treated as a separate line or
set of lines in three dimensions.

        <p>To plot multiple one- or two-argument groups, separate each group
with an empty format string, as

     <pre class="example">          plot3 (<var>x1</var>, <var>c1</var>, "", <var>c2</var>, "", ...)
</pre>
        <p>An example of the use of <code>plot3</code> is

     <pre class="example">          z = [0:0.05:5];
          plot3 (cos (2*pi*z), sin (2*pi*z), z, ";helix;");
          plot3 (z, exp (2i*pi*z), ";complex sinusoid;");
</pre>
        <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
     <!-- A simple blank line produces the correct behavior. -->
     <!-- @sp 1 -->
     <p class="noindent"><strong>See also:</strong> <a href="doc_002dplot.html#doc_002dplot">plot</a>, <a href="doc_002dxlabel.html#doc_002dxlabel">xlabel</a>, <a href="doc_002dylabel.html#doc_002dylabel">ylabel</a>, <a href="doc_002dzlabel.html#doc_002dzlabel">zlabel</a>, <a href="doc_002dtitle.html#doc_002dtitle">title</a>, <a href="doc_002dprint.html#doc_002dprint">print</a>. 
</p></blockquote></div>

<!-- view scripts/plot/view.m -->
   <p><a name="doc_002dview"></a>

<div class="defun">
&mdash; Function File: [<var>azimuth</var>, <var>elevation</var>] = <b>view</b> ()<var><a name="index-view-1289"></a></var><br>
&mdash; Function File:  <b>view</b> (<var>azimuth, elevation</var>)<var><a name="index-view-1290"></a></var><br>
&mdash; Function File:  <b>view</b> ([<var>azimuth elevation</var>])<var><a name="index-view-1291"></a></var><br>
&mdash; Function File:  <b>view</b> ([<var>x y z</var>])<var><a name="index-view-1292"></a></var><br>
&mdash; Function File:  <b>view</b> (<var>dims</var>)<var><a name="index-view-1293"></a></var><br>
&mdash; Function File:  <b>view</b> (<var>ax, <small class="dots">...</small></var>)<var><a name="index-view-1294"></a></var><br>
<blockquote><p>Query or set the viewpoint for the current axes.  The parameters
<var>azimuth</var> and <var>elevation</var> can be given as two arguments or as
2-element vector. 
The viewpoint can also be given with Cartesian coordinates <var>x</var>,
<var>y</var>, and <var>z</var>. 
The call <code>view (2)</code> sets the viewpoint to <var>azimuth</var> = 0
and <var>elevation</var> = 90, which is the default for 2-D graphs. 
The call <code>view (3)</code> sets the viewpoint to <var>azimuth</var> = -37.5
and <var>elevation</var> = 30, which is the default for 3-D graphs. 
If <var>ax</var> is given, the viewpoint is set for this axes, otherwise
it is set for the current axes. 
</p></blockquote></div>

<!-- slice scripts/plot/slice.m -->
   <p><a name="doc_002dslice"></a>

<div class="defun">
&mdash; Function File:  <b>slice</b> (<var>x, y, z, v, sx, sy, sz</var>)<var><a name="index-slice-1295"></a></var><br>
&mdash; Function File:  <b>slice</b> (<var>x, y, z, v, xi, yi, zi</var>)<var><a name="index-slice-1296"></a></var><br>
&mdash; Function File:  <b>slice</b> (<var>v, sx, sy, sz</var>)<var><a name="index-slice-1297"></a></var><br>
&mdash; Function File:  <b>slice</b> (<var>v, xi, yi, zi</var>)<var><a name="index-slice-1298"></a></var><br>
&mdash; Function File: <var>h</var> = <b>slice</b> (<var><small class="dots">...</small></var>)<var><a name="index-slice-1299"></a></var><br>
&mdash; Function File: <var>h</var> = <b>slice</b> (<var><small class="dots">...</small>, method</var>)<var><a name="index-slice-1300"></a></var><br>
<blockquote><p>Plot slices of 3-D data/scalar fields.  Each element of the 3-dimensional
array <var>v</var> represents a scalar value at a location given by the
parameters <var>x</var>, <var>y</var>, and <var>z</var>.  The parameters <var>x</var>,
<var>x</var>, and <var>z</var> are either 3-dimensional arrays of the same size
as the array <var>v</var> in the "meshgrid" format or vectors.  The
parameters <var>xi</var>, etc. respect a similar format to <var>x</var>, etc.,
and they represent the points at which the array <var>vi</var> is
interpolated using interp3.  The vectors <var>sx</var>, <var>sy</var>, and
<var>sz</var> contain points of orthogonal slices of the respective axes.

        <p>If <var>x</var>, <var>y</var>, <var>z</var> are omitted, they are assumed to be
<code>x = 1:size (</code><var>v</var><code>, 2)</code>, <code>y = 1:size (</code><var>v</var><code>, 1)</code> and
<code>z = 1:size (</code><var>v</var><code>, 3)</code>.

        <p><var>Method</var> is one of:

          <dl>
<dt>"nearest"<dd>Return the nearest neighbor.

          <br><dt>"linear"<dd>Linear interpolation from nearest neighbors.

          <br><dt>"cubic"<dd>Cubic interpolation from four nearest neighbors (not implemented yet).

          <br><dt>"spline"<dd>Cubic spline interpolation&mdash;smooth first and second derivatives
throughout the curve. 
</dl>

        <p>The default method is <code>"linear"</code>.

        <p>The optional return value <var>h</var> is a graphics handle to the created
surface object.

        <p>Examples:

     <pre class="example">          [x, y, z] = meshgrid (linspace (-8, 8, 32));
          v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
          slice (x, y, z, v, [], 0, []);
          [xi, yi] = meshgrid (linspace (-7, 7));
          zi = xi + yi;
          slice (x, y, z, v, xi, yi, zi);
</pre>
        <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
     <!-- A simple blank line produces the correct behavior. -->
     <!-- @sp 1 -->
     <p class="noindent"><strong>See also:</strong> <a href="doc_002dinterp3.html#doc_002dinterp3">interp3</a>, <a href="doc_002dsurface.html#doc_002dsurface">surface</a>, <a href="doc_002dpcolor.html#doc_002dpcolor">pcolor</a>. 
</p></blockquote></div>

<!-- ribbon scripts/plot/ribbon.m -->
   <p><a name="doc_002dribbon"></a>

<div class="defun">
&mdash; Function File:  <b>ribbon</b> (<var>x, y, width</var>)<var><a name="index-ribbon-1301"></a></var><br>
&mdash; Function File:  <b>ribbon</b> (<var>y</var>)<var><a name="index-ribbon-1302"></a></var><br>
&mdash; Function File: <var>h</var> = <b>ribbon</b> (<var><small class="dots">...</small></var>)<var><a name="index-ribbon-1303"></a></var><br>
<blockquote><p>Plot a ribbon plot for the columns of <var>y</var> vs.  <var>x</var>.  The
optional parameter <var>width</var> specifies the width of a single ribbon
(default is 0.75).  If <var>x</var> is omitted, a vector containing the
row numbers is assumed (1:rows(Y)).

        <p>The optional return value <var>h</var> is a vector of graphics handles to
the surface objects representing each ribbon. 
</p></blockquote></div>

<!-- shading scripts/plot/shading.m -->
   <p><a name="doc_002dshading"></a>

<div class="defun">
&mdash; Function File:  <b>shading</b> (<var>type</var>)<var><a name="index-shading-1304"></a></var><br>
&mdash; Function File:  <b>shading</b> (<var>ax, <small class="dots">...</small></var>)<var><a name="index-shading-1305"></a></var><br>
<blockquote><p>Set the shading of surface or patch graphic objects.  Valid arguments
for <var>type</var> are

          <dl>
<dt>"flat"<dd>Single colored patches with invisible edges.

          <br><dt>"faceted"<dd>Single colored patches with visible edges.

          <br><dt>"interp"<dd>Color between patch vertices are interpolated and the patch edges are
invisible. 
</dl>

        <p>If <var>ax</var> is given the shading is applied to axis <var>ax</var> instead
of the current axis. 
</p></blockquote></div>

<!-- scatter3 scripts/plot/scatter3.m -->
   <p><a name="doc_002dscatter3"></a>

<div class="defun">
&mdash; Function File:  <b>scatter3</b> (<var>x, y, z, s, c</var>)<var><a name="index-scatter3-1306"></a></var><br>
&mdash; Function File:  <b>scatter3</b> (<var><small class="dots">...</small>, 'filled'</var>)<var><a name="index-scatter3-1307"></a></var><br>
&mdash; Function File:  <b>scatter3</b> (<var><small class="dots">...</small>, style</var>)<var><a name="index-scatter3-1308"></a></var><br>
&mdash; Function File:  <b>scatter3</b> (<var><small class="dots">...</small>, prop, val</var>)<var><a name="index-scatter3-1309"></a></var><br>
&mdash; Function File:  <b>scatter3</b> (<var>h, <small class="dots">...</small></var>)<var><a name="index-scatter3-1310"></a></var><br>
&mdash; Function File: <var>h</var> = <b>scatter3</b> (<var><small class="dots">...</small></var>)<var><a name="index-scatter3-1311"></a></var><br>
<blockquote>
        <p>Plot a scatter plot of the data in 3D.  A marker is plotted at each point
defined by the points in the vectors <var>x</var>, <var>y</var> and <var>z</var>.  The size
of the markers used is determined by <var>s</var>, which can be a scalar or
a vector of the same length of <var>x</var>, <var>y</var> and <var>z</var>.  If <var>s</var> is
not given or is an empty matrix, then the default value of 8 points is used.

        <p>The color of the markers is determined by <var>c</var>, which can be a string
defining a fixed color; a 3-element vector giving the red, green, and blue
components of the color; a vector of the same length as <var>x</var> that gives
a scaled index into the current colormap; or a <var>n</var>-by-3 matrix defining
the colors of each of the markers individually.

        <p>The marker to use can be changed with the <var>style</var> argument, that is a
string defining a marker in the same manner as the <code>plot</code> command. 
If the argument 'filled' is given then the markers as filled.  All
additional arguments are passed to the underlying patch command.

        <p>The optional return value <var>h</var> is a graphics handle to the hggroup
object representing the points.

     <pre class="example">          [x, y, z] = peaks (20);
          scatter3 (x(:), y(:), z(:), [], z(:));
</pre>
        <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
     <!-- A simple blank line produces the correct behavior. -->
     <!-- @sp 1 -->
     <p class="noindent"><strong>See also:</strong> <a href="doc_002dplot.html#doc_002dplot">plot</a>, <a href="doc_002dpatch.html#doc_002dpatch">patch</a>, <a href="doc_002dscatter.html#doc_002dscatter">scatter</a>. 
</p></blockquote></div>

<ul class="menu">
<li><a accesskey="1" href="Aspect-Ratio.html#Aspect-Ratio">Aspect Ratio</a>
<li><a accesskey="2" href="Three_002ddimensional-Function-Plotting.html#Three_002ddimensional-Function-Plotting">Three-dimensional Function Plotting</a>
<li><a accesskey="3" href="Three_002ddimensional-Geometric-Shapes.html#Three_002ddimensional-Geometric-Shapes">Three-dimensional Geometric Shapes</a>
</ul>

   </body></html>

