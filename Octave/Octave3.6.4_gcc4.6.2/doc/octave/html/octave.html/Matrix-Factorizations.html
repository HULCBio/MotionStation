<html lang="en">
<head>
<title>Matrix Factorizations - GNU Octave</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Octave">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Linear-Algebra.html#Linear-Algebra" title="Linear Algebra">
<link rel="prev" href="Basic-Matrix-Functions.html#Basic-Matrix-Functions" title="Basic Matrix Functions">
<link rel="next" href="Functions-of-a-Matrix.html#Functions-of-a-Matrix" title="Functions of a Matrix">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Matrix-Factorizations"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Functions-of-a-Matrix.html#Functions-of-a-Matrix">Functions of a Matrix</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Basic-Matrix-Functions.html#Basic-Matrix-Functions">Basic Matrix Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Linear-Algebra.html#Linear-Algebra">Linear Algebra</a>
<hr>
</div>

<h3 class="section">18.3 Matrix Factorizations</h3>

<!-- chol src/DLD-FUNCTIONS/chol.cc -->
<p><a name="doc_002dchol"></a>

<div class="defun">
&mdash; Loadable Function: <var>R</var> = <b>chol</b> (<var>A</var>)<var><a name="index-chol-2045"></a></var><br>
&mdash; Loadable Function: [<var>R</var>, <var>p</var>] = <b>chol</b> (<var>A</var>)<var><a name="index-chol-2046"></a></var><br>
&mdash; Loadable Function: [<var>R</var>, <var>p</var>, <var>Q</var>] = <b>chol</b> (<var>S</var>)<var><a name="index-chol-2047"></a></var><br>
&mdash; Loadable Function: [<var>R</var>, <var>p</var>, <var>Q</var>] = <b>chol</b> (<var>S, 'vector'</var>)<var><a name="index-chol-2048"></a></var><br>
&mdash; Loadable Function: [<var>L</var>, <small class="dots">...</small>] = <b>chol</b> (<var><small class="dots">...</small>, 'lower'</var>)<var><a name="index-chol-2049"></a></var><br>
&mdash; Loadable Function: [<var>L</var>, <small class="dots">...</small>] = <b>chol</b> (<var><small class="dots">...</small>, 'upper'</var>)<var><a name="index-chol-2050"></a></var><br>
<blockquote><p><a name="index-Cholesky-factorization-2051"></a>Compute the Cholesky&nbsp;factor, <var>R</var>, of the symmetric positive definite
matrix <var>A</var>, where

     <pre class="example">          <var>R</var>' * <var>R</var> = <var>A</var>.
</pre>
        <p>Called with one output argument <code>chol</code> fails if <var>A</var> or <var>S</var> is
not positive definite.  With two or more output arguments <var>p</var> flags
whether the matrix was positive definite and <code>chol</code> does not fail.  A
zero value indicated that the matrix was positive definite and the <var>R</var>
gives the factorization, and <var>p</var> will have a positive value otherwise.

        <p>If called with 3 outputs then a sparsity preserving row/column permutation
is applied to <var>A</var> prior to the factorization.  That is <var>R</var>
is the factorization of <var>A</var><code>(</code><var>Q</var><code>,</code><var>Q</var><code>)</code> such that

     <pre class="example">          <var>R</var>' * <var>R</var> = <var>Q</var>' * <var>A</var> * <var>Q</var>.
</pre>
        <p>The sparsity preserving permutation is generally returned as a matrix. 
However, given the flag 'vector', <var>Q</var> will be returned as a vector
such that

     <pre class="example">          <var>R</var>' * <var>R</var> = <var>A</var>(<var>Q</var>, <var>Q</var>).
</pre>
        <p>Called with either a sparse or full matrix and using the 'lower' flag,
<code>chol</code> returns the lower triangular factorization such that

     <pre class="example">          <var>L</var> * <var>L</var>' = <var>A</var>.
</pre>
        <p>For full matrices, if the 'lower' flag is set only the lower triangular part
of the matrix is used for the factorization, otherwise the upper triangular
part is used.

        <p>In general the lower triangular factorization is significantly faster for
sparse matrices. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dcholinv.html#doc_002dcholinv">cholinv</a>, <a href="doc_002dchol2inv.html#doc_002dchol2inv">chol2inv</a>. 
</p></blockquote></div>

<!-- cholinv src/DLD-FUNCTIONS/chol.cc -->
   <p><a name="doc_002dcholinv"></a>

<div class="defun">
&mdash; Loadable Function:  <b>cholinv</b> (<var>A</var>)<var><a name="index-cholinv-2052"></a></var><br>
<blockquote><p>Use the Cholesky&nbsp;factorization to compute the inverse of the
symmetric positive definite matrix <var>A</var>. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dchol.html#doc_002dchol">chol</a>, <a href="doc_002dchol2inv.html#doc_002dchol2inv">chol2inv</a>, <a href="doc_002dinv.html#doc_002dinv">inv</a>. 
</p></blockquote></div>

<!-- chol2inv src/DLD-FUNCTIONS/chol.cc -->
   <p><a name="doc_002dchol2inv"></a>

<div class="defun">
&mdash; Loadable Function:  <b>chol2inv</b> (<var>U</var>)<var><a name="index-chol2inv-2053"></a></var><br>
<blockquote><p>Invert a symmetric, positive definite square matrix from its Cholesky
decomposition, <var>U</var>.  Note that <var>U</var> should be an upper-triangular
matrix with positive diagonal elements.  <code>chol2inv (</code><var>U</var><code>)</code>
provides <code>inv (</code><var>U</var><code>'*</code><var>U</var><code>)</code> but it is much faster than
using <code>inv</code>. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dchol.html#doc_002dchol">chol</a>, <a href="doc_002dcholinv.html#doc_002dcholinv">cholinv</a>, <a href="doc_002dinv.html#doc_002dinv">inv</a>. 
</p></blockquote></div>

<!-- cholupdate src/DLD-FUNCTIONS/chol.cc -->
   <p><a name="doc_002dcholupdate"></a>

<div class="defun">
&mdash; Loadable Function: [<var>R1</var>, <var>info</var>] = <b>cholupdate</b> (<var>R, u, op</var>)<var><a name="index-cholupdate-2054"></a></var><br>
<blockquote><p>Update or downdate a Cholesky&nbsp;factorization.  Given an upper triangular
matrix <var>R</var> and a column vector <var>u</var>, attempt to determine another
upper triangular matrix <var>R1</var> such that
          <ul>
<li><var>R1</var>'*<var>R1</var> = <var>R</var>'*<var>R</var> + <var>u</var>*<var>u</var>'
if <var>op</var> is "+"

          <li><var>R1</var>'*<var>R1</var> = <var>R</var>'*<var>R</var> - <var>u</var>*<var>u</var>'
if <var>op</var> is "-"
</ul>

        <p>If <var>op</var> is "-", <var>info</var> is set to
          <ul>
<li>0 if the downdate was successful,

          <li>1 if <var>R</var>'*<var>R</var> - <var>u</var>*<var>u</var>' is not positive definite,

          <li>2 if <var>R</var> is singular. 
</ul>

        <p>If <var>info</var> is not present, an error message is printed in cases 1 and 2. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dchol.html#doc_002dchol">chol</a>, <a href="doc_002dqrupdate.html#doc_002dqrupdate">qrupdate</a>. 
</p></blockquote></div>

<!-- cholinsert src/DLD-FUNCTIONS/chol.cc -->
   <p><a name="doc_002dcholinsert"></a>

<div class="defun">
&mdash; Loadable Function: <var>R1</var> = <b>cholinsert</b> (<var>R, j, u</var>)<var><a name="index-cholinsert-2055"></a></var><br>
&mdash; Loadable Function: [<var>R1</var>, <var>info</var>] = <b>cholinsert</b> (<var>R, j, u</var>)<var><a name="index-cholinsert-2056"></a></var><br>
<blockquote><p>Given a Cholesky&nbsp;factorization of a real symmetric or complex Hermitian
positive definite matrix <var>A</var>&nbsp;=&nbsp;<var>R</var>'*<var>R</var><!-- /@w -->, <var>R</var>&nbsp;upper
triangular, return the Cholesky&nbsp;factorization of
<var>A1</var>, where A1(p,p)&nbsp;=&nbsp;A<!-- /@w -->, A1(:,j)&nbsp;=&nbsp;A1(j,:)'&nbsp;=&nbsp;u<!-- /@w --> and
p&nbsp;=&nbsp;[1:j-1,j+1:n+1]<!-- /@w -->.  u(j)<!-- /@w --> should be positive. 
On return, <var>info</var> is set to
          <ul>
<li>0 if the insertion was successful,

          <li>1 if <var>A1</var> is not positive definite,

          <li>2 if <var>R</var> is singular. 
</ul>

        <p>If <var>info</var> is not present, an error message is printed in cases 1 and 2. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dchol.html#doc_002dchol">chol</a>, <a href="doc_002dcholupdate.html#doc_002dcholupdate">cholupdate</a>, <a href="doc_002dcholdelete.html#doc_002dcholdelete">choldelete</a>. 
</p></blockquote></div>

<!-- choldelete src/DLD-FUNCTIONS/chol.cc -->
   <p><a name="doc_002dcholdelete"></a>

<div class="defun">
&mdash; Loadable Function: <var>R1</var> = <b>choldelete</b> (<var>R, j</var>)<var><a name="index-choldelete-2057"></a></var><br>
<blockquote><p>Given a Cholesky&nbsp;factorization of a real symmetric or complex Hermitian
positive definite matrix <var>A</var>&nbsp;=&nbsp;<var>R</var>'*<var>R</var><!-- /@w -->, <var>R</var>&nbsp;upper
triangular, return the Cholesky&nbsp;factorization of A(p,p)<!-- /@w -->, where
p&nbsp;=&nbsp;[1:j-1,j+1:n+1]<!-- /@w -->. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dchol.html#doc_002dchol">chol</a>, <a href="doc_002dcholupdate.html#doc_002dcholupdate">cholupdate</a>, <a href="doc_002dcholinsert.html#doc_002dcholinsert">cholinsert</a>. 
</p></blockquote></div>

<!-- cholshift src/DLD-FUNCTIONS/chol.cc -->
   <p><a name="doc_002dcholshift"></a>

<div class="defun">
&mdash; Loadable Function: <var>R1</var> = <b>cholshift</b> (<var>R, i, j</var>)<var><a name="index-cholshift-2058"></a></var><br>
<blockquote><p>Given a Cholesky&nbsp;factorization of a real symmetric or complex Hermitian
positive definite matrix <var>A</var>&nbsp;=&nbsp;<var>R</var>'*<var>R</var><!-- /@w -->, <var>R</var>&nbsp;upper
triangular, return the Cholesky&nbsp;factorization of
<var>A</var>(p,p)<!-- /@w -->, where p<!-- /@w --> is the permutation <br>
<code>p = [1:i-1, shift(i:j, 1), j+1:n]</code> if <var>i</var>&nbsp;&lt;&nbsp;<var>j</var><!-- /@w --> <br>
 or <br>
<code>p = [1:j-1, shift(j:i,-1), i+1:n]</code> if <var>j</var>&nbsp;&lt;&nbsp;<var>i</var><!-- /@w -->.  <br>

     <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
     <!-- A simple blank line produces the correct behavior. -->
     <!-- @sp 1 -->
     <p class="noindent"><strong>See also:</strong> <a href="doc_002dchol.html#doc_002dchol">chol</a>, <a href="doc_002dcholinsert.html#doc_002dcholinsert">cholinsert</a>, <a href="doc_002dcholdelete.html#doc_002dcholdelete">choldelete</a>. 
</p></blockquote></div>

<!-- hess src/DLD-FUNCTIONS/hess.cc -->
   <p><a name="doc_002dhess"></a>

<div class="defun">
&mdash; Loadable Function: <var>H</var> = <b>hess</b> (<var>A</var>)<var><a name="index-hess-2059"></a></var><br>
&mdash; Loadable Function: [<var>P</var>, <var>H</var>] = <b>hess</b> (<var>A</var>)<var><a name="index-hess-2060"></a></var><br>
<blockquote><p><a name="index-Hessenberg-decomposition-2061"></a>Compute the Hessenberg decomposition of the matrix <var>A</var>.

        <p>The Hessenberg decomposition is
<var>P</var><code> * </code><var>H</var><code> * </code><var>P</var><code>' = </code><var>A</var> where <var>P</var> is a square
unitary matrix (<var>P</var><code>' * </code><var>P</var><code> = I</code>, using complex-conjugate
transposition) and <var>H</var> is upper Hessenberg
(<var>H</var><code>(i, j) = 0 forall i &gt;= j+1)</code>.

        <p>The Hessenberg decomposition is usually used as the first step in an
eigenvalue computation, but has other applications as well (see Golub,
Nash, and Van Loan, IEEE Transactions on Automatic Control, 1979). 
</p></blockquote></div>

<!-- lu src/DLD-FUNCTIONS/lu.cc -->
   <p><a name="doc_002dlu"></a>

<div class="defun">
&mdash; Loadable Function: [<var>L</var>, <var>U</var>] = <b>lu</b> (<var>A</var>)<var><a name="index-lu-2062"></a></var><br>
&mdash; Loadable Function: [<var>L</var>, <var>U</var>, <var>P</var>] = <b>lu</b> (<var>A</var>)<var><a name="index-lu-2063"></a></var><br>
&mdash; Loadable Function: [<var>L</var>, <var>U</var>, <var>P</var>, <var>Q</var>] = <b>lu</b> (<var>S</var>)<var><a name="index-lu-2064"></a></var><br>
&mdash; Loadable Function: [<var>L</var>, <var>U</var>, <var>P</var>, <var>Q</var>, <var>R</var>] = <b>lu</b> (<var>S</var>)<var><a name="index-lu-2065"></a></var><br>
&mdash; Loadable Function: [<small class="dots">...</small>] = <b>lu</b> (<var>S, thres</var>)<var><a name="index-lu-2066"></a></var><br>
&mdash; Loadable Function: <var>y</var> = <b>lu</b> (<var><small class="dots">...</small></var>)<var><a name="index-lu-2067"></a></var><br>
&mdash; Loadable Function: [<small class="dots">...</small>] = <b>lu</b> (<var><small class="dots">...</small>, 'vector'</var>)<var><a name="index-lu-2068"></a></var><br>
<blockquote><p><a name="index-LU-decomposition-2069"></a>Compute the LU&nbsp;decomposition of <var>A</var>.  If <var>A</var> is full
subroutines from
<span class="sc">lapack</span> are used and if <var>A</var> is sparse then <span class="sc">umfpack</span> is used.  The
result is returned in a permuted form, according to the optional return
value <var>P</var>.  For example, given the matrix <code>a = [1, 2; 3, 4]</code>,

     <pre class="example">          [l, u, p] = lu (<var>a</var>)
</pre>
        <p class="noindent">returns

     <pre class="example">          l =
          
            1.00000  0.00000
            0.33333  1.00000
          
          u =
          
            3.00000  4.00000
            0.00000  0.66667
          
          p =
          
            0  1
            1  0
</pre>
        <p>The matrix is not required to be square.

        <p>When called with two or three output arguments and a spare input matrix,
<code>lu</code> does not attempt to perform sparsity preserving column
permutations.  Called with a fourth output argument, the sparsity
preserving column transformation <var>Q</var> is returned, such that
<var>P</var><code> * </code><var>A</var><code> * </code><var>Q</var><code> = </code><var>L</var><code> * </code><var>U</var>.

        <p>Called with a fifth output argument and a sparse input matrix,
<code>lu</code> attempts to use a scaling factor <var>R</var> on the input matrix
such that
<var>P</var><code> * (</code><var>R</var><code> \ </code><var>A</var><code>) * </code><var>Q</var><code> = </code><var>L</var><code> * </code><var>U</var>. 
This typically leads to a sparser and more stable factorization.

        <p>An additional input argument <var>thres</var>, that defines the pivoting
threshold can be given.  <var>thres</var> can be a scalar, in which case
it defines the <span class="sc">umfpack</span> pivoting tolerance for both symmetric and
unsymmetric cases.  If <var>thres</var> is a 2-element vector, then the first
element defines the pivoting tolerance for the unsymmetric <span class="sc">umfpack</span>
pivoting strategy and the second for the symmetric strategy.  By default,
the values defined by <code>spparms</code> are used ([0.1, 0.001]).

        <p>Given the string argument 'vector', <code>lu</code> returns the values of <var>P</var>
and <var>Q</var> as vector values, such that for full matrix, <var>A</var><code>
(</code><var>P</var><code>,:) = </code><var>L</var><code> * </code><var>U</var>, and <var>R</var><code>(</code><var>P</var><code>,:) * </code><var>A</var><code>
(:, </code><var>Q</var><code>) = </code><var>L</var><code> * </code><var>U</var>.

        <p>With two output arguments, returns the permuted forms of the upper and
lower triangular matrices, such that <var>A</var><code> = </code><var>L</var><code> * </code><var>U</var>. 
With one output argument <var>y</var>, then the matrix returned by the <span class="sc">lapack</span>
routines is returned.  If the input matrix is sparse then the matrix <var>L</var>
is embedded into <var>U</var> to give a return value similar to the full case. 
For both full and sparse matrices, <code>lu</code> loses the permutation
information. 
</p></blockquote></div>

<!-- luupdate src/DLD-FUNCTIONS/lu.cc -->
   <p><a name="doc_002dluupdate"></a>

<div class="defun">
&mdash; Loadable Function: [<var>L</var>, <var>U</var>] = <b>luupdate</b> (<var>L, U, x, y</var>)<var><a name="index-luupdate-2070"></a></var><br>
&mdash; Loadable Function: [<var>L</var>, <var>U</var>, <var>P</var>] = <b>luupdate</b> (<var>L, U, P, x, y</var>)<var><a name="index-luupdate-2071"></a></var><br>
<blockquote><p>Given an LU&nbsp;factorization of a real or complex matrix
<var>A</var>&nbsp;=&nbsp;<var>L</var>*<var>U</var><!-- /@w -->, <var>L</var>&nbsp;lower unit trapezoidal and
<var>U</var>&nbsp;upper trapezoidal, return the LU&nbsp;factorization
of <var>A</var>&nbsp;+&nbsp;<var>x</var>*<var>y</var>.'<!-- /@w -->, where <var>x</var> and <var>y</var> are
column vectors (rank-1 update) or matrices with equal number of columns
(rank-k update). 
Optionally, row-pivoted updating can be used by supplying
a row permutation (pivoting) matrix <var>P</var>;
in that case, an updated permutation matrix is returned. 
Note that if <var>L</var>, <var>U</var>, <var>P</var> is a pivoted LU&nbsp;factorization
as obtained by <code>lu</code>:

     <pre class="example">            [<var>L</var>, <var>U</var>, <var>P</var>] = lu (<var>A</var>);
</pre>
        <p class="noindent">then a factorization of <var>A</var><code>+</code><var>x</var><code>*</code><var>y</var><code>.'</code> can be obtained
either as

     <pre class="example">            [<var>L1</var>, <var>U1</var>] = lu (<var>L</var>, <var>U</var>, <var>P</var>*<var>x</var>, <var>y</var>)
</pre>
        <p class="noindent">or

     <pre class="example">            [<var>L1</var>, <var>U1</var>, <var>P1</var>] = lu (<var>L</var>, <var>U</var>, <var>P</var>, <var>x</var>, <var>y</var>)
</pre>
        <p>The first form uses the unpivoted algorithm, which is faster, but less
stable.  The second form uses a slower pivoted algorithm, which is more
stable.

        <p>The matrix case is done as a sequence of rank-1 updates;
thus, for large enough k, it will be both faster and more accurate to
recompute the factorization from scratch. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dlu.html#doc_002dlu">lu</a>, <a href="doc_002dqrupdate.html#doc_002dqrupdate">qrupdate</a>, <a href="doc_002dcholupdate.html#doc_002dcholupdate">cholupdate</a>. 
</p></blockquote></div>

<!-- qr src/DLD-FUNCTIONS/qr.cc -->
   <p><a name="doc_002dqr"></a>

<div class="defun">
&mdash; Loadable Function: [<var>Q</var>, <var>R</var>, <var>P</var>] = <b>qr</b> (<var>A</var>)<var><a name="index-qr-2072"></a></var><br>
&mdash; Loadable Function: [<var>Q</var>, <var>R</var>, <var>P</var>] = <b>qr</b> (<var>A, '0'</var>)<var><a name="index-qr-2073"></a></var><br>
&mdash; Loadable Function: [<var>C</var>, <var>R</var>] = <b>qr</b> (<var>A, B</var>)<var><a name="index-qr-2074"></a></var><br>
&mdash; Loadable Function: [<var>C</var>, <var>R</var>] = <b>qr</b> (<var>A, B, '0'</var>)<var><a name="index-qr-2075"></a></var><br>
<blockquote><p><a name="index-QR-factorization-2076"></a>Compute the QR&nbsp;factorization of <var>A</var>, using standard <span class="sc">lapack</span>
subroutines.  For example, given the matrix <var>A</var><code> = [1, 2; 3, 4]</code>,

     <pre class="example">          [<var>Q</var>, <var>R</var>] = qr (<var>A</var>)
</pre>
        <p class="noindent">returns

     <pre class="example">          <var>Q</var> =
          
            -0.31623  -0.94868
            -0.94868   0.31623
          
          <var>R</var> =
          
            -3.16228  -4.42719
             0.00000  -0.63246
</pre>
        <p>The <code>qr</code> factorization has applications in the solution of least
squares problems

     <pre class="example">          <code>min norm(A x - b)</code>
</pre>
        <p>for overdetermined systems of equations (i.e.,
<var>A</var>
 is a tall, thin matrix).  The QR&nbsp;factorization is
<var>Q</var><code> * </code><var>Q</var><code> = </code><var>A</var> where <var>Q</var> is an orthogonal matrix and
<var>R</var> is upper triangular.

        <p>If given a second argument of '0', <code>qr</code> returns an economy-sized
QR&nbsp;factorization, omitting zero rows of <var>R</var> and the corresponding
columns of <var>Q</var>.

        <p>If the matrix <var>A</var> is full, the permuted QR&nbsp;factorization
<code>[</code><var>Q</var><code>, </code><var>R</var><code>, </code><var>P</var><code>] = qr (</code><var>A</var><code>)</code> forms the
QR&nbsp;factorization such that the diagonal entries of <var>R</var> are
decreasing in magnitude order.  For example, given the matrix <code>a = [1,
2; 3, 4]</code>,

     <pre class="example">          [<var>Q</var>, <var>R</var>, <var>P</var>] = qr (<var>A</var>)
</pre>
        <p class="noindent">returns

     <pre class="example">          <var>Q</var> =
          
            -0.44721  -0.89443
            -0.89443   0.44721
          
          <var>R</var> =
          
            -4.47214  -3.13050
             0.00000   0.44721
          
          <var>P</var> =
          
             0  1
             1  0
</pre>
        <p>The permuted <code>qr</code> factorization <code>[</code><var>Q</var><code>, </code><var>R</var><code>, </code><var>P</var><code>] = qr
(</code><var>A</var><code>)</code> factorization allows the construction of an orthogonal basis of
<code>span (A)</code>.

        <p>If the matrix <var>A</var> is sparse, then compute the sparse
QR&nbsp;factorization of <var>A</var>, using <span class="sc">CSparse</span>.  As the matrix <var>Q</var>
is in general a full matrix, this function returns the <var>Q</var>-less
factorization <var>R</var> of <var>A</var>, such that <var>R</var><code> = chol (</code><var>A</var><code>' *
</code><var>A</var><code>)</code>.

        <p>If the final argument is the scalar <code>0</code> and the number of rows is
larger than the number of columns, then an economy factorization is
returned.  That is <var>R</var> will have only <code>size (</code><var>A</var><code>,1)</code> rows.

        <p>If an additional matrix <var>B</var> is supplied, then <code>qr</code> returns
<var>C</var>, where <var>C</var><code> = </code><var>Q</var><code>' * </code><var>B</var>.  This allows the
least squares approximation of <var>A</var><code> \ </code><var>B</var> to be calculated
as

     <pre class="example">          [<var>C</var>, <var>R</var>] = qr (<var>A</var>, <var>B</var>)
          x = <var>R</var> \ <var>C</var>
</pre>
        </blockquote></div>

<!-- qrupdate src/DLD-FUNCTIONS/qr.cc -->
   <p><a name="doc_002dqrupdate"></a>

<div class="defun">
&mdash; Loadable Function: [<var>Q1</var>, <var>R1</var>] = <b>qrupdate</b> (<var>Q, R, u, v</var>)<var><a name="index-qrupdate-2077"></a></var><br>
<blockquote><p>Given a QR&nbsp;factorization of a real or complex matrix
<var>A</var>&nbsp;=&nbsp;<var>Q</var>*<var>R</var><!-- /@w -->, <var>Q</var>&nbsp;unitary and
<var>R</var>&nbsp;upper trapezoidal, return the QR&nbsp;factorization
of <var>A</var>&nbsp;+&nbsp;<var>u</var>*<var>v</var>'<!-- /@w -->, where <var>u</var> and <var>v</var> are
column vectors (rank-1 update) or matrices with equal number of columns
(rank-k update).  Notice that the latter case is done as a sequence of rank-1
updates; thus, for k large enough, it will be both faster and more accurate
to recompute the factorization from scratch.

        <p>The QR&nbsp;factorization supplied may be either full
(Q is square) or economized (R is square).

     <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
     <!-- A simple blank line produces the correct behavior. -->
     <!-- @sp 1 -->
     <p class="noindent"><strong>See also:</strong> <a href="doc_002dqr.html#doc_002dqr">qr</a>, <a href="doc_002dqrinsert.html#doc_002dqrinsert">qrinsert</a>, <a href="doc_002dqrdelete.html#doc_002dqrdelete">qrdelete</a>. 
</p></blockquote></div>

<!-- qrinsert src/DLD-FUNCTIONS/qr.cc -->
   <p><a name="doc_002dqrinsert"></a>

<div class="defun">
&mdash; Loadable Function: [<var>Q1</var>, <var>R1</var>] = <b>qrinsert</b> (<var>Q, R, j, x, orient</var>)<var><a name="index-qrinsert-2078"></a></var><br>
<blockquote><p>Given a QR&nbsp;factorization of a real or complex matrix
<var>A</var>&nbsp;=&nbsp;<var>Q</var>*<var>R</var><!-- /@w -->, <var>Q</var>&nbsp;unitary and
<var>R</var>&nbsp;upper trapezoidal, return the QR&nbsp;factorization of
[A(:,1:j-1)&nbsp;x&nbsp;A(:,j:n)]<!-- /@w -->, where <var>u</var> is a column vector to be
inserted into <var>A</var> (if <var>orient</var> is <code>"col"</code>), or the
QR&nbsp;factorization of [A(1:j-1,:);x;A(:,j:n)]<!-- /@w -->, where <var>x</var>
is a row vector to be inserted into <var>A</var> (if <var>orient</var> is
<code>"row"</code>).

        <p>The default value of <var>orient</var> is <code>"col"</code>. 
If <var>orient</var> is <code>"col"</code>,
<var>u</var> may be a matrix and <var>j</var> an index vector
resulting in the QR&nbsp;factorization of a matrix <var>B</var> such that
B(:,<var>j</var>)<!-- /@w --> gives <var>u</var> and B(:,<var>j</var>)&nbsp;=&nbsp;[]<!-- /@w --> gives <var>A</var>. 
Notice that the latter case is done as a sequence of k insertions;
thus, for k large enough, it will be both faster and more accurate to
recompute the factorization from scratch.

        <p>If <var>orient</var> is <code>"col"</code>,
the QR&nbsp;factorization supplied may be either full
(Q is square) or economized (R is square).

        <p>If <var>orient</var> is <code>"row"</code>, full factorization is needed. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dqr.html#doc_002dqr">qr</a>, <a href="doc_002dqrupdate.html#doc_002dqrupdate">qrupdate</a>, <a href="doc_002dqrdelete.html#doc_002dqrdelete">qrdelete</a>. 
</p></blockquote></div>

<!-- qrdelete src/DLD-FUNCTIONS/qr.cc -->
   <p><a name="doc_002dqrdelete"></a>

<div class="defun">
&mdash; Loadable Function: [<var>Q1</var>, <var>R1</var>] = <b>qrdelete</b> (<var>Q, R, j, orient</var>)<var><a name="index-qrdelete-2079"></a></var><br>
<blockquote><p>Given a QR&nbsp;factorization of a real or complex matrix
<var>A</var>&nbsp;=&nbsp;<var>Q</var>*<var>R</var><!-- /@w -->, <var>Q</var>&nbsp;unitary and
<var>R</var>&nbsp;upper trapezoidal, return the QR&nbsp;factorization of
[A(:,1:j-1)&nbsp;A(:,j+1:n)]<!-- /@w -->, i.e., <var>A</var> with one column deleted
(if <var>orient</var> is "col"), or the QR&nbsp;factorization of
[A(1:j-1,:);A(j+1:n,:)]<!-- /@w -->, i.e., <var>A</var> with one row deleted (if
   <var>orient</var> is "row").

        <p>The default value of <var>orient</var> is "col".

        <p>If <var>orient</var> is <code>"col"</code>,
<var>j</var> may be an index vector
resulting in the QR&nbsp;factorization of a matrix <var>B</var> such that
A(:,<var>j</var>)&nbsp;=&nbsp;[]<!-- /@w --> gives <var>B</var>. 
Notice that the latter case is done as a sequence of k deletions;
thus, for k large enough, it will be both faster and more accurate to
recompute the factorization from scratch.

        <p>If <var>orient</var> is <code>"col"</code>,
the QR&nbsp;factorization supplied may be either full
(Q is square) or economized (R is square).

        <p>If <var>orient</var> is <code>"row"</code>, full factorization is needed. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dqr.html#doc_002dqr">qr</a>, <a href="doc_002dqrinsert.html#doc_002dqrinsert">qrinsert</a>, <a href="doc_002dqrupdate.html#doc_002dqrupdate">qrupdate</a>. 
</p></blockquote></div>

<!-- qrshift src/DLD-FUNCTIONS/qr.cc -->
   <p><a name="doc_002dqrshift"></a>

<div class="defun">
&mdash; Loadable Function: [<var>Q1</var>, <var>R1</var>] = <b>qrshift</b> (<var>Q, R, i, j</var>)<var><a name="index-qrshift-2080"></a></var><br>
<blockquote><p>Given a QR&nbsp;factorization of a real or complex matrix
<var>A</var>&nbsp;=&nbsp;<var>Q</var>*<var>R</var><!-- /@w -->, <var>Q</var>&nbsp;unitary and
<var>R</var>&nbsp;upper trapezoidal, return the QR&nbsp;factorization
of <var>A</var>(:,p)<!-- /@w -->, where p<!-- /@w --> is the permutation <br>
<code>p = [1:i-1, shift(i:j, 1), j+1:n]</code> if <var>i</var>&nbsp;&lt;&nbsp;<var>j</var><!-- /@w --> <br>
 or <br>
<code>p = [1:j-1, shift(j:i,-1), i+1:n]</code> if <var>j</var>&nbsp;&lt;&nbsp;<var>i</var><!-- /@w -->.  <br>

     <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
     <!-- A simple blank line produces the correct behavior. -->
     <!-- @sp 1 -->
     <p class="noindent"><strong>See also:</strong> <a href="doc_002dqr.html#doc_002dqr">qr</a>, <a href="doc_002dqrinsert.html#doc_002dqrinsert">qrinsert</a>, <a href="doc_002dqrdelete.html#doc_002dqrdelete">qrdelete</a>. 
</p></blockquote></div>

<!-- qz src/DLD-FUNCTIONS/qz.cc -->
   <p><a name="doc_002dqz"></a>

<div class="defun">
&mdash; Loadable Function: <var>lambda</var> = <b>qz</b> (<var>A, B</var>)<var><a name="index-qz-2081"></a></var><br>
&mdash; Loadable Function: <var>lambda</var> = <b>qz</b> (<var>A, B, opt</var>)<var><a name="index-qz-2082"></a></var><br>
<blockquote><p>QZ&nbsp;decomposition of the generalized eigenvalue problem
(A x = s B x).  There are three ways to call this function:
          <ol type=1 start=1>
<li><var>lambda</var><code> = qz (</code><var>A</var><code>, </code><var>B</var><code>)</code>

          <p>Computes the generalized eigenvalues
<var>lambda</var>
of (A - s B).

          <li><code>[AA, BB, Q, Z, V, W, </code><var>lambda</var><code>] = qz (</code><var>A</var><code>, </code><var>B</var><code>)</code>

          <p>Computes QZ&nbsp;decomposition, generalized eigenvectors, and
generalized eigenvalues of (A - s B)

          <pre class="example">               
                   A * V = B * V * diag (<var>lambda</var>)
                   W' * A = diag (<var>lambda</var>) * W' * B
                   AA = Q * A * Z, BB = Q * B * Z
</pre>
          <p>with <var>Q</var> and <var>Z</var> orthogonal (unitary)= <var>I</var>

          <li><code>[AA,BB,Z{, </code><var>lambda</var><code>}] = qz (</code><var>A</var><code>, </code><var>B</var><code>, </code><var>opt</var><code>)</code>

          <p>As in form [2], but allows ordering of generalized eigenpairs
for (e.g.) solution of discrete time algebraic Riccati equations. 
Form 3 is not available for complex matrices, and does not compute
the generalized eigenvectors <var>V</var>, <var>W</var>, nor the orthogonal matrix
<var>Q</var>.

               <dl>
<dt><var>opt</var><dd>for ordering eigenvalues of the GEP pencil.  The leading block
of the revised pencil contains all eigenvalues that satisfy:
                    <dl>
<dt>"N"<dd>= unordered (default)

                    <br><dt>"S"<dd>= small: leading block has all |lambda| &le; 1

                    <br><dt>"B"<dd>= big: leading block has all |lambda| &ge; 1

                    <br><dt>"-"<dd>= negative real part: leading block has all eigenvalues
in the open left half-plane

                    <br><dt>"+"<dd>= non-negative real part: leading block has all eigenvalues
in the closed right half-plane
</dl>
               </dl>
          </ol>

        <p>Note: <code>qz</code> performs permutation balancing, but not scaling
(see <a href="doc_002dbalance.html#doc_002dbalance">doc-balance</a>).  The order of output arguments was selected for
compatibility with <span class="sc">matlab</span>. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dbalance.html#doc_002dbalance">balance</a>, <a href="doc_002deig.html#doc_002deig">eig</a>, <a href="doc_002dschur.html#doc_002dschur">schur</a>. 
</p></blockquote></div>

<!-- qzhess scripts/linear-algebra/qzhess.m -->
   <p><a name="doc_002dqzhess"></a>

<div class="defun">
&mdash; Function File: [<var>aa</var>, <var>bb</var>, <var>q</var>, <var>z</var>] = <b>qzhess</b> (<var>A, B</var>)<var><a name="index-qzhess-2083"></a></var><br>
<blockquote><p>Compute the Hessenberg-triangular decomposition of the matrix pencil
<code>(</code><var>A</var><code>, </code><var>B</var><code>)</code>, returning
<var>aa</var><code> = </code><var>q</var><code> * </code><var>A</var><code> * </code><var>z</var>,
<var>bb</var><code> = </code><var>q</var><code> * </code><var>B</var><code> * </code><var>z</var>, with <var>q</var> and <var>z</var>
orthogonal.  For example:

     <pre class="example">          [aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
               &rArr; aa = [ -3.02244, -4.41741;  0.92998,  0.69749 ]
               &rArr; bb = [ -8.60233, -9.99730;  0.00000, -0.23250 ]
               &rArr;  q = [ -0.58124, -0.81373; -0.81373,  0.58124 ]
               &rArr;  z = [ 1, 0; 0, 1 ]
</pre>
        <p>The Hessenberg-triangular decomposition is the first step in
Moler and Stewart's QZ&nbsp;decomposition algorithm.

        <p>Algorithm taken from Golub and Van Loan,
<cite>Matrix Computations, 2nd edition</cite>. 
</p></blockquote></div>

<!-- schur src/DLD-FUNCTIONS/schur.cc -->
   <p><a name="doc_002dschur"></a>

<div class="defun">
&mdash; Loadable Function: <var>S</var> = <b>schur</b> (<var>A</var>)<var><a name="index-schur-2084"></a></var><br>
&mdash; Loadable Function: <var>S</var> = <b>schur</b> (<var>A, "real"</var>)<var><a name="index-schur-2085"></a></var><br>
&mdash; Loadable Function: <var>S</var> = <b>schur</b> (<var>A, "complex"</var>)<var><a name="index-schur-2086"></a></var><br>
&mdash; Loadable Function: <var>S</var> = <b>schur</b> (<var>A, opt</var>)<var><a name="index-schur-2087"></a></var><br>
&mdash; Loadable Function: [<var>U</var>, <var>S</var>] = <b>schur</b> (<var>A, <small class="dots">...</small></var>)<var><a name="index-schur-2088"></a></var><br>
<blockquote><p><a name="index-Schur-decomposition-2089"></a>Compute the Schur&nbsp;decomposition of <var>A</var>

     <pre class="example">          <var>S</var><code> = </code><var>U</var><code>' * </code><var>A</var><code> * </code><var>U</var>
</pre>
        <p>where <var>U</var> is a unitary matrix
(<var>U</var><code>'* </code><var>U</var> is identity)
and <var>S</var> is upper triangular.  The eigenvalues of <var>A</var> (and <var>S</var>)
are the diagonal elements of <var>S</var>.  If the matrix <var>A</var>
is real, then the real Schur&nbsp;decomposition is computed, in which the
matrix <var>U</var> is orthogonal and <var>S</var> is block upper triangular
with blocks of size at most
<code>2 x 2</code>
along the diagonal.  The diagonal elements of <var>S</var>
(or the eigenvalues of the
<code>2 x 2</code>
blocks, when appropriate) are the eigenvalues of <var>A</var> and <var>S</var>.

        <p>The default for real matrices is a real Schur&nbsp;decomposition. 
A complex decomposition may be forced by passing the flag "complex".

        <p>The eigenvalues are optionally ordered along the diagonal according to
the value of <var>opt</var>.  <var>opt</var><code> = "a"</code> indicates that all
eigenvalues with negative real parts should be moved to the leading
block of <var>S</var>
(used in <code>are</code>), <var>opt</var><code> = "d"</code> indicates that all eigenvalues
with magnitude less than one should be moved to the leading block of <var>S</var>
(used in <code>dare</code>), and <var>opt</var><code> = "u"</code>, the default, indicates
that no ordering of eigenvalues should occur.  The leading <var>k</var>
columns of <var>U</var> always span the <var>A</var>-invariant
subspace corresponding to the <var>k</var> leading eigenvalues of <var>S</var>.

        <p>The Schur&nbsp;decomposition is used to compute eigenvalues of a
square matrix, and has applications in the solution of algebraic
Riccati equations in control (see <code>are</code> and <code>dare</code>). 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002drsf2csf.html#doc_002drsf2csf">rsf2csf</a>. 
</p></blockquote></div>

<!-- rsf2csf src/DLD-FUNCTIONS/schur.cc -->
   <p><a name="doc_002drsf2csf"></a>

<div class="defun">
&mdash; Function File: [<var>U</var>, <var>T</var>] = <b>rsf2csf</b> (<var>UR, TR</var>)<var><a name="index-rsf2csf-2090"></a></var><br>
<blockquote><p>Convert a real, upper quasi-triangular Schur&nbsp;form <var>TR</var> to a complex,
upper triangular Schur&nbsp;form <var>T</var>.

        <p>Note that the following relations hold:

        <p><var>UR</var><code> * </code><var>TR</var><code> * </code><var>UR</var><code>' = </code><var>U</var><code> * </code><var>T</var><code> * </code><var>U</var><code>'</code> and
<var>U</var><code>' * </code><var>U</var> is the identity matrix I.

        <p>Note also that <var>U</var> and <var>T</var> are not unique. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dschur.html#doc_002dschur">schur</a>. 
</p></blockquote></div>

<!-- subspace scripts/linear-algebra/subspace.m -->
   <p><a name="doc_002dsubspace"></a>

<div class="defun">
&mdash; Function File: <var>angle</var> = <b>subspace</b> (<var>A, B</var>)<var><a name="index-subspace-2091"></a></var><br>
<blockquote><p>Determine the largest principal angle between two subspaces
spanned by the columns of matrices <var>A</var> and <var>B</var>. 
</p></blockquote></div>

<!-- svd src/DLD-FUNCTIONS/svd.cc -->
   <p><a name="doc_002dsvd"></a>

<div class="defun">
&mdash; Loadable Function: <var>s</var> = <b>svd</b> (<var>A</var>)<var><a name="index-svd-2092"></a></var><br>
&mdash; Loadable Function: [<var>U</var>, <var>S</var>, <var>V</var>] = <b>svd</b> (<var>A</var>)<var><a name="index-svd-2093"></a></var><br>
&mdash; Loadable Function: [<var>U</var>, <var>S</var>, <var>V</var>] = <b>svd</b> (<var>A, econ</var>)<var><a name="index-svd-2094"></a></var><br>
<blockquote><p><a name="index-singular-value-decomposition-2095"></a>Compute the singular value decomposition of <var>A</var>

     <pre class="example">          A = U*S*V'
</pre>
        <p>The function <code>svd</code> normally returns only the vector of singular values. 
When called with three return values, it computes
<var>U</var>, <var>S</var>, and <var>V</var>. 
For example,

     <pre class="example">          svd (hilb (3))
</pre>
        <p class="noindent">returns

     <pre class="example">          ans =
          
            1.4083189
            0.1223271
            0.0026873
</pre>
        <p class="noindent">and

     <pre class="example">          [u, s, v] = svd (hilb (3))
</pre>
        <p class="noindent">returns

     <pre class="example">          u =
          
            -0.82704   0.54745   0.12766
            -0.45986  -0.52829  -0.71375
            -0.32330  -0.64901   0.68867
          
          s =
          
            1.40832  0.00000  0.00000
            0.00000  0.12233  0.00000
            0.00000  0.00000  0.00269
          
          v =
          
            -0.82704   0.54745   0.12766
            -0.45986  -0.52829  -0.71375
            -0.32330  -0.64901   0.68867
</pre>
        <p>If given a second argument, <code>svd</code> returns an economy-sized
decomposition, eliminating the unnecessary rows or columns of <var>U</var> or
<var>V</var>. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dsvd_005fdriver.html#doc_002dsvd_005fdriver">svd_driver</a>, <a href="doc_002dsvds.html#doc_002dsvds">svds</a>, <a href="doc_002deig.html#doc_002deig">eig</a>. 
</p></blockquote></div>

<!-- svd_driver src/DLD-FUNCTIONS/svd.cc -->
   <p><a name="doc_002dsvd_005fdriver"></a>

<div class="defun">
&mdash; Loadable Function: <var>val</var> = <b>svd_driver</b> ()<var><a name="index-svd_005fdriver-2096"></a></var><br>
&mdash; Loadable Function: <var>old_val</var> = <b>svd_driver</b> (<var>new_val</var>)<var><a name="index-svd_005fdriver-2097"></a></var><br>
&mdash; Loadable Function:  <b>svd_driver</b> (<var>new_val, "local"</var>)<var><a name="index-svd_005fdriver-2098"></a></var><br>
<blockquote><p>Query or set the underlying <span class="sc">lapack</span> driver used by <code>svd</code>. 
Currently recognized values are "gesvd" and "gesdd".  The default
is "gesvd".

        <p>When called from inside a function with the "local" option, the variable is
changed locally for the function and any subroutines it calls.  The original
variable value is restored when exiting the function. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002dsvd.html#doc_002dsvd">svd</a>. 
</p></blockquote></div>

<!-- FIXME - should there be a new section here? -->
<!-- housh scripts/linear-algebra/housh.m -->
   <p><a name="doc_002dhoush"></a>

<div class="defun">
&mdash; Function File: [<var>housv</var>, <var>beta</var>, <var>zer</var>] = <b>housh</b> (<var>x, j, z</var>)<var><a name="index-housh-2099"></a></var><br>
<blockquote><p>Compute Householder reflection vector <var>housv</var> to reflect <var>x</var>
to be the j-th column of identity, i.e.,

     <pre class="example">          (I - beta*housv*housv')x =  norm(x)*e(j) if x(j) &lt; 0,
          (I - beta*housv*housv')x = -norm(x)*e(j) if x(j) &gt;= 0
</pre>
        <p class="noindent">Inputs

          <dl>
<dt><var>x</var><dd>vector

          <br><dt><var>j</var><dd>index into vector

          <br><dt><var>z</var><dd>threshold for zero  (usually should be the number 0)
</dl>

     <p class="noindent">Outputs (see Golub and Van Loan):

          <dl>
<dt><var>beta</var><dd>If beta = 0, then no reflection need be applied (zer set to 0)

          <br><dt><var>housv</var><dd>householder vector
</dl>
        </p></blockquote></div>

<!-- krylov scripts/linear-algebra/krylov.m -->
   <p><a name="doc_002dkrylov"></a>

<div class="defun">
&mdash; Function File: [<var>u</var>, <var>h</var>, <var>nu</var>] = <b>krylov</b> (<var>A, V, k, eps1, pflg</var>)<var><a name="index-krylov-2100"></a></var><br>
<blockquote><p>Construct an orthogonal basis <var>u</var> of block Krylov subspace

     <pre class="example">          [v a*v a^2*v ... a^(k+1)*v]
</pre>
        <p class="noindent">Using Householder reflections to guard against loss of orthogonality.

        <p>If <var>V</var> is a vector, then <var>h</var> contains the Hessenberg matrix
such that <code>a*u == u*h+rk*ek'</code>, in which <code>rk =
a*u(:,k)-u*h(:,k)</code>, and <code>ek'</code> is the vector
<code>[0, 0, ..., 1]</code> of length <code>k</code>.  Otherwise, <var>h</var> is
meaningless.

        <p>If <var>V</var> is a vector and <var>k</var> is greater than
<code>length(A)-1</code>, then <var>h</var> contains the Hessenberg matrix such
that <code>a*u == u*h</code>.

        <p>The value of <var>nu</var> is the dimension of the span of the Krylov
subspace (based on <var>eps1</var>).

        <p>If <var>b</var> is a vector and <var>k</var> is greater than <var>m-1</var>, then
<var>h</var> contains the Hessenberg decomposition of <var>A</var>.

        <p>The optional parameter <var>eps1</var> is the threshold for zero.  The
default value is 1e-12.

        <p>If the optional parameter <var>pflg</var> is nonzero, row pivoting is used
to improve numerical behavior.  The default value is 0.

        <p>Reference: A. Hodel, P. Misra, <cite>Partial Pivoting in the Computation of
Krylov Subspaces of Large Sparse Systems</cite>, Proceedings of the 42nd IEEE
Conference on Decision and Control, December 2003. 
</p></blockquote></div>

   </body></html>

